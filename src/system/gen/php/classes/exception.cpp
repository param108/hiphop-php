/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/exception.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
/* preface finishes */
/* SRC: classes/exception.php line 259 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnexpectedValueException
Variant c_UnexpectedValueException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnexpectedValueException
Variant c_UnexpectedValueException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnexpectedValueException
Variant &c_UnexpectedValueException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_UnexpectedValueException
void c_UnexpectedValueException::o_getArray(Array &props) const {
  c_RuntimeException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_UnexpectedValueException
void c_UnexpectedValueException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_UnexpectedValueException
Variant * c_UnexpectedValueException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnexpectedValueException
Variant * c_UnexpectedValueException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnexpectedValueException
Variant * c_UnexpectedValueException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_UnexpectedValueException
Variant c_UnexpectedValueException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_UnexpectedValueException
IMPLEMENT_CLASS(UnexpectedValueException)
ObjectData *c_UnexpectedValueException::cloneImpl() {
  c_UnexpectedValueException *obj = NEW(c_UnexpectedValueException)();
  cloneSet(obj);
  return obj;
}
void c_UnexpectedValueException::cloneSet(c_UnexpectedValueException *clone) {
  c_RuntimeException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_UnexpectedValueException
Variant c_UnexpectedValueException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_UnexpectedValueException
Variant c_UnexpectedValueException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_UnexpectedValueException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_UnexpectedValueException
Variant c_UnexpectedValueException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_UnexpectedValueException
Variant c_UnexpectedValueException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_RuntimeException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_UnexpectedValueException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_RuntimeException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_UnexpectedValueException = {
  c_UnexpectedValueException::os_getInit,
  c_UnexpectedValueException::os_get,
  c_UnexpectedValueException::os_lval,
  c_UnexpectedValueException::os_invoke,
  c_UnexpectedValueException::os_constant,
};
void c_UnexpectedValueException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 233 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OverflowException
Variant c_OverflowException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_OverflowException
Variant c_OverflowException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OverflowException
Variant &c_OverflowException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_OverflowException
void c_OverflowException::o_getArray(Array &props) const {
  c_RuntimeException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_OverflowException
void c_OverflowException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_OverflowException
Variant * c_OverflowException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OverflowException
Variant * c_OverflowException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OverflowException
Variant * c_OverflowException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_OverflowException
Variant c_OverflowException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_OverflowException
IMPLEMENT_CLASS(OverflowException)
ObjectData *c_OverflowException::cloneImpl() {
  c_OverflowException *obj = NEW(c_OverflowException)();
  cloneSet(obj);
  return obj;
}
void c_OverflowException::cloneSet(c_OverflowException *clone) {
  c_RuntimeException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_OverflowException
Variant c_OverflowException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_OverflowException
Variant c_OverflowException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_OverflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_OverflowException
Variant c_OverflowException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_OverflowException
Variant c_OverflowException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_RuntimeException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_OverflowException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_RuntimeException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_OverflowException = {
  c_OverflowException::os_getInit,
  c_OverflowException::os_get,
  c_OverflowException::os_lval,
  c_OverflowException::os_invoke,
  c_OverflowException::os_constant,
};
void c_OverflowException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 225 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfBoundsException
Variant c_OutOfBoundsException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfBoundsException
Variant c_OutOfBoundsException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfBoundsException
Variant &c_OutOfBoundsException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfBoundsException
void c_OutOfBoundsException::o_getArray(Array &props) const {
  c_RuntimeException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfBoundsException
void c_OutOfBoundsException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_OutOfBoundsException
Variant * c_OutOfBoundsException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfBoundsException
Variant * c_OutOfBoundsException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfBoundsException
Variant * c_OutOfBoundsException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfBoundsException
Variant c_OutOfBoundsException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfBoundsException
IMPLEMENT_CLASS(OutOfBoundsException)
ObjectData *c_OutOfBoundsException::cloneImpl() {
  c_OutOfBoundsException *obj = NEW(c_OutOfBoundsException)();
  cloneSet(obj);
  return obj;
}
void c_OutOfBoundsException::cloneSet(c_OutOfBoundsException *clone) {
  c_RuntimeException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfBoundsException
Variant c_OutOfBoundsException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfBoundsException
Variant c_OutOfBoundsException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfBoundsException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_OutOfBoundsException
Variant c_OutOfBoundsException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_OutOfBoundsException
Variant c_OutOfBoundsException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_RuntimeException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_OutOfBoundsException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_RuntimeException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_OutOfBoundsException = {
  c_OutOfBoundsException::os_getInit,
  c_OutOfBoundsException::os_get,
  c_OutOfBoundsException::os_lval,
  c_OutOfBoundsException::os_invoke,
  c_OutOfBoundsException::os_constant,
};
void c_OutOfBoundsException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 155 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LogicException
Variant c_LogicException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_LogicException
Variant c_LogicException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LogicException
Variant &c_LogicException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_LogicException
void c_LogicException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_LogicException
void c_LogicException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_LogicException
Variant * c_LogicException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LogicException
Variant * c_LogicException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LogicException
Variant * c_LogicException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_LogicException
Variant c_LogicException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_LogicException
IMPLEMENT_CLASS(LogicException)
ObjectData *c_LogicException::cloneImpl() {
  c_LogicException *obj = NEW(c_LogicException)();
  cloneSet(obj);
  return obj;
}
void c_LogicException::cloneSet(c_LogicException *clone) {
  c_Exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_LogicException
Variant c_LogicException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_LogicException
Variant c_LogicException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_LogicException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_LogicException
Variant c_LogicException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_LogicException
Variant c_LogicException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_LogicException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_LogicException = {
  c_LogicException::os_getInit,
  c_LogicException::os_get,
  c_LogicException::os_lval,
  c_LogicException::os_invoke,
  c_LogicException::os_constant,
};
void c_LogicException::init() {
  c_Exception::init();
}
/* SRC: classes/exception.php line 241 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RangeException
Variant c_RangeException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_RangeException
Variant c_RangeException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RangeException
Variant &c_RangeException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_RangeException
void c_RangeException::o_getArray(Array &props) const {
  c_RuntimeException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_RangeException
void c_RangeException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_RangeException
Variant * c_RangeException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RangeException
Variant * c_RangeException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RangeException
Variant * c_RangeException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_RangeException
Variant c_RangeException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_RangeException
IMPLEMENT_CLASS(RangeException)
ObjectData *c_RangeException::cloneImpl() {
  c_RangeException *obj = NEW(c_RangeException)();
  cloneSet(obj);
  return obj;
}
void c_RangeException::cloneSet(c_RangeException *clone) {
  c_RuntimeException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_RangeException
Variant c_RangeException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_RangeException
Variant c_RangeException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_RangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_RangeException
Variant c_RangeException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_RangeException
Variant c_RangeException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_RuntimeException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_RangeException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_RuntimeException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_RangeException = {
  c_RangeException::os_getInit,
  c_RangeException::os_get,
  c_RangeException::os_lval,
  c_RangeException::os_invoke,
  c_RangeException::os_constant,
};
void c_RangeException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 193 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_InvalidArgumentException
Variant c_InvalidArgumentException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_InvalidArgumentException
Variant c_InvalidArgumentException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_InvalidArgumentException
Variant &c_InvalidArgumentException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_InvalidArgumentException
void c_InvalidArgumentException::o_getArray(Array &props) const {
  c_LogicException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_InvalidArgumentException
void c_InvalidArgumentException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_InvalidArgumentException
Variant * c_InvalidArgumentException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_InvalidArgumentException
Variant * c_InvalidArgumentException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_InvalidArgumentException
Variant * c_InvalidArgumentException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_InvalidArgumentException
Variant c_InvalidArgumentException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_InvalidArgumentException
IMPLEMENT_CLASS(InvalidArgumentException)
ObjectData *c_InvalidArgumentException::cloneImpl() {
  c_InvalidArgumentException *obj = NEW(c_InvalidArgumentException)();
  cloneSet(obj);
  return obj;
}
void c_InvalidArgumentException::cloneSet(c_InvalidArgumentException *clone) {
  c_LogicException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_InvalidArgumentException
Variant c_InvalidArgumentException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_InvalidArgumentException
Variant c_InvalidArgumentException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_InvalidArgumentException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_InvalidArgumentException
Variant c_InvalidArgumentException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_InvalidArgumentException
Variant c_InvalidArgumentException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_LogicException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_InvalidArgumentException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_LogicException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_InvalidArgumentException = {
  c_InvalidArgumentException::os_getInit,
  c_InvalidArgumentException::os_get,
  c_InvalidArgumentException::os_lval,
  c_InvalidArgumentException::os_invoke,
  c_InvalidArgumentException::os_constant,
};
void c_InvalidArgumentException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 250 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnderflowException
Variant c_UnderflowException::os_getInit(CStrRef s) {
  return c_RuntimeException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnderflowException
Variant c_UnderflowException::os_get(CStrRef s) {
  return c_RuntimeException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnderflowException
Variant &c_UnderflowException::os_lval(CStrRef s) {
  return c_RuntimeException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_UnderflowException
void c_UnderflowException::o_getArray(Array &props) const {
  c_RuntimeException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_UnderflowException
void c_UnderflowException::o_setArray(CArrRef props) {
  c_RuntimeException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_UnderflowException
Variant * c_UnderflowException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnderflowException
Variant * c_UnderflowException::o_realPropPublic(CStrRef s, int flags) const {
  return c_RuntimeException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnderflowException
Variant * c_UnderflowException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_UnderflowException
Variant c_UnderflowException::os_constant(const char *s) {
  return c_RuntimeException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_UnderflowException
IMPLEMENT_CLASS(UnderflowException)
ObjectData *c_UnderflowException::cloneImpl() {
  c_UnderflowException *obj = NEW(c_UnderflowException)();
  cloneSet(obj);
  return obj;
}
void c_UnderflowException::cloneSet(c_UnderflowException *clone) {
  c_RuntimeException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_UnderflowException
Variant c_UnderflowException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_UnderflowException
Variant c_UnderflowException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_UnderflowException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_UnderflowException
Variant c_UnderflowException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_UnderflowException
Variant c_UnderflowException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_RuntimeException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_UnderflowException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_RuntimeException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_UnderflowException = {
  c_UnderflowException::os_getInit,
  c_UnderflowException::os_get,
  c_UnderflowException::os_lval,
  c_UnderflowException::os_invoke,
  c_UnderflowException::os_constant,
};
void c_UnderflowException::init() {
  c_RuntimeException::init();
}
/* SRC: classes/exception.php line 209 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfRangeException
Variant c_OutOfRangeException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfRangeException
Variant c_OutOfRangeException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfRangeException
Variant &c_OutOfRangeException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfRangeException
void c_OutOfRangeException::o_getArray(Array &props) const {
  c_LogicException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfRangeException
void c_OutOfRangeException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_OutOfRangeException
Variant * c_OutOfRangeException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfRangeException
Variant * c_OutOfRangeException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfRangeException
Variant * c_OutOfRangeException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfRangeException
Variant c_OutOfRangeException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_OutOfRangeException
IMPLEMENT_CLASS(OutOfRangeException)
ObjectData *c_OutOfRangeException::cloneImpl() {
  c_OutOfRangeException *obj = NEW(c_OutOfRangeException)();
  cloneSet(obj);
  return obj;
}
void c_OutOfRangeException::cloneSet(c_OutOfRangeException *clone) {
  c_LogicException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfRangeException
Variant c_OutOfRangeException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfRangeException
Variant c_OutOfRangeException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_OutOfRangeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_OutOfRangeException
Variant c_OutOfRangeException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_OutOfRangeException
Variant c_OutOfRangeException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_LogicException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_OutOfRangeException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_LogicException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_OutOfRangeException = {
  c_OutOfRangeException::os_getInit,
  c_OutOfRangeException::os_get,
  c_OutOfRangeException::os_lval,
  c_OutOfRangeException::os_invoke,
  c_OutOfRangeException::os_constant,
};
void c_OutOfRangeException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 175 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadMethodCallException
Variant c_BadMethodCallException::os_getInit(CStrRef s) {
  return c_BadFunctionCallException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadMethodCallException
Variant c_BadMethodCallException::os_get(CStrRef s) {
  return c_BadFunctionCallException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadMethodCallException
Variant &c_BadMethodCallException::os_lval(CStrRef s) {
  return c_BadFunctionCallException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_BadMethodCallException
void c_BadMethodCallException::o_getArray(Array &props) const {
  c_BadFunctionCallException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_BadMethodCallException
void c_BadMethodCallException::o_setArray(CArrRef props) {
  c_BadFunctionCallException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_BadMethodCallException
Variant * c_BadMethodCallException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadMethodCallException
Variant * c_BadMethodCallException::o_realPropPublic(CStrRef s, int flags) const {
  return c_BadFunctionCallException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadMethodCallException
Variant * c_BadMethodCallException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_BadMethodCallException
Variant c_BadMethodCallException::os_constant(const char *s) {
  return c_BadFunctionCallException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_BadMethodCallException
IMPLEMENT_CLASS(BadMethodCallException)
ObjectData *c_BadMethodCallException::cloneImpl() {
  c_BadMethodCallException *obj = NEW(c_BadMethodCallException)();
  cloneSet(obj);
  return obj;
}
void c_BadMethodCallException::cloneSet(c_BadMethodCallException *clone) {
  c_BadFunctionCallException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_BadMethodCallException
Variant c_BadMethodCallException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_BadMethodCallException
Variant c_BadMethodCallException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_BadMethodCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_BadMethodCallException
Variant c_BadMethodCallException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_BadMethodCallException
Variant c_BadMethodCallException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_BadFunctionCallException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_BadMethodCallException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_BadFunctionCallException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_BadMethodCallException = {
  c_BadMethodCallException::os_getInit,
  c_BadMethodCallException::os_get,
  c_BadMethodCallException::os_lval,
  c_BadMethodCallException::os_invoke,
  c_BadMethodCallException::os_constant,
};
void c_BadMethodCallException::init() {
  c_BadFunctionCallException::init();
}
/* SRC: classes/exception.php line 217 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RuntimeException
Variant c_RuntimeException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_RuntimeException
Variant c_RuntimeException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RuntimeException
Variant &c_RuntimeException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_RuntimeException
void c_RuntimeException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_RuntimeException
void c_RuntimeException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_RuntimeException
Variant * c_RuntimeException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RuntimeException
Variant * c_RuntimeException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RuntimeException
Variant * c_RuntimeException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_RuntimeException
Variant c_RuntimeException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_RuntimeException
IMPLEMENT_CLASS(RuntimeException)
ObjectData *c_RuntimeException::cloneImpl() {
  c_RuntimeException *obj = NEW(c_RuntimeException)();
  cloneSet(obj);
  return obj;
}
void c_RuntimeException::cloneSet(c_RuntimeException *clone) {
  c_Exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_RuntimeException
Variant c_RuntimeException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_RuntimeException
Variant c_RuntimeException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_RuntimeException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_RuntimeException
Variant c_RuntimeException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_RuntimeException
Variant c_RuntimeException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_RuntimeException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_RuntimeException = {
  c_RuntimeException::os_getInit,
  c_RuntimeException::os_get,
  c_RuntimeException::os_lval,
  c_RuntimeException::os_invoke,
  c_RuntimeException::os_constant,
};
void c_RuntimeException::init() {
  c_Exception::init();
}
/* SRC: classes/exception.php line 10 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Exception
Variant c_Exception::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 15) {
    case 7:
      HASH_RETURN_NAMSTR(0x3CCB986B2CF0A747LL, NAMSTR(s_sys_ss2cf0a747, "trace"),
                         null, 5);
      break;
    case 9:
      HASH_RETURN_NAMSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code"),
                         0LL, 4);
      break;
    case 10:
      HASH_RETURN_NAMSTR(0x04AB35CACF8C8C9ALL, NAMSTR(s_sys_ss30737366, "line"),
                         null, 4);
      break;
    case 11:
      HASH_RETURN_NAMSTR(0x0247CDBB94C9D47BLL, NAMSTR(s_sys_ss6b362b85, "message"),
                         NAMSTR(s_sys_ss00000000, ""), 7);
      break;
    case 15:
      HASH_RETURN_NAMSTR(0x7863294A8F33D14FLL, NAMSTR(s_sys_ss70cc2eb1, "file"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Exception
Variant c_Exception::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Exception
Variant &c_Exception::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Exception
void c_Exception::o_getArray(Array &props) const {
  if (isInitialized(m_message)) props.set(NAMSTR(s_sys_ss6b362b85, "message"), m_message.isReferenced() ? ref(m_message) : m_message, true);
  if (isInitialized(m_code)) props.set(NAMSTR(s_sys_ss7a853247, "code"), m_code.isReferenced() ? ref(m_code) : m_code, true);
  if (isInitialized(m_file)) props.set(NAMSTR(s_sys_ss70cc2eb1, "file"), m_file.isReferenced() ? ref(m_file) : m_file, true);
  if (isInitialized(m_line)) props.set(NAMSTR(s_sys_ss30737366, "line"), m_line.isReferenced() ? ref(m_line) : m_line, true);
  if (isInitialized(m_trace)) props.set(NAMSTR(s_sys_ss2cf0a747, "trace"), m_trace.isReferenced() ? ref(m_trace) : m_trace, true);
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Exception
void c_Exception::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Exception
Variant * c_Exception::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Exception
Variant * c_Exception::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 15) {
    case 7:
      HASH_REALPROP_STRING(0x3CCB986B2CF0A747LL, "trace", 5, trace);
      break;
    case 9:
      HASH_REALPROP_STRING(0x58C72230857ACDB9LL, "code", 4, code);
      break;
    case 10:
      HASH_REALPROP_STRING(0x04AB35CACF8C8C9ALL, "line", 4, line);
      break;
    case 11:
      HASH_REALPROP_STRING(0x0247CDBB94C9D47BLL, "message", 7, message);
      break;
    case 15:
      HASH_REALPROP_STRING(0x7863294A8F33D14FLL, "file", 4, file);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Exception
Variant * c_Exception::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Exception
Variant c_Exception::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Exception
IMPLEMENT_CLASS(Exception)
c_Exception *c_Exception::create(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
) {
  CountableHelper h(this);
  init();
  t___construct(v_message, v_code);
  return this;
}
ObjectData *c_Exception::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("Exception::__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_Exception::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("Exception::__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_Exception::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("Exception::__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
ObjectData *c_Exception::cloneImpl() {
  c_Exception *obj = NEW(c_Exception)();
  cloneSet(obj);
  return obj;
}
void c_Exception::cloneSet(c_Exception *clone) {
  clone->m_message = m_message.isReferenced() ? ref(m_message) : m_message;
  clone->m_code = m_code.isReferenced() ? ref(m_code) : m_code;
  clone->m_file = m_file.isReferenced() ? ref(m_file) : m_file;
  clone->m_line = m_line.isReferenced() ? ref(m_line) : m_line;
  clone->m_trace = m_trace.isReferenced() ? ref(m_trace) : m_trace;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Exception
Variant c_Exception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Exception
Variant c_Exception::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Exception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Exception
Variant c_Exception::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Exception
Variant c_Exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Exception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_Exception = {
  c_Exception::os_getInit,
  c_Exception::os_get,
  c_Exception::os_lval,
  c_Exception::os_invoke,
  c_Exception::os_constant,
};
void c_Exception::init() {
  m_message = NAMSTR(s_sys_ss00000000, "");
  m_code = 0LL;
  m_file = null;
  m_line = null;
  m_trace = null;
  {CountableHelper h(this); t___init__();}
}
/* SRC: classes/exception.php line 23 */
void c_Exception::t___init__() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__init__);
  Variant v_top;
  Variant v_frame;

  {
    const Array &tmp1((x_debug_backtrace()));
    m_trace = tmp1;
  }
  LOOP_COUNTER(2);
  {
    while (!(empty(m_trace))) {
      LOOP_COUNTER_CHECK(2);
      {
        {
          Variant tmp3((m_trace.rvalAt(0LL, true)));
          v_top = tmp3;
        }
        {
          bool tmp4;
          {
            bool tmp5 = (empty(v_top, NAMSTR(s_sys_ss1f74c210, "class"), true));
            if (!tmp5) {
              bool tmp6 = ((toBoolean(x_strcasecmp(toString(v_top.rvalAt(NAMSTR(s_sys_ss58ba5adc, "function"), true, true)), NAMSTR(s_sys_ss55f425c0, "__init__"))) && toBoolean(x_strcasecmp(toString(v_top.rvalAt(NAMSTR(s_sys_ss58ba5adc, "function"), true, true)), NAMSTR(s_sys_ss229c615f, "__construct")))));
              if (tmp6) {
                const String &tmp7((toString(v_top.rvalAt(NAMSTR(s_sys_ss58ba5adc, "function"), true, true))));
                const String &tmp8((toString(v_top.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
                tmp6 = (toBoolean(x_strcasecmp(tmp7, tmp8)));
              }
              tmp5 = (tmp6);
            }
            bool tmp9 = (tmp5);
            if (!tmp9) {
              bool tmp10 = (toBoolean(x_strcasecmp(toString(v_top.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true)), NAMSTR(s_sys_ss7f49956c, "exception"))));
              if (tmp10) {
                bool tmp11((x_is_subclass_of(v_top.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true), NAMSTR(s_sys_ss7f49956c, "exception"))));
                tmp10 = (!(tmp11));
              }
              tmp9 = (tmp10);
            }
            tmp4 = (tmp9);
          }
          if (tmp4) {
            {
              break;
            }
          }
        }
        {
          const Variant &tmp12((x_array_shift(ref(m_trace))));
          v_frame = tmp12;
        }
      }
    }
  }
  if (isset(v_frame, NAMSTR(s_sys_ss70cc2eb1, "file"), true)) {
    {
      Variant tmp13((v_frame.rvalAt(NAMSTR(s_sys_ss70cc2eb1, "file"), true, true)));
      m_file = tmp13;
    }
  }
  if (isset(v_frame, NAMSTR(s_sys_ss30737366, "line"), true)) {
    {
      Variant tmp14((v_frame.rvalAt(NAMSTR(s_sys_ss30737366, "line"), true, true)));
      m_line = tmp14;
    }
  }
} /* function */
/* SRC: classes/exception.php line 44 */
void c_Exception::t___construct(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__construct);
  bool oldInCtor = gasInCtor(true);
  m_message = v_message;
  m_code = v_code;
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/exception.php line 58 */
Variant c_Exception::t_getmessage() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getMessage);
  return m_message;
} /* function */
/* SRC: classes/exception.php line 71 */
Variant c_Exception::t_getcode() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getCode);
  return m_code;
} /* function */
/* SRC: classes/exception.php line 85 */
Variant c_Exception::t_getfile() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getFile);
  return m_file;
} /* function */
/* SRC: classes/exception.php line 99 */
Variant c_Exception::t_getline() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getLine);
  return m_line;
} /* function */
/* SRC: classes/exception.php line 112 */
Variant c_Exception::t_gettrace() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getTrace);
  return m_trace;
} /* function */
/* SRC: classes/exception.php line 125 */
String c_Exception::t_gettraceasstring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::getTraceAsString);
  int64 v_i = 0;
  String v_s;
  Variant v_frame;

  v_i = 0LL;
  v_s = NAMSTR(s_sys_ss00000000, "");
  {
    LOOP_COUNTER(1);
    Variant map2 = t_gettrace();
    {
      StringBuffer tmp_sbuf_v_s(512);
      for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
        LOOP_COUNTER_CHECK(1);
        iter3->second(v_frame);
        {
          if (!(x_is_array(v_frame))) {
            continue;
          }
          {
            StringBuffer tmp4_buf;
            tmp4_buf.append("#", 1);
            tmp4_buf.append(toString(v_i));
            tmp4_buf.append(" ", 1);
            tmp4_buf.append(toString(v_frame.rvalAt(NAMSTR(s_sys_ss70cc2eb1, "file"), true, true)));
            tmp4_buf.append("(", 1);
            tmp4_buf.append(toString(v_frame.rvalAt(NAMSTR(s_sys_ss30737366, "line"), true, true)));
            tmp4_buf.append("): ", 3);
            Variant tmp5;
            if (isset(v_frame, NAMSTR(s_sys_ss1f74c210, "class"), true)) {
              const String &tmp6((toString(v_frame.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
              const String &tmp7((toString(v_frame.rvalAt(NAMSTR(s_sys_ss1fe107ad, "type"), true, true))));
              tmp5 = (concat(tmp6, tmp7));
            } else {
              tmp5 = (NAMSTR(s_sys_ss00000000, ""));
            }
            tmp4_buf.append(toString(tmp5));
            tmp4_buf.append(toString(v_frame.rvalAt(NAMSTR(s_sys_ss58ba5adc, "function"), true, true)));
            tmp4_buf.append("()\n", 3);
            CStrRef tmp4(tmp4_buf.detach());
            tmp_sbuf_v_s.add(tmp4);
          }
          v_i++;
        }
      }
      concat_assign(v_s, tmp_sbuf_v_s.detach());
    }
  }
  concat_assign(v_s, concat3(NAMSTR(s_sys_ss2e45e4ea, "#"), toString(v_i), NAMSTR(s_sys_ss10600e60, " {main}")));
  return v_s;
} /* function */
/* SRC: classes/exception.php line 143 */
String c_Exception::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Exception, Exception::__toString);
  return toString(t_getmessage());
} /* function */
/* SRC: classes/exception.php line 268 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ErrorException
Variant c_ErrorException::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_RETURN_NAMSTR(0x4FDAA620FA5F15F9LL, NAMSTR(s_sys_ss05a0ea07, "severity"),
                         null, 8);
      break;
    default:
      break;
  }
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ErrorException
Variant c_ErrorException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ErrorException
Variant &c_ErrorException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ErrorException
void c_ErrorException::o_getArray(Array &props) const {
  if (isInitialized(m_severity)) props.set(NAMSTR(s_sys_ss05a0ea07, "severity"), m_severity.isReferenced() ? ref(m_severity) : m_severity, true);
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ErrorException
void c_ErrorException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ErrorException
Variant * c_ErrorException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ErrorException
Variant * c_ErrorException::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_STRING(0x4FDAA620FA5F15F9LL, "severity", 8, severity);
      break;
    default:
      break;
  }
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ErrorException
Variant * c_ErrorException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ErrorException
Variant c_ErrorException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ErrorException
IMPLEMENT_CLASS(ErrorException)
c_ErrorException *c_ErrorException::create(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
, Variant v_severity //  = 0LL
, Variant v_filename //  = null
, Variant v_lineno //  = null
) {
  CountableHelper h(this);
  init();
  t___construct(v_message, v_code, v_severity, v_filename, v_lineno);
  return this;
}
ObjectData *c_ErrorException::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_ErrorException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_ErrorException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 5) throw_toomany_arguments("ErrorException::__construct", 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
ObjectData *c_ErrorException::cloneImpl() {
  c_ErrorException *obj = NEW(c_ErrorException)();
  cloneSet(obj);
  return obj;
}
void c_ErrorException::cloneSet(c_ErrorException *clone) {
  clone->m_severity = m_severity.isReferenced() ? ref(m_severity) : m_severity;
  c_Exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ErrorException
Variant c_ErrorException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0xc8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        return (t_getseverity());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      HASH_GUARD_LITSTR(0x4B378D0258AF461FLL, NAMSTR(s_sys_ss58af461f, "getSeverity")) {
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        return (t_getseverity());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ErrorException
Variant c_ErrorException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0xc8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        return (t_getseverity());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      HASH_GUARD_LITSTR(0x4B378D0258AF461FLL, NAMSTR(s_sys_ss58af461f, "getSeverity")) {
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        return (t_getseverity());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ErrorException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ErrorException
Variant c_ErrorException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ErrorException
Variant c_ErrorException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0xc8:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getseverity());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      HASH_GUARD_LITSTR(0x4B378D0258AF461FLL, NAMSTR(s_sys_ss58af461f, "getSeverity")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getseverity());
      }
      break;
    default:
      break;
  }
  #endif
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ErrorException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ErrorException = {
  c_ErrorException::os_getInit,
  c_ErrorException::os_get,
  c_ErrorException::os_lval,
  c_ErrorException::os_invoke,
  c_ErrorException::os_constant,
};
void c_ErrorException::init() {
  c_Exception::init();
  m_severity = null;
}
/* SRC: classes/exception.php line 270 */
void c_ErrorException::t___construct(Variant v_message //  = NAMSTR(s_sys_ss00000000, "")
, Variant v_code //  = 0LL
, Variant v_severity //  = 0LL
, Variant v_filename //  = null
, Variant v_lineno //  = null
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ErrorException, ErrorException::__construct);
  bool oldInCtor = gasInCtor(true);
  c_Exception::t___construct(v_message, v_code);
  m_severity = v_severity;
  if (!(x_is_null(v_filename))) {
    {
      m_file = v_filename;
    }
  }
  if (!(x_is_null(v_lineno))) {
    {
      m_line = v_lineno;
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/exception.php line 290 */
Variant c_ErrorException::t_getseverity() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ErrorException, ErrorException::getSeverity);
  return m_severity;
} /* function */
/* SRC: classes/exception.php line 165 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadFunctionCallException
Variant c_BadFunctionCallException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadFunctionCallException
Variant c_BadFunctionCallException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadFunctionCallException
Variant &c_BadFunctionCallException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_BadFunctionCallException
void c_BadFunctionCallException::o_getArray(Array &props) const {
  c_LogicException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_BadFunctionCallException
void c_BadFunctionCallException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_BadFunctionCallException
Variant * c_BadFunctionCallException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadFunctionCallException
Variant * c_BadFunctionCallException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadFunctionCallException
Variant * c_BadFunctionCallException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_BadFunctionCallException
Variant c_BadFunctionCallException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_BadFunctionCallException
IMPLEMENT_CLASS(BadFunctionCallException)
ObjectData *c_BadFunctionCallException::cloneImpl() {
  c_BadFunctionCallException *obj = NEW(c_BadFunctionCallException)();
  cloneSet(obj);
  return obj;
}
void c_BadFunctionCallException::cloneSet(c_BadFunctionCallException *clone) {
  c_LogicException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_BadFunctionCallException
Variant c_BadFunctionCallException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_BadFunctionCallException
Variant c_BadFunctionCallException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_BadFunctionCallException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_BadFunctionCallException
Variant c_BadFunctionCallException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_BadFunctionCallException
Variant c_BadFunctionCallException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_LogicException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_BadFunctionCallException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_LogicException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_BadFunctionCallException = {
  c_BadFunctionCallException::os_getInit,
  c_BadFunctionCallException::os_get,
  c_BadFunctionCallException::os_lval,
  c_BadFunctionCallException::os_invoke,
  c_BadFunctionCallException::os_constant,
};
void c_BadFunctionCallException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 201 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LengthException
Variant c_LengthException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_LengthException
Variant c_LengthException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LengthException
Variant &c_LengthException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_LengthException
void c_LengthException::o_getArray(Array &props) const {
  c_LogicException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_LengthException
void c_LengthException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_LengthException
Variant * c_LengthException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LengthException
Variant * c_LengthException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LengthException
Variant * c_LengthException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_LengthException
Variant c_LengthException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_LengthException
IMPLEMENT_CLASS(LengthException)
ObjectData *c_LengthException::cloneImpl() {
  c_LengthException *obj = NEW(c_LengthException)();
  cloneSet(obj);
  return obj;
}
void c_LengthException::cloneSet(c_LengthException *clone) {
  c_LogicException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_LengthException
Variant c_LengthException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_LengthException
Variant c_LengthException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_LengthException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_LengthException
Variant c_LengthException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_LengthException
Variant c_LengthException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_LogicException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_LengthException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_LogicException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_LengthException = {
  c_LengthException::os_getInit,
  c_LengthException::os_get,
  c_LengthException::os_lval,
  c_LengthException::os_invoke,
  c_LengthException::os_constant,
};
void c_LengthException::init() {
  c_LogicException::init();
}
/* SRC: classes/exception.php line 184 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DomainException
Variant c_DomainException::os_getInit(CStrRef s) {
  return c_LogicException::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DomainException
Variant c_DomainException::os_get(CStrRef s) {
  return c_LogicException::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DomainException
Variant &c_DomainException::os_lval(CStrRef s) {
  return c_LogicException::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DomainException
void c_DomainException::o_getArray(Array &props) const {
  c_LogicException::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DomainException
void c_DomainException::o_setArray(CArrRef props) {
  c_LogicException::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DomainException
Variant * c_DomainException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DomainException
Variant * c_DomainException::o_realPropPublic(CStrRef s, int flags) const {
  return c_LogicException::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DomainException
Variant * c_DomainException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DomainException
Variant c_DomainException::os_constant(const char *s) {
  return c_LogicException::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DomainException
IMPLEMENT_CLASS(DomainException)
ObjectData *c_DomainException::cloneImpl() {
  c_DomainException *obj = NEW(c_DomainException)();
  cloneSet(obj);
  return obj;
}
void c_DomainException::cloneSet(c_DomainException *clone) {
  c_LogicException::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DomainException
Variant c_DomainException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DomainException
Variant c_DomainException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DomainException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DomainException
Variant c_DomainException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DomainException
Variant c_DomainException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_LogicException::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DomainException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_LogicException::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DomainException = {
  c_DomainException::os_getInit,
  c_DomainException::os_get,
  c_DomainException::os_lval,
  c_DomainException::os_invoke,
  c_DomainException::os_constant,
};
void c_DomainException::init() {
  c_LogicException::init();
}
Object co_UnexpectedValueException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_UnexpectedValueException)())->dynCreate(params, init));
}
Object co_OverflowException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_OverflowException)())->dynCreate(params, init));
}
Object co_OutOfBoundsException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_OutOfBoundsException)())->dynCreate(params, init));
}
Object co_LogicException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_LogicException)())->dynCreate(params, init));
}
Object co_RangeException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_RangeException)())->dynCreate(params, init));
}
Object co_InvalidArgumentException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_InvalidArgumentException)())->dynCreate(params, init));
}
Object co_UnderflowException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_UnderflowException)())->dynCreate(params, init));
}
Object co_OutOfRangeException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_OutOfRangeException)())->dynCreate(params, init));
}
Object co_BadMethodCallException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_BadMethodCallException)())->dynCreate(params, init));
}
Object co_RuntimeException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_RuntimeException)())->dynCreate(params, init));
}
Object co_Exception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Exception)())->dynCreate(params, init));
}
Object co_ErrorException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ErrorException)())->dynCreate(params, init));
}
Object co_BadFunctionCallException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_BadFunctionCallException)())->dynCreate(params, init));
}
Object co_LengthException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_LengthException)())->dynCreate(params, init));
}
Object co_DomainException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DomainException)())->dynCreate(params, init));
}
Variant pm_php$classes$exception_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */, Globals *globals /* = get_globals() */) {
  PSEUDOMAIN_INJECTION_BUILTIN(run_init::classes/exception.php, pm_php$classes$exception_php);
  LVariableTable *gVariables __attribute__((__unused__)) = (LVariableTable *)g;
  return true;
} /* function */

///////////////////////////////////////////////////////////////////////////////
}

/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/exception.h>
#include <php/classes/reflection.h>
#include <php/classes/stdclass.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
/* preface finishes */
/* SRC: classes/reflection.php line 248 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionFunctionAbstract
Variant c_ReflectionFunctionAbstract::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_RETURN_NAMSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionFunctionAbstract
Variant c_ReflectionFunctionAbstract::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionFunctionAbstract
Variant &c_ReflectionFunctionAbstract::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionFunctionAbstract
void c_ReflectionFunctionAbstract::o_getArray(Array &props) const {
  if (isInitialized(m_info)) props.set(NAMSTR(s_sys_ss157d479f, "info"), m_info.isReferenced() ? ref(m_info) : m_info, true);
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionFunctionAbstract
void c_ReflectionFunctionAbstract::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionFunctionAbstract
Variant * c_ReflectionFunctionAbstract::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionFunctionAbstract
Variant * c_ReflectionFunctionAbstract::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_STRING(0x0F2EF58F157D479FLL, "info", 4, info);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionFunctionAbstract
Variant * c_ReflectionFunctionAbstract::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionFunctionAbstract
Variant c_ReflectionFunctionAbstract::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionFunctionAbstract
IMPLEMENT_CLASS(ReflectionFunctionAbstract)
ObjectData *c_ReflectionFunctionAbstract::cloneImpl() {
  c_ReflectionFunctionAbstract *obj = NEW(c_ReflectionFunctionAbstract)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionFunctionAbstract::cloneSet(c_ReflectionFunctionAbstract *clone) {
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunctionAbstract
Variant c_ReflectionFunctionAbstract::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunctionAbstract
Variant c_ReflectionFunctionAbstract::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunctionAbstract
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionFunctionAbstract
Variant c_ReflectionFunctionAbstract::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionFunctionAbstract
Variant c_ReflectionFunctionAbstract::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionFunctionAbstract::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionFunctionAbstract = {
  c_ReflectionFunctionAbstract::os_getInit,
  c_ReflectionFunctionAbstract::os_get,
  c_ReflectionFunctionAbstract::os_lval,
  c_ReflectionFunctionAbstract::os_invoke,
  c_ReflectionFunctionAbstract::os_constant,
};
void c_ReflectionFunctionAbstract::init() {
  m_info = null;
}
/* SRC: classes/reflection.php line 261 */
Variant c_ReflectionFunctionAbstract::t_getname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getName);
  return m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true);
} /* function */
/* SRC: classes/reflection.php line 276 */
Variant c_ReflectionFunctionAbstract::t_isinternal() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::isInternal);
  return m_info.rvalAt(NAMSTR(s_sys_ss71135554, "internal"), true, true);
} /* function */
/* SRC: classes/reflection.php line 280 */
Variant c_ReflectionFunctionAbstract::t_getclosure() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getClosure);
  return m_info.rvalAt(NAMSTR(s_sys_ss6d16d594, "closure"), true, true);
} /* function */
/* SRC: classes/reflection.php line 295 */
bool c_ReflectionFunctionAbstract::t_isuserdefined() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::isUserDefined);
  return !(toBoolean(m_info.rvalAt(NAMSTR(s_sys_ss71135554, "internal"), true, true)));
} /* function */
/* SRC: classes/reflection.php line 309 */
Variant c_ReflectionFunctionAbstract::t_getfilename() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getFileName);
  return m_info.rvalAt(NAMSTR(s_sys_ss70cc2eb1, "file"), true, true);
} /* function */
/* SRC: classes/reflection.php line 323 */
Variant c_ReflectionFunctionAbstract::t_getstartline() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getStartLine);
  return m_info.rvalAt(NAMSTR(s_sys_ss028b2c66, "line1"), true, true);
} /* function */
/* SRC: classes/reflection.php line 338 */
Variant c_ReflectionFunctionAbstract::t_getendline() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getEndLine);
  return m_info.rvalAt(NAMSTR(s_sys_ss3195c8e2, "line2"), true, true);
} /* function */
/* SRC: classes/reflection.php line 352 */
Variant c_ReflectionFunctionAbstract::t_getdoccomment() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getDocComment);
  return m_info.rvalAt(NAMSTR(s_sys_ss70714913, "doc"), true, true);
} /* function */
/* SRC: classes/reflection.php line 367 */
Variant c_ReflectionFunctionAbstract::t_getstaticvariables() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getStaticVariables);
  return m_info.rvalAt(NAMSTR(s_sys_ss70133db3, "static_variables"), true, true);
} /* function */
/* SRC: classes/reflection.php line 382 */
Variant c_ReflectionFunctionAbstract::t_returnsreference() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::returnsReference);
  return m_info.rvalAt(NAMSTR(s_sys_ss208f545e, "ref"), true, true);
} /* function */
/* SRC: classes/reflection.php line 397 */
Array c_ReflectionFunctionAbstract::t_getparameters() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getParameters);
  Array v_ret;
  Primitive v_name = 0;
  Variant v_info;
  p_ReflectionParameter v_param;

  v_ret = s_sys_sa00000000;
  {
    LOOP_COUNTER(1);
    Variant map2 = m_info.rvalAt(NAMSTR(s_sys_ss5646283f, "params"), true, true);
    for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v_info);
      v_name = iter3->first();
      {
        {
          p_ReflectionParameter tmp4((p_ReflectionParameter((NEWOBJ(c_ReflectionParameter)())->create(null, null))));
          v_param = tmp4;
        }
        v_param->m_info = v_info;
        {
          p_ReflectionParameter tmp5((v_param));
          v_ret.append((tmp5));
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 419 */
int c_ReflectionFunctionAbstract::t_getnumberofparameters() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getNumberOfParameters);
  return x_count(m_info.rvalAt(NAMSTR(s_sys_ss5646283f, "params"), true, true));
} /* function */
/* SRC: classes/reflection.php line 435 */
int64 c_ReflectionFunctionAbstract::t_getnumberofrequiredparameters() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getNumberOfRequiredParameters);
  int64 v_count = 0;
  Array v_params;
  Primitive v_name = 0;
  Variant v_param;

  v_count = 0LL;
  {
    const Array &tmp1((t_getparameters()));
    v_params = tmp1;
  }
  {
    LOOP_COUNTER(2);
    for (ArrayIter iter4 = v_params.begin(s_class_name); !iter4.end(); ++iter4) {
      LOOP_COUNTER_CHECK(2);
      iter4.second(v_param);
      v_name = iter4.first();
      {
        if (toBoolean(v_param. BIND_CLASS_DOT o_invoke_few_args(/* isOptional */ MethodIndex(321, 1) /* isOptional */ ,  "isOptional", 0x2D6EF48BBAB22735LL, 0))) {
          {
            break;
          }
        }
        v_count++;
      }
    }
  }
  return v_count;
} /* function */
/* SRC: classes/reflection.php line 1277 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionObject
Variant c_ReflectionObject::os_getInit(CStrRef s) {
  return c_ReflectionClass::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionObject
Variant c_ReflectionObject::os_get(CStrRef s) {
  return c_ReflectionClass::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionObject
Variant &c_ReflectionObject::os_lval(CStrRef s) {
  return c_ReflectionClass::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionObject
void c_ReflectionObject::o_getArray(Array &props) const {
  c_ReflectionClass::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionObject
void c_ReflectionObject::o_setArray(CArrRef props) {
  c_ReflectionClass::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionObject
Variant * c_ReflectionObject::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_GUARD_STRING(0x35A44A5E6AE2E71DLL, ReflectionClass) { return c_ReflectionClass::o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionObject
Variant * c_ReflectionObject::o_realPropPublic(CStrRef s, int flags) const {
  return c_ReflectionClass::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionObject
Variant * c_ReflectionObject::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionObject
Variant c_ReflectionObject::os_constant(const char *s) {
  return c_ReflectionClass::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionObject
IMPLEMENT_CLASS(ReflectionObject)
ObjectData *c_ReflectionObject::cloneImpl() {
  c_ReflectionObject *obj = NEW(c_ReflectionObject)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionObject::cloneSet(c_ReflectionObject *clone) {
  c_ReflectionClass::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionObject
Variant c_ReflectionObject::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x104:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getmethods());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethods(arg0));
        }
      }
      break;
    case 0x105:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 0x106:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getstaticpropertyvalue(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getstaticpropertyvalue(arg0, arg1));
        }
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x108:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,params.slice(0, count - 0, false)));
      }
      break;
    case 0x109:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 0x10a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x10b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_newinstanceargs(arg0));
        }
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x10e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isinstance(arg0));
        }
      }
      break;
    case 0x10d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasmethod(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 0x112:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 0x113:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasconstant(arg0));
        }
      }
      break;
    case 0x114:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethod(arg0));
        }
      }
      break;
    case 0x115:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 0x116:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x117:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_implementsinterface(arg0));
        }
      }
      break;
    case 0x118:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 0x11a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getconstant(arg0));
        }
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x11d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 0x11e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issubclassof(arg0));
        }
      }
      break;
    case 0x11f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasproperty(arg0));
        }
      }
      break;
    case 0x121:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 0x122:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 0x123:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setstaticpropertyvalue(arg0, arg1), null);
        }
      }
      break;
    case 0x124:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 0x125:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x128:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getproperty(arg0));
        }
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x40C7B30DCB439C8FLL, NAMSTR(s_sys_ss34bc6371, "hasProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasproperty(arg0));
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x21820E7AA4733998LL, NAMSTR(s_sys_ss5b8cc668, "hasMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasmethod(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0F1AD0A8EC4C229BLL, NAMSTR(s_sys_ss13b3dd65, "getDefaultProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1BC5F3D87676509ELL, NAMSTR(s_sys_ss7676509e, "isInterface")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x323D9BCB05797B22LL, NAMSTR(s_sys_ss05797b22, "getStaticProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x030CE1D6142F8C29LL, NAMSTR(s_sys_ss142f8c29, "isInstance")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isinstance(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x1D6B8CA358B49929LL, NAMSTR(s_sys_ss58b49929, "getExtensionName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x16BA16CE6488AAAALL, NAMSTR(s_sys_ss6488aaaa, "getMethods")) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getmethods());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethods(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x226F6E80CECD3CAALL, NAMSTR(s_sys_ss3132c356, "getConstructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD_LITSTR(0x24596BE6D21F7CAALL, NAMSTR(s_sys_ss2de08356, "getInterfaceNames")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x3C882D4A895F612ELL, NAMSTR(s_sys_ss76a09ed2, "getStaticPropertyValue")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getstaticpropertyvalue(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getstaticpropertyvalue(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x30A86FCA01FE7030LL, NAMSTR(s_sys_ss01fe7030, "newInstance")) {
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,params.slice(0, count - 0, false)));
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x3DB53E1FBD3C0734LL, NAMSTR(s_sys_ss42c3f8cc, "getConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getconstant(arg0));
        }
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x0D81ECE253A3B5B6LL, NAMSTR(s_sys_ss53a3b5b6, "getMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethod(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x25D24435915E6E3BLL, NAMSTR(s_sys_ss6ea191c5, "getExtension")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x0D8AAD6BA2BBCD3CLL, NAMSTR(s_sys_ss5d4432c4, "isInstantiable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x54C2DC04C4A62B3FLL, NAMSTR(s_sys_ss3b59d4c1, "hasConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasconstant(arg0));
        }
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x67C15E3D98C00B43LL, NAMSTR(s_sys_ss673ff4bd, "getInterfaces")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x1EB679C3602F4B44LL, NAMSTR(s_sys_ss602f4b44, "getProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x0FD73627FB023047LL, NAMSTR(s_sys_ss04fdcfb9, "getProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getproperty(arg0));
        }
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7D5A57B5370B68CELL, NAMSTR(s_sys_ss370b68ce, "isIterateable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x2735DCC254EE5C66LL, NAMSTR(s_sys_ss54ee5c66, "newInstanceArgs")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_newinstanceargs(arg0));
        }
      }
      break;
    case 104:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x07ECA928E37717F1LL, NAMSTR(s_sys_ss1c88e80f, "setStaticPropertyValue")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setstaticpropertyvalue(arg0, arg1), null);
        }
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x74F7FEDE16957472LL, NAMSTR(s_sys_ss16957472, "getParentClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x28DC702215C7D6FBLL, NAMSTR(s_sys_ss15c7d6fb, "implementsInterface")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_implementsinterface(arg0));
        }
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x373333991926C97ELL, NAMSTR(s_sys_ss1926c97e, "isSubclassOf")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issubclassof(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionClass::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionObject
Variant c_ReflectionObject::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x104:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(a0));
      }
      break;
    case 0x105:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 0x106:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        return (t_getstaticpropertyvalue(a0, a1));
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x108:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count <= 0) return (t_newinstance(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_newinstance(count,params));
      }
      break;
    case 0x109:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 0x10a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x10b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        return (t_newinstanceargs(a0));
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x10e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        return (t_isinstance(a0));
      }
      break;
    case 0x10d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        return (t_hasmethod(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x112:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 0x113:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        return (t_hasconstant(a0));
      }
      break;
    case 0x114:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        return (t_getmethod(a0));
      }
      break;
    case 0x115:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 0x116:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x117:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        return (t_implementsinterface(a0));
      }
      break;
    case 0x118:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 0x11a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        return (t_getconstant(a0));
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x11d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 0x11e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        return (t_issubclassof(a0));
      }
      break;
    case 0x11f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        return (t_hasproperty(a0));
      }
      break;
    case 0x121:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 0x122:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 0x123:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 0x124:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 0x125:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x128:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        return (t_getproperty(a0));
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x40C7B30DCB439C8FLL, NAMSTR(s_sys_ss34bc6371, "hasProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x21820E7AA4733998LL, NAMSTR(s_sys_ss5b8cc668, "hasMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0F1AD0A8EC4C229BLL, NAMSTR(s_sys_ss13b3dd65, "getDefaultProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1BC5F3D87676509ELL, NAMSTR(s_sys_ss7676509e, "isInterface")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x323D9BCB05797B22LL, NAMSTR(s_sys_ss05797b22, "getStaticProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x030CE1D6142F8C29LL, NAMSTR(s_sys_ss142f8c29, "isInstance")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        return (t_isinstance(a0));
      }
      HASH_GUARD_LITSTR(0x1D6B8CA358B49929LL, NAMSTR(s_sys_ss58b49929, "getExtensionName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x16BA16CE6488AAAALL, NAMSTR(s_sys_ss6488aaaa, "getMethods")) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(a0));
      }
      HASH_GUARD_LITSTR(0x226F6E80CECD3CAALL, NAMSTR(s_sys_ss3132c356, "getConstructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD_LITSTR(0x24596BE6D21F7CAALL, NAMSTR(s_sys_ss2de08356, "getInterfaceNames")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x3C882D4A895F612ELL, NAMSTR(s_sys_ss76a09ed2, "getStaticPropertyValue")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x30A86FCA01FE7030LL, NAMSTR(s_sys_ss01fe7030, "newInstance")) {
        if (count <= 0) return (t_newinstance(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_newinstance(count,params));
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x3DB53E1FBD3C0734LL, NAMSTR(s_sys_ss42c3f8cc, "getConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x0D81ECE253A3B5B6LL, NAMSTR(s_sys_ss53a3b5b6, "getMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x25D24435915E6E3BLL, NAMSTR(s_sys_ss6ea191c5, "getExtension")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x0D8AAD6BA2BBCD3CLL, NAMSTR(s_sys_ss5d4432c4, "isInstantiable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x54C2DC04C4A62B3FLL, NAMSTR(s_sys_ss3b59d4c1, "hasConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x67C15E3D98C00B43LL, NAMSTR(s_sys_ss673ff4bd, "getInterfaces")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x1EB679C3602F4B44LL, NAMSTR(s_sys_ss602f4b44, "getProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x0FD73627FB023047LL, NAMSTR(s_sys_ss04fdcfb9, "getProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7D5A57B5370B68CELL, NAMSTR(s_sys_ss370b68ce, "isIterateable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x2735DCC254EE5C66LL, NAMSTR(s_sys_ss54ee5c66, "newInstanceArgs")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        return (t_newinstanceargs(a0));
      }
      break;
    case 104:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x07ECA928E37717F1LL, NAMSTR(s_sys_ss1c88e80f, "setStaticPropertyValue")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x74F7FEDE16957472LL, NAMSTR(s_sys_ss16957472, "getParentClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x28DC702215C7D6FBLL, NAMSTR(s_sys_ss15c7d6fb, "implementsInterface")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        return (t_implementsinterface(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x373333991926C97ELL, NAMSTR(s_sys_ss1926c97e, "isSubclassOf")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionClass::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionObject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionObject
Variant c_ReflectionObject::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionClass::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionObject
Variant c_ReflectionObject::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x104:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getmethods());
        else return (t_getmethods(a0));
      }
      break;
    case 0x105:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isiterateable());
      }
      break;
    case 0x106:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        else return (t_getstaticpropertyvalue(a0, a1));
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 0x108:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,vargs));
      }
      break;
    case 0x109:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextension());
      }
      break;
    case 0x10a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstructor());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x10b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_newinstanceargs(a0));
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 0x10e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstance(a0));
      }
      break;
    case 0x10d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasmethod(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x112:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperties());
      }
      break;
    case 0x113:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasconstant(a0));
      }
      break;
    case 0x114:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmethod(a0));
      }
      break;
    case 0x115:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextensionname());
      }
      break;
    case 0x116:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparentclass());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0x117:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_implementsinterface(a0));
      }
      break;
    case 0x118:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfacenames());
      }
      break;
    case 0x11a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstant(a0));
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 0x11d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinterface());
      }
      break;
    case 0x11e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issubclassof(a0));
      }
      break;
    case 0x11f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasproperty(a0));
      }
      break;
    case 0x121:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticproperties());
      }
      break;
    case 0x122:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultproperties());
      }
      break;
    case 0x123:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 0x124:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstantiable());
      }
      break;
    case 0x125:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfaces());
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x128:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperty(a0));
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x40C7B30DCB439C8FLL, NAMSTR(s_sys_ss34bc6371, "hasProperty")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x21820E7AA4733998LL, NAMSTR(s_sys_ss5b8cc668, "hasMethod")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0F1AD0A8EC4C229BLL, NAMSTR(s_sys_ss13b3dd65, "getDefaultProperties")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1BC5F3D87676509ELL, NAMSTR(s_sys_ss7676509e, "isInterface")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x323D9BCB05797B22LL, NAMSTR(s_sys_ss05797b22, "getStaticProperties")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x030CE1D6142F8C29LL, NAMSTR(s_sys_ss142f8c29, "isInstance")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstance(a0));
      }
      HASH_GUARD_LITSTR(0x1D6B8CA358B49929LL, NAMSTR(s_sys_ss58b49929, "getExtensionName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x16BA16CE6488AAAALL, NAMSTR(s_sys_ss6488aaaa, "getMethods")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getmethods());
        else return (t_getmethods(a0));
      }
      HASH_GUARD_LITSTR(0x226F6E80CECD3CAALL, NAMSTR(s_sys_ss3132c356, "getConstructor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstructor());
      }
      HASH_GUARD_LITSTR(0x24596BE6D21F7CAALL, NAMSTR(s_sys_ss2de08356, "getInterfaceNames")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x3C882D4A895F612ELL, NAMSTR(s_sys_ss76a09ed2, "getStaticPropertyValue")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        else return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x30A86FCA01FE7030LL, NAMSTR(s_sys_ss01fe7030, "newInstance")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,vargs));
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x3DB53E1FBD3C0734LL, NAMSTR(s_sys_ss42c3f8cc, "getConstant")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x0D81ECE253A3B5B6LL, NAMSTR(s_sys_ss53a3b5b6, "getMethod")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x25D24435915E6E3BLL, NAMSTR(s_sys_ss6ea191c5, "getExtension")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x0D8AAD6BA2BBCD3CLL, NAMSTR(s_sys_ss5d4432c4, "isInstantiable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x54C2DC04C4A62B3FLL, NAMSTR(s_sys_ss3b59d4c1, "hasConstant")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x67C15E3D98C00B43LL, NAMSTR(s_sys_ss673ff4bd, "getInterfaces")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x1EB679C3602F4B44LL, NAMSTR(s_sys_ss602f4b44, "getProperties")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x0FD73627FB023047LL, NAMSTR(s_sys_ss04fdcfb9, "getProperty")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7D5A57B5370B68CELL, NAMSTR(s_sys_ss370b68ce, "isIterateable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x2735DCC254EE5C66LL, NAMSTR(s_sys_ss54ee5c66, "newInstanceArgs")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_newinstanceargs(a0));
      }
      break;
    case 104:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x07ECA928E37717F1LL, NAMSTR(s_sys_ss1c88e80f, "setStaticPropertyValue")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x74F7FEDE16957472LL, NAMSTR(s_sys_ss16957472, "getParentClass")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x28DC702215C7D6FBLL, NAMSTR(s_sys_ss15c7d6fb, "implementsInterface")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_implementsinterface(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x373333991926C97ELL, NAMSTR(s_sys_ss1926c97e, "isSubclassOf")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionClass::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionObject::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionClass::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionObject = {
  c_ReflectionObject::os_getInit,
  c_ReflectionObject::os_get,
  c_ReflectionObject::os_lval,
  c_ReflectionObject::os_invoke,
  c_ReflectionObject::os_constant,
};
void c_ReflectionObject::init() {
  c_ReflectionClass::init();
}
/* SRC: classes/reflection.php line 1294 */
Variant c_ReflectionObject::ti_export(const char* cls, Variant v_obj, CVarRef v_ret) {
  STATIC_METHOD_INJECTION_BUILTIN(ReflectionObject, ReflectionObject::export);
  String v_str;

  {
    p_ReflectionObject tmp1 = NEWOBJ(c_ReflectionObject)();
    (tmp1->create(v_obj));
    v_obj = tmp1;
  }
  v_str = (toString(v_obj));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 27 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionException
Variant c_ReflectionException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionException
Variant c_ReflectionException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionException
Variant &c_ReflectionException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionException
void c_ReflectionException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionException
void c_ReflectionException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionException
Variant * c_ReflectionException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionException
Variant * c_ReflectionException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionException
Variant * c_ReflectionException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionException
Variant c_ReflectionException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionException
IMPLEMENT_CLASS(ReflectionException)
ObjectData *c_ReflectionException::cloneImpl() {
  c_ReflectionException *obj = NEW(c_ReflectionException)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionException::cloneSet(c_ReflectionException *clone) {
  c_Exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionException
Variant c_ReflectionException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionException
Variant c_ReflectionException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionException
Variant c_ReflectionException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionException
Variant c_ReflectionException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionException = {
  c_ReflectionException::os_getInit,
  c_ReflectionException::os_get,
  c_ReflectionException::os_lval,
  c_ReflectionException::os_invoke,
  c_ReflectionException::os_constant,
};
void c_ReflectionException::init() {
  c_Exception::init();
}
/* SRC: classes/reflection.php line 538 */
const int64 q_ReflectionClass_IS_IMPLICIT_ABSTRACT = 16LL;
const int64 q_ReflectionClass_IS_EXPLICIT_ABSTRACT = 32LL;
const int64 q_ReflectionClass_IS_FINAL = 64LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionClass
Variant c_ReflectionClass::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 3) {
    case 2:
      HASH_RETURN_NAMSTR(0x5655B4FF77E35232LL, NAMSTR(s_sys_ss77e35232, "name"),
                         null, 4);
      break;
    case 3:
      HASH_RETURN_NAMSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionClass
Variant c_ReflectionClass::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionClass
Variant &c_ReflectionClass::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionClass
void c_ReflectionClass::o_getArray(Array &props) const {
  if (isInitialized(m_name)) props.set(NAMSTR(s_sys_ss77e35232, "name"), m_name.isReferenced() ? ref(m_name) : m_name, true);
  if (isInitialized(m_info)) props.add(NAMSTR(s_sys_ss77c51ddf, "\000ReflectionClass\000info"), m_info.isReferenced() ? ref(m_info) : m_info, true);
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionClass
void c_ReflectionClass::o_setArray(CArrRef props) {
  props->load(NAMSTR(s_sys_ss77c51ddf, "\000ReflectionClass\000info"), m_info);
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionClass
Variant * c_ReflectionClass::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_GUARD_STRING(0x35A44A5E6AE2E71DLL, ReflectionClass) { return o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionClass
Variant * c_ReflectionClass::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_REALPROP_STRING(0x5655B4FF77E35232LL, "name", 4, name);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionClass
Variant * c_ReflectionClass::o_realPropPrivate(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_STRING(0x0F2EF58F157D479FLL, "info", 4, info);
      break;
    default:
      break;
  }
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionClass
Variant c_ReflectionClass::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_RETURN(0x042E299D3BE2773ALL, q_ReflectionClass_IS_IMPLICIT_ABSTRACT, "IS_IMPLICIT_ABSTRACT");
      break;
    case 6:
      HASH_RETURN(0x468EF528A19B529ELL, q_ReflectionClass_IS_EXPLICIT_ABSTRACT, "IS_EXPLICIT_ABSTRACT");
      HASH_RETURN(0x47AAFAC74A58AD66LL, q_ReflectionClass_IS_FINAL, "IS_FINAL");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionClass
IMPLEMENT_CLASS(ReflectionClass)
c_ReflectionClass *c_ReflectionClass::create(Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_name);
  return this;
}
ObjectData *c_ReflectionClass::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_ReflectionClass::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_ReflectionClass::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_ReflectionClass::cloneImpl() {
  c_ReflectionClass *obj = NEW(c_ReflectionClass)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionClass::cloneSet(c_ReflectionClass *clone) {
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionClass
Variant c_ReflectionClass::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x104:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getmethods());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethods(arg0));
        }
      }
      break;
    case 0x105:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 0x106:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getstaticpropertyvalue(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getstaticpropertyvalue(arg0, arg1));
        }
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x108:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,params.slice(0, count - 0, false)));
      }
      break;
    case 0x109:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 0x10a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x10b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_newinstanceargs(arg0));
        }
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x10e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isinstance(arg0));
        }
      }
      break;
    case 0x10d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasmethod(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 0x112:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 0x113:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasconstant(arg0));
        }
      }
      break;
    case 0x114:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethod(arg0));
        }
      }
      break;
    case 0x115:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 0x116:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x117:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_implementsinterface(arg0));
        }
      }
      break;
    case 0x118:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 0x11a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getconstant(arg0));
        }
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x11d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 0x11e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issubclassof(arg0));
        }
      }
      break;
    case 0x11f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasproperty(arg0));
        }
      }
      break;
    case 0x121:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 0x120:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_test(arg0, arg1));
        }
      }
      break;
    case 0x122:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 0x123:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setstaticpropertyvalue(arg0, arg1), null);
        }
      }
      break;
    case 0x124:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 0x125:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 0xfe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetch(arg0));
        }
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x128:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getproperty(arg0));
        }
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x40C7B30DCB439C8FLL, NAMSTR(s_sys_ss34bc6371, "hasProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasproperty(arg0));
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x21820E7AA4733998LL, NAMSTR(s_sys_ss5b8cc668, "hasMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasmethod(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0F1AD0A8EC4C229BLL, NAMSTR(s_sys_ss13b3dd65, "getDefaultProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1BC5F3D87676509ELL, NAMSTR(s_sys_ss7676509e, "isInterface")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x323D9BCB05797B22LL, NAMSTR(s_sys_ss05797b22, "getStaticProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x030CE1D6142F8C29LL, NAMSTR(s_sys_ss142f8c29, "isInstance")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isinstance(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x1D6B8CA358B49929LL, NAMSTR(s_sys_ss58b49929, "getExtensionName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x16BA16CE6488AAAALL, NAMSTR(s_sys_ss6488aaaa, "getMethods")) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getmethods());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethods(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x226F6E80CECD3CAALL, NAMSTR(s_sys_ss3132c356, "getConstructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD_LITSTR(0x24596BE6D21F7CAALL, NAMSTR(s_sys_ss2de08356, "getInterfaceNames")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x3C882D4A895F612ELL, NAMSTR(s_sys_ss76a09ed2, "getStaticPropertyValue")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getstaticpropertyvalue(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getstaticpropertyvalue(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x30A86FCA01FE7030LL, NAMSTR(s_sys_ss01fe7030, "newInstance")) {
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,params.slice(0, count - 0, false)));
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x3DB53E1FBD3C0734LL, NAMSTR(s_sys_ss42c3f8cc, "getConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getconstant(arg0));
        }
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x0D81ECE253A3B5B6LL, NAMSTR(s_sys_ss53a3b5b6, "getMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getmethod(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x25D24435915E6E3BLL, NAMSTR(s_sys_ss6ea191c5, "getExtension")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x0D8AAD6BA2BBCD3CLL, NAMSTR(s_sys_ss5d4432c4, "isInstantiable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x54C2DC04C4A62B3FLL, NAMSTR(s_sys_ss3b59d4c1, "hasConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasconstant(arg0));
        }
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x67C15E3D98C00B43LL, NAMSTR(s_sys_ss673ff4bd, "getInterfaces")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x1EB679C3602F4B44LL, NAMSTR(s_sys_ss602f4b44, "getProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x0FD73627FB023047LL, NAMSTR(s_sys_ss04fdcfb9, "getProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getproperty(arg0));
        }
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7D5A57B5370B68CELL, NAMSTR(s_sys_ss370b68ce, "isIterateable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x2735DCC254EE5C66LL, NAMSTR(s_sys_ss54ee5c66, "newInstanceArgs")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_newinstanceargs(arg0));
        }
      }
      break;
    case 103:
      HASH_GUARD_LITSTR(0x37349B25A0ED29E7LL, NAMSTR(s_sys_ss5f12d619, "test")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_test(arg0, arg1));
        }
      }
      break;
    case 104:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x07ECA928E37717F1LL, NAMSTR(s_sys_ss1c88e80f, "setStaticPropertyValue")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setstaticpropertyvalue(arg0, arg1), null);
        }
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x74F7FEDE16957472LL, NAMSTR(s_sys_ss16957472, "getParentClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x28DC702215C7D6FBLL, NAMSTR(s_sys_ss15c7d6fb, "implementsInterface")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_implementsinterface(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetch(arg0));
        }
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x373333991926C97ELL, NAMSTR(s_sys_ss1926c97e, "isSubclassOf")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issubclassof(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionClass
Variant c_ReflectionClass::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x104:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(a0));
      }
      break;
    case 0x105:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 0x106:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        return (t_getstaticpropertyvalue(a0, a1));
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x108:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count <= 0) return (t_newinstance(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_newinstance(count,params));
      }
      break;
    case 0x109:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 0x10a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x10b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        return (t_newinstanceargs(a0));
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x10e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        return (t_isinstance(a0));
      }
      break;
    case 0x10d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        return (t_hasmethod(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x112:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 0x113:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        return (t_hasconstant(a0));
      }
      break;
    case 0x114:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        return (t_getmethod(a0));
      }
      break;
    case 0x115:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 0x116:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x117:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        return (t_implementsinterface(a0));
      }
      break;
    case 0x118:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 0x11a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        return (t_getconstant(a0));
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x11d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 0x11e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        return (t_issubclassof(a0));
      }
      break;
    case 0x11f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        return (t_hasproperty(a0));
      }
      break;
    case 0x121:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 0x120:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
        return (t_test(a0, a1));
      }
      break;
    case 0x122:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 0x123:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 0x124:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 0x125:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 0xfe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
        return (t_fetch(a0));
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x128:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        return (t_getproperty(a0));
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x40C7B30DCB439C8FLL, NAMSTR(s_sys_ss34bc6371, "hasProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x21820E7AA4733998LL, NAMSTR(s_sys_ss5b8cc668, "hasMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0F1AD0A8EC4C229BLL, NAMSTR(s_sys_ss13b3dd65, "getDefaultProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1BC5F3D87676509ELL, NAMSTR(s_sys_ss7676509e, "isInterface")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x323D9BCB05797B22LL, NAMSTR(s_sys_ss05797b22, "getStaticProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x030CE1D6142F8C29LL, NAMSTR(s_sys_ss142f8c29, "isInstance")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        return (t_isinstance(a0));
      }
      HASH_GUARD_LITSTR(0x1D6B8CA358B49929LL, NAMSTR(s_sys_ss58b49929, "getExtensionName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x16BA16CE6488AAAALL, NAMSTR(s_sys_ss6488aaaa, "getMethods")) {
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(a0));
      }
      HASH_GUARD_LITSTR(0x226F6E80CECD3CAALL, NAMSTR(s_sys_ss3132c356, "getConstructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD_LITSTR(0x24596BE6D21F7CAALL, NAMSTR(s_sys_ss2de08356, "getInterfaceNames")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x3C882D4A895F612ELL, NAMSTR(s_sys_ss76a09ed2, "getStaticPropertyValue")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x30A86FCA01FE7030LL, NAMSTR(s_sys_ss01fe7030, "newInstance")) {
        if (count <= 0) return (t_newinstance(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_newinstance(count,params));
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x3DB53E1FBD3C0734LL, NAMSTR(s_sys_ss42c3f8cc, "getConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x0D81ECE253A3B5B6LL, NAMSTR(s_sys_ss53a3b5b6, "getMethod")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x25D24435915E6E3BLL, NAMSTR(s_sys_ss6ea191c5, "getExtension")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x0D8AAD6BA2BBCD3CLL, NAMSTR(s_sys_ss5d4432c4, "isInstantiable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x54C2DC04C4A62B3FLL, NAMSTR(s_sys_ss3b59d4c1, "hasConstant")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x67C15E3D98C00B43LL, NAMSTR(s_sys_ss673ff4bd, "getInterfaces")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x1EB679C3602F4B44LL, NAMSTR(s_sys_ss602f4b44, "getProperties")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x0FD73627FB023047LL, NAMSTR(s_sys_ss04fdcfb9, "getProperty")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7D5A57B5370B68CELL, NAMSTR(s_sys_ss370b68ce, "isIterateable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x2735DCC254EE5C66LL, NAMSTR(s_sys_ss54ee5c66, "newInstanceArgs")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        return (t_newinstanceargs(a0));
      }
      break;
    case 103:
      HASH_GUARD_LITSTR(0x37349B25A0ED29E7LL, NAMSTR(s_sys_ss5f12d619, "test")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
        return (t_test(a0, a1));
      }
      break;
    case 104:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x07ECA928E37717F1LL, NAMSTR(s_sys_ss1c88e80f, "setStaticPropertyValue")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x74F7FEDE16957472LL, NAMSTR(s_sys_ss16957472, "getParentClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x28DC702215C7D6FBLL, NAMSTR(s_sys_ss15c7d6fb, "implementsInterface")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        return (t_implementsinterface(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
        return (t_fetch(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x373333991926C97ELL, NAMSTR(s_sys_ss1926c97e, "isSubclassOf")) {
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionClass
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionClass
Variant c_ReflectionClass::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionClass
Variant c_ReflectionClass::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x104:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getmethods());
        else return (t_getmethods(a0));
      }
      break;
    case 0x105:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isiterateable());
      }
      break;
    case 0x106:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        else return (t_getstaticpropertyvalue(a0, a1));
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 0x108:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,vargs));
      }
      break;
    case 0x109:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextension());
      }
      break;
    case 0x10a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstructor());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x10b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_newinstanceargs(a0));
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 0x10e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstance(a0));
      }
      break;
    case 0x10d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasmethod(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x112:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperties());
      }
      break;
    case 0x113:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasconstant(a0));
      }
      break;
    case 0x114:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmethod(a0));
      }
      break;
    case 0x115:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextensionname());
      }
      break;
    case 0x116:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparentclass());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0x117:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_implementsinterface(a0));
      }
      break;
    case 0x118:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfacenames());
      }
      break;
    case 0x11a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstant(a0));
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 0x11d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinterface());
      }
      break;
    case 0x11e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issubclassof(a0));
      }
      break;
    case 0x11f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasproperty(a0));
      }
      break;
    case 0x121:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticproperties());
      }
      break;
    case 0x120:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_test(a0, a1));
      }
      break;
    case 0x122:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultproperties());
      }
      break;
    case 0x123:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 0x124:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstantiable());
      }
      break;
    case 0x125:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfaces());
      }
      break;
    case 0xfe:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fetch(a0));
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x128:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperty(a0));
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x40C7B30DCB439C8FLL, NAMSTR(s_sys_ss34bc6371, "hasProperty")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x21820E7AA4733998LL, NAMSTR(s_sys_ss5b8cc668, "hasMethod")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0F1AD0A8EC4C229BLL, NAMSTR(s_sys_ss13b3dd65, "getDefaultProperties")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1BC5F3D87676509ELL, NAMSTR(s_sys_ss7676509e, "isInterface")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x323D9BCB05797B22LL, NAMSTR(s_sys_ss05797b22, "getStaticProperties")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x030CE1D6142F8C29LL, NAMSTR(s_sys_ss142f8c29, "isInstance")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstance(a0));
      }
      HASH_GUARD_LITSTR(0x1D6B8CA358B49929LL, NAMSTR(s_sys_ss58b49929, "getExtensionName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x16BA16CE6488AAAALL, NAMSTR(s_sys_ss6488aaaa, "getMethods")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getmethods());
        else return (t_getmethods(a0));
      }
      HASH_GUARD_LITSTR(0x226F6E80CECD3CAALL, NAMSTR(s_sys_ss3132c356, "getConstructor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstructor());
      }
      HASH_GUARD_LITSTR(0x24596BE6D21F7CAALL, NAMSTR(s_sys_ss2de08356, "getInterfaceNames")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x3C882D4A895F612ELL, NAMSTR(s_sys_ss76a09ed2, "getStaticPropertyValue")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        else return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x30A86FCA01FE7030LL, NAMSTR(s_sys_ss01fe7030, "newInstance")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,vargs));
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x3DB53E1FBD3C0734LL, NAMSTR(s_sys_ss42c3f8cc, "getConstant")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x0D81ECE253A3B5B6LL, NAMSTR(s_sys_ss53a3b5b6, "getMethod")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x25D24435915E6E3BLL, NAMSTR(s_sys_ss6ea191c5, "getExtension")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x0D8AAD6BA2BBCD3CLL, NAMSTR(s_sys_ss5d4432c4, "isInstantiable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x54C2DC04C4A62B3FLL, NAMSTR(s_sys_ss3b59d4c1, "hasConstant")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x67C15E3D98C00B43LL, NAMSTR(s_sys_ss673ff4bd, "getInterfaces")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x1EB679C3602F4B44LL, NAMSTR(s_sys_ss602f4b44, "getProperties")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x0FD73627FB023047LL, NAMSTR(s_sys_ss04fdcfb9, "getProperty")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7D5A57B5370B68CELL, NAMSTR(s_sys_ss370b68ce, "isIterateable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x2735DCC254EE5C66LL, NAMSTR(s_sys_ss54ee5c66, "newInstanceArgs")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_newinstanceargs(a0));
      }
      break;
    case 103:
      HASH_GUARD_LITSTR(0x37349B25A0ED29E7LL, NAMSTR(s_sys_ss5f12d619, "test")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_test(a0, a1));
      }
      break;
    case 104:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x07ECA928E37717F1LL, NAMSTR(s_sys_ss1c88e80f, "setStaticPropertyValue")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x74F7FEDE16957472LL, NAMSTR(s_sys_ss16957472, "getParentClass")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x28DC702215C7D6FBLL, NAMSTR(s_sys_ss15c7d6fb, "implementsInterface")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_implementsinterface(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fetch(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x373333991926C97ELL, NAMSTR(s_sys_ss1926c97e, "isSubclassOf")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionClass::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionClass = {
  c_ReflectionClass::os_getInit,
  c_ReflectionClass::os_get,
  c_ReflectionClass::os_lval,
  c_ReflectionClass::os_invoke,
  c_ReflectionClass::os_constant,
};
void c_ReflectionClass::init() {
  m_name = null;
  m_info = null;
}
/* SRC: classes/reflection.php line 546 */
void c_ReflectionClass::t___construct(Variant v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::__construct);
  bool oldInCtor = gasInCtor(true);
  if (x_is_object(v_name)) {
    {
      {
        const Variant &tmp1((x_get_class(v_name)));
        v_name = tmp1;
      }
    }
  }
  else {
    {
      {
        bool tmp2;
        {
          bool tmp3((toBoolean(x_call_user_func(2, NAMSTR(s_sys_ss471864c8, "class_exists"), Array(ArrayInit(1, true).setRef(v_name).create())))));
          bool tmp4 = (!(tmp3));
          if (tmp4) {
            bool tmp5((toBoolean(x_call_user_func(2, NAMSTR(s_sys_ss4e9b09e6, "interface_exists"), Array(ArrayInit(1, true).setRef(v_name).create())))));
            tmp4 = (!(tmp5));
          }
          tmp2 = (tmp4);
        }
        if (tmp2) {
          {
            {
              p_ReflectionException tmp6 = NEWOBJ(c_ReflectionException)();
              throw_exception((tmp6->create(concat3(NAMSTR(s_sys_ss1f74c210_1, "Class "), toString(v_name), NAMSTR(s_sys_ss20448282, " does not exist"))), tmp6));
            }
          }
        }
      }
    }
  }
  {
    const String &tmp7((x_hphp_get_original_class_name(toString(v_name))));
    m_name = tmp7;
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 559 */
Variant c_ReflectionClass::t_fetch(CVarRef v_what) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::fetch);
  Variant v_name;
  p_ReflectionClass v_p;
  Primitive v_interface = 0;
  Variant v__;

  if (!(toBoolean(m_info))) {
    {
      {
        const Variant &tmp1((x_call_user_func(2, NAMSTR(s_sys_ss5f965e7b, "hphp_get_class_info"), Array(ArrayInit(1, true).setRef(m_name).create()))));
        m_info = tmp1;
      }
      if (empty(m_info)) {
        {
          {
            p_ReflectionException tmp2 = NEWOBJ(c_ReflectionException)();
            throw_exception((tmp2->create(concat3(NAMSTR(s_sys_ss1f74c210_1, "Class "), toString(v_name), NAMSTR(s_sys_ss20448282, " does not exist"))), tmp2));
          }
        }
      }
      if (toBoolean(t_isinterface())) {
        {
          if (!(empty(m_info, NAMSTR(s_sys_ss2d13045e, "parent"), true))) {
            {
              {
                p_ReflectionClass tmp3 = NEWOBJ(c_ReflectionClass)();
                (tmp3->create(m_info.rvalAt(NAMSTR(s_sys_ss2d13045e, "parent"), true, true)));
                v_p = tmp3;
              }
              {
                Variant tmp4((m_info.rvalAt(NAMSTR(s_sys_ss2d13045e, "parent"), true, true)));
                lval(m_info.lvalAt(NAMSTR(s_sys_ss56221a08, "interfaces"), false, true)).append((tmp4));
              }
              {
                const Variant &tmp5((v_p->t_fetch(NAMSTR(s_sys_ss56221a08, "interfaces"))));
                m_info.setOpEqual(277, NAMSTR(s_sys_ss56221a08, "interfaces"), (tmp5), true);
              }
              {
                Variant tmp6((v_p->m_info.rvalAt(NAMSTR(s_sys_ss68683632, "methods"), true, true)));
                m_info.setOpEqual(277, NAMSTR(s_sys_ss68683632, "methods"), (tmp6), true);
              }
              {
                Variant tmp7((v_p->m_info.rvalAt(NAMSTR(s_sys_ss1d07a592, "constants"), true, true)));
                m_info.setOpEqual(277, NAMSTR(s_sys_ss1d07a592, "constants"), (tmp7), true);
              }
            }
          }
        }
      }
      else {
        {
          {
            LOOP_COUNTER(8);
            Variant map9 = m_info.rvalAt(NAMSTR(s_sys_ss56221a08, "interfaces"), true, true);
            for (ArrayIterPtr iter10 = map9.begin(s_class_name); !iter10->end(); iter10->next()) {
              LOOP_COUNTER_CHECK(8);
              iter10->second(v__);
              v_interface = iter10->first();
              {
                {
                  p_ReflectionClass tmp11 = NEWOBJ(c_ReflectionClass)();
                  (tmp11->create(v_interface));
                  v_p = tmp11;
                }
                {
                  const Variant &tmp12((v_p->t_fetch(NAMSTR(s_sys_ss68683632, "methods"))));
                  m_info.setOpEqual(277, NAMSTR(s_sys_ss68683632, "methods"), (tmp12), true);
                }
                {
                  Variant tmp13((v_p->m_info.rvalAt(NAMSTR(s_sys_ss1d07a592, "constants"), true, true)));
                  m_info.setOpEqual(277, NAMSTR(s_sys_ss1d07a592, "constants"), (tmp13), true);
                }
                {
                  Variant tmp14((v_p->m_info.rvalAt(NAMSTR(s_sys_ss56221a08, "interfaces"), true, true)));
                  m_info.setOpEqual(277, NAMSTR(s_sys_ss56221a08, "interfaces"), (tmp14), true);
                }
              }
            }
          }
          if (!(empty(m_info, NAMSTR(s_sys_ss2d13045e, "parent"), true))) {
            {
              {
                p_ReflectionClass tmp15 = NEWOBJ(c_ReflectionClass)();
                (tmp15->create(m_info.rvalAt(NAMSTR(s_sys_ss2d13045e, "parent"), true, true)));
                v_p = tmp15;
              }
              {
                const Variant &tmp16((v_p->t_fetch(NAMSTR(s_sys_ss56221a08, "interfaces"))));
                m_info.setOpEqual(277, NAMSTR(s_sys_ss56221a08, "interfaces"), (tmp16), true);
              }
              {
                Variant tmp17((v_p->m_info.rvalAt(NAMSTR(s_sys_ss749653da, "properties"), true, true)));
                m_info.setOpEqual(277, NAMSTR(s_sys_ss749653da, "properties"), (tmp17), true);
              }
              {
                Variant tmp18((v_p->m_info.rvalAt(NAMSTR(s_sys_ss68683632, "methods"), true, true)));
                m_info.setOpEqual(277, NAMSTR(s_sys_ss68683632, "methods"), (tmp18), true);
              }
              {
                Variant tmp19((v_p->m_info.rvalAt(NAMSTR(s_sys_ss1d07a592, "constants"), true, true)));
                m_info.setOpEqual(277, NAMSTR(s_sys_ss1d07a592, "constants"), (tmp19), true);
              }
            }
          }
        }
      }
    }
  }
  return m_info.rvalAt(v_what, true);
} /* function */
/* SRC: classes/reflection.php line 593 */
bool c_ReflectionClass::t_test(CVarRef v_what, CVarRef v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::test);
  Variant v_v;

  {
    const Variant &tmp1((t_fetch(v_what)));
    v_v = tmp1;
  }
  return (toBoolean(v_v) && isset(v_v, v_name));
} /* function */
/* SRC: classes/reflection.php line 598 */
String c_ReflectionClass::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 617 */
Variant c_ReflectionClass::ti_export(const char* cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::export);
  p_ReflectionClass v_obj;
  String v_str;

  {
    p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
    (tmp1->create(v_name));
    v_obj = tmp1;
  }
  v_str = (toString(v_obj));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 635 */
Variant c_ReflectionClass::t_getname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getName);
  return t_fetch(NAMSTR(s_sys_ss77e35232, "name"));
} /* function */
/* SRC: classes/reflection.php line 649 */
Variant c_ReflectionClass::t_isinternal() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isInternal);
  return t_fetch(NAMSTR(s_sys_ss71135554, "internal"));
} /* function */
/* SRC: classes/reflection.php line 662 */
bool c_ReflectionClass::t_isuserdefined() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isUserDefined);
  {
    bool tmp1((toBoolean(t_fetch(NAMSTR(s_sys_ss71135554, "internal")))));
    return !(tmp1);
  }
} /* function */
/* SRC: classes/reflection.php line 676 */
bool c_ReflectionClass::t_isinstantiable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isInstantiable);
  {
    bool tmp1((toBoolean(t_fetch(NAMSTR(s_sys_ss01d79b38, "abstract")))));
    return !(tmp1);
  }
} /* function */
/* SRC: classes/reflection.php line 691 */
bool c_ReflectionClass::t_hasconstant(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::hasConstant);
  return t_test(NAMSTR(s_sys_ss1d07a592, "constants"), v_name);
} /* function */
/* SRC: classes/reflection.php line 705 */
bool c_ReflectionClass::t_hasmethod(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::hasMethod);
  {
    const String &tmp1((x_strtolower(toString(v_name))));
    return t_test(NAMSTR(s_sys_ss68683632, "methods"), tmp1);
  }
} /* function */
/* SRC: classes/reflection.php line 720 */
bool c_ReflectionClass::t_hasproperty(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::hasProperty);
  return t_test(NAMSTR(s_sys_ss749653da, "properties"), v_name);
} /* function */
/* SRC: classes/reflection.php line 735 */
Variant c_ReflectionClass::t_getfilename() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getFileName);
  return t_fetch(NAMSTR(s_sys_ss70cc2eb1, "file"));
} /* function */
/* SRC: classes/reflection.php line 749 */
Variant c_ReflectionClass::t_getstartline() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getStartLine);
  return t_fetch(NAMSTR(s_sys_ss028b2c66, "line1"));
} /* function */
/* SRC: classes/reflection.php line 762 */
Variant c_ReflectionClass::t_getendline() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getEndLine);
  return t_fetch(NAMSTR(s_sys_ss3195c8e2, "line2"));
} /* function */
/* SRC: classes/reflection.php line 776 */
Variant c_ReflectionClass::t_getdoccomment() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getDocComment);
  return t_fetch(NAMSTR(s_sys_ss70714913, "doc"));
} /* function */
/* SRC: classes/reflection.php line 790 */
Variant c_ReflectionClass::t_getconstructor() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getConstructor);
  Variant v_name;

  if (t_hasmethod(NAMSTR(s_sys_ss229c615f, "__construct"))) {
    {
      return t_getmethod(NAMSTR(s_sys_ss229c615f, "__construct"));
    }
  }
  {
    bool tmp1;
    {
      const Variant &tmp2((t_fetch(NAMSTR(s_sys_ss77e35232, "name"))));
      tmp1 = (t_hasmethod((v_name = tmp2)));
    }
    if (tmp1) {
      {
        return t_getmethod(v_name);
      }
    }
  }
  return null;
} /* function */
/* SRC: classes/reflection.php line 811 */
p_ReflectionMethod c_ReflectionClass::t_getmethod(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getMethod);
  String v_lname;
  Variant v_methods;
  Variant v_class;
  p_ReflectionMethod v_ret;

  {
    const String &tmp1((x_strtolower(toString(v_name))));
    v_lname = tmp1;
  }
  {
    const Variant &tmp2((t_fetch(NAMSTR(s_sys_ss68683632, "methods"))));
    v_methods = tmp2;
  }
  if (!(isset(v_methods, v_lname))) {
    {
      {
        Variant tmp3((m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true)));
        v_class = tmp3;
      }
      {
        p_ReflectionException tmp4 = NEWOBJ(c_ReflectionException)();
        throw_exception((tmp4->create(concat5(NAMSTR(s_sys_ss76d82ece, "Method "), toString(v_class), NAMSTR(s_sys_ss1cfa5b62, "::"), toString(v_name), NAMSTR(s_sys_ss20448282, " does not exist"))), tmp4));
      }
    }
  }
  {
    p_ReflectionMethod tmp5((p_ReflectionMethod((NEWOBJ(c_ReflectionMethod)())->create(null, null))));
    v_ret = tmp5;
  }
  {
    Variant tmp6((v_methods.rvalAt(v_lname, true)));
    v_ret->m_info = tmp6;
  }
  v_ret->m_name = v_lname;
  {
    Variant tmp7((m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true)));
    v_ret->m_class = tmp7;
  }
  {
    bool tmp8;
    {
      bool tmp9 = (equal(v_lname, NAMSTR(s_sys_ss229c615f, "__construct")));
      if (!tmp9) {
        bool tmp10((toBoolean(x_strcasecmp(v_lname, toString(v_ret->m_class)))));
        bool tmp11 = (!(tmp10));
        if (tmp11) {
          bool tmp12((t_hasmethod(NAMSTR(s_sys_ss229c615f, "__construct"))));
          tmp11 = (!(tmp12));
        }
        tmp9 = (tmp11);
      }
      tmp8 = (tmp9);
    }
    if (tmp8) {
      {
        v_ret->m_info.set(NAMSTR(s_sys_ss3a464145, "constructor"), (true), true);
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 847 */
Array c_ReflectionClass::t_getmethods(CVarRef v_filter //  = 65535LL
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getMethods);
  Array v_ret;
  Variant v_methods;
  Primitive v_name = 0;
  Variant v__;
  p_ReflectionMethod v_m;

  v_ret = s_sys_sa00000000;
  {
    const Variant &tmp1((t_fetch(NAMSTR(s_sys_ss68683632, "methods"))));
    v_methods = tmp1;
  }
  {
    LOOP_COUNTER(2);
    for (ArrayIterPtr iter4 = v_methods.begin(s_class_name); !iter4->end(); iter4->next()) {
      LOOP_COUNTER_CHECK(2);
      iter4->second(v__);
      v_name = iter4->first();
      {
        {
          const p_ReflectionMethod &tmp5((t_getmethod(v_name)));
          v_m = tmp5;
        }
        if (((((((toBoolean(bitwise_and(v_filter, 256LL /* reflectionmethod::IS_PUBLIC */)) && v_m->t_ispublic()) || (toBoolean(bitwise_and(v_filter, 512LL /* reflectionmethod::IS_PROTECTED */)) && v_m->t_isprotected())) || (toBoolean(bitwise_and(v_filter, 1024LL /* reflectionmethod::IS_PRIVATE */)) && v_m->t_isprivate())) || (toBoolean(bitwise_and(v_filter, 1LL /* reflectionmethod::IS_STATIC */)) && toBoolean(v_m->t_isstatic()))) || (toBoolean(bitwise_and(v_filter, 4LL /* reflectionmethod::IS_FINAL */)) && toBoolean(v_m->t_isfinal()))) || (toBoolean(bitwise_and(v_filter, 2LL /* reflectionmethod::IS_ABSTRACT */)) && toBoolean(v_m->t_isabstract())))) {
          {
            {
              p_ReflectionMethod tmp6((v_m));
              v_ret.append((tmp6));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 876 */
p_ReflectionProperty c_ReflectionClass::t_getproperty(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getProperty);
  Variant v_properties;
  Variant v_class;
  p_ReflectionProperty v_ret;

  {
    const Variant &tmp1((t_fetch(NAMSTR(s_sys_ss749653da, "properties"))));
    v_properties = tmp1;
  }
  if (!(isset(v_properties, v_name))) {
    {
      {
        Variant tmp2((m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true)));
        v_class = tmp2;
      }
      {
        p_ReflectionException tmp3 = NEWOBJ(c_ReflectionException)();
        throw_exception((tmp3->create(concat5(NAMSTR(s_sys_ss3512adea, "Property "), toString(v_class), NAMSTR(s_sys_ss1cfa5b62, "::"), toString(v_name), NAMSTR(s_sys_ss20448282, " does not exist"))), tmp3));
      }
    }
  }
  {
    p_ReflectionProperty tmp4((p_ReflectionProperty((NEWOBJ(c_ReflectionProperty)())->create(null, null))));
    v_ret = tmp4;
  }
  {
    Variant tmp5((v_properties.rvalAt(v_name, true)));
    v_ret->m_info = tmp5;
  }
  v_ret->m_name = v_name;
  {
    Variant tmp6((m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true)));
    v_ret->m_class = tmp6;
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 899 */
Array c_ReflectionClass::t_getproperties() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getProperties);
  Array v_ret;
  Primitive v_name = 0;
  Variant v__;

  v_ret = s_sys_sa00000000;
  {
    LOOP_COUNTER(1);
    Variant map2 = t_fetch(NAMSTR(s_sys_ss749653da, "properties"));
    for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v__);
      v_name = iter3->first();
      {
        {
          const p_ReflectionProperty &tmp4((t_getproperty(v_name)));
          v_ret.append((tmp4));
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 917 */
Variant c_ReflectionClass::t_getconstants() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getConstants);
  return t_fetch(NAMSTR(s_sys_ss1d07a592, "constants"));
} /* function */
/* SRC: classes/reflection.php line 931 */
Variant c_ReflectionClass::t_getconstant(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getConstant);
  Variant v_constants;
  Variant v_class;

  {
    const Variant &tmp1((t_fetch(NAMSTR(s_sys_ss1d07a592, "constants"))));
    v_constants = tmp1;
  }
  if (!(isset(v_constants, v_name))) {
    {
      {
        Variant tmp2((m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true)));
        v_class = tmp2;
      }
      {
        p_ReflectionException tmp3 = NEWOBJ(c_ReflectionException)();
        throw_exception((tmp3->create(concat5(NAMSTR(s_sys_ss644993a4, "Class constant "), toString(v_class), NAMSTR(s_sys_ss1cfa5b62, "::"), toString(v_name), NAMSTR(s_sys_ss20448282, " does not exist"))), tmp3));
      }
    }
  }
  return v_constants.rvalAt(v_name, true);
} /* function */
/* SRC: classes/reflection.php line 951 */
Variant c_ReflectionClass::t_getinterfaces() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getInterfaces);
  Variant v_ret;
  Primitive v_name = 0;
  Variant v__;
  p_ReflectionClass v_cls;

  v_ret = s_sys_sa00000000;
  {
    LOOP_COUNTER(1);
    Variant map2 = t_fetch(NAMSTR(s_sys_ss56221a08, "interfaces"));
    for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v__);
      v_name = iter3->first();
      {
        {
          p_ReflectionClass tmp4 = NEWOBJ(c_ReflectionClass)();
          (tmp4->create(v_name));
          v_cls = tmp4;
        }
        if (toBoolean(v_cls->t_isinterface())) {
          {
            {
              const Variant &tmp5((v_cls->t_getname()));
              p_ReflectionClass tmp6((v_cls));
              v_ret.set(tmp5, (tmp6));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 972 */
Array c_ReflectionClass::t_getinterfacenames() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getInterfaceNames);
  Array v_ret;
  Primitive v_name = 0;
  Variant v__;
  p_ReflectionClass v_cls;

  v_ret = s_sys_sa00000000;
  {
    LOOP_COUNTER(1);
    Variant map2 = t_fetch(NAMSTR(s_sys_ss56221a08, "interfaces"));
    for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v__);
      v_name = iter3->first();
      {
        {
          p_ReflectionClass tmp4 = NEWOBJ(c_ReflectionClass)();
          (tmp4->create(v_name));
          v_cls = tmp4;
        }
        if (toBoolean(v_cls->t_isinterface())) {
          {
            {
              const Variant &tmp5((v_cls->t_getname()));
              v_ret.append((tmp5));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 993 */
Variant c_ReflectionClass::t_isinterface() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isInterface);
  return t_fetch(NAMSTR(s_sys_ss1558c380, "interface"));
} /* function */
/* SRC: classes/reflection.php line 1005 */
Variant c_ReflectionClass::t_isabstract() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isAbstract);
  return t_fetch(NAMSTR(s_sys_ss01d79b38, "abstract"));
} /* function */
/* SRC: classes/reflection.php line 1017 */
Variant c_ReflectionClass::t_isfinal() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isFinal);
  return t_fetch(NAMSTR(s_sys_ss2f433c87, "final"));
} /* function */
/* SRC: classes/reflection.php line 1030 */
Variant c_ReflectionClass::t_getmodifiers() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getModifiers);
  return t_fetch(NAMSTR(s_sys_ss6d6e147d, "modifiers"));
} /* function */
/* SRC: classes/reflection.php line 1044 */
bool c_ReflectionClass::t_isinstance(CVarRef v_obj) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isInstance);
  return x_hphp_instanceof(toObject(v_obj), toString(m_name));
} /* function */
/* SRC: classes/reflection.php line 1057 */
Object c_ReflectionClass::t_newinstance(int num_args, Array args /* = Array() */) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::newInstance);
  Array v_args;

  {
    const Array &tmp1((func_get_args(num_args, Array(),args)));
    v_args = tmp1;
  }
  return x_hphp_create_object(toString(m_name), v_args);
} /* function */
/* SRC: classes/reflection.php line 1076 */
Object c_ReflectionClass::t_newinstanceargs(CVarRef v_args) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::newInstanceArgs);
  {
    const String &tmp1((toString(m_name)));
    const Array &tmp2((toArray(x_array_values(v_args))));
    return x_hphp_create_object(tmp1, tmp2);
  }
} /* function */
/* SRC: classes/reflection.php line 1090 */
Variant c_ReflectionClass::t_getparentclass() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getParentClass);
  {
    bool tmp1;
    {
      const Variant &tmp2((t_fetch(NAMSTR(s_sys_ss2d13045e, "parent"))));
      tmp1 = (empty(tmp2));
    }
    if (tmp1) {
      {
        return false;
      }
    }
  }
  {
    p_ReflectionClass tmp3 = NEWOBJ(c_ReflectionClass)();
    const Variant &tmp4((t_fetch(NAMSTR(s_sys_ss2d13045e, "parent"))));
    return (tmp3->create(tmp4), tmp3);
  }
} /* function */
/* SRC: classes/reflection.php line 1108 */
Variant c_ReflectionClass::t_issubclassof(Variant v_cls) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isSubclassOf);
  Primitive v_name = 0;
  Variant v__;

  if (instanceOf(v_cls, "ReflectionClass")) {
    {
      {
        Variant tmp1((v_cls. BIND_CLASS_DOT o_invoke_few_args(/* fetch */ MethodIndex(254, 1) /* fetch */ ,  "fetch", 0x5E82B850BB90B0FBLL, 1, NAMSTR(s_sys_ss77e35232, "name"))));
        v_cls = tmp1;
      }
    }
  }
  {
    LOOP_COUNTER(2);
    Variant map3 = t_fetch(NAMSTR(s_sys_ss56221a08, "interfaces"));
    for (ArrayIterPtr iter4 = map3.begin(s_class_name); !iter4->end(); iter4->next()) {
      LOOP_COUNTER_CHECK(2);
      iter4->second(v__);
      v_name = iter4->first();
      {
        {
          bool tmp5;
          {
            int tmp6((x_strcasecmp(toString(v_cls), toString(v_name))));
            tmp5 = (equal(tmp6, 0LL));
          }
          if (tmp5) {
            {
              return true;
            }
          }
        }
      }
    }
  }
  {
    bool tmp7;
    {
      const Variant &tmp8((t_fetch(NAMSTR(s_sys_ss2d13045e, "parent"))));
      tmp7 = (empty(tmp8));
    }
    if (tmp7) {
      {
        return false;
      }
    }
  }
  {
    bool tmp9;
    {
      const String &tmp10((toString(v_cls)));
      const String &tmp11((toString(t_fetch(NAMSTR(s_sys_ss2d13045e, "parent")))));
      int tmp12((x_strcasecmp(tmp10, tmp11)));
      tmp9 = (equal(tmp12, 0LL));
    }
    if (tmp9) {
      {
        return true;
      }
    }
  }
  {
    const Object &tmp13((toObject(t_getparentclass())));
    return wrap_variant(tmp13-> BIND_CLASS_ARROW(ObjectData) o_invoke_few_args(/* isSubclassOf */ MethodIndex(286, 1) /* isSubclassOf */ ,  "isSubclassOf", 0x373333991926C97ELL, 1, v_cls));
  }
} /* function */
/* SRC: classes/reflection.php line 1136 */
Variant c_ReflectionClass::t_getstaticproperties() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getStaticProperties);
  Variant v_ret;
  Variant v_prop;

  v_ret = s_sys_sa00000000;
  {
    LOOP_COUNTER(1);
    Variant map2 = t_getproperties();
    for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v_prop);
      {
        if (toBoolean(v_prop. BIND_CLASS_DOT o_invoke_few_args(/* isStatic */ MethodIndex(311, 1) /* isStatic */ ,  "isStatic", 0x7A15DC56E8CC0B19LL, 0))) {
          {
            {
              const Variant &tmp4((v_prop.o_get(NAMSTR(s_sys_ss77e35232, "name"), true)));
              Variant tmp5((v_prop));
              v_ret.set(tmp4, (tmp5));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 1157 */
Variant c_ReflectionClass::t_getstaticpropertyvalue(CVarRef v_name, CVarRef v_default //  = null_variant
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getStaticPropertyValue);
  {
    bool tmp1;
    {
      bool tmp2 = (t_hasproperty(v_name));
      if (tmp2) {
        const p_ReflectionProperty &tmp3((t_getproperty(v_name)));
        tmp2 = (toBoolean(tmp3->t_isstatic()));
      }
      tmp1 = (tmp2);
    }
    if (tmp1) {
      {
        return x_hphp_get_static_property(toString(m_name), toString(v_name));
      }
    }
  }
  return v_default;
} /* function */
/* SRC: classes/reflection.php line 1178 */
void c_ReflectionClass::t_setstaticpropertyvalue(CVarRef v_name, CVarRef v_value) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::setStaticPropertyValue);
  x_hphp_set_static_property(toString(m_name), toString(v_name), v_value);
} /* function */
/* SRC: classes/reflection.php line 1192 */
Variant c_ReflectionClass::t_getdefaultproperties() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getDefaultProperties);
  Variant v_ret;
  Variant v_prop;

  v_ret = s_sys_sa00000000;
  {
    LOOP_COUNTER(1);
    Variant map2 = t_getproperties();
    for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v_prop);
      {
        if (toBoolean(v_prop. BIND_CLASS_DOT o_invoke_few_args(/* isDefault */ MethodIndex(325, 1) /* isDefault */ ,  "isDefault", 0x384A52597AB11F15LL, 0))) {
          {
            {
              const Variant &tmp4((v_prop.o_get(NAMSTR(s_sys_ss77e35232, "name"), true)));
              Variant tmp5((v_prop));
              v_ret.set(tmp4, (tmp5));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 1211 */
Variant c_ReflectionClass::t_isiterateable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::isIterateable);
  return t_issubclassof(NAMSTR(s_sys_ss403290f5, "ArrayAccess"));
} /* function */
/* SRC: classes/reflection.php line 1226 */
bool c_ReflectionClass::t_implementsinterface(Variant v_cls) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::implementsInterface);
  Primitive v_name = 0;
  Variant v__;

  if (instanceOf(v_cls, "ReflectionClass")) {
    {
      {
        Variant tmp1((v_cls. BIND_CLASS_DOT o_invoke_few_args(/* fetch */ MethodIndex(254, 1) /* fetch */ ,  "fetch", 0x5E82B850BB90B0FBLL, 1, NAMSTR(s_sys_ss77e35232, "name"))));
        v_cls = tmp1;
      }
    }
  }
  {
    LOOP_COUNTER(2);
    Variant map3 = t_fetch(NAMSTR(s_sys_ss56221a08, "interfaces"));
    for (ArrayIterPtr iter4 = map3.begin(s_class_name); !iter4->end(); iter4->next()) {
      LOOP_COUNTER_CHECK(2);
      iter4->second(v__);
      v_name = iter4->first();
      {
        {
          bool tmp5;
          {
            int tmp6((x_strcasecmp(toString(v_cls), toString(v_name))));
            tmp5 = (equal(tmp6, 0LL));
          }
          if (tmp5) {
            {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
} /* function */
/* SRC: classes/reflection.php line 1248 */
Variant c_ReflectionClass::t_getextension() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getExtension);
  return t_fetch(NAMSTR(s_sys_ss02406793, "extension"));
} /* function */
/* SRC: classes/reflection.php line 1262 */
Variant c_ReflectionClass::t_getextensionname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionClass, ReflectionClass::getExtensionName);
  {
    const Object &tmp1((toObject(t_fetch(NAMSTR(s_sys_ss02406793, "extension")))));
    return wrap_variant(tmp1-> BIND_CLASS_ARROW(ObjectData) o_invoke_few_args(/* getName */ MethodIndex(139, 1) /* getName */ ,  "getName", 0x23F51CDECC198965LL, 0));
  }
} /* function */
/* SRC: classes/reflection.php line 1803 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionExtension
Variant c_ReflectionExtension::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 3) {
    case 2:
      HASH_RETURN_NAMSTR(0x5655B4FF77E35232LL, NAMSTR(s_sys_ss77e35232, "name"),
                         null, 4);
      break;
    case 3:
      HASH_RETURN_NAMSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionExtension
Variant c_ReflectionExtension::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionExtension
Variant &c_ReflectionExtension::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionExtension
void c_ReflectionExtension::o_getArray(Array &props) const {
  if (isInitialized(m_name)) props.add(NAMSTR(s_sys_ss7730b079, "\000ReflectionExtension\000name"), m_name.isReferenced() ? ref(m_name) : m_name, true);
  if (isInitialized(m_info)) props.add(NAMSTR(s_sys_ss446ed36e, "\000ReflectionExtension\000info"), m_info.isReferenced() ? ref(m_info) : m_info, true);
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionExtension
void c_ReflectionExtension::o_setArray(CArrRef props) {
  props->load(NAMSTR(s_sys_ss7730b079, "\000ReflectionExtension\000name"), m_name);
  props->load(NAMSTR(s_sys_ss446ed36e, "\000ReflectionExtension\000info"), m_info);
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionExtension
Variant * c_ReflectionExtension::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_GUARD_STRING(0x0B61E0BFCFA06573LL, ReflectionExtension) { return o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionExtension
Variant * c_ReflectionExtension::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionExtension
Variant * c_ReflectionExtension::o_realPropPrivate(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 3) {
    case 2:
      HASH_REALPROP_STRING(0x5655B4FF77E35232LL, "name", 4, name);
      break;
    case 3:
      HASH_REALPROP_STRING(0x0F2EF58F157D479FLL, "info", 4, info);
      break;
    default:
      break;
  }
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionExtension
Variant c_ReflectionExtension::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionExtension
IMPLEMENT_CLASS(ReflectionExtension)
c_ReflectionExtension *c_ReflectionExtension::create(Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_name);
  return this;
}
ObjectData *c_ReflectionExtension::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_ReflectionExtension::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_ReflectionExtension::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_ReflectionExtension::cloneImpl() {
  c_ReflectionExtension *obj = NEW(c_ReflectionExtension)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionExtension::cloneSet(c_ReflectionExtension *clone) {
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionExtension
Variant c_ReflectionExtension::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x129:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
        return (t_info());
      }
      break;
    case 0x12a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
        return (t_getinientries());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 0x12b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
        return (t_getclassnames());
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
        return (t_getversion());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x12c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
        return (t_getclasses());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD_LITSTR(0x0113D73FC859EDC2LL, NAMSTR(s_sys_ss37a6123e, "getClasses")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
        return (t_getclasses());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851, "getFunctions")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x5CE2786E11341594LL, NAMSTR(s_sys_ss11341594, "getClassNames")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
        return (t_getclassnames());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x306B5F4D1D03D335LL, NAMSTR(s_sys_ss1d03d335, "getINIEntries")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
        return (t_getinientries());
      }
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316, "getVersion")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
        return (t_getversion());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
        return (t_info());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionExtension
Variant c_ReflectionExtension::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 0x129:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
        return (t_info());
      }
      break;
    case 0x12a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
        return (t_getinientries());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 0x12b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
        return (t_getclassnames());
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
        return (t_getversion());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x12c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
        return (t_getclasses());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD_LITSTR(0x0113D73FC859EDC2LL, NAMSTR(s_sys_ss37a6123e, "getClasses")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
        return (t_getclasses());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851, "getFunctions")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x5CE2786E11341594LL, NAMSTR(s_sys_ss11341594, "getClassNames")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
        return (t_getclassnames());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x306B5F4D1D03D335LL, NAMSTR(s_sys_ss1d03d335, "getINIEntries")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
        return (t_getinientries());
      }
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316, "getVersion")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
        return (t_getversion());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
        return (t_info());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionExtension
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionExtension
Variant c_ReflectionExtension::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionExtension
Variant c_ReflectionExtension::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x129:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_info());
      }
      break;
    case 0x12a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinientries());
      }
      break;
    case 0x11b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 0x12b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclassnames());
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x12c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclasses());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD_LITSTR(0x0113D73FC859EDC2LL, NAMSTR(s_sys_ss37a6123e, "getClasses")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclasses());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851, "getFunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x5CE2786E11341594LL, NAMSTR(s_sys_ss11341594, "getClassNames")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclassnames());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x306B5F4D1D03D335LL, NAMSTR(s_sys_ss1d03d335, "getINIEntries")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinientries());
      }
      HASH_GUARD_LITSTR(0x1CC71CB013143955LL, NAMSTR(s_sys_ss13143955, "getConstants")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316, "getVersion")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_info());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionExtension::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionExtension = {
  c_ReflectionExtension::os_getInit,
  c_ReflectionExtension::os_get,
  c_ReflectionExtension::os_lval,
  c_ReflectionExtension::os_invoke,
  c_ReflectionExtension::os_constant,
};
void c_ReflectionExtension::init() {
  m_name = null;
  m_info = null;
}
/* SRC: classes/reflection.php line 1807 */
void c_ReflectionExtension::t___construct(Variant v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::__construct);
  bool oldInCtor = gasInCtor(true);
  {
    const Array &tmp1((x_hphp_get_extension_info(toString(v_name))));
    m_info = tmp1;
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 1811 */
String c_ReflectionExtension::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 1830 */
Variant c_ReflectionExtension::ti_export(const char* cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::export);
  p_ReflectionExtension v_obj;
  String v_str;

  {
    p_ReflectionExtension tmp1 = NEWOBJ(c_ReflectionExtension)();
    (tmp1->create(v_name));
    v_obj = tmp1;
  }
  v_str = (toString(v_obj));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 1848 */
Variant c_ReflectionExtension::t_getname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::getName);
  return m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1861 */
Variant c_ReflectionExtension::t_getversion() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::getVersion);
  return m_info.rvalAt(NAMSTR(s_sys_ss009c2796, "version"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1877 */
Variant c_ReflectionExtension::t_getfunctions() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::getFunctions);
  return m_info.rvalAt(NAMSTR(s_sys_ss18fea5e1, "functions"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1890 */
Variant c_ReflectionExtension::t_getconstants() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::getConstants);
  return m_info.rvalAt(NAMSTR(s_sys_ss1d07a592, "constants"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1904 */
Variant c_ReflectionExtension::t_getinientries() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::getINIEntries);
  return m_info.rvalAt(NAMSTR(s_sys_ss3a6b8527, "ini"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1919 */
Variant c_ReflectionExtension::t_getclasses() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::getClasses);
  return m_info.rvalAt(NAMSTR(s_sys_ss251b7f2b, "classes"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1934 */
Array c_ReflectionExtension::t_getclassnames() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::getClassNames);
  Array v_ret;
  Variant v_cls;

  v_ret = s_sys_sa00000000;
  {
    LOOP_COUNTER(1);
    Variant map2 = m_info.rvalAt(NAMSTR(s_sys_ss251b7f2b, "classes"), true, true);
    for (ArrayIterPtr iter3 = map2.begin(s_class_name); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v_cls);
      {
        {
          Variant tmp4((v_cls. BIND_CLASS_DOT o_invoke_few_args(/* getName */ MethodIndex(139, 1) /* getName */ ,  "getName", 0x23F51CDECC198965LL, 0)));
          v_ret.append((tmp4));
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 1950 */
Variant c_ReflectionExtension::t_info() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionExtension, ReflectionExtension::info);
  return m_info.rvalAt(NAMSTR(s_sys_ss157d479f, "info"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1556 */
const int64 q_ReflectionMethod_IS_STATIC = 1LL;
const int64 q_ReflectionMethod_IS_PUBLIC = 256LL;
const int64 q_ReflectionMethod_IS_PROTECTED = 512LL;
const int64 q_ReflectionMethod_IS_PRIVATE = 1024LL;
const int64 q_ReflectionMethod_IS_ABSTRACT = 2LL;
const int64 q_ReflectionMethod_IS_FINAL = 4LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionMethod
Variant c_ReflectionMethod::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_RETURN_NAMSTR(0x2E3A246D1F74C210LL, NAMSTR(s_sys_ss1f74c210, "class"),
                         null, 5);
      break;
    case 2:
      HASH_RETURN_NAMSTR(0x5655B4FF77E35232LL, NAMSTR(s_sys_ss77e35232, "name"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ReflectionFunctionAbstract::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionMethod
Variant c_ReflectionMethod::os_get(CStrRef s) {
  return c_ReflectionFunctionAbstract::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionMethod
Variant &c_ReflectionMethod::os_lval(CStrRef s) {
  return c_ReflectionFunctionAbstract::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionMethod
void c_ReflectionMethod::o_getArray(Array &props) const {
  if (isInitialized(m_name)) props.set(NAMSTR(s_sys_ss77e35232, "name"), m_name.isReferenced() ? ref(m_name) : m_name, true);
  if (isInitialized(m_class)) props.set(NAMSTR(s_sys_ss1f74c210, "class"), m_class.isReferenced() ? ref(m_class) : m_class, true);
  c_ReflectionFunctionAbstract::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionMethod
void c_ReflectionMethod::o_setArray(CArrRef props) {
  c_ReflectionFunctionAbstract::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionMethod
Variant * c_ReflectionMethod::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionMethod
Variant * c_ReflectionMethod::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_REALPROP_STRING(0x2E3A246D1F74C210LL, "class", 5, class);
      break;
    case 2:
      HASH_REALPROP_STRING(0x5655B4FF77E35232LL, "name", 4, name);
      break;
    default:
      break;
  }
  return c_ReflectionFunctionAbstract::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionMethod
Variant * c_ReflectionMethod::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionMethod
Variant c_ReflectionMethod::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_RETURN(0x7DA78A433EE05120LL, q_ReflectionMethod_IS_STATIC, "IS_STATIC");
      break;
    case 1:
      HASH_RETURN(0x163BE642CB04C741LL, q_ReflectionMethod_IS_PRIVATE, "IS_PRIVATE");
      break;
    case 3:
      HASH_RETURN(0x3784532769C1EF03LL, q_ReflectionMethod_IS_PUBLIC, "IS_PUBLIC");
      HASH_RETURN(0x6572B785E302A373LL, q_ReflectionMethod_IS_ABSTRACT, "IS_ABSTRACT");
      break;
    case 6:
      HASH_RETURN(0x47AAFAC74A58AD66LL, q_ReflectionMethod_IS_FINAL, "IS_FINAL");
      break;
    case 14:
      HASH_RETURN(0x10A614A8C272DC9ELL, q_ReflectionMethod_IS_PROTECTED, "IS_PROTECTED");
      break;
    default:
      break;
  }
  return c_ReflectionFunctionAbstract::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionMethod
IMPLEMENT_CLASS(ReflectionMethod)
c_ReflectionMethod *c_ReflectionMethod::create(Variant v_cls, Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_cls, v_name);
  return this;
}
ObjectData *c_ReflectionMethod::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_ReflectionMethod::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_ReflectionMethod::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
ObjectData *c_ReflectionMethod::cloneImpl() {
  c_ReflectionMethod *obj = NEW(c_ReflectionMethod)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionMethod::cloneSet(c_ReflectionMethod *clone) {
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_class = m_class.isReferenced() ? ref(m_class) : m_class;
  c_ReflectionFunctionAbstract::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionMethod
Variant c_ReflectionMethod::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x135:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 0x136:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 0x137:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 0x139:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
        return (t_isconstructor());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 0x131:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_invokeargs(arg0, arg1));
        }
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1, arg2));
        }
      }
      break;
    case 0x133:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_invoke(count, arg0));
          return (t_invoke(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 0x13a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x13b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
        return (t_isdestructor());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD_LITSTR(0x3FCE192CF6199942LL, NAMSTR(s_sys_ss09e666be, "invoke")) {
        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_invoke(count, arg0));
          return (t_invoke(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x3235AF57F23103C4LL, NAMSTR(s_sys_ss0dcefc3c, "invokeArgs")) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_invokeargs(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x51A20EA0E327F607LL, NAMSTR(s_sys_ss1cd809f9, "isDestructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
        return (t_isdestructor());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x7A15DC56E8CC0B19LL, NAMSTR(s_sys_ss1733f4e7, "isStatic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1, arg2));
        }
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x2D7209A590477CEALL, NAMSTR(s_sys_ss6fb88316, "isProtected")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x37AAE0845E2F636FLL, NAMSTR(s_sys_ss5e2f636f, "isPrivate")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x654B5F965C5CAC7ALL, NAMSTR(s_sys_ss5c5cac7a, "isConstructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
        return (t_isconstructor());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x2820F10358723B7CLL, NAMSTR(s_sys_ss58723b7c, "isPublic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionMethod
Variant c_ReflectionMethod::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x135:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 0x136:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 0x137:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 0x139:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
        return (t_isconstructor());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 0x131:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
        return (t_invokeargs(a0, a1));
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 0x133:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
        if (count <= 1) return (t_invoke(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_invoke(count,a0, params));
      }
      break;
    case 0x13a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x13b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
        return (t_isdestructor());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD_LITSTR(0x3FCE192CF6199942LL, NAMSTR(s_sys_ss09e666be, "invoke")) {
        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
        if (count <= 1) return (t_invoke(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_invoke(count,a0, params));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x3235AF57F23103C4LL, NAMSTR(s_sys_ss0dcefc3c, "invokeArgs")) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
        return (t_invokeargs(a0, a1));
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x51A20EA0E327F607LL, NAMSTR(s_sys_ss1cd809f9, "isDestructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
        return (t_isdestructor());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x7A15DC56E8CC0B19LL, NAMSTR(s_sys_ss1733f4e7, "isStatic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x2D7209A590477CEALL, NAMSTR(s_sys_ss6fb88316, "isProtected")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x37AAE0845E2F636FLL, NAMSTR(s_sys_ss5e2f636f, "isPrivate")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x654B5F965C5CAC7ALL, NAMSTR(s_sys_ss5c5cac7a, "isConstructor")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
        return (t_isconstructor());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x2820F10358723B7CLL, NAMSTR(s_sys_ss58723b7c, "isPublic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionMethod
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionMethod
Variant c_ReflectionMethod::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionMethod
Variant c_ReflectionMethod::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x135:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprivate());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 0x136:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprotected());
      }
      break;
    case 0x137:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isstatic());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 0x139:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isconstructor());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      break;
    case 0x10f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 0x131:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_invokeargs(a0, a1));
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 0x133:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_invoke(count, a0));
        return (t_invoke(count, a0,vargs));
      }
      break;
    case 0x13a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispublic());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0x13b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdestructor());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 0x126:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD_LITSTR(0x3FCE192CF6199942LL, NAMSTR(s_sys_ss09e666be, "invoke")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_invoke(count, a0));
        return (t_invoke(count, a0,vargs));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x3235AF57F23103C4LL, NAMSTR(s_sys_ss0dcefc3c, "invokeArgs")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_invokeargs(a0, a1));
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x51A20EA0E327F607LL, NAMSTR(s_sys_ss1cd809f9, "isDestructor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdestructor());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x7A15DC56E8CC0B19LL, NAMSTR(s_sys_ss1733f4e7, "isStatic")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isstatic());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x2D7209A590477CEALL, NAMSTR(s_sys_ss6fb88316, "isProtected")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprotected());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x06FB6A7DC3D795AELL, NAMSTR(s_sys_ss3c286a52, "isFinal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x37AAE0845E2F636FLL, NAMSTR(s_sys_ss5e2f636f, "isPrivate")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprivate());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7460D945DA32FDB7LL, NAMSTR(s_sys_ss25cd0249, "isAbstract")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x654B5F965C5CAC7ALL, NAMSTR(s_sys_ss5c5cac7a, "isConstructor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isconstructor());
      }
      break;
    case 60:
      HASH_GUARD_LITSTR(0x2820F10358723B7CLL, NAMSTR(s_sys_ss58723b7c, "isPublic")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispublic());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionFunctionAbstract::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionMethod::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionFunctionAbstract::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionMethod = {
  c_ReflectionMethod::os_getInit,
  c_ReflectionMethod::os_get,
  c_ReflectionMethod::os_lval,
  c_ReflectionMethod::os_invoke,
  c_ReflectionMethod::os_constant,
};
void c_ReflectionMethod::init() {
  c_ReflectionFunctionAbstract::init();
  m_name = null;
  m_class = null;
}
/* SRC: classes/reflection.php line 1568 */
void c_ReflectionMethod::t___construct(Variant v_cls, Variant v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_method;

  if ((toBoolean(v_cls) && toBoolean(v_name))) {
    {
      if (!(x_is_object(v_cls))) {
        {
          p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
          (tmp1->create(v_cls));
          v_cls = tmp1;
        }
      }
      {
        Variant tmp2((v_cls. BIND_CLASS_DOT o_invoke_few_args(/* getMethod */ MethodIndex(276, 1) /* getMethod */ ,  "getMethod", 0x0D81ECE253A3B5B6LL, 1, v_name)));
        v_method = tmp2;
      }
      if (toBoolean(v_method)) {
        {
          {
            const Variant &tmp3((v_method.o_getPublic(NAMSTR(s_sys_ss157d479f, "info"), true)));
            m_info = tmp3;
          }
          {
            const Variant &tmp4((v_method.o_getPublic(NAMSTR(s_sys_ss77e35232, "name"), true)));
            m_name = tmp4;
          }
          {
            const Variant &tmp5((v_method.o_getPublic(NAMSTR(s_sys_ss1f74c210, "class"), true)));
            m_class = tmp5;
          }
        }
      }
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 1580 */
String c_ReflectionMethod::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 1601 */
Variant c_ReflectionMethod::ti_export(const char* cls, Variant v_cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::export);
  Variant v_obj;
  String v_str;

  if (!(x_is_object(v_cls))) {
    {
      p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
      (tmp1->create(v_cls));
      v_cls = tmp1;
    }
  }
  {
    const Variant &tmp2((v_cls.o_invoke_few_args(/* getMethod */ MethodIndex(276, 1) /* getMethod */ ,  "getMethod", 0x0D81ECE253A3B5B6LL, 1, v_name)));
    v_obj = tmp2;
  }
  v_str = (toString(v_obj));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 1622 */
Variant c_ReflectionMethod::t_invoke(int num_args, CVarRef v_obj, Array args /* = Array() */) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::invoke);
  Variant v_args;

  {
    const Array &tmp1((func_get_args(num_args, Array(ArrayInit(1, true).set(v_obj).create()),args)));
    v_args = tmp1;
  }
  x_array_shift(ref(v_args));
  {
    Variant tmp2((v_obj));
    const String &tmp3((toString(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
    const String &tmp4((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
    return x_hphp_invoke_method(tmp2, tmp3, tmp4, toArray(v_args));
  }
} /* function */
/* SRC: classes/reflection.php line 1643 */
Variant c_ReflectionMethod::t_invokeargs(CVarRef v_obj, CVarRef v_args) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::invokeArgs);
  {
    Variant tmp1((v_obj));
    const String &tmp2((toString(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
    const String &tmp3((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
    const Array &tmp4((toArray(x_array_values(v_args))));
    return x_hphp_invoke_method(tmp1, tmp2, tmp3, tmp4);
  }
} /* function */
/* SRC: classes/reflection.php line 1656 */
Variant c_ReflectionMethod::t_isfinal() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isFinal);
  return m_info.rvalAt(NAMSTR(s_sys_ss2f433c87, "final"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1669 */
Variant c_ReflectionMethod::t_isabstract() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isAbstract);
  return m_info.rvalAt(NAMSTR(s_sys_ss01d79b38, "abstract"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1681 */
bool c_ReflectionMethod::t_ispublic() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isPublic);
  return equal(m_info.rvalAt(NAMSTR(s_sys_ss7b513d57, "access"), true, true), NAMSTR(s_sys_ss13766fad, "public"));
} /* function */
/* SRC: classes/reflection.php line 1694 */
bool c_ReflectionMethod::t_isprivate() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isPrivate);
  return equal(m_info.rvalAt(NAMSTR(s_sys_ss7b513d57, "access"), true, true), NAMSTR(s_sys_ss52349fb9, "private"));
} /* function */
/* SRC: classes/reflection.php line 1707 */
bool c_ReflectionMethod::t_isprotected() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isProtected);
  return equal(m_info.rvalAt(NAMSTR(s_sys_ss7b513d57, "access"), true, true), NAMSTR(s_sys_ss649ab5a0, "protected"));
} /* function */
/* SRC: classes/reflection.php line 1719 */
Variant c_ReflectionMethod::t_isstatic() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isStatic);
  return m_info.rvalAt(NAMSTR(s_sys_ss796d376e, "static"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1732 */
bool c_ReflectionMethod::t_isconstructor() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isConstructor);
  return isset(m_info, NAMSTR(s_sys_ss3a464145, "constructor"), true);
} /* function */
/* SRC: classes/reflection.php line 1745 */
bool c_ReflectionMethod::t_isdestructor() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::isDestructor);
  {
    const Variant &tmp1((t_getname()));
    return equal(tmp1, NAMSTR(s_sys_ss5533e10d, "__destruct"));
  }
} /* function */
/* SRC: classes/reflection.php line 1767 */
Variant c_ReflectionMethod::t_getmodifiers() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::getModifiers);
  return m_info.rvalAt(NAMSTR(s_sys_ss6d6e147d, "modifiers"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1771 */
Variant c_ReflectionMethod::t_getclosure() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::getClosure);
  return m_info.rvalAt(NAMSTR(s_sys_ss6d16d594, "closure"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1785 */
Variant c_ReflectionMethod::t_getdeclaringclass() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionMethod, ReflectionMethod::getDeclaringClass);
  if (empty(m_info, NAMSTR(s_sys_ss1f74c210, "class"), true)) {
    {
      return null;
    }
  }
  {
    p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
    return (tmp1->create(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true)), tmp1);
  }
} /* function */
/* SRC: classes/reflection.php line 1315 */
const int64 q_ReflectionProperty_IS_STATIC = 1LL;
const int64 q_ReflectionProperty_IS_PUBLIC = 256LL;
const int64 q_ReflectionProperty_IS_PROTECTED = 512LL;
const int64 q_ReflectionProperty_IS_PRIVATE = 1024LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionProperty
Variant c_ReflectionProperty::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 7) {
    case 0:
      HASH_RETURN_NAMSTR(0x2E3A246D1F74C210LL, NAMSTR(s_sys_ss1f74c210, "class"),
                         null, 5);
      break;
    case 2:
      HASH_RETURN_NAMSTR(0x5655B4FF77E35232LL, NAMSTR(s_sys_ss77e35232, "name"),
                         null, 4);
      break;
    case 7:
      HASH_RETURN_NAMSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionProperty
Variant c_ReflectionProperty::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionProperty
Variant &c_ReflectionProperty::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionProperty
void c_ReflectionProperty::o_getArray(Array &props) const {
  if (isInitialized(m_info)) props.set(NAMSTR(s_sys_ss157d479f, "info"), m_info.isReferenced() ? ref(m_info) : m_info, true);
  if (isInitialized(m_name)) props.set(NAMSTR(s_sys_ss77e35232, "name"), m_name.isReferenced() ? ref(m_name) : m_name, true);
  if (isInitialized(m_class)) props.set(NAMSTR(s_sys_ss1f74c210, "class"), m_class.isReferenced() ? ref(m_class) : m_class, true);
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionProperty
void c_ReflectionProperty::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionProperty
Variant * c_ReflectionProperty::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionProperty
Variant * c_ReflectionProperty::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 0:
      HASH_REALPROP_STRING(0x2E3A246D1F74C210LL, "class", 5, class);
      break;
    case 2:
      HASH_REALPROP_STRING(0x5655B4FF77E35232LL, "name", 4, name);
      break;
    case 7:
      HASH_REALPROP_STRING(0x0F2EF58F157D479FLL, "info", 4, info);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionProperty
Variant * c_ReflectionProperty::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionProperty
Variant c_ReflectionProperty::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_RETURN(0x7DA78A433EE05120LL, q_ReflectionProperty_IS_STATIC, "IS_STATIC");
      break;
    case 1:
      HASH_RETURN(0x163BE642CB04C741LL, q_ReflectionProperty_IS_PRIVATE, "IS_PRIVATE");
      break;
    case 3:
      HASH_RETURN(0x3784532769C1EF03LL, q_ReflectionProperty_IS_PUBLIC, "IS_PUBLIC");
      break;
    case 6:
      HASH_RETURN(0x10A614A8C272DC9ELL, q_ReflectionProperty_IS_PROTECTED, "IS_PROTECTED");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionProperty
IMPLEMENT_CLASS(ReflectionProperty)
c_ReflectionProperty *c_ReflectionProperty::create(Variant v_cls, Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_cls, v_name);
  return this;
}
ObjectData *c_ReflectionProperty::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_ReflectionProperty::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_ReflectionProperty::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
ObjectData *c_ReflectionProperty::cloneImpl() {
  c_ReflectionProperty *obj = NEW(c_ReflectionProperty)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionProperty::cloneSet(c_ReflectionProperty *clone) {
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_class = m_class.isReferenced() ? ref(m_class) : m_class;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionProperty
Variant c_ReflectionProperty::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x135:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 0x144:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getvalue());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getvalue(arg0));
        }
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x136:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 0x137:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 0x145:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
        return (t_isdefault());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1, arg2));
        }
      }
      break;
    case 0x13a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 0x146:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
        return (t_setaccessible(), null);
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x147:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setvalue(arg0, arg1));
        }
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
        return (t_getname());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD_LITSTR(0x791E9751F5B8C5A2LL, NAMSTR(s_sys_ss0a473a5e, "setAccessible")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
        return (t_setaccessible(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x56879BCEB40997E3LL, NAMSTR(s_sys_ss4bf6681d, "getValue")) {
        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getvalue());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getvalue(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1, arg2));
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2D7209A590477CEALL, NAMSTR(s_sys_ss6fb88316, "isProtected")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x37AAE0845E2F636FLL, NAMSTR(s_sys_ss5e2f636f, "isPrivate")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x384A52597AB11F15LL, NAMSTR(s_sys_ss7ab11f15, "isDefault")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
        return (t_isdefault());
      }
      HASH_GUARD_LITSTR(0x36FBED35008C8DB5LL, NAMSTR(s_sys_ss008c8db5, "setValue")) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setvalue(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x7A15DC56E8CC0B19LL, NAMSTR(s_sys_ss1733f4e7, "isStatic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x2820F10358723B7CLL, NAMSTR(s_sys_ss58723b7c, "isPublic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionProperty
Variant c_ReflectionProperty::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x135:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 0x144:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
        if (count <= 0) return (t_getvalue());
        return (t_getvalue(a0));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x136:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 0x137:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 0x145:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
        return (t_isdefault());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 0x13a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 0x146:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
        return (t_setaccessible(), null);
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x147:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
        return (t_setvalue(a0, a1));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
        return (t_getname());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD_LITSTR(0x791E9751F5B8C5A2LL, NAMSTR(s_sys_ss0a473a5e, "setAccessible")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
        return (t_setaccessible(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x56879BCEB40997E3LL, NAMSTR(s_sys_ss4bf6681d, "getValue")) {
        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
        if (count <= 0) return (t_getvalue());
        return (t_getvalue(a0));
      }
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2D7209A590477CEALL, NAMSTR(s_sys_ss6fb88316, "isProtected")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x37AAE0845E2F636FLL, NAMSTR(s_sys_ss5e2f636f, "isPrivate")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x384A52597AB11F15LL, NAMSTR(s_sys_ss7ab11f15, "isDefault")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
        return (t_isdefault());
      }
      HASH_GUARD_LITSTR(0x36FBED35008C8DB5LL, NAMSTR(s_sys_ss008c8db5, "setValue")) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
        return (t_setvalue(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x7A15DC56E8CC0B19LL, NAMSTR(s_sys_ss1733f4e7, "isStatic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x2820F10358723B7CLL, NAMSTR(s_sys_ss58723b7c, "isPublic")) {
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionProperty
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionProperty
Variant c_ReflectionProperty::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionProperty
Variant c_ReflectionProperty::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x135:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprivate());
      }
      break;
    case 0x144:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getvalue());
        else return (t_getvalue(a0));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x136:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprotected());
      }
      break;
    case 0x137:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isstatic());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 0x145:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefault());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x110:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 0x13a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispublic());
      }
      break;
    case 0x146:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setaccessible(), null);
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 0x147:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setvalue(a0, a1));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD_LITSTR(0x791E9751F5B8C5A2LL, NAMSTR(s_sys_ss0a473a5e, "setAccessible")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setaccessible(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x56879BCEB40997E3LL, NAMSTR(s_sys_ss4bf6681d, "getValue")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getvalue());
        else return (t_getvalue(a0));
      }
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2D7209A590477CEALL, NAMSTR(s_sys_ss6fb88316, "isProtected")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprotected());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x37AAE0845E2F636FLL, NAMSTR(s_sys_ss5e2f636f, "isPrivate")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprivate());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x24253EBA491D6014LL, NAMSTR(s_sys_ss491d6014, "getModifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x384A52597AB11F15LL, NAMSTR(s_sys_ss7ab11f15, "isDefault")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefault());
      }
      HASH_GUARD_LITSTR(0x36FBED35008C8DB5LL, NAMSTR(s_sys_ss008c8db5, "setValue")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setvalue(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x7A15DC56E8CC0B19LL, NAMSTR(s_sys_ss1733f4e7, "isStatic")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isstatic());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x2820F10358723B7CLL, NAMSTR(s_sys_ss58723b7c, "isPublic")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispublic());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionProperty::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionProperty = {
  c_ReflectionProperty::os_getInit,
  c_ReflectionProperty::os_get,
  c_ReflectionProperty::os_lval,
  c_ReflectionProperty::os_invoke,
  c_ReflectionProperty::os_constant,
};
void c_ReflectionProperty::init() {
  m_info = null;
  m_name = null;
  m_class = null;
}
/* SRC: classes/reflection.php line 1325 */
void c_ReflectionProperty::t___construct(Variant v_cls, Variant v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_prop;

  if ((toBoolean(v_cls) && toBoolean(v_name))) {
    {
      if (!(x_is_object(v_cls))) {
        {
          p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
          (tmp1->create(v_cls));
          v_cls = tmp1;
        }
      }
      {
        Variant tmp2((v_cls. BIND_CLASS_DOT o_invoke_few_args(/* getProperty */ MethodIndex(296, 1) /* getProperty */ ,  "getProperty", 0x0FD73627FB023047LL, 1, v_name)));
        v_prop = tmp2;
      }
      if (toBoolean(v_prop)) {
        {
          {
            const Variant &tmp3((v_prop.o_getPublic(NAMSTR(s_sys_ss157d479f, "info"), true)));
            m_info = tmp3;
          }
          {
            const Variant &tmp4((v_prop.o_getPublic(NAMSTR(s_sys_ss77e35232, "name"), true)));
            m_name = tmp4;
          }
          {
            const Variant &tmp5((v_prop.o_getPublic(NAMSTR(s_sys_ss1f74c210, "class"), true)));
            m_class = tmp5;
          }
        }
      }
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 1337 */
String c_ReflectionProperty::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 1353 */
Variant c_ReflectionProperty::ti_export(const char* cls, Variant v_cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::export);
  Variant v_obj;
  String v_str;

  if (!(x_is_object(v_cls))) {
    {
      p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
      (tmp1->create(v_cls));
      v_cls = tmp1;
    }
  }
  {
    const Variant &tmp2((v_cls.o_invoke_few_args(/* getProperty */ MethodIndex(296, 1) /* getProperty */ ,  "getProperty", 0x0FD73627FB023047LL, 1, v_name)));
    v_obj = tmp2;
  }
  v_str = (toString(v_obj));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 1372 */
Variant c_ReflectionProperty::t_getname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::getName);
  return m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1385 */
bool c_ReflectionProperty::t_ispublic() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::isPublic);
  return equal(m_info.rvalAt(NAMSTR(s_sys_ss7b513d57, "access"), true, true), NAMSTR(s_sys_ss13766fad, "public"));
} /* function */
/* SRC: classes/reflection.php line 1398 */
bool c_ReflectionProperty::t_isprivate() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::isPrivate);
  return equal(m_info.rvalAt(NAMSTR(s_sys_ss7b513d57, "access"), true, true), NAMSTR(s_sys_ss52349fb9, "private"));
} /* function */
/* SRC: classes/reflection.php line 1411 */
bool c_ReflectionProperty::t_isprotected() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::isProtected);
  return equal(m_info.rvalAt(NAMSTR(s_sys_ss7b513d57, "access"), true, true), NAMSTR(s_sys_ss649ab5a0, "protected"));
} /* function */
/* SRC: classes/reflection.php line 1424 */
Variant c_ReflectionProperty::t_isstatic() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::isStatic);
  return m_info.rvalAt(NAMSTR(s_sys_ss796d376e, "static"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1438 */
Variant c_ReflectionProperty::t_isdefault() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::isDefault);
  return m_info.rvalAt(NAMSTR(s_sys_ss6463ffdf, "default"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1452 */
void c_ReflectionProperty::t_setaccessible() {
} /* function */
/* SRC: classes/reflection.php line 1465 */
Variant c_ReflectionProperty::t_getmodifiers() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::getModifiers);
  return m_info.rvalAt(NAMSTR(s_sys_ss6d6e147d, "modifiers"), true, true);
} /* function */
/* SRC: classes/reflection.php line 1481 */
Variant c_ReflectionProperty::t_getvalue(CVarRef v_obj //  = null_variant
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::getValue);
  if (toBoolean(t_isstatic())) {
    {
      {
        const String &tmp1((toString(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
        const String &tmp2((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
        return x_hphp_get_static_property(tmp1, tmp2);
      }
    }
  }
  if (toBoolean(v_obj)) {
    {
      {
        const Object &tmp3((toObject(v_obj)));
        const String &tmp4((toString(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
        const String &tmp5((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
        return x_hphp_get_property(tmp3, tmp4, tmp5);
      }
    }
  }
  return null;
} /* function */
/* SRC: classes/reflection.php line 1506 */
Variant c_ReflectionProperty::t_setvalue(CVarRef v_obj, CVarRef v_value) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::setValue);
  if (toBoolean(t_isstatic())) {
    {
      {
        const String &tmp1((toString(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
        const String &tmp2((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
        return (x_hphp_set_static_property(tmp1, tmp2, v_value), null);
      }
    }
  }
  {
    const Object &tmp3((toObject(v_obj)));
    const String &tmp4((toString(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true))));
    const String &tmp5((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
    x_hphp_set_property(tmp3, tmp4, tmp5, v_value);
  }
  return null;
} /* function */
/* SRC: classes/reflection.php line 1524 */
Variant c_ReflectionProperty::t_getdeclaringclass() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::getDeclaringClass);
  if (empty(m_info, NAMSTR(s_sys_ss1f74c210, "class"), true)) {
    {
      return null;
    }
  }
  {
    p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
    return (tmp1->create(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true)), tmp1);
  }
} /* function */
/* SRC: classes/reflection.php line 1541 */
Variant c_ReflectionProperty::t_getdoccomment() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionProperty, ReflectionProperty::getDocComment);
  return m_info.rvalAt(NAMSTR(s_sys_ss70714913, "doc"), true, true);
} /* function */
/* SRC: classes/reflection.php line 461 */
const int64 q_ReflectionFunction_IS_DEPRECATED = 262144LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionFunction
Variant c_ReflectionFunction::os_getInit(CStrRef s) {
  return c_ReflectionFunctionAbstract::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionFunction
Variant c_ReflectionFunction::os_get(CStrRef s) {
  return c_ReflectionFunctionAbstract::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionFunction
Variant &c_ReflectionFunction::os_lval(CStrRef s) {
  return c_ReflectionFunctionAbstract::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionFunction
void c_ReflectionFunction::o_getArray(Array &props) const {
  c_ReflectionFunctionAbstract::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionFunction
void c_ReflectionFunction::o_setArray(CArrRef props) {
  c_ReflectionFunctionAbstract::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionFunction
Variant * c_ReflectionFunction::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionFunction
Variant * c_ReflectionFunction::o_realPropPublic(CStrRef s, int flags) const {
  return c_ReflectionFunctionAbstract::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionFunction
Variant * c_ReflectionFunction::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionFunction
Variant c_ReflectionFunction::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_RETURN(0x25C5A7C72E7B0EF6LL, q_ReflectionFunction_IS_DEPRECATED, "IS_DEPRECATED");
      break;
    default:
      break;
  }
  return c_ReflectionFunctionAbstract::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionFunction
IMPLEMENT_CLASS(ReflectionFunction)
c_ReflectionFunction *c_ReflectionFunction::create(Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_name);
  return this;
}
ObjectData *c_ReflectionFunction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_ReflectionFunction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_ReflectionFunction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_ReflectionFunction::cloneImpl() {
  c_ReflectionFunction *obj = NEW(c_ReflectionFunction)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionFunction::cloneSet(c_ReflectionFunction *clone) {
  c_ReflectionFunctionAbstract::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunction
Variant c_ReflectionFunction::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 0x131:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_invokeargs(arg0));
        }
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 0x133:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count <= 0) return (t_invoke(count));
        return (t_invoke(count,params.slice(0, count - 0, false)));
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD_LITSTR(0x3FCE192CF6199942LL, NAMSTR(s_sys_ss09e666be, "invoke")) {
        if (count <= 0) return (t_invoke(count));
        return (t_invoke(count,params.slice(0, count - 0, false)));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x3235AF57F23103C4LL, NAMSTR(s_sys_ss0dcefc3c, "invokeArgs")) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_invokeargs(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunction
Variant c_ReflectionFunction::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 0x131:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
        return (t_invokeargs(a0));
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x133:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count <= 0) return (t_invoke(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_invoke(count,params));
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD_LITSTR(0x3FCE192CF6199942LL, NAMSTR(s_sys_ss09e666be, "invoke")) {
        if (count <= 0) return (t_invoke(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_invoke(count,params));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x3235AF57F23103C4LL, NAMSTR(s_sys_ss0dcefc3c, "invokeArgs")) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
        return (t_invokeargs(a0));
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        return (t_getstartline());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        return (t_getendline());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionFunction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionFunction
Variant c_ReflectionFunction::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionFunction
Variant c_ReflectionFunction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x12d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 0x107:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x12e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 0x10c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 0x12f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x130:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      break;
    case 0x131:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_invokeargs(a0));
      }
      break;
    case 0x132:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 0x133:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_invoke(count));
        return (t_invoke(count,vargs));
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0x119:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 0x11c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 0x134:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x127:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD_LITSTR(0x3FCE192CF6199942LL, NAMSTR(s_sys_ss09e666be, "invoke")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_invoke(count));
        return (t_invoke(count,vargs));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x3235AF57F23103C4LL, NAMSTR(s_sys_ss0dcefc3c, "invokeArgs")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_invokeargs(a0));
      }
      HASH_GUARD_LITSTR(0x39C1BB731CB1CB04LL, NAMSTR(s_sys_ss1cb1cb04, "getStartLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d_1, "getFileName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x48FDF6C5835C64CFLL, NAMSTR(s_sys_ss7ca39b31, "isInternal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x57D8DC34C9A03560LL, NAMSTR(s_sys_ss365fcaa0, "getNumberOfParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x4D637DECDBFA6221LL, NAMSTR(s_sys_ss24059ddf, "getNumberOfRequiredParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x33A6C2CFBDB05EE2LL, NAMSTR(s_sys_ss424fa11e, "getClosure")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x6A6B8BECAE7D4164LL, NAMSTR(s_sys_ss5182be9c, "isUserDefined")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x37FFB8F44A3329A8LL, NAMSTR(s_sys_ss4a3329a8, "getStaticVariables")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      HASH_GUARD_LITSTR(0x1A3AB3B0276D2668LL, NAMSTR(s_sys_ss276d2668, "returnsReference")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3E62225132C2A32DLL, NAMSTR(s_sys_ss32c2a32d, "getParameters")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      break;
    case 48:
      HASH_GUARD_LITSTR(0x6C19E85007BC4570LL, NAMSTR(s_sys_ss07bc4570, "getEndLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7C4F424FDA56ADF8LL, NAMSTR(s_sys_ss25a95208, "getDocComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionFunctionAbstract::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionFunction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ReflectionFunctionAbstract::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionFunction = {
  c_ReflectionFunction::os_getInit,
  c_ReflectionFunction::os_get,
  c_ReflectionFunction::os_lval,
  c_ReflectionFunction::os_invoke,
  c_ReflectionFunction::os_constant,
};
void c_ReflectionFunction::init() {
  c_ReflectionFunctionAbstract::init();
}
/* SRC: classes/reflection.php line 465 */
void c_ReflectionFunction::t___construct(Variant v_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunction, ReflectionFunction::__construct);
  bool oldInCtor = gasInCtor(true);
  {
    const Array &tmp1((x_hphp_get_function_info(toString(v_name))));
    m_info = tmp1;
  }
  if (empty(m_info)) {
    {
      {
        p_ReflectionException tmp2 = NEWOBJ(c_ReflectionException)();
        throw_exception((tmp2->create(concat3(NAMSTR(s_sys_ss38ae19c4, "Function "), toString(v_name), NAMSTR(s_sys_ss20448282, " does not exist"))), tmp2));
      }
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 472 */
String c_ReflectionFunction::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunction, ReflectionFunction::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 492 */
Variant c_ReflectionFunction::ti_export(const char* cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION_BUILTIN(ReflectionFunction, ReflectionFunction::export);
  p_ReflectionFunction v_obj;
  String v_str;

  {
    p_ReflectionFunction tmp1 = NEWOBJ(c_ReflectionFunction)();
    (tmp1->create(v_name));
    v_obj = tmp1;
  }
  v_str = (toString(v_obj));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 508 */
Variant c_ReflectionFunction::t_invoke(int num_args, Array args /* = Array() */) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunction, ReflectionFunction::invoke);
  Array v_args;

  {
    const Array &tmp1((func_get_args(num_args, Array(),args)));
    v_args = tmp1;
  }
  {
    const String &tmp2((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
    return x_hphp_invoke(tmp2, v_args);
  }
} /* function */
/* SRC: classes/reflection.php line 523 */
Variant c_ReflectionFunction::t_invokeargs(CVarRef v_args) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionFunction, ReflectionFunction::invokeArgs);
  {
    const String &tmp1((toString(m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true))));
    const Array &tmp2((toArray(x_array_values(v_args))));
    return x_hphp_invoke(tmp1, tmp2);
  }
} /* function */
/* SRC: classes/reflection.php line 46 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionParameter
Variant c_ReflectionParameter::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_RETURN_NAMSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info"),
                         null, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionParameter
Variant c_ReflectionParameter::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionParameter
Variant &c_ReflectionParameter::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionParameter
void c_ReflectionParameter::o_getArray(Array &props) const {
  if (isInitialized(m_info)) props.set(NAMSTR(s_sys_ss157d479f, "info"), m_info.isReferenced() ? ref(m_info) : m_info, true);
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionParameter
void c_ReflectionParameter::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ReflectionParameter
Variant * c_ReflectionParameter::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionParameter
Variant * c_ReflectionParameter::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 1:
      HASH_REALPROP_STRING(0x0F2EF58F157D479FLL, "info", 4, info);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionParameter
Variant * c_ReflectionParameter::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionParameter
Variant c_ReflectionParameter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ReflectionParameter
IMPLEMENT_CLASS(ReflectionParameter)
c_ReflectionParameter *c_ReflectionParameter::create(Variant v_func, Variant v_param) {
  CountableHelper h(this);
  init();
  t___construct(v_func, v_param);
  return this;
}
ObjectData *c_ReflectionParameter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_ReflectionParameter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_ReflectionParameter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
ObjectData *c_ReflectionParameter::cloneImpl() {
  c_ReflectionParameter *obj = NEW(c_ReflectionParameter)();
  cloneSet(obj);
  return obj;
}
void c_ReflectionParameter::cloneSet(c_ReflectionParameter *clone) {
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionParameter
Variant c_ReflectionParameter::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 0x13c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
        return (t_isdefaultvalueavailable());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x13d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
        return (t_getclass());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1, arg2));
        }
      }
      break;
    case 0x13e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
        return (t_allowsnull());
      }
      break;
    case 0x13f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
        return (t_getposition());
      }
      break;
    case 0x140:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
        return (t_isarray());
      }
      break;
    case 0x141:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
        return (t_isoptional());
      }
      break;
    case 0x142:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
        return (t_getdefaultvalue());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x143:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
        return (t_ispassedbyreference());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(o_getClassName(), arg0, arg1, arg2));
        }
      }
      HASH_GUARD_LITSTR(0x4044F1EEBF3BB8C8LL, NAMSTR(s_sys_ss40c44738, "getPosition")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
        return (t_getposition());
      }
      break;
    case 9:
      HASH_GUARD_LITSTR(0x4F51DA0B633E9909LL, NAMSTR(s_sys_ss633e9909, "getClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
        return (t_getclass());
      }
      HASH_GUARD_LITSTR(0x24ED05F4504C4C09LL, NAMSTR(s_sys_ss504c4c09, "allowsNull")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
        return (t_allowsnull());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x27C482A6C7951E0CLL, NAMSTR(s_sys_ss386ae1f4, "getDefaultValue")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
        return (t_getdefaultvalue());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x13E3F304BDD89FB1LL, NAMSTR(s_sys_ss4227604f, "isPassedByReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
        return (t_ispassedbyreference());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x6E34805C91257C92LL, NAMSTR(s_sys_ss6eda836e, "isDefaultValueAvailable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
        return (t_isdefaultvalueavailable());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x2D6EF48BBAB22735LL, NAMSTR(s_sys_ss454dd8cb, "isOptional")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
        return (t_isoptional());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x5A9CE40C0F25871DLL, NAMSTR(s_sys_ss0f25871d, "isArray")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
        return (t_isarray());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionParameter
Variant c_ReflectionParameter::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 0x13c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
        return (t_isdefaultvalueavailable());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x13d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
        return (t_getclass());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 0x13e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
        return (t_allowsnull());
      }
      break;
    case 0x13f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
        return (t_getposition());
      }
      break;
    case 0x140:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
        return (t_isarray());
      }
      break;
    case 0x141:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
        return (t_isoptional());
      }
      break;
    case 0x142:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
        return (t_getdefaultvalue());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 0x143:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
        return (t_ispassedbyreference());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x4044F1EEBF3BB8C8LL, NAMSTR(s_sys_ss40c44738, "getPosition")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
        return (t_getposition());
      }
      break;
    case 9:
      HASH_GUARD_LITSTR(0x4F51DA0B633E9909LL, NAMSTR(s_sys_ss633e9909, "getClass")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
        return (t_getclass());
      }
      HASH_GUARD_LITSTR(0x24ED05F4504C4C09LL, NAMSTR(s_sys_ss504c4c09, "allowsNull")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
        return (t_allowsnull());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x27C482A6C7951E0CLL, NAMSTR(s_sys_ss386ae1f4, "getDefaultValue")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
        return (t_getdefaultvalue());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x13E3F304BDD89FB1LL, NAMSTR(s_sys_ss4227604f, "isPassedByReference")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
        return (t_ispassedbyreference());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x6E34805C91257C92LL, NAMSTR(s_sys_ss6eda836e, "isDefaultValueAvailable")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
        return (t_isdefaultvalueavailable());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x2D6EF48BBAB22735LL, NAMSTR(s_sys_ss454dd8cb, "isOptional")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
        return (t_isoptional());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x5A9CE40C0F25871DLL, NAMSTR(s_sys_ss0f25871d, "isArray")) {
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
        return (t_isarray());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ReflectionParameter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionParameter
Variant c_ReflectionParameter::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_export(c, arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ReflectionParameter
Variant c_ReflectionParameter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x138:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 0x13c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultvalueavailable());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x13d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclass());
      }
      break;
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 0x13e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_allowsnull());
      }
      break;
    case 0x13f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getposition());
      }
      break;
    case 0x140:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isarray());
      }
      break;
    case 0x141:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isoptional());
      }
      break;
    case 0x142:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultvalue());
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x143:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispassedbyreference());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x6ED51288559D6063LL, NAMSTR(s_sys_ss559d6063, "getDeclaringClass")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x4044F1EEBF3BB8C8LL, NAMSTR(s_sys_ss40c44738, "getPosition")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getposition());
      }
      break;
    case 9:
      HASH_GUARD_LITSTR(0x4F51DA0B633E9909LL, NAMSTR(s_sys_ss633e9909, "getClass")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclass());
      }
      HASH_GUARD_LITSTR(0x24ED05F4504C4C09LL, NAMSTR(s_sys_ss504c4c09, "allowsNull")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_allowsnull());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x27C482A6C7951E0CLL, NAMSTR(s_sys_ss386ae1f4, "getDefaultValue")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultvalue());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x13E3F304BDD89FB1LL, NAMSTR(s_sys_ss4227604f, "isPassedByReference")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispassedbyreference());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x6E34805C91257C92LL, NAMSTR(s_sys_ss6eda836e, "isDefaultValueAvailable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultvalueavailable());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x2D6EF48BBAB22735LL, NAMSTR(s_sys_ss454dd8cb, "isOptional")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isoptional());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x5A9CE40C0F25871DLL, NAMSTR(s_sys_ss0f25871d, "isArray")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isarray());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ReflectionParameter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x111:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x0B5ABC58C98E70E8LL, NAMSTR(s_sys_ss36718f18, "export")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ReflectionParameter = {
  c_ReflectionParameter::os_getInit,
  c_ReflectionParameter::os_get,
  c_ReflectionParameter::os_lval,
  c_ReflectionParameter::os_invoke,
  c_ReflectionParameter::os_constant,
};
void c_ReflectionParameter::init() {
  m_info = null;
}
/* SRC: classes/reflection.php line 49 */
void c_ReflectionParameter::t___construct(Variant v_func, Variant v_param) {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_params;

  if ((toBoolean(v_func) && toBoolean(v_param))) {
    {
      {
        Variant tmp1((v_func. BIND_CLASS_DOT o_invoke_few_args(/* getParameters */ MethodIndex(304, 1) /* getParameters */ ,  "getParameters", 0x3E62225132C2A32DLL, 0)));
        v_params = tmp1;
      }
      {
        const Variant &tmp2((v_params.rvalAt(v_param, true).o_getPublic(NAMSTR(s_sys_ss157d479f, "info"), true)));
        m_info = tmp2;
      }
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 56 */
String c_ReflectionParameter::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 75 */
Variant c_ReflectionParameter::ti_export(const char* cls, CVarRef v_func, CVarRef v_param, CVarRef v_ret) {
  STATIC_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::export);
  p_ReflectionParameter v_obj;
  String v_str;

  {
    p_ReflectionParameter tmp1 = NEWOBJ(c_ReflectionParameter)();
    (tmp1->create(v_func, v_param));
    v_obj = tmp1;
  }
  v_str = (toString(v_obj));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 93 */
Variant c_ReflectionParameter::t_getname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::getName);
  return m_info.rvalAt(NAMSTR(s_sys_ss77e35232, "name"), true, true);
} /* function */
/* SRC: classes/reflection.php line 108 */
Variant c_ReflectionParameter::t_ispassedbyreference() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::isPassedByReference);
  return m_info.rvalAt(NAMSTR(s_sys_ss208f545e, "ref"), true, true);
} /* function */
/* SRC: classes/reflection.php line 122 */
Variant c_ReflectionParameter::t_getdeclaringclass() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::getDeclaringClass);
  if (empty(m_info, NAMSTR(s_sys_ss1f74c210, "class"), true)) {
    {
      return null;
    }
  }
  {
    p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
    return (tmp1->create(m_info.rvalAt(NAMSTR(s_sys_ss1f74c210, "class"), true, true)), tmp1);
  }
} /* function */
/* SRC: classes/reflection.php line 139 */
Variant c_ReflectionParameter::t_getclass() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::getClass);
  if (empty(m_info, NAMSTR(s_sys_ss1fe107ad, "type"), true)) {
    {
      return null;
    }
  }
  {
    p_ReflectionClass tmp1 = NEWOBJ(c_ReflectionClass)();
    return (tmp1->create(m_info.rvalAt(NAMSTR(s_sys_ss1fe107ad, "type"), true, true)), tmp1);
  }
} /* function */
/* SRC: classes/reflection.php line 155 */
bool c_ReflectionParameter::t_isarray() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::isArray);
  return equal(m_info.rvalAt(NAMSTR(s_sys_ss1fe107ad, "type"), true, true), NAMSTR(s_sys_ss7eaeeecb, "array"));
} /* function */
/* SRC: classes/reflection.php line 169 */
Variant c_ReflectionParameter::t_allowsnull() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::allowsNull);
  return m_info.rvalAt(NAMSTR(s_sys_ss781593b7, "nullable"), true, true);
} /* function */
/* SRC: classes/reflection.php line 182 */
bool c_ReflectionParameter::t_isoptional() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::isOptional);
  return x_array_key_exists(NAMSTR(s_sys_ss6463ffdf, "default"), m_info);
} /* function */
/* SRC: classes/reflection.php line 197 */
bool c_ReflectionParameter::t_isdefaultvalueavailable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::isDefaultValueAvailable);
  return x_array_key_exists(NAMSTR(s_sys_ss6463ffdf, "default"), m_info);
} /* function */
/* SRC: classes/reflection.php line 212 */
Variant c_ReflectionParameter::t_getdefaultvalue() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::getDefaultValue);
  Variant v_defaultValue;

  {
    bool tmp1;
    {
      bool tmp2((t_isoptional()));
      tmp1 = (!(tmp2));
    }
    if (tmp1) {
      {
        throw_exception(p_ReflectionException((NEWOBJ(c_ReflectionException)())->create(NAMSTR(s_sys_ss4fc853c6, "Parameter is not optional"))));
      }
    }
  }
  {
    Variant tmp3((m_info.rvalAt(NAMSTR(s_sys_ss6463ffdf, "default"), true, true)));
    v_defaultValue = tmp3;
  }
  if (instanceOf(v_defaultValue, "stdclass")) {
    {
      {
        const String &tmp4((toString(v_defaultValue.o_getPublic(NAMSTR(s_sys_ss10d8f28e, "msg"), true))));
        x_hphp_throw_fatal_error(tmp4);
      }
    }
  }
  return v_defaultValue;
} /* function */
/* SRC: classes/reflection.php line 233 */
Variant c_ReflectionParameter::t_getposition() {
  INSTANCE_METHOD_INJECTION_BUILTIN(ReflectionParameter, ReflectionParameter::getPosition);
  return m_info.rvalAt(NAMSTR(s_sys_ss43880cae, "index"), true, true);
} /* function */
Object co_ReflectionFunctionAbstract(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionFunctionAbstract)())->dynCreate(params, init));
}
Object co_ReflectionObject(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionObject)())->dynCreate(params, init));
}
Object co_ReflectionException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionException)())->dynCreate(params, init));
}
Object co_ReflectionClass(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionClass)())->dynCreate(params, init));
}
Object co_ReflectionExtension(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionExtension)())->dynCreate(params, init));
}
Object co_ReflectionMethod(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionMethod)())->dynCreate(params, init));
}
Object co_ReflectionProperty(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionProperty)())->dynCreate(params, init));
}
Object co_ReflectionFunction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionFunction)())->dynCreate(params, init));
}
Object co_ReflectionParameter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ReflectionParameter)())->dynCreate(params, init));
}
Variant pm_php$classes$reflection_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */, Globals *globals /* = get_globals() */) {
  PSEUDOMAIN_INJECTION_BUILTIN(run_init::classes/reflection.php, pm_php$classes$reflection_php);
  LVariableTable *gVariables __attribute__((__unused__)) = (LVariableTable *)g;
  return true;
} /* function */

///////////////////////////////////////////////////////////////////////////////
}

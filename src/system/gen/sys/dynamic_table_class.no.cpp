/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/base/runtime_option.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
#include <sys/literal_strings.h>


using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////


// Class Invoke Tables
#define M(x, y) MethodIndex(x, y)
#define H(x,y,z) MethodIndexHMap(#x,MethodIndex(y,z))
#define Z MethodIndexHMap(0,MethodIndex(0,0))
const unsigned methodIndexHMapSizeSys = 878;
extern const MethodIndexHMap methodIndexHMapSys [];
const MethodIndexHMap methodIndexHMapSys [methodIndexHMapSizeSys] = {
Z, H(getArrayCopy,14,1), Z, 
H(__destruct,35,1), Z, Z, 
Z, Z, H(addCompletion,162,1), 
Z, H(insertData,66,1), H(getserverstatus,216,1), 
H(endDTDEntity,410,1), H(hasChildren,258,1), Z, 
H(openFile,197,1), Z, Z, 
Z, Z, H(getElementsByTagNameNS,75,1), 
Z, Z, H(setValue,327,1), 
H(getInterfaceNames,280,1), Z, H(getTraceAsString,31,1), 
H(closecursor,248,1), Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
H(isFinal,271,1), Z, Z, 
Z, H(getClassNames,299,1), Z, 
Z, H(getCTime,184,1), Z, 
Z, H(rewind,9,1), H(startDTD,427,1), 
H(setFileClass,178,1), H(getFlags,22,1), Z, 
Z, Z, Z, 
Z, H(isDestructor,315,1), H(normalize,57,1), 
H(__getfunctions,367,1), H(loadHTML,78,1), Z, 
Z, H(fwrite,394,1), H(startElement,412,1), 
H(openblob,337,1), H(setFlags,17,1), H(query,124,1), 
H(xend,145,1), H(getParentClass,278,1), H(asXML,354,1), 
H(close,171,1), Z, H(createAttributens,85,1), 
Z, H(getInterfaces,293,1), H(registerPHPFunctions,126,1), 
H(escapestring,333,1), H(appendChild,50,1), H(endAttribute,436,1), 
H(registerNamespace,127,1), H(seek,21,1), H(numcolumns,342,1), 
H(__toString,26,1), H(insertBefore,46,1), H(startDTDEntity,404,1), 
H(cloneNode,52,1), H(endPI,426,1), H(setclass,377,1), 
H(endElement,423,1), Z, H(endDTDElement,429,1), 
Z, Z, Z, 
H(setfetchmode,245,1), Z, H(fgetcsv,381,1), 
H(arg,141,1), Z, H(getClosure,308,1), 
H(hasMethod,269,1), H(relaxNGValidateSource,89,1), Z, 
H(load,84,1), H(argRest,163,1), H(lasterrorcode,338,1), 
Z, H(args,161,1), Z, 
Z, Z, Z, 
H(__get,62,1), Z, Z, 
Z, Z, Z, 
Z, H(getSubPathname,256,1), H(delete,223,1), 
Z, H(getExtensionName,277,1), Z, 
Z, H(isInstantiable,292,1), H(getcolumnmeta,242,1), 
Z, Z, Z, 
H(setMaxLineLen,384,1), H(open,335,1), Z, 
H(getDeclaringClass,312,1), H(createaggregate,334,1), H(addChild,357,1), 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, H(helpCmds,142,1), 
Z, Z, Z, 
Z, Z, H(getLinkTarget,180,1), 
Z, H(columntype,341,1), Z, 
H(begintransaction,237,1), Z, Z, 
H(getPath,185,1), H(fetchcolumn,241,1), Z, 
H(getPathInfo,183,1), H(isConstructor,313,1), H(isInternal,295,1), 
Z, Z, Z, 
Z, H(loadXML,92,1), H(helpSection,156,1), 
Z, Z, H(isSubclassOf,286,1), 
Z, Z, Z, 
Z, H(attributes,359,1), Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, H(replaceData,68,1), H(startAttributens,411,1), 
H(isSupported,63,1), H(substringData,65,1), H(startCData,431,1), 
Z, Z, H(bindcolumn,244,1), 
H(loadImages,205,1), Z, Z, 
Z, Z, H(createElementNS,87,1), 
H(addsoapheader,372,1), H(getversion,222,1), H(onClient,168,1), 
H(getFileInfo,194,1), H(getConstant,282,1), Z, 
H(getTimezone,132,1), H(startComment,439,1), Z, 
Z, Z, Z, 
H(registerXPathNamespace,351,1), H(setAttributeNS,108,1), H(hasFeature,119,1), 
H(__sleep,240,1), H(hasAttributeNS,106,1), H(prepare,238,1), 
Z, Z, H(rollback,233,1), 
H(outputMemory,402,1), H(getTrace,32,1), H(getAttributeNS,109,1), 
Z, H(lookupNamespaceUri,49,1), Z, 
H(sortwithsortkeys,34,1), H(c14n,55,1), H(geterrormessage,43,1), 
Z, Z, Z, 
H(setInfoClass,179,1), Z, Z, 
Z, Z, Z, 
Z, H(valid,3,1), Z, 
H(invoke,307,1), H(__isset,358,1), H(saveHTML,91,1), 
H(getConstants,283,1), H(setAttributeNode,116,1), Z, 
Z, Z, Z, 
H(fetcharray,343,1), H(getNamedItem,120,1), Z, 
Z, Z, H(writeElement,422,1), 
Z, H(querysingle,339,1), Z, 
H(getFrame,159,1), Z, H(removeAttribute,115,1), 
H(getProperty,296,1), H(startDocument,403,1), H(getNamedItemNS,123,1), 
H(export,273,1), H(send,166,1), H(setIDAttributeNode,113,1), 
H(isFile,190,1), H(getErrors,207,1), Z, 
Z, Z, H(getlocale,42,1), 
Z, Z, H(onServer,169,1), 
Z, H(implementsInterface,279,1), Z, 
Z, H(getavailabledrivers,235,1), Z, 
Z, H(rowcount,249,1), H(mapping,203,1), 
H(fault,376,1), H(execute,250,1), H(getExtension,265,1), 
H(replace,225,1), H(getMethods,260,1), H(setIDAttribute,112,1), 
H(getextendedstats,227,1), H(commit,234,1), Z, 
Z, H(getDocNamespaces,355,1), Z, 
Z, H(getLineNo,45,1), H(hasProperty,287,1), 
Z, Z, H(debugdumpparams,255,1), 
Z, Z, Z, 
Z, Z, Z, 
H(setstrength,39,1), Z, Z, 
H(getType,199,1), Z, Z, 
H(getName,139,1), H(lookupPrefix,56,1), H(natsort,16,1), 
H(item,121,1), H(format,128,1), H(setTime,131,1), 
H(schemaValidate,80,1), H(ksort,23,1), H(saveHTMLFile,97,1), 
H(createDocument,117,1), Z, H(getInnerIterator,4,1), 
Z, Z, H(getIterator,122,1), 
Z, Z, Z, 
H(isAbstract,294,1), H(__soapcall,364,1), H(read,172,1), 
H(eof,387,1), H(getNodePath,58,1), Z, 
Z, H(onAutoComplete,167,1), H(createProcessingInstruction,82,1), 
H(getStaticProperties,289,1), H(writeAttribute,407,1), H(hasAttribute,105,1), 
Z, Z, Z, 
Z, Z, H(getMTime,192,1), 
H(xpath,350,1), Z, Z, 
H(quit,157,1), H(ftell,393,1), Z, 
Z, Z, Z, 
H(loadDims,202,1), Z, Z, 
Z, Z, Z, 
Z, Z, H(getStartLine,281,1), 
Z, Z, Z, 
H(isDefaultValueAvailable,316,1), H(createDocumentFragment,101,1), H(hasChildNodes,64,1), 
H(serialize,348,1), H(isPublic,314,1), Z, 
Z, H(createComment,99,1), Z, 
Z, H(relaxNGValidate,77,1), H(setDate,129,1), 
Z, H(getCommand,147,1), Z, 
H(unserialize,347,1), Z, H(getattribute,33,1), 
H(decrement,214,1), Z, Z, 
Z, Z, Z, 
Z, H(getFunctions,297,1), H(addserver,210,1), 
H(listAbbreviations,138,1), H(errorinfo,239,1), Z, 
H(next,1,1), H(schemaValidateSource,76,1), Z, 
Z, Z, Z, 
H(writeDTD,409,1), H(__wakeup,232,1), H(__getlastresponseheaders,368,1), 
Z, Z, Z, 
H(getPathname,176,1), H(createTextNode,90,1), H(c14nfile,59,1), 
H(getATime,195,1), H(removeAttributeNS,110,1), H(getstats,215,1), 
H(isDir,193,1), H(endDTDAttlist,401,1), H(writeDTDEntity,425,1), 
H(setTimezone,134,1), H(normalizeDocument,100,1), H(text,438,1), 
H(css,204,1), H(importNode,88,1), H(modify,135,1), 
H(__set,51,1), Z, Z, 
H(getDocComment,284,1), Z, H(finalize,345,1), 
H(getCsvControl,383,1), H(loadextension,329,1), Z, 
Z, Z, H(paramcount,346,1), 
H(createElement,86,1), H(xinclude,95,1), H(error,144,1), 
Z, H(fgets,391,1), Z, 
Z, Z, H(newInstance,264,1), 
H(columnname,340,1), H(lastinsertrowid,331,1), H(getGroup,177,1), 
Z, H(getCurrentLocation,164,1), Z, 
Z, H(setIndentString,420,1), Z, 
Z, Z, Z, 
H(current,7,1), Z, Z, 
Z, Z, H(test,288,1), 
Z, Z, H(offsetSet,13,1), 
Z, H(writeCData,415,1), Z, 
H(contains,398,1), Z, H(attach,396,1), 
Z, H(append,5,1), Z, 
H(setattribute,41,1), Z, H(__call,8,1), 
Z, H(createDocumentType,118,1), H(nextrowset,243,1), 
H(returnsReference,306,1), Z, Z, 
Z, Z, Z, 
H(print,154,1), H(isPassedByReference,323,1), Z, 
Z, Z, H(getElementsByTagName,72,1), 
H(isStatic,311,1), H(quote,236,1), H(getStaticVariables,303,1), 
H(getFilename,189,1), H(offsetUnset,12,1), H(fflush,388,1), 
H(isDefaultNamespace,47,1), H(getAttributeNode,111,1), H(isExecutable,196,1), 
H(sort,36,1), H(addString,201,1), H(fseek,379,1), 
Z, Z, Z, 
Z, Z, H(saveXML,81,1), 
Z, Z, Z, 
Z, H(isId,48,1), H(getPerms,173,1), 
Z, Z, H(count,15,1), 
Z, H(offsetGet,11,1), H(isPrivate,309,1), 
H(setobject,375,1), H(output,150,1), Z, 
H(createfunction,330,1), Z, Z, 
Z, H(add,221,1), Z, 
H(appendXML,102,1), H(__getlastrequestheaders,366,1), H(pconnect,220,1), 
H(flush,226,1), H(setStaticPropertyValue,291,1), H(replaceChild,53,1), 
H(key,2,1), H(__getlastresponse,369,1), H(writeRaw,424,1), 
Z, Z, Z, 
Z, H(isLocal,170,1), Z, 
Z, Z, Z, 
H(increment,213,1), H(fgetc,389,1), H(startDTDAttlist,430,1), 
H(getMethod,276,1), Z, Z, 
Z, Z, Z, 
H(getFile,30,1), Z, Z, 
Z, Z, H(getParameters,304,1), 
Z, Z, H(deleteData,69,1), 
H(fpassthru,390,1), H(isArray,320,1), H(getMaxLineLen,385,1), 
H(exec,230,1), H(setserverparams,212,1), Z, 
Z, Z, Z, 
Z, Z, Z, 
H(__setsoapheaders,362,1), Z, H(isDefault,325,1), 
Z, H(isSameNode,60,1), Z, 
H(setIndent,428,1), H(isLink,187,1), H(addUrl,208,1), 
H(writeAttributeNS,418,1), Z, H(createAttribute,94,1), 
Z, Z, Z, 
Z, Z, Z, 
Z, H(getClasses,300,1), H(set,211,1), 
H(getEndLine,268,1), Z, Z, 
H(isnormalized,228,1), H(setpersistence,373,1), Z, 
H(get,219,1), H(removeChild,61,1), H(setAccessible,326,1), 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, H(columncount,246,1), 
H(setcompressthreshold,218,1), Z, Z, 
H(changes,336,1), Z, H(writeComment,406,1), 
Z, Z, Z, 
Z, Z, H(getINIEntries,298,1), 
H(newInstanceArgs,267,1), Z, Z, 
Z, H(compare,44,1), Z, 
Z, Z, H(getChildren,259,1), 
H(isOptional,321,1), H(isUserDefined,263,1), H(allowsNull,318,1), 
Z, Z, H(ask,143,1), 
H(save,93,1), H(startElementNS,413,1), H(isInstance,270,1), 
H(endComment,408,1), H(createEntityReference,79,1), H(handle,374,1), 
Z, H(getPosition,319,1), Z, 
H(endDTD,433,1), Z, Z, 
Z, Z, Z, 
Z, H(printFrame,153,1), H(getConstructor,266,1), 
H(__construct,6,1), Z, H(__unset,353,1), 
H(natcasesort,19,1), H(getOwner,191,1), H(fetchall,252,1), 
H(__dorequest,360,1), H(setCsvControl,382,1), H(getMessage,25,1), 
H(asort,20,1), H(__setlocation,365,1), Z, 
Z, Z, Z, 
Z, Z, H(lasterrormsg,332,1), 
Z, H(getNamespaces,352,1), H(getLine,28,1), 
Z, Z, Z, 
H(getSeverity,200,1), Z, Z, 
Z, Z, Z, 
H(setAttributeNodeNS,107,1), H(addAttribute,349,1), H(fgetss,380,1), 
H(getBasename,175,1), Z, Z, 
H(startAttribute,421,1), Z, Z, 
Z, Z, Z, 
H(isInterface,285,1), H(getAttributeNodeNS,104,1), Z, 
H(bindparam,247,1), Z, Z, 
H(isIterateable,261,1), H(argValue,149,1), Z, 
H(setISODate,133,1), H(hasConstant,275,1), Z, 
H(getStackTrace,151,1), Z, H(addfunction,371,1), 
H(uksort,18,1), H(getElementById,98,1), Z, 
H(code,155,1), H(getstrength,38,1), Z, 
Z, Z, H(writePI,419,1), 
H(registerNodeClass,83,1), H(ftruncate,386,1), H(getNumberOfRequiredParameters,301,1), 
H(listIdentifiers,137,1), H(invokeArgs,305,1), H(helpBody,158,1), 
H(getCode,27,1), Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
H(fetch,254,1), H(getTransitions,136,1), H(writeDTDAttlist,432,1), 
Z, H(lastinsertid,231,1), H(isWhitespaceInElementContent,70,1), 
H(__gettypes,370,1), H(isDot,198,1), H(isReadable,181,1), 
Z, Z, H(getDefaultProperties,290,1), 
H(connect,224,1), H(setIDAttributeNS,103,1), H(startPI,437,1), 
Z, H(bindvalue,253,1), H(endCData,405,1), 
H(getSubPath,257,1), Z, H(__setcookie,363,1), 
Z, Z, Z, 
H(helpTitle,146,1), Z, Z, 
H(argCount,140,1), H(evaluate,125,1), H(startDTDElement,414,1), 
H(hasAttributes,54,1), H(writeDTDElement,417,1), H(loadHTMLFile,96,1), 
Z, Z, Z, 
Z, Z, H(appendData,67,1), 
Z, Z, Z, 
Z, H(removeAttributeNode,114,1), H(detach,397,1), 
Z, H(splitText,71,1), H(__getlastrequest,361,1), 
Z, Z, Z, 
Z, Z, H(getStaticPropertyValue,262,1), 
Z, Z, H(clear,206,1), 
Z, H(setoptimeout,217,1), H(geterrorcode,37,1), 
H(validate,74,1), H(getDefaultValue,322,1), Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, H(reset,344,1), 
H(getSize,188,1), Z, H(create,40,1), 
Z, H(openURI,435,1), Z, 
Z, H(getProperties,274,1), H(endDocument,416,1), 
H(errorcode,229,1), Z, H(fullEndElement,400,1), 
H(offsetExists,10,1), H(addFile,209,1), H(getRealPath,182,1), 
H(fetchobject,251,1), H(getClass,317,1), H(getNumberOfParameters,302,1), 
H(fstat,395,1), H(flock,392,1), H(children,356,1), 
H(fscanf,378,1), H(isProtected,310,1), H(isWritable,174,1), 
H(uasort,24,1), Z, Z, 
H(createCDATASection,73,1), H(getInode,186,1), Z, 
H(openMemory,434,1), Z, Z, 
H(getValue,324,1), Z, H(getOffset,130,1), 
Z, H(info,152,1), H(tutorial,148,1), 
Z, H(help,160,1), Z, 
H(writeElementNS,399,1), Z, H(getModifiers,272,1), 
H(version,328,1), H(__init__,29,1), Z, 
Z, H(wrap,165,1)};
#undef M
#undef H
#undef Z
extern const unsigned methodIndexReverseCallIndexSys[];
const unsigned methodIndexReverseCallIndexSys[] = {0, 
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,
39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,
59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,
79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,
99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,
139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,
159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,
179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,
199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,
219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,
259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,
279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,
299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,
319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,
339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,
359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,
379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,
399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,
419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438
};
extern const char * methodIndexReverseIndexSys[];
const char * methodIndexReverseIndexSys[] = {
"next", "key", "valid", "getInnerIterator", "append", 
"__construct", "current", "__call", "rewind", "offsetExists", 
"offsetGet", "offsetUnset", "offsetSet", "getArrayCopy", "count", 
"natsort", "setFlags", "uksort", "natcasesort", "asort", 
"seek", "getFlags", "ksort", "uasort", "getMessage", 
"__toString", "getCode", "getLine", "__init__", "getFile", 
"getTraceAsString", "getTrace", "getattribute", "sortwithsortkeys", "__destruct", 
"sort", "geterrorcode", "getstrength", "setstrength", "create", 
"setattribute", "getlocale", "geterrormessage", "compare", "getLineNo", 
"insertBefore", "isDefaultNamespace", "isId", "lookupNamespaceUri", "appendChild", 
"__set", "cloneNode", "replaceChild", "hasAttributes", "c14n", 
"lookupPrefix", "normalize", "getNodePath", "c14nfile", "isSameNode", 
"removeChild", "__get", "isSupported", "hasChildNodes", "substringData", 
"insertData", "appendData", "replaceData", "deleteData", "isWhitespaceInElementContent", 
"splitText", "getElementsByTagName", "createCDATASection", "validate", "getElementsByTagNameNS", 
"schemaValidateSource", "relaxNGValidate", "loadHTML", "createEntityReference", "schemaValidate", 
"saveXML", "createProcessingInstruction", "registerNodeClass", "load", "createAttributens", 
"createElement", "createElementNS", "importNode", "relaxNGValidateSource", "createTextNode", 
"saveHTML", "loadXML", "save", "createAttribute", "xinclude", 
"loadHTMLFile", "saveHTMLFile", "getElementById", "createComment", "normalizeDocument", 
"createDocumentFragment", "appendXML", "setIDAttributeNS", "getAttributeNodeNS", "hasAttribute", 
"hasAttributeNS", "setAttributeNodeNS", "setAttributeNS", "getAttributeNS", "removeAttributeNS", 
"getAttributeNode", "setIDAttribute", "setIDAttributeNode", "removeAttributeNode", "removeAttribute", 
"setAttributeNode", "createDocument", "createDocumentType", "hasFeature", "getNamedItem", 
"item", "getIterator", "getNamedItemNS", "query", "evaluate", 
"registerPHPFunctions", "registerNamespace", "format", "setDate", "getOffset", 
"setTime", "getTimezone", "setISODate", "setTimezone", "modify", 
"getTransitions", "listIdentifiers", "listAbbreviations", "getName", "argCount", 
"arg", "helpCmds", "ask", "error", "xend", 
"helpTitle", "getCommand", "tutorial", "argValue", "output", 
"getStackTrace", "info", "printFrame", "print", "code", 
"helpSection", "quit", "helpBody", "getFrame", "help", 
"args", "addCompletion", "argRest", "getCurrentLocation", "wrap", 
"send", "onAutoComplete", "onClient", "onServer", "isLocal", 
"close", "read", "getPerms", "isWritable", "getBasename", 
"getPathname", "getGroup", "setFileClass", "setInfoClass", "getLinkTarget", 
"isReadable", "getRealPath", "getPathInfo", "getCTime", "getPath", 
"getInode", "isLink", "getSize", "getFilename", "isFile", 
"getOwner", "getMTime", "isDir", "getFileInfo", "getATime", 
"isExecutable", "openFile", "isDot", "getType", "getSeverity", 
"addString", "loadDims", "mapping", "css", "loadImages", 
"clear", "getErrors", "addUrl", "addFile", "addserver", 
"set", "setserverparams", "increment", "decrement", "getstats", 
"getserverstatus", "setoptimeout", "setcompressthreshold", "get", "pconnect", 
"add", "getversion", "delete", "connect", "replace", 
"flush", "getextendedstats", "isnormalized", "errorcode", "exec", 
"lastinsertid", "__wakeup", "rollback", "commit", "getavailabledrivers", 
"quote", "begintransaction", "prepare", "errorinfo", "__sleep", 
"fetchcolumn", "getcolumnmeta", "nextrowset", "bindcolumn", "setfetchmode", 
"columncount", "bindparam", "closecursor", "rowcount", "execute", 
"fetchobject", "fetchall", "bindvalue", "fetch", "debugdumpparams", 
"getSubPathname", "getSubPath", "hasChildren", "getChildren", "getMethods", 
"isIterateable", "getStaticPropertyValue", "isUserDefined", "newInstance", "getExtension", 
"getConstructor", "newInstanceArgs", "getEndLine", "hasMethod", "isInstance", 
"isFinal", "getModifiers", "export", "getProperties", "hasConstant", 
"getMethod", "getExtensionName", "getParentClass", "implementsInterface", "getInterfaceNames", 
"getStartLine", "getConstant", "getConstants", "getDocComment", "isInterface", 
"isSubclassOf", "hasProperty", "test", "getStaticProperties", "getDefaultProperties", 
"setStaticPropertyValue", "isInstantiable", "getInterfaces", "isAbstract", "isInternal", 
"getProperty", "getFunctions", "getINIEntries", "getClassNames", "getClasses", 
"getNumberOfRequiredParameters", "getNumberOfParameters", "getStaticVariables", "getParameters", "invokeArgs", 
"returnsReference", "invoke", "getClosure", "isPrivate", "isProtected", 
"isStatic", "getDeclaringClass", "isConstructor", "isPublic", "isDestructor", 
"isDefaultValueAvailable", "getClass", "allowsNull", "getPosition", "isArray", 
"isOptional", "getDefaultValue", "isPassedByReference", "getValue", "isDefault", 
"setAccessible", "setValue", "version", "loadextension", "createfunction", 
"lastinsertrowid", "lasterrormsg", "escapestring", "createaggregate", "open", 
"changes", "openblob", "lasterrorcode", "querysingle", "columnname", 
"columntype", "numcolumns", "fetcharray", "reset", "finalize", 
"paramcount", "unserialize", "serialize", "addAttribute", "xpath", 
"registerXPathNamespace", "getNamespaces", "__unset", "asXML", "getDocNamespaces", 
"children", "addChild", "__isset", "attributes", "__dorequest", 
"__getlastrequest", "__setsoapheaders", "__setcookie", "__soapcall", "__setlocation", 
"__getlastrequestheaders", "__getfunctions", "__getlastresponseheaders", "__getlastresponse", "__gettypes", 
"addfunction", "addsoapheader", "setpersistence", "handle", "setobject", 
"fault", "setclass", "fscanf", "fseek", "fgetss", 
"fgetcsv", "setCsvControl", "getCsvControl", "setMaxLineLen", "getMaxLineLen", 
"ftruncate", "eof", "fflush", "fgetc", "fpassthru", 
"fgets", "flock", "ftell", "fwrite", "fstat", 
"attach", "detach", "contains", "writeElementNS", "fullEndElement", 
"endDTDAttlist", "outputMemory", "startDocument", "startDTDEntity", "endCData", 
"writeComment", "writeAttribute", "endComment", "writeDTD", "endDTDEntity", 
"startAttributens", "startElement", "startElementNS", "startDTDElement", "writeCData", 
"endDocument", "writeDTDElement", "writeAttributeNS", "writePI", "setIndentString", 
"startAttribute", "writeElement", "endElement", "writeRaw", "writeDTDEntity", 
"endPI", "startDTD", "setIndent", "endDTDElement", "startDTDAttlist", 
"startCData", "writeDTDAttlist", "endDTD", "openMemory", "openURI", 
"endAttribute", "startPI", "text", "startComment"};
#ifndef NOFMCGEN
bool RuntimeOption::FastMethodCall = true;
#else
bool RuntimeOption::FastMethodCall = false;
#endif
extern struct ObjectStaticCallbacks cw_ReflectionFunctionAbstract;
extern struct ObjectStaticCallbacks cw_ReflectionObject;
extern struct ObjectStaticCallbacks cw_SplFileObject;
extern struct ObjectStaticCallbacks cw_UnexpectedValueException;
extern struct ObjectStaticCallbacks cw_stdClass;
extern struct ObjectStaticCallbacks cw_ReflectionException;
extern struct ObjectStaticCallbacks cw_OverflowException;
extern struct ObjectStaticCallbacks cw_SplFileInfo;
extern struct ObjectStaticCallbacks cw_ArrayIterator;
extern struct ObjectStaticCallbacks cw_AppendIterator;
extern struct ObjectStaticCallbacks cw_OutOfBoundsException;
extern struct ObjectStaticCallbacks cw_LogicException;
extern struct ObjectStaticCallbacks cw_RangeException;
extern struct ObjectStaticCallbacks cw_SplObjectStorage;
extern struct ObjectStaticCallbacks cw_InvalidArgumentException;
extern struct ObjectStaticCallbacks cw_ReflectionClass;
extern struct ObjectStaticCallbacks cw_UnderflowException;
extern struct ObjectStaticCallbacks cw_ReflectionExtension;
extern struct ObjectStaticCallbacks cw_OutOfRangeException;
extern struct ObjectStaticCallbacks cw_ReflectionMethod;
extern struct ObjectStaticCallbacks cw_BadMethodCallException;
extern struct ObjectStaticCallbacks cw_ReflectionProperty;
extern struct ObjectStaticCallbacks cw___PHP_Incomplete_Class;
extern struct ObjectStaticCallbacks cw_RuntimeException;
extern struct ObjectStaticCallbacks cw_Exception;
extern struct ObjectStaticCallbacks cw_ReflectionFunction;
extern struct ObjectStaticCallbacks cw_ErrorException;
extern struct ObjectStaticCallbacks cw_RecursiveDirectoryIterator;
extern struct ObjectStaticCallbacks cw_DirectoryIterator;
extern struct ObjectStaticCallbacks cw_BadFunctionCallException;
extern struct ObjectStaticCallbacks cw_LengthException;
extern struct ObjectStaticCallbacks cw_DomainException;
extern struct ObjectStaticCallbacks cw_RecursiveIteratorIterator;
extern struct ObjectStaticCallbacks cw_Directory;
extern struct ObjectStaticCallbacks cw_FilterIterator;
extern struct ObjectStaticCallbacks cw_ReflectionParameter;
Object co_PDOException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDOException)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOException
Variant c_PDOException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOException
Variant c_PDOException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOException
Variant &c_PDOException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOException
void c_PDOException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOException
void c_PDOException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDOException
Variant * c_PDOException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOException
Variant * c_PDOException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOException
Variant * c_PDOException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOException
Variant c_PDOException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOException
IMPLEMENT_CLASS(PDOException)
c_PDOException *c_PDOException::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_PDOException::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_PDOException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_PDOException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_PDOException::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDOException::cloneImpl() {
  c_PDOException *obj = NEW(c_PDOException)();
  cloneSet(obj);
  return obj;
}
void c_PDOException::cloneSet(c_PDOException *clone) {
  c_Exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_PDOException
Variant c_PDOException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_PDOException
Variant c_PDOException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_PDOException
Variant c_PDOException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_PDOException
Variant c_PDOException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDOException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_PDOException = {
  c_PDOException::os_getInit,
  c_PDOException::os_get,
  c_PDOException::os_lval,
  c_PDOException::os_invoke,
  c_PDOException::os_constant,
};
Object co_DOMDocumentFragment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocumentFragment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentFragment
Variant &c_DOMDocumentFragment::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentFragment
void c_DOMDocumentFragment::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentFragment
void c_DOMDocumentFragment::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentFragment
IMPLEMENT_CLASS(DOMDocumentFragment)
c_DOMDocumentFragment *c_DOMDocumentFragment::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMDocumentFragment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMDocumentFragment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMDocumentFragment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMDocumentFragment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocumentFragment::cloneImpl() {
  c_DOMDocumentFragment *obj = NEW(c_DOMDocumentFragment)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocumentFragment::cloneSet(c_DOMDocumentFragment *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentFragment
Variant c_DOMDocumentFragment::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x66:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendxml(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendXML")) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendxml(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentFragment
Variant c_DOMDocumentFragment::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x66:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendXML")) {
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMDocumentFragment
Variant c_DOMDocumentFragment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x66:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendxml(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss3e6df6cf, "appendXML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendxml(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocumentFragment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMDocumentFragment = {
  c_DOMDocumentFragment::os_getInit,
  c_DOMDocumentFragment::os_get,
  c_DOMDocumentFragment::os_lval,
  c_DOMDocumentFragment::os_invoke,
  c_DOMDocumentFragment::os_constant,
};
Object co_DOMText(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMText)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMText
Variant c_DOMText::os_getInit(CStrRef s) {
  return c_DOMCharacterData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMText
Variant c_DOMText::os_get(CStrRef s) {
  return c_DOMCharacterData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMText
Variant &c_DOMText::os_lval(CStrRef s) {
  return c_DOMCharacterData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMText
void c_DOMText::o_getArray(Array &props) const {
  c_DOMCharacterData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMText
void c_DOMText::o_setArray(CArrRef props) {
  c_DOMCharacterData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMText
Variant * c_DOMText::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMText
Variant * c_DOMText::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMCharacterData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMText
Variant * c_DOMText::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMText
Variant c_DOMText::os_constant(const char *s) {
  return c_DOMCharacterData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMText
IMPLEMENT_CLASS(DOMText)
c_DOMText *c_DOMText::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMText::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_DOMText::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_DOMText::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_DOMText::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMText::cloneImpl() {
  c_DOMText *obj = NEW(c_DOMText)();
  cloneSet(obj);
  return obj;
}
void c_DOMText::cloneSet(c_DOMText *clone) {
  c_DOMCharacterData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMText
Variant c_DOMText::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMText
Variant c_DOMText::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMText
Variant c_DOMText::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMText
Variant c_DOMText::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMCharacterData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMText::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMCharacterData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMText = {
  c_DOMText::os_getInit,
  c_DOMText::os_get,
  c_DOMText::os_lval,
  c_DOMText::os_invoke,
  c_DOMText::os_constant,
};
Object co_DebuggerClient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DebuggerClient)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerClient
Variant c_DebuggerClient::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerClient
Variant c_DebuggerClient::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerClient
Variant &c_DebuggerClient::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerClient
void c_DebuggerClient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerClient
void c_DebuggerClient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DebuggerClient
Variant * c_DebuggerClient::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerClient
Variant * c_DebuggerClient::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerClient
Variant * c_DebuggerClient::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerClient
Variant c_DebuggerClient::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x2038737F45604DE2LL, q_DebuggerClient_AUTO_COMPLETE_VARIABLES, "AUTO_COMPLETE_VARIABLES");
      break;
    case 7:
      HASH_RETURN(0x1B352E31B034F827LL, q_DebuggerClient_AUTO_COMPLETE_FILENAMES, "AUTO_COMPLETE_FILENAMES");
      HASH_RETURN(0x0F17BB5BEC004CA7LL, q_DebuggerClient_AUTO_COMPLETE_CLASSES, "AUTO_COMPLETE_CLASSES");
      break;
    case 9:
      HASH_RETURN(0x6A811D407DC24A29LL, q_DebuggerClient_AUTO_COMPLETE_CLASS_CONSTANTS, "AUTO_COMPLETE_CLASS_CONSTANTS");
      break;
    case 11:
      HASH_RETURN(0x1858E5511222BC8BLL, q_DebuggerClient_AUTO_COMPLETE_CLASS_PROPERTIES, "AUTO_COMPLETE_CLASS_PROPERTIES");
      HASH_RETURN(0x1DE12226E1E87B6BLL, q_DebuggerClient_AUTO_COMPLETE_CODE, "AUTO_COMPLETE_CODE");
      break;
    case 15:
      HASH_RETURN(0x2C29DCF63AAC70EFLL, q_DebuggerClient_AUTO_COMPLETE_CLASS_METHODS, "AUTO_COMPLETE_CLASS_METHODS");
      HASH_RETURN(0x76A6B174D3E2108FLL, q_DebuggerClient_AUTO_COMPLETE_KEYWORDS, "AUTO_COMPLETE_KEYWORDS");
      break;
    case 19:
      HASH_RETURN(0x78221A7B002235D3LL, q_DebuggerClient_AUTO_COMPLETE_CONSTANTS, "AUTO_COMPLETE_CONSTANTS");
      break;
    case 31:
      HASH_RETURN(0x7CAE318E6EF6449FLL, q_DebuggerClient_AUTO_COMPLETE_FUNCTIONS, "AUTO_COMPLETE_FUNCTIONS");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerClient
IMPLEMENT_CLASS(DebuggerClient)
c_DebuggerClient *c_DebuggerClient::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DebuggerClient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DebuggerClient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DebuggerClient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DebuggerClient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DebuggerClient::cloneImpl() {
  c_DebuggerClient *obj = NEW(c_DebuggerClient)();
  cloneSet(obj);
  return obj;
}
void c_DebuggerClient::cloneSet(c_DebuggerClient *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerClient
Variant c_DebuggerClient::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x8c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      break;
    case 0x8d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_arg(arg0, arg1));
        }
      }
      break;
    case 0x8e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_helpcmds(count, arg0, arg1), null);
          return (t_helpcmds(count,arg0, arg1, params.slice(2, count - 2, false)), null);
        }
      }
      break;
    case 0x8f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_ask(count, arg0));
          return (t_ask(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 0x90:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_error(count, arg0), null);
          return (t_error(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x91:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xend(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x92:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helptitle(arg0), null);
        }
      }
      break;
    case 0x93:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      break;
    case 0x94:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_tutorial(arg0), null);
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x95:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argvalue(arg0));
        }
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_output(count, arg0), null);
          return (t_output(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x97:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_info(count, arg0), null);
          return (t_info(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x99:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_printframe(arg0), null);
        }
      }
      break;
    case 0x9a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_print(count, arg0), null);
          return (t_print(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0x9b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_code(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_code(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_code(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_code(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0x9c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpsection(arg0), null);
        }
      }
      break;
    case 0x9d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 0x9e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpbody(arg0), null);
        }
      }
      break;
    case 0x9f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 0xa0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_help(count, arg0), null);
          return (t_help(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 0xa1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 0xa2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addcompletion(arg0), null);
        }
      }
      break;
    case 0xa3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argrest(arg0));
        }
      }
      break;
    case 0xa4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 0xa5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_wrap(arg0));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addcompletion(arg0), null);
        }
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_ask(count, arg0));
          return (t_ask(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_printframe(arg0), null);
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpbody(arg0), null);
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_helpcmds(count, arg0, arg1), null);
          return (t_helpcmds(count,arg0, arg1, params.slice(2, count - 2, false)), null);
        }
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_print(count, arg0), null);
          return (t_print(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argrest(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_error(count, arg0), null);
          return (t_error(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_info(count, arg0), null);
          return (t_info(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helptitle(arg0), null);
        }
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_argvalue(arg0));
        }
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_tutorial(arg0), null);
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_helpsection(arg0), null);
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_arg(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_help(count, arg0), null);
          return (t_help(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xend(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_wrap(arg0));
        }
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_code(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_code(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_code(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_code(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_output(count, arg0), null);
          return (t_output(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerClient
Variant c_DebuggerClient::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x8c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      break;
    case 0x8d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        return (t_arg(a0, a1));
      }
      break;
    case 0x8e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        Array params;
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_helpcmds(count,a0, a1, params), null);
      }
      break;
    case 0x8f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        if (count <= 1) return (t_ask(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_ask(count,a0, params));
      }
      break;
    case 0x90:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        if (count <= 1) return (t_error(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_error(count,a0, params), null);
      }
      break;
    case 0x91:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        return (t_xend(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x92:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        return (t_helptitle(a0), null);
      }
      break;
    case 0x93:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      break;
    case 0x94:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        return (t_tutorial(a0), null);
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x95:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        return (t_argvalue(a0));
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        if (count <= 1) return (t_output(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_output(count,a0, params), null);
      }
      break;
    case 0x97:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        if (count <= 1) return (t_info(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_info(count,a0, params), null);
      }
      break;
    case 0x99:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        return (t_printframe(a0), null);
      }
      break;
    case 0x9a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        if (count <= 1) return (t_print(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_print(count,a0, params), null);
      }
      break;
    case 0x9b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        if (count <= 1) return (t_code(a0), null);
        if (count == 2) return (t_code(a0, a1), null);
        if (count == 3) return (t_code(a0, a1, a2), null);
        return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 0x9c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        return (t_helpsection(a0), null);
      }
      break;
    case 0x9d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 0x9e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        return (t_helpbody(a0), null);
      }
      break;
    case 0x9f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 0xa0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        if (count <= 1) return (t_help(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_help(count,a0, params), null);
      }
      break;
    case 0xa1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 0xa2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        return (t_addcompletion(a0), null);
      }
      break;
    case 0xa3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        return (t_argrest(a0));
      }
      break;
    case 0xa4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 0xa5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        return (t_wrap(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        if (count <= 1) return (t_ask(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_ask(count,a0, params));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        Array params;
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_helpcmds(count,a0, a1, params), null);
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        if (count <= 1) return (t_print(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_print(count,a0, params), null);
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        if (count <= 1) return (t_error(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_error(count,a0, params), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        if (count <= 1) return (t_info(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_info(count,a0, params), null);
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        return (t_arg(a0, a1));
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        if (count <= 1) return (t_help(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_help(count,a0, params), null);
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        if (count <= 1) return (t_code(a0), null);
        if (count == 2) return (t_code(a0, a1), null);
        if (count == 3) return (t_code(a0, a1, a2), null);
        return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        if (count <= 1) return (t_output(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_output(count,a0, params), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DebuggerClient
Variant c_DebuggerClient::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DebuggerClient
Variant c_DebuggerClient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x8c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argcount());
      }
      break;
    case 0x8d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_arg(a0, a1));
      }
      break;
    case 0x8e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        return (t_helpcmds(count, a0, a1,vargs), null);
      }
      break;
    case 0x8f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_ask(count, a0));
        return (t_ask(count, a0,vargs));
      }
      break;
    case 0x90:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_error(count, a0), null);
        return (t_error(count, a0,vargs), null);
      }
      break;
    case 0x91:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xend(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x92:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helptitle(a0), null);
      }
      break;
    case 0x93:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcommand());
      }
      break;
    case 0x94:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_tutorial(a0), null);
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x95:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argvalue(a0));
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_output(count, a0), null);
        return (t_output(count, a0,vargs), null);
      }
      break;
    case 0x97:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstacktrace());
      }
      break;
    case 0x98:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_info(count, a0), null);
        return (t_info(count, a0,vargs), null);
      }
      break;
    case 0x99:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_printframe(a0), null);
      }
      break;
    case 0x9a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_print(count, a0), null);
        return (t_print(count, a0,vargs), null);
      }
      break;
    case 0x9b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_code(a0), null);
        else if (count == 2) return (t_code(a0, a1), null);
        else if (count == 3) return (t_code(a0, a1, a2), null);
        else return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 0x9c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpsection(a0), null);
      }
      break;
    case 0x9d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_quit(), null);
      }
      break;
    case 0x9e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpbody(a0), null);
      }
      break;
    case 0x9f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getframe());
      }
      break;
    case 0xa0:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_help(count, a0), null);
        return (t_help(count, a0,vargs), null);
      }
      break;
    case 0xa1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_args());
      }
      break;
    case 0xa2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addcompletion(a0), null);
      }
      break;
    case 0xa3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argrest(a0));
      }
      break;
    case 0xa4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcurrentlocation());
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 0xa5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_wrap(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss0b181780, "addCompletion")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss400a55be, "ask")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_ask(count, a0));
        return (t_ask(count, a0,vargs));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss377c4984, "getFrame")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss1dcaea85, "printFrame")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss521bc472, "args")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss5aaea631, "helpBody")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss6a0a46af, "helpCmds")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        return (t_helpcmds(count, a0, a1,vargs), null);
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss52b098d1, "print")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_print(count, a0), null);
        return (t_print(count, a0,vargs), null);
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss2c493a97, "getCommand")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss74d168d7, "argRest")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss5ec24921, "error")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_error(count, a0), null);
        return (t_error(count, a0,vargs), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss157d479f, "info")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_info(count, a0), null);
        return (t_info(count, a0,vargs), null);
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss3731c423, "helpTitle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss00554726, "getCurrentLocation")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss388f16d8, "argValue")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss0516b6ac, "tutorial")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss2a696def, "argCount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss3e2b4c6f, "helpSection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss2566090c, "arg")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_arg(a0, a1));
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss202dcacc, "help")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_help(count, a0), null);
        return (t_help(count, a0,vargs), null);
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss6fdb484a, "xend")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss13fc6fb7, "getStackTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss4aa2b277, "wrap")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss7a853247, "code")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_code(a0), null);
        else if (count == 2) return (t_code(a0, a1), null);
        else if (count == 3) return (t_code(a0, a1, a2), null);
        else return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss0631017a, "quit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_output(count, a0), null);
        return (t_output(count, a0,vargs), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DebuggerClient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DebuggerClient = {
  c_DebuggerClient::os_getInit,
  c_DebuggerClient::os_get,
  c_DebuggerClient::os_lval,
  c_DebuggerClient::os_invoke,
  c_DebuggerClient::os_constant,
};
Object co_DOMCDATASection(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMCDATASection)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCDATASection
Variant c_DOMCDATASection::os_getInit(CStrRef s) {
  return c_DOMText::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCDATASection
Variant c_DOMCDATASection::os_get(CStrRef s) {
  return c_DOMText::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCDATASection
Variant &c_DOMCDATASection::os_lval(CStrRef s) {
  return c_DOMText::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCDATASection
void c_DOMCDATASection::o_getArray(Array &props) const {
  c_DOMText::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCDATASection
void c_DOMCDATASection::o_setArray(CArrRef props) {
  c_DOMText::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMCDATASection
Variant * c_DOMCDATASection::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCDATASection
Variant * c_DOMCDATASection::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMText::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCDATASection
Variant * c_DOMCDATASection::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCDATASection
Variant c_DOMCDATASection::os_constant(const char *s) {
  return c_DOMText::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCDATASection
IMPLEMENT_CLASS(DOMCDATASection)
c_DOMCDATASection *c_DOMCDATASection::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMCDATASection::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMCDATASection::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMCDATASection::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_DOMCDATASection::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMCDATASection::cloneImpl() {
  c_DOMCDATASection *obj = NEW(c_DOMCDATASection)();
  cloneSet(obj);
  return obj;
}
void c_DOMCDATASection::cloneSet(c_DOMCDATASection *clone) {
  c_DOMText::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCDATASection
Variant c_DOMCDATASection::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_splittext(arg0));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCDATASection
Variant c_DOMCDATASection::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMCDATASection
Variant c_DOMCDATASection::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMCDATASection
Variant c_DOMCDATASection::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x46:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x47:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0f6c02dd, "isWhitespaceInElementContent")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss727ded49, "splitText")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_splittext(a0));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMText::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMCDATASection::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMText::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMCDATASection = {
  c_DOMCDATASection::os_getInit,
  c_DOMCDATASection::os_get,
  c_DOMCDATASection::os_lval,
  c_DOMCDATASection::os_invoke,
  c_DOMCDATASection::os_constant,
};
Object co_Locale(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Locale)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Locale
Variant c_Locale::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Locale
Variant c_Locale::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Locale
Variant &c_Locale::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Locale
void c_Locale::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Locale
void c_Locale::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Locale
Variant * c_Locale::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Locale
Variant * c_Locale::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Locale
Variant * c_Locale::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Locale
Variant c_Locale::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_RETURN(0x78695696B47AF8CDLL, q_Locale_ACTUAL_LOCALE, "ACTUAL_LOCALE");
      HASH_RETURN(0x35B10383BBF3BAE1LL, q_Locale_VALID_LOCALE, "VALID_LOCALE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Locale
IMPLEMENT_CLASS(Locale)
c_Locale *c_Locale::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Locale::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Locale::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Locale::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_Locale::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Locale::cloneImpl() {
  c_Locale *obj = NEW(c_Locale)();
  cloneSet(obj);
  return obj;
}
void c_Locale::cloneSet(c_Locale *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Locale
Variant c_Locale::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Locale
Variant c_Locale::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Locale
Variant c_Locale::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Locale
Variant c_Locale::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Locale::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_Locale = {
  c_Locale::os_getInit,
  c_Locale::os_get,
  c_Locale::os_lval,
  c_Locale::os_invoke,
  c_Locale::os_constant,
};
Object co_DOMDocumentType(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocumentType)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentType
Variant c_DOMDocumentType::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentType
Variant c_DOMDocumentType::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentType
Variant &c_DOMDocumentType::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentType
void c_DOMDocumentType::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentType
void c_DOMDocumentType::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentType
Variant * c_DOMDocumentType::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentType
Variant * c_DOMDocumentType::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentType
Variant * c_DOMDocumentType::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentType
Variant c_DOMDocumentType::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentType
IMPLEMENT_CLASS(DOMDocumentType)
c_DOMDocumentType *c_DOMDocumentType::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMDocumentType::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMDocumentType::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMDocumentType::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMDocumentType::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocumentType::cloneImpl() {
  c_DOMDocumentType *obj = NEW(c_DOMDocumentType)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocumentType::cloneSet(c_DOMDocumentType *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentType
Variant c_DOMDocumentType::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentType
Variant c_DOMDocumentType::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMDocumentType
Variant c_DOMDocumentType::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMDocumentType
Variant c_DOMDocumentType::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocumentType::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMDocumentType = {
  c_DOMDocumentType::os_getInit,
  c_DOMDocumentType::os_get,
  c_DOMDocumentType::os_lval,
  c_DOMDocumentType::os_invoke,
  c_DOMDocumentType::os_constant,
};
Object co_SQLite3Stmt(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3Stmt)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Stmt
Variant c_SQLite3Stmt::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Stmt
Variant c_SQLite3Stmt::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Stmt
Variant &c_SQLite3Stmt::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Stmt
void c_SQLite3Stmt::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Stmt
void c_SQLite3Stmt::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Stmt
Variant c_SQLite3Stmt::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Stmt
IMPLEMENT_CLASS(SQLite3Stmt)
c_SQLite3Stmt *c_SQLite3Stmt::create(Object a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SQLite3Stmt::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_SQLite3Stmt::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_SQLite3Stmt::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_SQLite3Stmt::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3Stmt::cloneImpl() {
  c_SQLite3Stmt *obj = NEW(c_SQLite3Stmt)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3Stmt::cloneSet(c_SQLite3Stmt *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Stmt
Variant c_SQLite3Stmt::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x15a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 0xf7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindparam(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindparam(arg0, arg1, arg2));
        }
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 0xfd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindparam(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindparam(arg0, arg1, arg2));
        }
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Stmt
Variant c_SQLite3Stmt::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x15a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 0xf7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 0xfd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SQLite3Stmt
Variant c_SQLite3Stmt::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SQLite3Stmt
Variant c_SQLite3Stmt::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 0x15a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_paramcount());
      }
      break;
    case 0xf7:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_execute());
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_clear());
      }
      break;
    case 0xfd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss01e93357, "paramcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3Stmt::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SQLite3Stmt = {
  c_SQLite3Stmt::os_getInit,
  c_SQLite3Stmt::os_get,
  c_SQLite3Stmt::os_lval,
  c_SQLite3Stmt::os_invoke,
  c_SQLite3Stmt::os_constant,
};
Object co_DOMNodeList(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNodeList)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeList
Variant c_DOMNodeList::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeList
Variant c_DOMNodeList::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeList
Variant &c_DOMNodeList::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeList
void c_DOMNodeList::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeList
void c_DOMNodeList::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeList
Variant * c_DOMNodeList::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeList
Variant * c_DOMNodeList::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeList
Variant * c_DOMNodeList::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeList
Variant c_DOMNodeList::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeList
IMPLEMENT_CLASS(DOMNodeList)
c_DOMNodeList *c_DOMNodeList::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNodeList::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNodeList::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNodeList::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMNodeList::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNodeList::cloneImpl() {
  c_DOMNodeList *obj = NEW(c_DOMNodeList)();
  cloneSet(obj);
  return obj;
}
void c_DOMNodeList::cloneSet(c_DOMNodeList *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeList
Variant c_DOMNodeList::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeList
Variant c_DOMNodeList::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNodeList
Variant c_DOMNodeList::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNodeList
Variant c_DOMNodeList::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNodeList::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMNodeList = {
  c_DOMNodeList::os_getInit,
  c_DOMNodeList::os_get,
  c_DOMNodeList::os_lval,
  c_DOMNodeList::os_invoke,
  c_DOMNodeList::os_constant,
};
Object co_Normalizer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Normalizer)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Normalizer
Variant c_Normalizer::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Normalizer
Variant c_Normalizer::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Normalizer
Variant &c_Normalizer::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Normalizer
void c_Normalizer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Normalizer
void c_Normalizer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Normalizer
Variant * c_Normalizer::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Normalizer
Variant * c_Normalizer::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Normalizer
Variant * c_Normalizer::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Normalizer
Variant c_Normalizer::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 1:
      HASH_RETURN(0x2C9DA0E379A28381LL, q_Normalizer_FORM_KD, "FORM_KD");
      HASH_RETURN(0x1C369D0E14B76C41LL, q_Normalizer_FORM_KC, "FORM_KC");
      HASH_RETURN(0x3E3AA0A97BD09921LL, q_Normalizer_NFKC, "NFKC");
      break;
    case 2:
      HASH_RETURN(0x07512AA38ADD1AE2LL, q_Normalizer_FORM_D, "FORM_D");
      break;
    case 6:
      HASH_RETURN(0x51422F059BEFCD86LL, q_Normalizer_NFC, "NFC");
      break;
    case 15:
      HASH_RETURN(0x58B301790FA834EFLL, q_Normalizer_NFD, "NFD");
      HASH_RETURN(0x3CF19F2D23C185CFLL, q_Normalizer_NFKD, "NFKD");
      break;
    case 19:
      HASH_RETURN(0x2EFDCA1922BFB273LL, q_Normalizer_NONE, "NONE");
      break;
    case 31:
      HASH_RETURN(0x3BE3511FDA9A9E7FLL, q_Normalizer_FORM_C, "FORM_C");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Normalizer
IMPLEMENT_CLASS(Normalizer)
c_Normalizer *c_Normalizer::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Normalizer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Normalizer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Normalizer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_Normalizer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Normalizer::cloneImpl() {
  c_Normalizer *obj = NEW(c_Normalizer)();
  cloneSet(obj);
  return obj;
}
void c_Normalizer::cloneSet(c_Normalizer *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Normalizer
Variant c_Normalizer::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(o_getClassName(), arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_normalize(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(o_getClassName(), arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_isnormalized(o_getClassName(), arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(o_getClassName(), arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_normalize(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(o_getClassName(), arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_isnormalized(o_getClassName(), arg0, arg1));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Normalizer
Variant c_Normalizer::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Normalizer
Variant c_Normalizer::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(c, arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_normalize(c, arg0, arg1));
        }
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(c, arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_isnormalized(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_isnormalized(c, arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_isnormalized(c, arg0, arg1));
        }
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (ti_normalize(c, arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (ti_normalize(c, arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Normalizer
Variant c_Normalizer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Normalizer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    case 0xe4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss5f66ed1d, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_Normalizer = {
  c_Normalizer::os_getInit,
  c_Normalizer::os_get,
  c_Normalizer::os_lval,
  c_Normalizer::os_invoke,
  c_Normalizer::os_constant,
};
Object co_DOMCharacterData(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMCharacterData)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCharacterData
Variant c_DOMCharacterData::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCharacterData
Variant c_DOMCharacterData::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCharacterData
Variant &c_DOMCharacterData::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCharacterData
void c_DOMCharacterData::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCharacterData
void c_DOMCharacterData::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMCharacterData
Variant * c_DOMCharacterData::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCharacterData
Variant * c_DOMCharacterData::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCharacterData
Variant * c_DOMCharacterData::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCharacterData
Variant c_DOMCharacterData::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCharacterData
IMPLEMENT_CLASS(DOMCharacterData)
c_DOMCharacterData *c_DOMCharacterData::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMCharacterData::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMCharacterData::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMCharacterData::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMCharacterData::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMCharacterData::cloneImpl() {
  c_DOMCharacterData *obj = NEW(c_DOMCharacterData)();
  cloneSet(obj);
  return obj;
}
void c_DOMCharacterData::cloneSet(c_DOMCharacterData *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCharacterData
Variant c_DOMCharacterData::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCharacterData
Variant c_DOMCharacterData::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMCharacterData
Variant c_DOMCharacterData::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMCharacterData
Variant c_DOMCharacterData::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMCharacterData::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMCharacterData = {
  c_DOMCharacterData::os_getInit,
  c_DOMCharacterData::os_get,
  c_DOMCharacterData::os_lval,
  c_DOMCharacterData::os_invoke,
  c_DOMCharacterData::os_constant,
};
Object co_DOMEntityReference(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMEntityReference)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntityReference
Variant c_DOMEntityReference::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntityReference
Variant c_DOMEntityReference::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntityReference
Variant &c_DOMEntityReference::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntityReference
void c_DOMEntityReference::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntityReference
void c_DOMEntityReference::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMEntityReference
Variant * c_DOMEntityReference::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntityReference
Variant * c_DOMEntityReference::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntityReference
Variant * c_DOMEntityReference::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntityReference
Variant c_DOMEntityReference::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntityReference
IMPLEMENT_CLASS(DOMEntityReference)
c_DOMEntityReference *c_DOMEntityReference::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMEntityReference::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMEntityReference::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMEntityReference::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_DOMEntityReference::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMEntityReference::cloneImpl() {
  c_DOMEntityReference *obj = NEW(c_DOMEntityReference)();
  cloneSet(obj);
  return obj;
}
void c_DOMEntityReference::cloneSet(c_DOMEntityReference *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntityReference
Variant c_DOMEntityReference::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntityReference
Variant c_DOMEntityReference::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMEntityReference
Variant c_DOMEntityReference::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMEntityReference
Variant c_DOMEntityReference::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMEntityReference::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMEntityReference = {
  c_DOMEntityReference::os_getInit,
  c_DOMEntityReference::os_get,
  c_DOMEntityReference::os_lval,
  c_DOMEntityReference::os_invoke,
  c_DOMEntityReference::os_constant,
};
Object co_SimpleXMLElementIterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SimpleXMLElementIterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElementIterator
Variant &c_SimpleXMLElementIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElementIterator
void c_SimpleXMLElementIterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElementIterator
void c_SimpleXMLElementIterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElementIterator
IMPLEMENT_CLASS(SimpleXMLElementIterator)
c_SimpleXMLElementIterator *c_SimpleXMLElementIterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SimpleXMLElementIterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SimpleXMLElementIterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SimpleXMLElementIterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_SimpleXMLElementIterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SimpleXMLElementIterator::cloneImpl() {
  c_SimpleXMLElementIterator *obj = NEW(c_SimpleXMLElementIterator)();
  cloneSet(obj);
  return obj;
}
void c_SimpleXMLElementIterator::cloneSet(c_SimpleXMLElementIterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SimpleXMLElementIterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SimpleXMLElementIterator = {
  c_SimpleXMLElementIterator::os_getInit,
  c_SimpleXMLElementIterator::os_get,
  c_SimpleXMLElementIterator::os_lval,
  c_SimpleXMLElementIterator::os_invoke,
  c_SimpleXMLElementIterator::os_constant,
};
Object co_DateTimeZone(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DateTimeZone)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTimeZone
Variant c_DateTimeZone::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTimeZone
Variant c_DateTimeZone::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTimeZone
Variant &c_DateTimeZone::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTimeZone
void c_DateTimeZone::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTimeZone
void c_DateTimeZone::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DateTimeZone
Variant * c_DateTimeZone::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTimeZone
Variant * c_DateTimeZone::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTimeZone
Variant * c_DateTimeZone::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTimeZone
Variant c_DateTimeZone::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x5213CDB166554802LL, q_DateTimeZone_AFRICA, "AFRICA");
      break;
    case 10:
      HASH_RETURN(0x1F67AB7044E3CA2ALL, q_DateTimeZone_EUROPE, "EUROPE");
      break;
    case 12:
      HASH_RETURN(0x76F99914EEA96ECCLL, q_DateTimeZone_ARCTIC, "ARCTIC");
      break;
    case 13:
      HASH_RETURN(0x338F44565E0C038DLL, q_DateTimeZone_AMERICA, "AMERICA");
      break;
    case 15:
      HASH_RETURN(0x22CAA6990573E5EFLL, q_DateTimeZone_PACIFIC, "PACIFIC");
      break;
    case 19:
      HASH_RETURN(0x7879534F49C301F3LL, q_DateTimeZone_PER_COUNTRY, "PER_COUNTRY");
      break;
    case 20:
      HASH_RETURN(0x6FB9D84AA364CA14LL, q_DateTimeZone_UTC, "UTC");
      break;
    case 23:
      HASH_RETURN(0x5A01AACAA61E0FF7LL, q_DateTimeZone_ASIA, "ASIA");
      HASH_RETURN(0x3E74CAEDAD25E137LL, q_DateTimeZone_INDIAN, "INDIAN");
      break;
    case 24:
      HASH_RETURN(0x0C4F30470A9EEBF8LL, q_DateTimeZone_ALL, "ALL");
      break;
    case 25:
      HASH_RETURN(0x2BEDCED53E63BC79LL, q_DateTimeZone_ATLANTIC, "ATLANTIC");
      break;
    case 30:
      HASH_RETURN(0x3C168ED86522549ELL, q_DateTimeZone_AUSTRALIA, "AUSTRALIA");
      HASH_RETURN(0x690180C3BA732B5ELL, q_DateTimeZone_ALL_WITH_BC, "ALL_WITH_BC");
      break;
    case 31:
      HASH_RETURN(0x6B29DE65F46EAFDFLL, q_DateTimeZone_ANTARCTICA, "ANTARCTICA");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTimeZone
IMPLEMENT_CLASS(DateTimeZone)
c_DateTimeZone *c_DateTimeZone::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DateTimeZone::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DateTimeZone::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DateTimeZone::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_DateTimeZone::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DateTimeZone::cloneImpl() {
  c_DateTimeZone *obj = NEW(c_DateTimeZone)();
  cloneSet(obj);
  return obj;
}
void c_DateTimeZone::cloneSet(c_DateTimeZone *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DateTimeZone
Variant c_DateTimeZone::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x88:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getoffset(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "getTransitions")) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getoffset(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DateTimeZone
Variant c_DateTimeZone::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x88:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "getTransitions")) {
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DateTimeZone
Variant c_DateTimeZone::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(c));
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(c));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DateTimeZone
Variant c_DateTimeZone::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x88:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettransitions());
      }
      break;
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(o_getClassName()));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss7b316c0c, "getTransitions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DateTimeZone::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x89:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(c));
      }
      break;
    case 0x8a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(c));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss6c3ed068, "listAbbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss456c2f9d, "listIdentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DateTimeZone = {
  c_DateTimeZone::os_getInit,
  c_DateTimeZone::os_get,
  c_DateTimeZone::os_lval,
  c_DateTimeZone::os_invoke,
  c_DateTimeZone::os_constant,
};
Object co_DOMNodeIterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNodeIterator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeIterator
Variant c_DOMNodeIterator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeIterator
Variant c_DOMNodeIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeIterator
Variant &c_DOMNodeIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeIterator
void c_DOMNodeIterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeIterator
void c_DOMNodeIterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeIterator
Variant c_DOMNodeIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeIterator
IMPLEMENT_CLASS(DOMNodeIterator)
c_DOMNodeIterator *c_DOMNodeIterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNodeIterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNodeIterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNodeIterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMNodeIterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNodeIterator::cloneImpl() {
  c_DOMNodeIterator *obj = NEW(c_DOMNodeIterator)();
  cloneSet(obj);
  return obj;
}
void c_DOMNodeIterator::cloneSet(c_DOMNodeIterator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeIterator
Variant c_DOMNodeIterator::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeIterator
Variant c_DOMNodeIterator::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNodeIterator
Variant c_DOMNodeIterator::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNodeIterator
Variant c_DOMNodeIterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNodeIterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMNodeIterator = {
  c_DOMNodeIterator::os_getInit,
  c_DOMNodeIterator::os_get,
  c_DOMNodeIterator::os_lval,
  c_DOMNodeIterator::os_invoke,
  c_DOMNodeIterator::os_constant,
};
Object co_DOMImplementation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMImplementation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMImplementation
Variant c_DOMImplementation::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMImplementation
Variant c_DOMImplementation::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMImplementation
Variant &c_DOMImplementation::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMImplementation
void c_DOMImplementation::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMImplementation
void c_DOMImplementation::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMImplementation
Variant * c_DOMImplementation::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMImplementation
Variant * c_DOMImplementation::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMImplementation
Variant * c_DOMImplementation::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMImplementation
Variant c_DOMImplementation::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMImplementation
IMPLEMENT_CLASS(DOMImplementation)
c_DOMImplementation *c_DOMImplementation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMImplementation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMImplementation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMImplementation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMImplementation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMImplementation::cloneImpl() {
  c_DOMImplementation *obj = NEW(c_DOMImplementation)();
  cloneSet(obj);
  return obj;
}
void c_DOMImplementation::cloneSet(c_DOMImplementation *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMImplementation
Variant c_DOMImplementation::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x75:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocument(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_createdocument(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 0x76:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocumenttype());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocumenttype(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_createdocumenttype(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createdocumenttype(arg0, arg1, arg2));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x77:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_hasfeature(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createDocumentType")) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocumenttype());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocumenttype(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_createdocumenttype(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createdocumenttype(arg0, arg1, arg2));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasFeature")) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_hasfeature(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createDocument")) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_createdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_createdocument(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_createdocument(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMImplementation
Variant c_DOMImplementation::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x75:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        if (count == 1) return (t_createdocument(a0));
        if (count == 2) return (t_createdocument(a0, a1));
        return (t_createdocument(a0, a1, a2));
      }
      break;
    case 0x76:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        if (count == 1) return (t_createdocumenttype(a0));
        if (count == 2) return (t_createdocumenttype(a0, a1));
        return (t_createdocumenttype(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x77:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createDocumentType")) {
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        if (count == 1) return (t_createdocumenttype(a0));
        if (count == 2) return (t_createdocumenttype(a0, a1));
        return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasFeature")) {
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createDocument")) {
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        if (count == 1) return (t_createdocument(a0));
        if (count == 2) return (t_createdocument(a0, a1));
        return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMImplementation
Variant c_DOMImplementation::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMImplementation
Variant c_DOMImplementation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x75:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 0x76:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x77:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasfeature(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss6f3dbac3, "createDocumentType")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss3cf9595d, "hasFeature")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss4c82e4b2, "createDocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMImplementation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMImplementation = {
  c_DOMImplementation::os_getInit,
  c_DOMImplementation::os_get,
  c_DOMImplementation::os_lval,
  c_DOMImplementation::os_invoke,
  c_DOMImplementation::os_constant,
};
Object co_SoapHeader(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapHeader)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapHeader
Variant c_SoapHeader::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapHeader
Variant c_SoapHeader::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapHeader
Variant &c_SoapHeader::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapHeader
void c_SoapHeader::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapHeader
void c_SoapHeader::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapHeader
Variant * c_SoapHeader::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapHeader
Variant * c_SoapHeader::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapHeader
Variant * c_SoapHeader::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapHeader
Variant c_SoapHeader::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapHeader
IMPLEMENT_CLASS(SoapHeader)
c_SoapHeader *c_SoapHeader::create(String a0, String a1, Variant a2, bool a3, Variant a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_SoapHeader::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_SoapHeader::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_SoapHeader::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_SoapHeader::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapHeader::cloneImpl() {
  c_SoapHeader *obj = NEW(c_SoapHeader)();
  cloneSet(obj);
  return obj;
}
void c_SoapHeader::cloneSet(c_SoapHeader *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapHeader
Variant c_SoapHeader::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapHeader
Variant c_SoapHeader::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapHeader
Variant c_SoapHeader::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapHeader
Variant c_SoapHeader::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapHeader::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SoapHeader = {
  c_SoapHeader::os_getInit,
  c_SoapHeader::os_get,
  c_SoapHeader::os_lval,
  c_SoapHeader::os_invoke,
  c_SoapHeader::os_constant,
};
Object co_DOMNotation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNotation)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNotation
Variant c_DOMNotation::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNotation
Variant c_DOMNotation::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNotation
Variant &c_DOMNotation::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNotation
void c_DOMNotation::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNotation
void c_DOMNotation::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNotation
Variant * c_DOMNotation::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNotation
Variant * c_DOMNotation::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNotation
Variant * c_DOMNotation::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNotation
Variant c_DOMNotation::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNotation
IMPLEMENT_CLASS(DOMNotation)
c_DOMNotation *c_DOMNotation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNotation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNotation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNotation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMNotation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNotation::cloneImpl() {
  c_DOMNotation *obj = NEW(c_DOMNotation)();
  cloneSet(obj);
  return obj;
}
void c_DOMNotation::cloneSet(c_DOMNotation *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNotation
Variant c_DOMNotation::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNotation
Variant c_DOMNotation::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNotation
Variant c_DOMNotation::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNotation
Variant c_DOMNotation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNotation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMNotation = {
  c_DOMNotation::os_getInit,
  c_DOMNotation::os_get,
  c_DOMNotation::os_lval,
  c_DOMNotation::os_invoke,
  c_DOMNotation::os_constant,
};
Object co_DebuggerProxy(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DebuggerProxy)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerProxy
Variant c_DebuggerProxy::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerProxy
Variant c_DebuggerProxy::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerProxy
Variant &c_DebuggerProxy::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerProxy
void c_DebuggerProxy::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerProxy
void c_DebuggerProxy::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DebuggerProxy
Variant * c_DebuggerProxy::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerProxy
Variant * c_DebuggerProxy::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerProxy
Variant * c_DebuggerProxy::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerProxy
Variant c_DebuggerProxy::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerProxy
IMPLEMENT_CLASS(DebuggerProxy)
c_DebuggerProxy *c_DebuggerProxy::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DebuggerProxy::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DebuggerProxy::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DebuggerProxy::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DebuggerProxy::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DebuggerProxy::cloneImpl() {
  c_DebuggerProxy *obj = NEW(c_DebuggerProxy)();
  cloneSet(obj);
  return obj;
}
void c_DebuggerProxy::cloneSet(c_DebuggerProxy *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerProxy
Variant c_DebuggerProxy::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xaa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_send(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerProxy
Variant c_DebuggerProxy::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xaa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DebuggerProxy
Variant c_DebuggerProxy::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DebuggerProxy
Variant c_DebuggerProxy::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xaa:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islocal());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0xa6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss7fd1c778, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss529d270c, "isLocal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DebuggerProxy::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DebuggerProxy = {
  c_DebuggerProxy::os_getInit,
  c_DebuggerProxy::os_get,
  c_DebuggerProxy::os_lval,
  c_DebuggerProxy::os_invoke,
  c_DebuggerProxy::os_constant,
};
Object co_DOMComment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMComment)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMComment
Variant c_DOMComment::os_getInit(CStrRef s) {
  return c_DOMCharacterData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMComment
Variant c_DOMComment::os_get(CStrRef s) {
  return c_DOMCharacterData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMComment
Variant &c_DOMComment::os_lval(CStrRef s) {
  return c_DOMCharacterData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMComment
void c_DOMComment::o_getArray(Array &props) const {
  c_DOMCharacterData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMComment
void c_DOMComment::o_setArray(CArrRef props) {
  c_DOMCharacterData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMComment
Variant * c_DOMComment::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMComment
Variant * c_DOMComment::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMCharacterData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMComment
Variant * c_DOMComment::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMComment
Variant c_DOMComment::os_constant(const char *s) {
  return c_DOMCharacterData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMComment
IMPLEMENT_CLASS(DOMComment)
c_DOMComment *c_DOMComment::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMComment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_DOMComment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_DOMComment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
void c_DOMComment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMComment::cloneImpl() {
  c_DOMComment *obj = NEW(c_DOMComment)();
  cloneSet(obj);
  return obj;
}
void c_DOMComment::cloneSet(c_DOMComment *clone) {
  c_DOMCharacterData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMComment
Variant c_DOMComment::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_deletedata(arg0, arg1));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appenddata(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_substringdata(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacedata(arg0, arg1, arg2));
        }
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertdata(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMComment
Variant c_DOMComment::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMComment
Variant c_DOMComment::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMComment
Variant c_DOMComment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x41:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x42:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x43:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x44:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 0x45:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss6714d118, "deleteData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_deletedata(a0, a1));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss1fd2d92d, "appendData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appenddata(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss3deb668e, "substringData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_substringdata(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss5e0c2b4c, "replaceData")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss794310c3, "insertData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_insertdata(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMCharacterData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMComment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMCharacterData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMComment = {
  c_DOMComment::os_getInit,
  c_DOMComment::os_get,
  c_DOMComment::os_lval,
  c_DOMComment::os_invoke,
  c_DOMComment::os_constant,
};
Object co_SQLite3(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3
Variant c_SQLite3::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3
Variant c_SQLite3::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3
Variant &c_SQLite3::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3
void c_SQLite3::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3
void c_SQLite3::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3
Variant * c_SQLite3::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3
Variant * c_SQLite3::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3
Variant * c_SQLite3::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3
Variant c_SQLite3::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3
IMPLEMENT_CLASS(SQLite3)
c_SQLite3 *c_SQLite3::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SQLite3::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SQLite3::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SQLite3::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_SQLite3::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3::cloneImpl() {
  c_SQLite3 *obj = NEW(c_SQLite3)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3::cloneSet(c_SQLite3 *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3
Variant c_SQLite3::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 0x148:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 0x149:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadextension(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x14a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_createfunction(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createfunction(arg0, arg1, arg2));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x14b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x14d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_escapestring(arg0));
        }
      }
      break;
    case 0x14c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      break;
    case 0x14e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 3) return (t_createaggregate(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createaggregate(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x14f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_open(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_open(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_open(arg0, arg1, arg2), null);
        }
      }
      break;
    case 0x150:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 0x151:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 3) return (t_openblob(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_openblob(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x152:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_prepare(arg0));
        }
      }
      break;
    case 0x153:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_querysingle(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_querysingle(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 3) return (t_openblob(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_openblob(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 3) return (t_createaggregate(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createaggregate(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_open(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_open(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_open(arg0, arg1, arg2), null);
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_createfunction(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createfunction(arg0, arg1, arg2));
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadextension(arg0));
        }
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_querysingle(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_querysingle(arg0, arg1));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_prepare(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_escapestring(arg0));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3
Variant c_SQLite3::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 0x148:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 0x149:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x14a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(a0, a1));
        return (t_createfunction(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x14b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0x14d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(a0));
      }
      break;
    case 0x14c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      break;
    case 0x14e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 0x14f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(a0), null);
        if (count == 2) return (t_open(a0, a1), null);
        return (t_open(a0, a1, a2), null);
      }
      break;
    case 0x150:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 0x151:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(a0, a1, a2));
        return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 0x152:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(a0));
      }
      break;
    case 0x153:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(a0));
        return (t_querysingle(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(a0, a1, a2));
        return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(a0), null);
        if (count == 2) return (t_open(a0, a1), null);
        return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(a0, a1));
        return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(a0));
        return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SQLite3
Variant c_SQLite3::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SQLite3
Variant c_SQLite3::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 0x148:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_version());
      }
      break;
    case 0x149:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadextension(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x14a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x14b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lastinsertrowid());
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 0x14d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_escapestring(a0));
      }
      break;
    case 0x14c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrormsg());
      }
      break;
    case 0x14e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 0x14f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 0x150:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_changes());
      }
      break;
    case 0x151:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 0x152:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrorcode());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_prepare(a0));
      }
      break;
    case 0x153:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss094466c2, "lasterrormsg")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss742bf3c2, "openblob")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss6bd68143, "createaggregate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss0c124bc4, "open")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss3d0354f6, "lasterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss291057cd, "createfunction")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss764fd7e7, "changes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss0a487664, "loadextension")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss4f02341a, "lastinsertrowid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss009c2796, "version")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss4132abee, "querysingle")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss44dae9cb, "escapestring")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SQLite3 = {
  c_SQLite3::os_getInit,
  c_SQLite3::os_get,
  c_SQLite3::os_lval,
  c_SQLite3::os_invoke,
  c_SQLite3::os_constant,
};
Object co_DOMAttr(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMAttr)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMAttr
Variant c_DOMAttr::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMAttr
Variant c_DOMAttr::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMAttr
Variant &c_DOMAttr::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMAttr
void c_DOMAttr::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMAttr
void c_DOMAttr::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMAttr
Variant * c_DOMAttr::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMAttr
Variant * c_DOMAttr::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMAttr
Variant * c_DOMAttr::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMAttr
Variant c_DOMAttr::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMAttr
IMPLEMENT_CLASS(DOMAttr)
c_DOMAttr *c_DOMAttr::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMAttr::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMAttr::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMAttr::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_DOMAttr::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMAttr::cloneImpl() {
  c_DOMAttr *obj = NEW(c_DOMAttr)();
  cloneSet(obj);
  return obj;
}
void c_DOMAttr::cloneSet(c_DOMAttr *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMAttr
Variant c_DOMAttr::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x30:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isId")) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMAttr
Variant c_DOMAttr::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x30:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isId")) {
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMAttr
Variant c_DOMAttr::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMAttr
Variant c_DOMAttr::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x30:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isid());
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss15d17f24, "isId")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isid());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMAttr::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMAttr = {
  c_DOMAttr::os_getInit,
  c_DOMAttr::os_get,
  c_DOMAttr::os_lval,
  c_DOMAttr::os_invoke,
  c_DOMAttr::os_constant,
};
Object co_SoapVar(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapVar)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapVar
Variant c_SoapVar::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapVar
Variant c_SoapVar::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapVar
Variant &c_SoapVar::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapVar
void c_SoapVar::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapVar
void c_SoapVar::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapVar
Variant * c_SoapVar::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapVar
Variant * c_SoapVar::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapVar
Variant * c_SoapVar::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapVar
Variant c_SoapVar::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapVar
IMPLEMENT_CLASS(SoapVar)
c_SoapVar *c_SoapVar::create(Variant a0, Variant a1, String a2, String a3, String a4, String a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_SoapVar::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_SoapVar::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_SoapVar::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_SoapVar::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapVar::cloneImpl() {
  c_SoapVar *obj = NEW(c_SoapVar)();
  cloneSet(obj);
  return obj;
}
void c_SoapVar::cloneSet(c_SoapVar *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapVar
Variant c_SoapVar::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapVar
Variant c_SoapVar::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapVar
Variant c_SoapVar::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapVar
Variant c_SoapVar::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapVar::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SoapVar = {
  c_SoapVar::os_getInit,
  c_SoapVar::os_get,
  c_SoapVar::os_lval,
  c_SoapVar::os_invoke,
  c_SoapVar::os_constant,
};
Object co_DOMNamedNodeMap(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNamedNodeMap)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNamedNodeMap
Variant &c_DOMNamedNodeMap::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNamedNodeMap
void c_DOMNamedNodeMap::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNamedNodeMap
void c_DOMNamedNodeMap::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNamedNodeMap
IMPLEMENT_CLASS(DOMNamedNodeMap)
c_DOMNamedNodeMap *c_DOMNamedNodeMap::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNamedNodeMap::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNamedNodeMap::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNamedNodeMap::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMNamedNodeMap::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNamedNodeMap::cloneImpl() {
  c_DOMNamedNodeMap *obj = NEW(c_DOMNamedNodeMap)();
  cloneSet(obj);
  return obj;
}
void c_DOMNamedNodeMap::cloneSet(c_DOMNamedNodeMap *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 0x78:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnameditem(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x7b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getnameditemns(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_item(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getNamedItem")) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnameditem(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getNamedItemNS")) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getnameditemns(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 0x78:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x7b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getNamedItem")) {
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getNamedItemNS")) {
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x79:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 0x78:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditem(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x7b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditemns(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss7cf6fd3a, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss7f9adc3a, "getNamedItem")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss00b0f0e5, "getNamedItemNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNamedNodeMap::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMNamedNodeMap = {
  c_DOMNamedNodeMap::os_getInit,
  c_DOMNamedNodeMap::os_get,
  c_DOMNamedNodeMap::os_lval,
  c_DOMNamedNodeMap::os_invoke,
  c_DOMNamedNodeMap::os_constant,
};
Object co_SQLite3Result(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3Result)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Result
Variant c_SQLite3Result::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Result
Variant c_SQLite3Result::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Result
Variant &c_SQLite3Result::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Result
void c_SQLite3Result::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Result
void c_SQLite3Result::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Result
Variant * c_SQLite3Result::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Result
Variant * c_SQLite3Result::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Result
Variant * c_SQLite3Result::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Result
Variant c_SQLite3Result::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Result
IMPLEMENT_CLASS(SQLite3Result)
c_SQLite3Result *c_SQLite3Result::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SQLite3Result::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SQLite3Result::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SQLite3Result::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_SQLite3Result::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3Result::cloneImpl() {
  c_SQLite3Result *obj = NEW(c_SQLite3Result)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3Result::cloneSet(c_SQLite3Result *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Result
Variant c_SQLite3Result::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x154:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columnname(arg0));
        }
      }
      break;
    case 0x155:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columntype(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x156:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 0x157:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetcharray());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetcharray(arg0));
        }
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0x159:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columnname(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetcharray());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetcharray(arg0));
        }
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_columntype(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Result
Variant c_SQLite3Result::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x154:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(a0));
      }
      break;
    case 0x155:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x156:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 0x157:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        return (t_fetcharray(a0));
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 0x159:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SQLite3Result
Variant c_SQLite3Result::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SQLite3Result
Variant c_SQLite3Result::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x154:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columnname(a0));
      }
      break;
    case 0x155:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columntype(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x156:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_numcolumns());
      }
      break;
    case 0x157:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 0x158:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 0x159:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_finalize());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss22a924e0, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss22784996, "numcolumns")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss1181b808, "columnname")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss10e3c595, "fetcharray")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss1b6c6a84, "finalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss009d8c6d, "columntype")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3Result::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SQLite3Result = {
  c_SQLite3Result::os_getInit,
  c_SQLite3Result::os_get,
  c_SQLite3Result::os_lval,
  c_SQLite3Result::os_invoke,
  c_SQLite3Result::os_constant,
};
Object co_SimpleXMLElement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SimpleXMLElement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElement
Variant c_SimpleXMLElement::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElement
Variant c_SimpleXMLElement::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElement
Variant &c_SimpleXMLElement::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElement
void c_SimpleXMLElement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElement
void c_SimpleXMLElement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElement
Variant c_SimpleXMLElement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElement
IMPLEMENT_CLASS(SimpleXMLElement)
c_SimpleXMLElement *c_SimpleXMLElement::create(String a0, int64 a1, bool a2, String a3, bool a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_SimpleXMLElement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_SimpleXMLElement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_SimpleXMLElement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
void c_SimpleXMLElement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SimpleXMLElement::cloneImpl() {
  c_SimpleXMLElement *obj = NEW(c_SimpleXMLElement)();
  cloneSet(obj);
  return obj;
}
void c_SimpleXMLElement::cloneSet(c_SimpleXMLElement *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElement
Variant c_SimpleXMLElement::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x15d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addattribute(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addattribute(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addattribute(arg0, arg1, arg2), null);
        }
      }
      break;
    case 0xf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xpath(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 0xa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetexists(arg0));
        }
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_registerxpathnamespace(arg0, arg1));
        }
      }
      break;
    case 0xb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetget(arg0));
        }
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnamespaces(arg0));
        }
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___unset(arg0));
        }
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_asxml());
          CVarRef arg0((ad->getValue(pos)));
          return (t_asxml(arg0));
        }
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getdocnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getdocnamespaces(arg0));
        }
      }
      break;
    case 0xc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetunset(arg0), null);
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_children());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_children(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_children(arg0, arg1));
        }
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addchild(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addchild(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addchild(arg0, arg1, arg2));
        }
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___isset(arg0));
        }
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_attributes());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_attributes(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_attributes(arg0, arg1));
        }
      }
      break;
    case 0xd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_offsetset(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700, "offsetExists")) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetexists(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addChild")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addchild(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addchild(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addchild(arg0, arg1, arg2));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addAttribute")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addattribute(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addattribute(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addattribute(arg0, arg1, arg2), null);
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68, "offsetGet")) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetget(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_xpath(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___unset(arg0));
        }
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_attributes());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_attributes(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_attributes(arg0, arg1));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getNamespaces")) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getnamespaces(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asXML")) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_asxml());
          CVarRef arg0((ad->getValue(pos)));
          return (t_asxml(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_children());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_children(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_children(arg0, arg1));
        }
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___isset(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getDocNamespaces")) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getdocnamespaces());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getdocnamespaces(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8, "offsetSet")) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_offsetset(arg0, arg1), null);
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546, "offsetUnset")) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_offsetunset(arg0), null);
        }
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerXPathNamespace")) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_registerxpathnamespace(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElement
Variant c_SimpleXMLElement::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x15d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(a0), null);
        if (count == 2) return (t_addattribute(a0, a1), null);
        return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 0xf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0xa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(a0));
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    case 0xb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(a0));
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        return (t_getnamespaces(a0));
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(a0));
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        return (t_asxml(a0));
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        return (t_getdocnamespaces(a0));
      }
      break;
    case 0xc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(a0), null);
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        if (count == 1) return (t_children(a0));
        return (t_children(a0, a1));
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(a0));
        if (count == 2) return (t_addchild(a0, a1));
        return (t_addchild(a0, a1, a2));
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        return (t___isset(a0));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        if (count == 1) return (t_attributes(a0));
        return (t_attributes(a0, a1));
      }
      break;
    case 0xd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700, "offsetExists")) {
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addChild")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(a0));
        if (count == 2) return (t_addchild(a0, a1));
        return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addAttribute")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(a0), null);
        if (count == 2) return (t_addattribute(a0, a1), null);
        return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68, "offsetGet")) {
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(a0));
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        if (count == 1) return (t_attributes(a0));
        return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getNamespaces")) {
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        return (t_getnamespaces(a0));
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asXML")) {
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        if (count == 1) return (t_children(a0));
        return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getDocNamespaces")) {
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8, "offsetSet")) {
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546, "offsetUnset")) {
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerXPathNamespace")) {
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SimpleXMLElement
Variant c_SimpleXMLElement::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SimpleXMLElement
Variant c_SimpleXMLElement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x15d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 0xf:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_count());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xpath(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0xa:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetexists(a0));
      }
      break;
    case 0x7a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    case 0xb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetget(a0));
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___unset(a0));
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 0xc:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetunset(a0), null);
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___isset(a0));
      }
      break;
    case 0x8b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 0xd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetset(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss742fc700, "offsetExists")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss32a12503, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss65104d10, "count")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss7990386c, "addChild")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss19beead6, "addAttribute")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss0bbfbb68, "offsetGet")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss196a9a1b, "xpath")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_xpath(a0));
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss365df865, "__unset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss65cc0de3, "attributes")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss33e6769b, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss1c4bf05a, "getNamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss5fd864a6, "asXML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss61d17d53, "children")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss51de8712, "__isset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss0b2f34f1, "getDocNamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss5b7508c8, "offsetSet")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss19c96546, "offsetUnset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss7854f83d, "registerXPathNamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SimpleXMLElement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SimpleXMLElement = {
  c_SimpleXMLElement::os_getInit,
  c_SimpleXMLElement::os_get,
  c_SimpleXMLElement::os_lval,
  c_SimpleXMLElement::os_invoke,
  c_SimpleXMLElement::os_constant,
};
Object co_Memcache(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Memcache)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcache
Variant c_Memcache::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcache
Variant c_Memcache::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcache
Variant &c_Memcache::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcache
void c_Memcache::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcache
void c_Memcache::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Memcache
Variant * c_Memcache::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcache
Variant * c_Memcache::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcache
Variant * c_Memcache::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcache
Variant c_Memcache::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcache
IMPLEMENT_CLASS(Memcache)
c_Memcache *c_Memcache::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Memcache::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Memcache::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Memcache::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_Memcache::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Memcache::cloneImpl() {
  c_Memcache *obj = NEW(c_Memcache)();
  cloneSet(obj);
  return obj;
}
void c_Memcache::cloneSet(c_Memcache *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Memcache
Variant c_Memcache::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xd2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addserver(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addserver(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_addserver(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_addserver(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t_addserver(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 6) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5));
          CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 7) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
          CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 8) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
          CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
        }
      }
      break;
    case 0xd3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_set(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_set(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_set(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xd4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setserverparams(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_setserverparams(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_setserverparams(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_setserverparams(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t_setserverparams(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setserverparams(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xd5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_increment(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_increment(arg0, arg1));
        }
      }
      break;
    case 0xd6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_decrement(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_decrement(arg0, arg1));
        }
      }
      break;
    case 0xd7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getstats(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_getstats(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getstats(arg0, arg1, arg2));
        }
      }
      break;
    case 0xd8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getserverstatus(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getserverstatus(arg0, arg1));
        }
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setoptimeout(arg0));
        }
      }
      break;
    case 0xda:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setcompressthreshold(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setcompressthreshold(arg0, arg1));
        }
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_get(arg0));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          return (t_get(arg0, arg1));
        }
      }
      break;
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_add(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_add(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_add(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_pconnect(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_pconnect(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_pconnect(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_pconnect(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_delete(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_delete(arg0, arg1));
        }
      }
      break;
    case 0xe0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_connect(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_connect(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_connect(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_connect(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 0xe1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_replace(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_replace(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replace(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0xe3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getextendedstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getextendedstats(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_getextendedstats(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getextendedstats(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_replace(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_replace(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replace(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_increment(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_increment(arg0, arg1));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setoptimeout(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_add(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_add(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_add(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_getserverstatus(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getserverstatus(arg0, arg1));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setcompressthreshold(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setcompressthreshold(arg0, arg1));
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_delete(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_delete(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getstats(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_getstats(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getstats(arg0, arg1, arg2));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_decrement(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_decrement(arg0, arg1));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_set(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_set(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_set(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getextendedstats());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_getextendedstats(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_getextendedstats(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getextendedstats(arg0, arg1, arg2));
        }
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addserver(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addserver(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_addserver(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_addserver(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t_addserver(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 6) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5));
          CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 7) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
          CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 8) return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
          CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
        }
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_get(arg0));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          return (t_get(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_pconnect(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_pconnect(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_pconnect(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_pconnect(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setserverparams(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_setserverparams(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_setserverparams(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_setserverparams(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t_setserverparams(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setserverparams(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_connect(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_connect(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_connect(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_connect(arg0, arg1, arg2, arg3));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Memcache
Variant c_Memcache::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xd2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        if (count <= 1) return (t_addserver(a0));
        if (count == 2) return (t_addserver(a0, a1));
        if (count == 3) return (t_addserver(a0, a1, a2));
        if (count == 4) return (t_addserver(a0, a1, a2, a3));
        if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        return (t_addserver(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0xd3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        if (count <= 2) return (t_set(a0, a1));
        if (count == 3) return (t_set(a0, a1, a2));
        return (t_set(a0, a1, a2, a3));
      }
      break;
    case 0xd4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        if (count <= 1) return (t_setserverparams(a0));
        if (count == 2) return (t_setserverparams(a0, a1));
        if (count == 3) return (t_setserverparams(a0, a1, a2));
        if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xd5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        if (count <= 1) return (t_increment(a0));
        return (t_increment(a0, a1));
      }
      break;
    case 0xd6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        if (count <= 1) return (t_decrement(a0));
        return (t_decrement(a0, a1));
      }
      break;
    case 0xd7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        if (count <= 0) return (t_getstats());
        if (count == 1) return (t_getstats(a0));
        if (count == 2) return (t_getstats(a0, a1));
        return (t_getstats(a0, a1, a2));
      }
      break;
    case 0xd8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        if (count <= 1) return (t_getserverstatus(a0));
        return (t_getserverstatus(a0, a1));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        return (t_setoptimeout(a0));
      }
      break;
    case 0xda:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        if (count <= 1) return (t_setcompressthreshold(a0));
        return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        if (count <= 1) return (t_get(a0));
        return (t_get(a0, ref(a1)));
      }
      break;
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        if (count <= 2) return (t_add(a0, a1));
        if (count == 3) return (t_add(a0, a1, a2));
        return (t_add(a0, a1, a2, a3));
      }
      break;
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        if (count <= 1) return (t_pconnect(a0));
        if (count == 2) return (t_pconnect(a0, a1));
        if (count == 3) return (t_pconnect(a0, a1, a2));
        return (t_pconnect(a0, a1, a2, a3));
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        if (count <= 1) return (t_delete(a0));
        return (t_delete(a0, a1));
      }
      break;
    case 0xe0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        if (count <= 1) return (t_connect(a0));
        if (count == 2) return (t_connect(a0, a1));
        if (count == 3) return (t_connect(a0, a1, a2));
        return (t_connect(a0, a1, a2, a3));
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 0xe1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        if (count <= 2) return (t_replace(a0, a1));
        if (count == 3) return (t_replace(a0, a1, a2));
        return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 0xe3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        if (count <= 0) return (t_getextendedstats());
        if (count == 1) return (t_getextendedstats(a0));
        if (count == 2) return (t_getextendedstats(a0, a1));
        return (t_getextendedstats(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        if (count <= 2) return (t_replace(a0, a1));
        if (count == 3) return (t_replace(a0, a1, a2));
        return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        if (count <= 1) return (t_increment(a0));
        return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        return (t_setoptimeout(a0));
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        if (count <= 2) return (t_add(a0, a1));
        if (count == 3) return (t_add(a0, a1, a2));
        return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        if (count <= 1) return (t_getserverstatus(a0));
        return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        if (count <= 1) return (t_setcompressthreshold(a0));
        return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        if (count <= 1) return (t_delete(a0));
        return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        if (count <= 0) return (t_getstats());
        if (count == 1) return (t_getstats(a0));
        if (count == 2) return (t_getstats(a0, a1));
        return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        if (count <= 1) return (t_decrement(a0));
        return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        if (count <= 2) return (t_set(a0, a1));
        if (count == 3) return (t_set(a0, a1, a2));
        return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        if (count <= 0) return (t_getextendedstats());
        if (count == 1) return (t_getextendedstats(a0));
        if (count == 2) return (t_getextendedstats(a0, a1));
        return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        if (count <= 1) return (t_addserver(a0));
        if (count == 2) return (t_addserver(a0, a1));
        if (count == 3) return (t_addserver(a0, a1, a2));
        if (count == 4) return (t_addserver(a0, a1, a2, a3));
        if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        return (t_addserver(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        if (count <= 1) return (t_get(a0));
        return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        if (count <= 1) return (t_pconnect(a0));
        if (count == 2) return (t_pconnect(a0, a1));
        if (count == 3) return (t_pconnect(a0, a1, a2));
        return (t_pconnect(a0, a1, a2, a3));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        if (count <= 1) return (t_setserverparams(a0));
        if (count == 2) return (t_setserverparams(a0, a1));
        if (count == 3) return (t_setserverparams(a0, a1, a2));
        if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        if (count <= 1) return (t_connect(a0));
        if (count == 2) return (t_connect(a0, a1));
        if (count == 3) return (t_connect(a0, a1, a2));
        return (t_connect(a0, a1, a2, a3));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Memcache
Variant c_Memcache::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Memcache
Variant c_Memcache::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xd2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        Variant a6;
        Variant a7;
        Variant a8;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a6 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a7 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a8 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addserver(a0));
        else if (count == 2) return (t_addserver(a0, a1));
        else if (count == 3) return (t_addserver(a0, a1, a2));
        else if (count == 4) return (t_addserver(a0, a1, a2, a3));
        else if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        else if (count == 6) return (t_addserver(a0, a1, a2, a3, a4, a5));
        else if (count == 7) return (t_addserver(a0, a1, a2, a3, a4, a5, a6));
        else if (count == 8) return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7));
        else return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7, a8));
      }
      break;
    case 0xd3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_set(a0, a1));
        else if (count == 3) return (t_set(a0, a1, a2));
        else return (t_set(a0, a1, a2, a3));
      }
      break;
    case 0xd4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setserverparams(a0));
        else if (count == 2) return (t_setserverparams(a0, a1));
        else if (count == 3) return (t_setserverparams(a0, a1, a2));
        else if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        else if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        else return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0xd5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 0xd6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 0xd7:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getstats());
        else if (count == 1) return (t_getstats(a0));
        else if (count == 2) return (t_getstats(a0, a1));
        else return (t_getstats(a0, a1, a2));
      }
      break;
    case 0xd8:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getserverstatus(a0));
        else return (t_getserverstatus(a0, a1));
      }
      break;
    case 0xab:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 0xd9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setoptimeout(a0));
      }
      break;
    case 0xda:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setcompressthreshold(a0));
        else return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 0xdb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_get(a0));
        else return (t_get(a0, ref(a1)));
      }
      break;
    case 0xdd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_add(a0, a1));
        else if (count == 3) return (t_add(a0, a1, a2));
        else return (t_add(a0, a1, a2, a3));
      }
      break;
    case 0xdc:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_pconnect(a0));
        else if (count == 2) return (t_pconnect(a0, a1));
        else if (count == 3) return (t_pconnect(a0, a1, a2));
        else return (t_pconnect(a0, a1, a2, a3));
      }
      break;
    case 0xde:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 0xdf:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 0xe0:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_connect(a0));
        else if (count == 2) return (t_connect(a0, a1));
        else if (count == 3) return (t_connect(a0, a1, a2));
        else return (t_connect(a0, a1, a2, a3));
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 0xe1:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_replace(a0, a1));
        else if (count == 3) return (t_replace(a0, a1, a2));
        else return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 0xe3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getextendedstats());
        else if (count == 1) return (t_getextendedstats(a0));
        else if (count == 2) return (t_getextendedstats(a0, a1));
        else return (t_getextendedstats(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss4140acbf, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss280a6146, "replace")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_replace(a0, a1));
        else if (count == 3) return (t_replace(a0, a1, a2));
        else return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss2086ba39, "increment")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss1661de0b, "setoptimeout")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setoptimeout(a0));
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss0386ba75, "add")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_add(a0, a1));
        else if (count == 3) return (t_add(a0, a1, a2));
        else return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss44c893b1, "getserverstatus")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getserverstatus(a0));
        else return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss28a8ea92, "setcompressthreshold")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setcompressthreshold(a0));
        else return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss0590aa2d, "delete")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3be3d316_1, "getversion")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss7ce59bd9, "getstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getstats());
        else if (count == 1) return (t_getstats(a0));
        else if (count == 2) return (t_getstats(a0, a1));
        else return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2ba4c1da, "decrement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss3de7a9df, "set")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_set(a0, a1));
        else if (count == 3) return (t_set(a0, a1, a2));
        else return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss7940889b, "getextendedstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getextendedstats());
        else if (count == 1) return (t_getextendedstats(a0));
        else if (count == 2) return (t_getextendedstats(a0, a1));
        else return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss6237aae6, "addserver")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        Variant a6;
        Variant a7;
        Variant a8;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a6 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a7 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a8 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addserver(a0));
        else if (count == 2) return (t_addserver(a0, a1));
        else if (count == 3) return (t_addserver(a0, a1, a2));
        else if (count == 4) return (t_addserver(a0, a1, a2, a3));
        else if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        else if (count == 6) return (t_addserver(a0, a1, a2, a3, a4, a5));
        else if (count == 7) return (t_addserver(a0, a1, a2, a3, a4, a5, a6));
        else if (count == 8) return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7));
        else return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7, a8));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss296527d8, "get")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_get(a0));
        else return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss13cd7279, "pconnect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_pconnect(a0));
        else if (count == 2) return (t_pconnect(a0, a1));
        else if (count == 3) return (t_pconnect(a0, a1, a2));
        else return (t_pconnect(a0, a1, a2, a3));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss71006d43, "setserverparams")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_setserverparams(a0));
        else if (count == 2) return (t_setserverparams(a0, a1));
        else if (count == 3) return (t_setserverparams(a0, a1, a2));
        else if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        else if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        else return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss52e92802, "connect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_connect(a0));
        else if (count == 2) return (t_connect(a0, a1));
        else if (count == 3) return (t_connect(a0, a1, a2));
        else return (t_connect(a0, a1, a2, a3));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Memcache::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_Memcache = {
  c_Memcache::os_getInit,
  c_Memcache::os_get,
  c_Memcache::os_lval,
  c_Memcache::os_invoke,
  c_Memcache::os_constant,
};
Object co_DOMProcessingInstruction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMProcessingInstruction)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMProcessingInstruction
Variant &c_DOMProcessingInstruction::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMProcessingInstruction
void c_DOMProcessingInstruction::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMProcessingInstruction
void c_DOMProcessingInstruction::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMProcessingInstruction
IMPLEMENT_CLASS(DOMProcessingInstruction)
c_DOMProcessingInstruction *c_DOMProcessingInstruction::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMProcessingInstruction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMProcessingInstruction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMProcessingInstruction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_DOMProcessingInstruction::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMProcessingInstruction::cloneImpl() {
  c_DOMProcessingInstruction *obj = NEW(c_DOMProcessingInstruction)();
  cloneSet(obj);
  return obj;
}
void c_DOMProcessingInstruction::cloneSet(c_DOMProcessingInstruction *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMProcessingInstruction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMProcessingInstruction = {
  c_DOMProcessingInstruction::os_getInit,
  c_DOMProcessingInstruction::os_get,
  c_DOMProcessingInstruction::os_lval,
  c_DOMProcessingInstruction::os_invoke,
  c_DOMProcessingInstruction::os_constant,
};
Object co_PDOStatement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDOStatement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOStatement
Variant c_PDOStatement::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOStatement
Variant c_PDOStatement::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOStatement
Variant &c_PDOStatement::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOStatement
void c_PDOStatement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOStatement
void c_PDOStatement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDOStatement
Variant * c_PDOStatement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOStatement
Variant * c_PDOStatement::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOStatement
Variant * c_PDOStatement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOStatement
Variant c_PDOStatement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOStatement
IMPLEMENT_CLASS(PDOStatement)
c_PDOStatement *c_PDOStatement::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_PDOStatement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_PDOStatement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_PDOStatement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_PDOStatement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDOStatement::cloneImpl() {
  c_PDOStatement *obj = NEW(c_PDOStatement)();
  cloneSet(obj);
  return obj;
}
void c_PDOStatement::cloneSet(c_PDOStatement *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_PDOStatement
Variant c_PDOStatement::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchcolumn());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetchcolumn(arg0));
        }
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0xf2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getcolumnmeta(arg0));
        }
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0xf3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindcolumn(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_bindcolumn(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_bindcolumn(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindcolumn(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0xf5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setfetchmode(count, arg0));
          return (t_setfetchmode(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 0xf6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 0xf7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindparam(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_bindparam(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_bindparam(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindparam(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0xf8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_execute());
          CVarRef arg0((ad->getValue(pos)));
          return (t_execute(arg0));
        }
      }
      break;
    case 0xfb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchobject());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchobject(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fetchobject(arg0, arg1));
        }
      }
      break;
    case 0xfd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 0xfc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchall());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchall(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_fetchall(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fetchall(arg0, arg1, arg2));
        }
      }
      break;
    case 0xfe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetch());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetch(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_fetch(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fetch(arg0, arg1, arg2));
        }
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 0xff:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchall());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchall(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_fetchall(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fetchall(arg0, arg1, arg2));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindvalue(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindvalue(arg0, arg1, arg2));
        }
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_execute());
          CVarRef arg0((ad->getValue(pos)));
          return (t_execute(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindparam(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_bindparam(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_bindparam(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindparam(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchcolumn());
          CVarRef arg0((ad->getValue(pos)));
          return (t_fetchcolumn(arg0));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_bindcolumn(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_bindcolumn(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_bindcolumn(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_bindcolumn(arg0, arg1, arg2, arg3, arg4));
        }
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetchobject());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetchobject(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fetchobject(arg0, arg1));
        }
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setfetchmode(count, arg0));
          return (t_setfetchmode(count,arg0, params.slice(1, count - 1, false)));
        }
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getcolumnmeta(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fetch());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fetch(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_fetch(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fetch(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_PDOStatement
Variant c_PDOStatement::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        return (t_fetchcolumn(a0));
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 0xf2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0xf3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xf5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setfetchmode(count,a0, params));
      }
      break;
    case 0xf6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 0xf7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xf8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        return (t_execute(a0));
      }
      break;
    case 0xfb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        if (count == 1) return (t_fetchobject(a0));
        return (t_fetchobject(a0, a1));
      }
      break;
    case 0xfd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 0xfc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        if (count == 1) return (t_fetchall(a0));
        if (count == 2) return (t_fetchall(a0, a1));
        return (t_fetchall(a0, a1, a2));
      }
      break;
    case 0xfe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        if (count == 1) return (t_fetch(a0));
        if (count == 2) return (t_fetch(a0, a1));
        return (t_fetch(a0, a1, a2));
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 0xff:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        if (count == 1) return (t_fetchall(a0));
        if (count == 2) return (t_fetchall(a0, a1));
        return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        if (count == 1) return (t_fetchobject(a0));
        return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setfetchmode(count,a0, params));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        if (count == 1) return (t_fetch(a0));
        if (count == 2) return (t_fetch(a0, a1));
        return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_PDOStatement
Variant c_PDOStatement::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_PDOStatement
Variant c_PDOStatement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0xf1:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0xf2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcolumnmeta(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0xf3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_nextrowset());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0xf4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xf5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 0xf6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columncount());
      }
      break;
    case 0xf7:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 0xf8:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_closecursor());
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rowcount());
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 0xfb:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 0xfd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 0xfc:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 0xfe:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 0xff:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_debugdumpparams());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss65eb8e41, "fetchall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss3628e403, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss6739a3fb, "closecursor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss14a88eb2, "execute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss236e6e71, "columncount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss3b0d5dae, "nextrowset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1ba41696, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss10c5ffd9, "fetchcolumn")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss76fcd666, "rowcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss5f6ade63, "bindcolumn")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss3327229d, "fetchobject")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss20136861, "setfetchmode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss3bd7b2a2, "debugdumpparams")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss06e717fb, "getcolumnmeta")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss446f4f05, "fetch")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDOStatement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_PDOStatement = {
  c_PDOStatement::os_getInit,
  c_PDOStatement::os_get,
  c_PDOStatement::os_lval,
  c_PDOStatement::os_invoke,
  c_PDOStatement::os_constant,
};
Object co_SoapClient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapClient)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapClient
Variant c_SoapClient::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapClient
Variant c_SoapClient::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapClient
Variant &c_SoapClient::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapClient
void c_SoapClient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapClient
void c_SoapClient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapClient
Variant * c_SoapClient::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapClient
Variant * c_SoapClient::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapClient
Variant * c_SoapClient::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapClient
Variant c_SoapClient::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapClient
IMPLEMENT_CLASS(SoapClient)
c_SoapClient *c_SoapClient::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapClient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_SoapClient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_SoapClient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_SoapClient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapClient::cloneImpl() {
  c_SoapClient *obj = NEW(c_SoapClient)();
  cloneSet(obj);
  return obj;
}
void c_SoapClient::cloneSet(c_SoapClient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapClient::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapClient
Variant c_SoapClient::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 4) return (t___dorequest(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___dorequest(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setsoapheaders());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setsoapheaders(arg0));
        }
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___setcookie(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___setcookie(arg0, arg1));
        }
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___soapcall(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___soapcall(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___soapcall(arg0, arg1, arg2, arg3));
          CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          return (t___soapcall(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setlocation());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setlocation(arg0));
        }
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 0x170:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 0x171:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 0x172:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 0x8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___call(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___call(arg0, arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 4) return (t___dorequest(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___dorequest(arg0, arg1, arg2, arg3, arg4));
        }
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___setcookie(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___setcookie(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___soapcall(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___soapcall(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___soapcall(arg0, arg1, arg2, arg3));
          CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
          return (t___soapcall(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setsoapheaders());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setsoapheaders(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___setlocation());
          CVarRef arg0((ad->getValue(pos)));
          return (t___setlocation(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapClient
Variant c_SoapClient::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        return (t___dorequest(a0, a1, a2, a3, a4));
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        return (t___setsoapheaders(a0));
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(a0));
        return (t___setcookie(a0, a1));
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(a0, a1));
        if (count == 3) return (t___soapcall(a0, a1, a2));
        if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        return (t___setlocation(a0));
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 0x170:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 0x171:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 0x172:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 0x8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(a0));
        return (t___setcookie(a0, a1));
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(a0, a1));
        if (count == 3) return (t___soapcall(a0, a1, a2));
        if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        return (t___setlocation(a0));
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapClient
Variant c_SoapClient::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapClient
Variant c_SoapClient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequest());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequestheaders());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getfunctions());
      }
      break;
    case 0x170:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponseheaders());
      }
      break;
    case 0x171:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponse());
      }
      break;
    case 0x172:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___gettypes());
      }
      break;
    case 0x8:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___call(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss5ebf091c, "__getlastrequest")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss3b37de8c, "__getlastrequestheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss53ceeb6c, "__call")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss5fc59871, "__getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss31035a54, "__getlastresponse")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss7e8aaef5, "__dorequest")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss3402f38b, "__setcookie")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss7604b9d5, "__gettypes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss62050d99, "__soapcall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss58a82cfa, "__getlastresponseheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss2a1cca45, "__setsoapheaders")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss4dbc36ff, "__setlocation")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapClient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SoapClient = {
  c_SoapClient::os_getInit,
  c_SoapClient::os_get,
  c_SoapClient::os_lval,
  c_SoapClient::os_invoke,
  c_SoapClient::os_constant,
};
Object co_SoapParam(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapParam)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapParam
Variant c_SoapParam::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapParam
Variant c_SoapParam::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapParam
Variant &c_SoapParam::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapParam
void c_SoapParam::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapParam
void c_SoapParam::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapParam
Variant * c_SoapParam::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapParam
Variant * c_SoapParam::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapParam
Variant * c_SoapParam::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapParam
Variant c_SoapParam::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapParam
IMPLEMENT_CLASS(SoapParam)
c_SoapParam *c_SoapParam::create(Variant a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapParam::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_SoapParam::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_SoapParam::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
void c_SoapParam::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapParam::cloneImpl() {
  c_SoapParam *obj = NEW(c_SoapParam)();
  cloneSet(obj);
  return obj;
}
void c_SoapParam::cloneSet(c_SoapParam *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapParam
Variant c_SoapParam::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapParam
Variant c_SoapParam::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapParam
Variant c_SoapParam::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapParam
Variant c_SoapParam::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapParam::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SoapParam = {
  c_SoapParam::os_getInit,
  c_SoapParam::os_get,
  c_SoapParam::os_lval,
  c_SoapParam::os_invoke,
  c_SoapParam::os_constant,
};
Object co_DateTime(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DateTime)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTime
Variant c_DateTime::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTime
Variant c_DateTime::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTime
Variant &c_DateTime::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTime
void c_DateTime::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTime
void c_DateTime::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DateTime
Variant * c_DateTime::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTime
Variant * c_DateTime::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTime
Variant * c_DateTime::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTime
Variant c_DateTime::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_RETURN(0x65F665B8975D4C44LL, q_DateTime_RSS, "RSS");
      break;
    case 5:
      HASH_RETURN(0x4C70260A54584B05LL, q_DateTime_ATOM, "ATOM");
      break;
    case 9:
      HASH_RETURN(0x0D93F5DDBEAD7BC9LL, q_DateTime_ISO8601, "ISO8601");
      break;
    case 10:
      HASH_RETURN(0x2E8A54E476F8FF8ALL, q_DateTime_RFC850, "RFC850");
      break;
    case 12:
      HASH_RETURN(0x2183317DB64F7D2CLL, q_DateTime_COOKIE, "COOKIE");
      HASH_RETURN(0x51E9E1D29858652CLL, q_DateTime_RFC1036, "RFC1036");
      HASH_RETURN(0x2035891FE861602CLL, q_DateTime_RFC3339, "RFC3339");
      break;
    case 23:
      HASH_RETURN(0x1CC8F0E77D83F017LL, q_DateTime_RFC2822, "RFC2822");
      break;
    case 27:
      HASH_RETURN(0x64B53064426F891BLL, q_DateTime_RFC822, "RFC822");
      HASH_RETURN(0x0D99FD60C002B3DBLL, q_DateTime_W3C, "W3C");
      break;
    case 30:
      HASH_RETURN(0x325DE23E7968F7FELL, q_DateTime_RFC1123, "RFC1123");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTime
IMPLEMENT_CLASS(DateTime)
c_DateTime *c_DateTime::create(String a0, Object a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DateTime::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DateTime::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DateTime::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_DateTime::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DateTime::cloneImpl() {
  c_DateTime *obj = NEW(c_DateTime)();
  cloneSet(obj);
  return obj;
}
void c_DateTime::cloneSet(c_DateTime *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DateTime
Variant c_DateTime::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x80:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_format(arg0));
        }
      }
      break;
    case 0x81:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setdate(arg0, arg1, arg2));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 0x83:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_settime(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_settime(arg0, arg1, arg2));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x84:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 0x85:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_setisodate(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setisodate(arg0, arg1, arg2));
        }
      }
      break;
    case 0x86:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_settimezone(arg0));
        }
      }
      break;
    case 0x87:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_modify(arg0));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_modify(arg0));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setDate")) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setdate(arg0, arg1, arg2));
        }
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "getTimezone")) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setISODate")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_setisodate(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setisodate(arg0, arg1, arg2));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "setTime")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_settime(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_settime(arg0, arg1, arg2));
        }
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "setTimezone")) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_settimezone(arg0));
        }
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_format(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DateTime
Variant c_DateTime::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x80:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(a0));
      }
      break;
    case 0x81:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 0x83:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(a0, a1));
        return (t_settime(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x84:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 0x85:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(a0, a1));
        return (t_setisodate(a0, a1, a2));
      }
      break;
    case 0x86:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(a0));
      }
      break;
    case 0x87:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setDate")) {
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "getTimezone")) {
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setISODate")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(a0, a1));
        return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "setTime")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(a0, a1));
        return (t_settime(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "setTimezone")) {
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DateTime
Variant c_DateTime::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DateTime
Variant c_DateTime::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x80:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_format(a0));
      }
      break;
    case 0x81:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setdate(a0, a1, a2));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x82:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset());
      }
      break;
    case 0x83:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x84:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettimezone());
      }
      break;
    case 0x85:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 0x86:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_settimezone(a0));
      }
      break;
    case 0x87:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_modify(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss0f080587, "modify")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss2362edf5, "setDate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss0b55bd0b, "getOffset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss3be7716c, "getTimezone")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss6ee55a74, "setISODate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss34f4c258, "setTime")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss746a8348, "setTimezone")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss55073565, "format")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DateTime::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DateTime = {
  c_DateTime::os_getInit,
  c_DateTime::os_get,
  c_DateTime::os_lval,
  c_DateTime::os_invoke,
  c_DateTime::os_constant,
};
Object co_Collator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Collator)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Collator
Variant c_Collator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Collator
Variant c_Collator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Collator
Variant &c_Collator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Collator
void c_Collator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Collator
void c_Collator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Collator
Variant * c_Collator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Collator
Variant * c_Collator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Collator
Variant * c_Collator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Collator
Variant c_Collator::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_RETURN(0x44D1DA387595A403LL, q_Collator_SORT_REGULAR, "SORT_REGULAR");
      HASH_RETURN(0x243ECA9F2933DFC3LL, q_Collator_ON, "ON");
      break;
    case 4:
      HASH_RETURN(0x2FC0EE2E1B088E44LL, q_Collator_NUMERIC_COLLATION, "NUMERIC_COLLATION");
      break;
    case 7:
      HASH_RETURN(0x11D151DDDD2A4107LL, q_Collator_HIRAGANA_QUATERNARY_MODE, "HIRAGANA_QUATERNARY_MODE");
      break;
    case 12:
      HASH_RETURN(0x12C49411F55E648CLL, q_Collator_QUATERNARY, "QUATERNARY");
      break;
    case 20:
      HASH_RETURN(0x6A7AD33CDF49E8D4LL, q_Collator_SORT_NUMERIC, "SORT_NUMERIC");
      HASH_RETURN(0x342F3FCC372ABD54LL, q_Collator_NON_IGNORABLE, "NON_IGNORABLE");
      break;
    case 21:
      HASH_RETURN(0x43A7AE36C693E955LL, q_Collator_DEFAULT_VALUE, "DEFAULT_VALUE");
      break;
    case 24:
      HASH_RETURN(0x6DED35804EDAD218LL, q_Collator_CASE_LEVEL, "CASE_LEVEL");
      HASH_RETURN(0x0AE48A6C6BE5D798LL, q_Collator_LOWER_FIRST, "LOWER_FIRST");
      break;
    case 27:
      HASH_RETURN(0x2C6A6D2A478AF4DBLL, q_Collator_UPPER_FIRST, "UPPER_FIRST");
      break;
    case 29:
      HASH_RETURN(0x58342E71EC59E4DDLL, q_Collator_IDENTICAL, "IDENTICAL");
      break;
    case 32:
      HASH_RETURN(0x092DDC88428C3A20LL, q_Collator_PRIMARY, "PRIMARY");
      break;
    case 33:
      HASH_RETURN(0x713FE3D58B4C7661LL, q_Collator_FRENCH_COLLATION, "FRENCH_COLLATION");
      HASH_RETURN(0x25FE54F210EC5FE1LL, q_Collator_SECONDARY, "SECONDARY");
      HASH_RETURN(0x6E252898020550A1LL, q_Collator_TERTIARY, "TERTIARY");
      break;
    case 35:
      HASH_RETURN(0x2C984380FDBF8563LL, q_Collator_STRENGTH, "STRENGTH");
      break;
    case 39:
      HASH_RETURN(0x7306AAA31A7C8BE7LL, q_Collator_DEFAULT_STRENGTH, "DEFAULT_STRENGTH");
      break;
    case 45:
      HASH_RETURN(0x304F6E12C5B7486DLL, q_Collator_CASE_FIRST, "CASE_FIRST");
      break;
    case 52:
      HASH_RETURN(0x395D56BB0A8525F4LL, q_Collator_NORMALIZATION_MODE, "NORMALIZATION_MODE");
      break;
    case 53:
      HASH_RETURN(0x595FDD99C9EFE835LL, q_Collator_ALTERNATE_HANDLING, "ALTERNATE_HANDLING");
      break;
    case 60:
      HASH_RETURN(0x334AAA38C97C62FCLL, q_Collator_SORT_STRING, "SORT_STRING");
      HASH_RETURN(0x0039CBFC3620143CLL, q_Collator_SHIFTED, "SHIFTED");
      break;
    case 61:
      HASH_RETURN(0x136402C9E51A75FDLL, q_Collator_OFF, "OFF");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Collator
IMPLEMENT_CLASS(Collator)
c_Collator *c_Collator::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_Collator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_Collator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_Collator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_Collator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Collator::cloneImpl() {
  c_Collator *obj = NEW(c_Collator)();
  cloneSet(obj);
  return obj;
}
void c_Collator::cloneSet(c_Collator *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Collator
Variant c_Collator::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0x22:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0(ref(ad->getValueRef(pos)));
          return (t_sortwithsortkeys(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x24:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0(ref(ad->getValueRef(pos)));
          if (count <= 1) return (t_sort(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_sort(arg0, arg1));
        }
      }
      break;
    case 0x25:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 0x26:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 0x14:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0(ref(ad->getValueRef(pos)));
          if (count <= 1) return (t_asort(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_asort(arg0, arg1));
        }
      }
      break;
    case 0x27:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setstrength(arg0));
        }
      }
      break;
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(o_getClassName(), arg0));
        }
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0x2a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getlocale());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getlocale(arg0));
        }
      }
      break;
    case 0x2b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 0x2c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_compare(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getlocale());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getlocale(arg0));
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0(ref(ad->getValueRef(pos)));
          if (count <= 1) return (t_sort(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_sort(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0(ref(ad->getValueRef(pos)));
          return (t_sortwithsortkeys(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0(ref(ad->getValueRef(pos)));
          if (count <= 1) return (t_asort(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_asort(arg0, arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_compare(arg0, arg1));
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(o_getClassName(), arg0));
        }
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setstrength(arg0));
        }
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_Collator
Variant c_Collator::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0x22:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x24:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        if (count <= 1) return (t_sort(ref(a0)));
        return (t_sort(ref(a0), a1));
      }
      break;
    case 0x25:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 0x26:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 0x14:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        if (count <= 1) return (t_asort(ref(a0)));
        return (t_asort(ref(a0), a1));
      }
      break;
    case 0x27:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        return (t_setstrength(a0));
      }
      break;
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x2a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        if (count <= 0) return (t_getlocale());
        return (t_getlocale(a0));
      }
      break;
    case 0x2b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 0x2c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        return (t_compare(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        if (count <= 0) return (t_getlocale());
        return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        if (count <= 1) return (t_sort(ref(a0)));
        return (t_sort(ref(a0), a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        if (count <= 1) return (t_asort(ref(a0)));
        return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Collator
Variant c_Collator::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(c, arg0));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (ti_create(c, arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_Collator
Variant c_Collator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0x22:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x24:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_sort(ref(a0)));
        else return (t_sort(ref(a0), a1));
      }
      break;
    case 0x25:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrorcode());
      }
      break;
    case 0x26:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstrength());
      }
      break;
    case 0x14:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_asort(ref(a0)));
        else return (t_asort(ref(a0), a1));
      }
      break;
    case 0x27:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstrength(a0));
      }
      break;
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x2a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getlocale());
        else return (t_getlocale(a0));
      }
      break;
    case 0x2b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrormessage());
      }
      break;
    case 0x2c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_compare(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss4d6296e0, "geterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss2965ce02, "getlocale")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getlocale());
        else return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss71e244d6, "sort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_sort(ref(a0)));
        else return (t_sort(ref(a0), a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss7787fc15, "sortwithsortkeys")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss5cbbd412, "asort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_asort(ref(a0)));
        else return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss73bc832f, "geterrormessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss42130cae, "compare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss4cbf9ed7, "setstrength")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss5fa4b3a2, "getstrength")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Collator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x28:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(c, a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss6fae7baa, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_create(c, a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_Collator = {
  c_Collator::os_getInit,
  c_Collator::os_get,
  c_Collator::os_lval,
  c_Collator::os_invoke,
  c_Collator::os_constant,
};
Object co_PDO(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDO)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDO
Variant c_PDO::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDO
Variant c_PDO::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDO
Variant &c_PDO::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDO
void c_PDO::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDO
void c_PDO::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDO
Variant * c_PDO::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDO
Variant * c_PDO::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDO
Variant * c_PDO::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDO
Variant c_PDO::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 0:
      HASH_RETURN(0x1800ED92A8884D00LL, q_PDO_ATTR_CASE, "ATTR_CASE");
      break;
    case 2:
      HASH_RETURN(0x07BAFBAE5A431902LL, q_PDO_ATTR_STATEMENT_CLASS, "ATTR_STATEMENT_CLASS");
      break;
    case 4:
      HASH_RETURN(0x0229D662F91D9C04LL, q_PDO_ERRMODE_EXCEPTION, "ERRMODE_EXCEPTION");
      break;
    case 8:
      HASH_RETURN(0x3BE7A02FD980AA08LL, q_PDO_CASE_NATURAL, "CASE_NATURAL");
      break;
    case 13:
      HASH_RETURN(0x099B533427CCC20DLL, q_PDO_FETCH_OBJ, "FETCH_OBJ");
      break;
    case 17:
      HASH_RETURN(0x5FAD218776C6E511LL, q_PDO_FETCH_INTO, "FETCH_INTO");
      break;
    case 25:
      HASH_RETURN(0x78CB81320C710019LL, q_PDO_FETCH_BOUND, "FETCH_BOUND");
      break;
    case 27:
      HASH_RETURN(0x3158D52C3627FE1BLL, q_PDO_MYSQL_ATTR_INIT_COMMAND, "MYSQL_ATTR_INIT_COMMAND");
      break;
    case 28:
      HASH_RETURN(0x03CF598D3CCCD01CLL, q_PDO_ATTR_CLIENT_VERSION, "ATTR_CLIENT_VERSION");
      break;
    case 29:
      HASH_RETURN(0x2BE16C4111A7B41DLL, q_PDO_ATTR_FETCH_CATALOG_NAMES, "ATTR_FETCH_CATALOG_NAMES");
      break;
    case 30:
      HASH_RETURN(0x2A5BA04D0218F11ELL, q_PDO_CASE_LOWER, "CASE_LOWER");
      break;
    case 35:
      HASH_RETURN(0x16B15CF4B0DD7E23LL, q_PDO_FETCH_GROUP, "FETCH_GROUP");
      break;
    case 37:
      HASH_RETURN(0x37F650C462FB6A25LL, q_PDO_CASE_UPPER, "CASE_UPPER");
      break;
    case 42:
      HASH_RETURN(0x262D9BE84029992ALL, q_PDO_PARAM_EVT_FETCH_POST, "PARAM_EVT_FETCH_POST");
      break;
    case 51:
      HASH_RETURN(0x15D2BCCED7726933LL, q_PDO_ATTR_TIMEOUT, "ATTR_TIMEOUT");
      break;
    case 59:
      HASH_RETURN(0x01B17428BEE0243BLL, q_PDO_PARAM_EVT_EXEC_PRE, "PARAM_EVT_EXEC_PRE");
      break;
    case 60:
      HASH_RETURN(0x2739A1D49673D43CLL, q_PDO_ATTR_ERRMODE, "ATTR_ERRMODE");
      HASH_RETURN(0x6AC5C285F4DD863CLL, q_PDO_ATTR_DEFAULT_FETCH_MODE, "ATTR_DEFAULT_FETCH_MODE");
      break;
    case 61:
      HASH_RETURN(0x3E11051E4101D73DLL, q_PDO_ATTR_EMULATE_PREPARES, "ATTR_EMULATE_PREPARES");
      break;
    case 68:
      HASH_RETURN(0x2189354E22363544LL, q_PDO_ATTR_PREFETCH, "ATTR_PREFETCH");
      break;
    case 72:
      HASH_RETURN(0x428D5CA64BB99E48LL, q_PDO_FETCH_UNIQUE, "FETCH_UNIQUE");
      break;
    case 78:
      HASH_RETURN(0x39B4E90F36E93B4ELL, q_PDO_MYSQL_ATTR_READ_DEFAULT_GROUP, "MYSQL_ATTR_READ_DEFAULT_GROUP");
      break;
    case 82:
      HASH_RETURN(0x58A833E2336C6152LL, q_PDO_ATTR_SERVER_INFO, "ATTR_SERVER_INFO");
      break;
    case 86:
      HASH_RETURN(0x57B75F4773C81556LL, q_PDO_PARAM_EVT_NORMALIZE, "PARAM_EVT_NORMALIZE");
      break;
    case 91:
      HASH_RETURN(0x5495020CF262F15BLL, q_PDO_ATTR_CONNECTION_STATUS, "ATTR_CONNECTION_STATUS");
      HASH_RETURN(0x37888F551D85275BLL, q_PDO_ATTR_ORACLE_NULLS, "ATTR_ORACLE_NULLS");
      break;
    case 97:
      HASH_RETURN(0x416A0550A8F12E61LL, q_PDO_MYSQL_ATTR_FOUND_ROWS, "MYSQL_ATTR_FOUND_ROWS");
      break;
    case 101:
      HASH_RETURN(0x15A3522970275465LL, q_PDO_FETCH_ORI_NEXT, "FETCH_ORI_NEXT");
      break;
    case 104:
      HASH_RETURN(0x162EAA2134F1C068LL, q_PDO_ATTR_FETCH_TABLE_NAMES, "ATTR_FETCH_TABLE_NAMES");
      break;
    case 111:
      HASH_RETURN(0x350E9275757FD66FLL, q_PDO_FETCH_ORI_REL, "FETCH_ORI_REL");
      break;
    case 112:
      HASH_RETURN(0x6870D9DE66F43D70LL, q_PDO_FETCH_ASSOC, "FETCH_ASSOC");
      break;
    case 113:
      HASH_RETURN(0x713C8339790FC071LL, q_PDO_ATTR_CURSOR_NAME, "ATTR_CURSOR_NAME");
      break;
    case 116:
      HASH_RETURN(0x1FB97A35B6711374LL, q_PDO_ATTR_MAX_COLUMN_LEN, "ATTR_MAX_COLUMN_LEN");
      break;
    case 117:
      HASH_RETURN(0x0E51487F9370EE75LL, q_PDO_ATTR_AUTOCOMMIT, "ATTR_AUTOCOMMIT");
      break;
    case 121:
      HASH_RETURN(0x630122BA9EC73379LL, q_PDO_PARAM_NULL, "PARAM_NULL");
      HASH_RETURN(0x05B00276031D7D79LL, q_PDO_PARAM_EVT_ALLOC, "PARAM_EVT_ALLOC");
      break;
    case 125:
      HASH_RETURN(0x500C039681520C7DLL, q_PDO_PARAM_BOOL, "PARAM_BOOL");
      break;
    case 126:
      HASH_RETURN(0x5CF4F38A0D7D087ELL, q_PDO_NULL_NATURAL, "NULL_NATURAL");
      break;
    case 131:
      HASH_RETURN(0x3F414F2735132983LL, q_PDO_PARAM_INT, "PARAM_INT");
      break;
    case 132:
      HASH_RETURN(0x2011B5A528057784LL, q_PDO_FETCH_NUM, "FETCH_NUM");
      break;
    case 133:
      HASH_RETURN(0x5451E44C627DD885LL, q_PDO_FETCH_ORI_PRIOR, "FETCH_ORI_PRIOR");
      break;
    case 134:
      HASH_RETURN(0x1B8BA5EEAABCB786LL, q_PDO_PARAM_EVT_EXEC_POST, "PARAM_EVT_EXEC_POST");
      HASH_RETURN(0x1B51C692B91D7486LL, q_PDO_MYSQL_ATTR_USE_BUFFERED_QUERY, "MYSQL_ATTR_USE_BUFFERED_QUERY");
      break;
    case 136:
      HASH_RETURN(0x7E64209D5A925F88LL, q_PDO_PARAM_STR, "PARAM_STR");
      break;
    case 138:
      HASH_RETURN(0x45AB9806DE21EA8ALL, q_PDO_ATTR_CURSOR, "ATTR_CURSOR");
      break;
    case 141:
      HASH_RETURN(0x0EDB017494A81E8DLL, q_PDO_ATTR_DRIVER_NAME, "ATTR_DRIVER_NAME");
      break;
    case 142:
      HASH_RETURN(0x126B3038F3355A8ELL, q_PDO_FETCH_USE_DEFAULT, "FETCH_USE_DEFAULT");
      break;
    case 143:
      HASH_RETURN(0x1F200B094608BE8FLL, q_PDO_ATTR_SERVER_VERSION, "ATTR_SERVER_VERSION");
      HASH_RETURN(0x1175C5F56147488FLL, q_PDO_MYSQL_ATTR_DIRECT_QUERY, "MYSQL_ATTR_DIRECT_QUERY");
      break;
    case 150:
      HASH_RETURN(0x25BE9238386C2796LL, q_PDO_FETCH_PROPS_LATE, "FETCH_PROPS_LATE");
      break;
    case 153:
      HASH_RETURN(0x657BEA5F741C4999LL, q_PDO_FETCH_COLUMN, "FETCH_COLUMN");
      HASH_RETURN(0x18B801DE8D8C9099LL, q_PDO_FETCH_CLASSTYPE, "FETCH_CLASSTYPE");
      break;
    case 156:
      HASH_RETURN(0x1EC178DF86F4FD9CLL, q_PDO_FETCH_SERIALIZE, "FETCH_SERIALIZE");
      break;
    case 160:
      HASH_RETURN(0x052245CE02FBF4A0LL, q_PDO_MYSQL_ATTR_LOCAL_INFILE, "MYSQL_ATTR_LOCAL_INFILE");
      break;
    case 162:
      HASH_RETURN(0x28D5B850B76FEEA2LL, q_PDO_FETCH_BOTH, "FETCH_BOTH");
      HASH_RETURN(0x0D0BCCC6768A88A2LL, q_PDO_FETCH_KEY_PAIR, "FETCH_KEY_PAIR");
      break;
    case 164:
      HASH_RETURN(0x6851B7545234FCA4LL, q_PDO_PARAM_EVT_FETCH_PRE, "PARAM_EVT_FETCH_PRE");
      break;
    case 168:
      HASH_RETURN(0x167DD614E842FAA8LL, q_PDO_CURSOR_FWDONLY, "CURSOR_FWDONLY");
      break;
    case 169:
      HASH_RETURN(0x6AEB66DE7A454FA9LL, q_PDO_FETCH_ORI_FIRST, "FETCH_ORI_FIRST");
      break;
    case 170:
      HASH_RETURN(0x392400A66B305EAALL, q_PDO_CURSOR_SCROLL, "CURSOR_SCROLL");
      break;
    case 171:
      HASH_RETURN(0x2F6AE87AF5701AABLL, q_PDO_FETCH_ORI_LAST, "FETCH_ORI_LAST");
      break;
    case 180:
      HASH_RETURN(0x56D59339A0F5D8B4LL, q_PDO_ATTR_PERSISTENT, "ATTR_PERSISTENT");
      break;
    case 184:
      HASH_RETURN(0x08657D6005DD08B8LL, q_PDO_NULL_EMPTY_STRING, "NULL_EMPTY_STRING");
      break;
    case 197:
      HASH_RETURN(0x60CE39F6493319C5LL, q_PDO_ATTR_STRINGIFY_FETCHES, "ATTR_STRINGIFY_FETCHES");
      break;
    case 198:
      HASH_RETURN(0x61BD1667BB46C9C6LL, q_PDO_MYSQL_ATTR_READ_DEFAULT_FILE, "MYSQL_ATTR_READ_DEFAULT_FILE");
      break;
    case 200:
      HASH_RETURN(0x30D00303975C98C8LL, q_PDO_FETCH_FUNC, "FETCH_FUNC");
      HASH_RETURN(0x47D4494BE4FA26C8LL, q_PDO_FETCH_ORI_ABS, "FETCH_ORI_ABS");
      break;
    case 202:
      HASH_RETURN(0x29B68A596E0615CALL, q_PDO_NULL_TO_STRING, "NULL_TO_STRING");
      break;
    case 203:
      HASH_RETURN(0x73FAA1AA068D19CBLL, q_PDO_MYSQL_ATTR_MAX_BUFFER_SIZE, "MYSQL_ATTR_MAX_BUFFER_SIZE");
      break;
    case 208:
      HASH_RETURN(0x439351C7C64634D0LL, q_PDO_FETCH_CLASS, "FETCH_CLASS");
      break;
    case 209:
      HASH_RETURN(0x5C75BB222F23C4D1LL, q_PDO_FETCH_LAZY, "FETCH_LAZY");
      break;
    case 211:
      HASH_RETURN(0x57F9152D7EC3A5D3LL, q_PDO_MYSQL_ATTR_COMPRESS, "MYSQL_ATTR_COMPRESS");
      break;
    case 220:
      HASH_RETURN(0x4D1DDF7F772C54DCLL, q_PDO_ERRMODE_WARNING, "ERRMODE_WARNING");
      break;
    case 235:
      HASH_RETURN(0x2E4175EAAB1F75EBLL, q_PDO_ERRMODE_SILENT, "ERRMODE_SILENT");
      break;
    case 245:
      HASH_RETURN(0x16017F3F58821EF5LL, q_PDO_ERR_NONE, "ERR_NONE");
      break;
    case 246:
      HASH_RETURN(0x674F9B0D2030C3F6LL, q_PDO_PARAM_LOB, "PARAM_LOB");
      break;
    case 247:
      HASH_RETURN(0x16EC9F213D7F57F7LL, q_PDO_FETCH_NAMED, "FETCH_NAMED");
      break;
    case 248:
      HASH_RETURN(0x6C0021FD5D20A1F8LL, q_PDO_PARAM_INPUT_OUTPUT, "PARAM_INPUT_OUTPUT");
      break;
    case 251:
      HASH_RETURN(0x13EC16B8F7B7B1FBLL, q_PDO_MYSQL_ATTR_IGNORE_SPACE, "MYSQL_ATTR_IGNORE_SPACE");
      break;
    case 253:
      HASH_RETURN(0x51938FCA0AE827FDLL, q_PDO_PARAM_STMT, "PARAM_STMT");
      break;
    case 254:
      HASH_RETURN(0x56335EC3392D8EFELL, q_PDO_PARAM_EVT_FREE, "PARAM_EVT_FREE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDO
IMPLEMENT_CLASS(PDO)
c_PDO *c_PDO::create(String a0, String a1, String a2, Array a3) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3);
  return this;
}
ObjectData *c_PDO::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3));
    } while (false);
  }
  return this;
}
void c_PDO::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_PDO::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
void c_PDO::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDO::cloneImpl() {
  c_PDO *obj = NEW(c_PDO)();
  cloneSet(obj);
  return obj;
}
void c_PDO::cloneSet(c_PDO *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_PDO
Variant c_PDO::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_lastinsertid());
          CVarRef arg0((ad->getValue(pos)));
          return (t_lastinsertid(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    case 0xe9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 0xea:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 0xec:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_quote(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_quote(arg0, arg1));
        }
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0xed:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_prepare(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_prepare(arg0, arg1));
        }
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_exec(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_lastinsertid());
          CVarRef arg0((ad->getValue(pos)));
          return (t_lastinsertid(arg0));
        }
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_quote(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_quote(arg0, arg1));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_prepare(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_prepare(arg0, arg1));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_query(arg0));
        }
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_PDO
Variant c_PDO::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        return (t_lastinsertid(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 0xe9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 0xea:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 0xec:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(a0));
        return (t_quote(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xed:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(a0));
        return (t_prepare(a0, a1));
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(a0));
        return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(a0));
        return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_PDO
Variant c_PDO::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_PDO
Variant c_PDO::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xe5:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0xe6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 0xe7:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0xe8:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 0xe9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rollback());
      }
      break;
    case 0xea:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_commit());
      }
      break;
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 0xec:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0xed:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_begintransaction());
      }
      break;
    case 0xee:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 0xef:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 0xf0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss2372f2c7, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss4f78df74, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss45d283ee, "lastinsertid")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss55f7a324, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss7f04605e, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss65e3f324, "commit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss25243fd3, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss7b6b9b12, "quote")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss4ba591af, "prepare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss6d79ec36, "rollback")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss5c33e23b, "begintransaction")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDO::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xeb:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss53c7cbf2, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_PDO = {
  c_PDO::os_getInit,
  c_PDO::os_get,
  c_PDO::os_lval,
  c_PDO::os_invoke,
  c_PDO::os_constant,
};
Object co_ImageSprite(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ImageSprite)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ImageSprite
Variant c_ImageSprite::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ImageSprite
Variant c_ImageSprite::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ImageSprite
Variant &c_ImageSprite::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ImageSprite
void c_ImageSprite::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ImageSprite
void c_ImageSprite::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ImageSprite
Variant * c_ImageSprite::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ImageSprite
Variant * c_ImageSprite::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ImageSprite
Variant * c_ImageSprite::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ImageSprite
Variant c_ImageSprite::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ImageSprite
IMPLEMENT_CLASS(ImageSprite)
c_ImageSprite *c_ImageSprite::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_ImageSprite::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_ImageSprite::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_ImageSprite::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_ImageSprite::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_ImageSprite::cloneImpl() {
  c_ImageSprite *obj = NEW(c_ImageSprite)();
  cloneSet(obj);
  return obj;
}
void c_ImageSprite::cloneSet(c_ImageSprite *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ImageSprite
Variant c_ImageSprite::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xc9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_addstring(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addstring(arg0, arg1, arg2));
        }
      }
      break;
    case 0xca:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_loaddims());
          CVarRef arg0((ad->getValue(pos)));
          return (t_loaddims(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xcb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        return (t_mapping());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xcc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_css(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_css(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_css(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_css(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_output());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_output(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_output(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_output(arg0, arg1, arg2));
        }
      }
      break;
    case 0xcd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_loadimages());
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadimages(arg0));
        }
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clear());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clear(arg0));
        }
      }
      break;
    case 0xcf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        return (t_geterrors());
      }
      break;
    case 0xd0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addurl(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addurl(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addurl(arg0, arg1, arg2));
        }
      }
      break;
    case 0xd1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addfile(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss5bcefe00, "getErrors")) {
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        return (t_geterrors());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss3a82a85e, "loadDims")) {
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_loaddims());
          CVarRef arg0((ad->getValue(pos)));
          return (t_loaddims(arg0));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clear());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clear(arg0));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss21d1906f, "addFile")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addfile(arg0, arg1));
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss2ec0b554, "loadImages")) {
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_loadimages());
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadimages(arg0));
        }
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss05d35d69, "mapping")) {
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        return (t_mapping());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss6cd2dcc6, "addString")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_addstring(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addstring(arg0, arg1, arg2));
        }
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss3871547c, "css")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_css(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_css(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_css(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_css(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss0dc84a7d, "addUrl")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_addurl(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_addurl(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_addurl(arg0, arg1, arg2));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_output());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_output(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_output(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_output(arg0, arg1, arg2));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_ImageSprite
Variant c_ImageSprite::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xc9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        if (count <= 2) return (t_addstring(a0, a1));
        return (t_addstring(a0, a1, a2));
      }
      break;
    case 0xca:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        if (count <= 0) return (t_loaddims());
        return (t_loaddims(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0xcb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        return (t_mapping());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0xcc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        if (count <= 1) return (t_css(a0));
        if (count == 2) return (t_css(a0, a1));
        if (count == 3) return (t_css(a0, a1, a2));
        return (t_css(a0, a1, a2, a3));
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        if (count <= 0) return (t_output());
        if (count == 1) return (t_output(a0));
        if (count == 2) return (t_output(a0, a1));
        return (t_output(a0, a1, a2));
      }
      break;
    case 0xcd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        if (count <= 0) return (t_loadimages());
        return (t_loadimages(a0));
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        if (count <= 0) return (t_clear());
        return (t_clear(a0));
      }
      break;
    case 0xcf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        return (t_geterrors());
      }
      break;
    case 0xd0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        if (count <= 1) return (t_addurl(a0));
        if (count == 2) return (t_addurl(a0, a1));
        return (t_addurl(a0, a1, a2));
      }
      break;
    case 0xd1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        if (count <= 1) return (t_addfile(a0));
        return (t_addfile(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss5bcefe00, "getErrors")) {
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        return (t_geterrors());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss3a82a85e, "loadDims")) {
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        if (count <= 0) return (t_loaddims());
        return (t_loaddims(a0));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        if (count <= 0) return (t_clear());
        return (t_clear(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss21d1906f, "addFile")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        if (count <= 1) return (t_addfile(a0));
        return (t_addfile(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss2ec0b554, "loadImages")) {
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        if (count <= 0) return (t_loadimages());
        return (t_loadimages(a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss05d35d69, "mapping")) {
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        return (t_mapping());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss6cd2dcc6, "addString")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        if (count <= 2) return (t_addstring(a0, a1));
        return (t_addstring(a0, a1, a2));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss3871547c, "css")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        if (count <= 1) return (t_css(a0));
        if (count == 2) return (t_css(a0, a1));
        if (count == 3) return (t_css(a0, a1, a2));
        return (t_css(a0, a1, a2, a3));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss0dc84a7d, "addUrl")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        if (count <= 1) return (t_addurl(a0));
        if (count == 2) return (t_addurl(a0, a1));
        return (t_addurl(a0, a1, a2));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        if (count <= 0) return (t_output());
        if (count == 1) return (t_output(a0));
        if (count == 2) return (t_output(a0, a1));
        return (t_output(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ImageSprite
Variant c_ImageSprite::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_ImageSprite
Variant c_ImageSprite::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xc9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_addstring(a0, a1));
        else return (t_addstring(a0, a1, a2));
      }
      break;
    case 0xca:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_loaddims());
        else return (t_loaddims(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0xcb:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_mapping());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0xcc:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_css(a0));
        else if (count == 2) return (t_css(a0, a1));
        else if (count == 3) return (t_css(a0, a1, a2));
        else return (t_css(a0, a1, a2, a3));
      }
      break;
    case 0x96:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_output());
        else if (count == 1) return (t_output(a0));
        else if (count == 2) return (t_output(a0, a1));
        else return (t_output(a0, a1, a2));
      }
      break;
    case 0xcd:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_loadimages());
        else return (t_loadimages(a0));
      }
      break;
    case 0xce:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clear());
        else return (t_clear(a0));
      }
      break;
    case 0xcf:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrors());
      }
      break;
    case 0xd0:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addurl(a0));
        else if (count == 2) return (t_addurl(a0, a1));
        else return (t_addurl(a0, a1, a2));
      }
      break;
    case 0xd1:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addfile(a0));
        else return (t_addfile(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss5bcefe00, "getErrors")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_geterrors());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss3a82a85e, "loadDims")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_loaddims());
        else return (t_loaddims(a0));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss5a226667, "clear")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clear());
        else return (t_clear(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss21d1906f, "addFile")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addfile(a0));
        else return (t_addfile(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss2ec0b554, "loadImages")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_loadimages());
        else return (t_loadimages(a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss05d35d69, "mapping")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_mapping());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss6cd2dcc6, "addString")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_addstring(a0, a1));
        else return (t_addstring(a0, a1, a2));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss3871547c, "css")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_css(a0));
        else if (count == 2) return (t_css(a0, a1));
        else if (count == 3) return (t_css(a0, a1, a2));
        else return (t_css(a0, a1, a2, a3));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss0dc84a7d, "addUrl")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_addurl(a0));
        else if (count == 2) return (t_addurl(a0, a1));
        else return (t_addurl(a0, a1, a2));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss48839881, "output")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_output());
        else if (count == 1) return (t_output(a0));
        else if (count == 2) return (t_output(a0, a1));
        else return (t_output(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ImageSprite::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_ImageSprite = {
  c_ImageSprite::os_getInit,
  c_ImageSprite::os_get,
  c_ImageSprite::os_lval,
  c_ImageSprite::os_invoke,
  c_ImageSprite::os_constant,
};
Object co_DOMEntity(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMEntity)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntity
Variant c_DOMEntity::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntity
Variant c_DOMEntity::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntity
Variant &c_DOMEntity::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntity
void c_DOMEntity::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntity
void c_DOMEntity::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMEntity
Variant * c_DOMEntity::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntity
Variant * c_DOMEntity::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntity
Variant * c_DOMEntity::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntity
Variant c_DOMEntity::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntity
IMPLEMENT_CLASS(DOMEntity)
c_DOMEntity *c_DOMEntity::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMEntity::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMEntity::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMEntity::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMEntity::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMEntity::cloneImpl() {
  c_DOMEntity *obj = NEW(c_DOMEntity)();
  cloneSet(obj);
  return obj;
}
void c_DOMEntity::cloneSet(c_DOMEntity *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntity
Variant c_DOMEntity::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntity
Variant c_DOMEntity::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMEntity
Variant c_DOMEntity::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMEntity
Variant c_DOMEntity::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMEntity::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMEntity = {
  c_DOMEntity::os_getInit,
  c_DOMEntity::os_get,
  c_DOMEntity::os_lval,
  c_DOMEntity::os_invoke,
  c_DOMEntity::os_constant,
};
Object co_XMLWriter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_XMLWriter)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_XMLWriter
Variant c_XMLWriter::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_XMLWriter
Variant c_XMLWriter::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_XMLWriter
Variant &c_XMLWriter::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_XMLWriter
void c_XMLWriter::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_XMLWriter
void c_XMLWriter::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_XMLWriter
Variant * c_XMLWriter::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_XMLWriter
Variant * c_XMLWriter::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_XMLWriter
Variant * c_XMLWriter::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_XMLWriter
Variant c_XMLWriter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_XMLWriter
IMPLEMENT_CLASS(XMLWriter)
c_XMLWriter *c_XMLWriter::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_XMLWriter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_XMLWriter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_XMLWriter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_XMLWriter::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_XMLWriter::cloneImpl() {
  c_XMLWriter *obj = NEW(c_XMLWriter)();
  cloneSet(obj);
  return obj;
}
void c_XMLWriter::cloneSet(c_XMLWriter *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_XMLWriter
Variant c_XMLWriter::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x18f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 3) return (t_writeelementns(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeelementns(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x192:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_outputmemory());
          CVarRef arg0((ad->getValue(pos)));
          return (t_outputmemory(arg0));
        }
      }
      break;
    case 0x191:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 0x190:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 0x193:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_startdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_startdocument(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_startdocument(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 0x194:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startdtdentity(arg0, arg1));
        }
      }
      break;
    case 0x195:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 0x196:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecomment(arg0));
        }
      }
      break;
    case 0x197:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeattribute(arg0, arg1));
        }
      }
      break;
    case 0x198:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x199:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writedtd(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_writedtd(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_writedtd(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtd(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x19a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      break;
    case 0x19b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 0x19c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startelement(arg0));
        }
      }
      break;
    case 0x19d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 0x19e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdelement(arg0));
        }
      }
      break;
    case 0x1a0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 0x19f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecdata(arg0));
        }
      }
      break;
    case 0x1a1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtdelement(arg0, arg1));
        }
      }
      break;
    case 0x1a2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeattributens(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x1a3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writepi(arg0, arg1));
        }
      }
      break;
    case 0x1a4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindentstring(arg0));
        }
      }
      break;
    case 0x1a5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startattribute(arg0));
        }
      }
      break;
    case 0x1a6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writeelement(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeelement(arg0, arg1));
        }
      }
      break;
    case 0x1a7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 0x1a8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writeraw(arg0));
        }
      }
      break;
    case 0x1a9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_writedtdentity(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_writedtdentity(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_writedtdentity(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 0x1aa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 0x1ab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_startdtd(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_startdtd(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startdtd(arg0, arg1, arg2));
        }
      }
      break;
    case 0x1ac:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindent(arg0));
        }
      }
      break;
    case 0x1ad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 0x1ae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdattlist(arg0));
        }
      }
      break;
    case 0x1af:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 0x1b0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtdattlist(arg0, arg1));
        }
      }
      break;
    case 0x1b1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 0x1b3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_openuri(arg0));
        }
      }
      break;
    case 0x1b2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 0x1b4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 0x1b5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startpi(arg0));
        }
      }
      break;
    case 0x1b6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_text(arg0));
        }
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 0x1b7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writeCData")) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecdata(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startDTD")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_startdtd(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_startdtd(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startdtd(arg0, arg1, arg2));
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writeDTD")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writedtd(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_writedtd(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_writedtd(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtd(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openMemory")) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endCData")) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writeComment")) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writecomment(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startAttribute")) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startattribute(arg0));
        }
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeElement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_writeelement(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeelement(arg0, arg1));
        }
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_text(arg0));
        }
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startCData")) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endPI")) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writeDTDAttlist")) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtdattlist(arg0, arg1));
        }
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setIndentString")) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindentstring(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endElement")) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endComment")) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeRaw")) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_writeraw(arg0));
        }
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startDocument")) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_startdocument());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_startdocument(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_startdocument(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startdocument(arg0, arg1, arg2));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputMemory")) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_outputmemory());
          CVarRef arg0((ad->getValue(pos)));
          return (t_outputmemory(arg0));
        }
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openURI")) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_openuri(arg0));
        }
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "endDTD")) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writeDTDEntity")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_writedtdentity(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_writedtdentity(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_writedtdentity(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4));
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtdentity(arg0, arg1, arg2, arg3, arg4, arg5));
        }
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "endDTDElement")) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeAttribute")) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeattribute(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endAttribute")) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startAttributens")) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writeDTDElement")) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writedtdelement(arg0, arg1));
        }
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeAttributeNS")) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeattributens(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "endDTDEntity")) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writePI")) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writepi(arg0, arg1));
        }
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeElementNS")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 3) return (t_writeelementns(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_writeelementns(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startPI")) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startpi(arg0));
        }
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "endDocument")) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startDTDEntity")) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startdtdentity(arg0, arg1));
        }
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startElement")) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startelement(arg0));
        }
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setIndent")) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setindent(arg0));
        }
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startElementNS")) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_startelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startDTDAttlist")) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdattlist(arg0));
        }
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "endDTDAttlist")) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startDTDElement")) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_startdtdelement(arg0));
        }
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_flush());
          CVarRef arg0((ad->getValue(pos)));
          return (t_flush(arg0));
        }
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullEndElement")) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startComment")) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_XMLWriter
Variant c_XMLWriter::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x18f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 0x192:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        return (t_outputmemory(a0));
      }
      break;
    case 0x191:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 0x190:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 0x193:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        if (count == 1) return (t_startdocument(a0));
        if (count == 2) return (t_startdocument(a0, a1));
        return (t_startdocument(a0, a1, a2));
      }
      break;
    case 0x194:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 0x195:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 0x196:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(a0));
      }
      break;
    case 0x197:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(a0, a1));
      }
      break;
    case 0x198:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x199:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(a0));
        if (count == 2) return (t_writedtd(a0, a1));
        if (count == 3) return (t_writedtd(a0, a1, a2));
        return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x19a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      break;
    case 0x19b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 0x19c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(a0));
      }
      break;
    case 0x19d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 0x19e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(a0));
      }
      break;
    case 0x1a0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 0x19f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(a0));
      }
      break;
    case 0x1a1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 0x1a2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 0x1a3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(a0, a1));
      }
      break;
    case 0x1a4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(a0));
      }
      break;
    case 0x1a5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(a0));
      }
      break;
    case 0x1a6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(a0));
        return (t_writeelement(a0, a1));
      }
      break;
    case 0x1a7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 0x1a8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(a0));
      }
      break;
    case 0x1a9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(a0, a1));
        if (count == 3) return (t_writedtdentity(a0, a1, a2));
        if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x1aa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 0x1ab:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(a0));
        if (count == 2) return (t_startdtd(a0, a1));
        return (t_startdtd(a0, a1, a2));
      }
      break;
    case 0x1ac:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(a0));
      }
      break;
    case 0x1ad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 0x1ae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(a0));
      }
      break;
    case 0x1af:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 0x1b0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 0x1b1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 0x1b3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(a0));
      }
      break;
    case 0x1b2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 0x1b4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 0x1b5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(a0));
      }
      break;
    case 0x1b6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(a0));
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 0x1b7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writeCData")) {
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startDTD")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(a0));
        if (count == 2) return (t_startdtd(a0, a1));
        return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writeDTD")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(a0));
        if (count == 2) return (t_writedtd(a0, a1));
        if (count == 3) return (t_writedtd(a0, a1, a2));
        return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openMemory")) {
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endCData")) {
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writeComment")) {
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(a0));
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startAttribute")) {
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeElement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(a0));
        return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startCData")) {
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endPI")) {
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writeDTDAttlist")) {
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setIndentString")) {
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endElement")) {
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endComment")) {
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeRaw")) {
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startDocument")) {
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        if (count == 1) return (t_startdocument(a0));
        if (count == 2) return (t_startdocument(a0, a1));
        return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputMemory")) {
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openURI")) {
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "endDTD")) {
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writeDTDEntity")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(a0, a1));
        if (count == 3) return (t_writedtdentity(a0, a1, a2));
        if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "endDTDElement")) {
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeAttribute")) {
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endAttribute")) {
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startAttributens")) {
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writeDTDElement")) {
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeAttributeNS")) {
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "endDTDEntity")) {
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writePI")) {
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeElementNS")) {
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startPI")) {
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "endDocument")) {
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startDTDEntity")) {
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startElement")) {
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setIndent")) {
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startElementNS")) {
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startDTDAttlist")) {
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "endDTDAttlist")) {
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startDTDElement")) {
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullEndElement")) {
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startComment")) {
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_XMLWriter
Variant c_XMLWriter::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_XMLWriter
Variant c_XMLWriter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x18f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 0x192:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 0x191:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdattlist());
      }
      break;
    case 0x190:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fullendelement());
      }
      break;
    case 0x193:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 0x194:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 0x195:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcdata());
      }
      break;
    case 0x196:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecomment(a0));
      }
      break;
    case 0x197:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattribute(a0, a1));
      }
      break;
    case 0x198:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcomment());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x199:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x19a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdentity());
      }
      break;
    case 0x19b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 0x19c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelement(a0));
      }
      break;
    case 0x19d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 0x19e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdelement(a0));
      }
      break;
    case 0x1a0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddocument());
      }
      break;
    case 0x19f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecdata(a0));
      }
      break;
    case 0x1a1:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 0x1a2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 0x1a3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writepi(a0, a1));
      }
      break;
    case 0x1a4:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindentstring(a0));
      }
      break;
    case 0x1a5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattribute(a0));
      }
      break;
    case 0x1a6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 0x1a7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endelement());
      }
      break;
    case 0x1a8:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeraw(a0));
      }
      break;
    case 0x1a9:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 0x1aa:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endpi());
      }
      break;
    case 0x1ab:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 0x1ac:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindent(a0));
      }
      break;
    case 0x1ad:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdelement());
      }
      break;
    case 0x1ae:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdattlist(a0));
      }
      break;
    case 0x1af:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcdata());
      }
      break;
    case 0x1b0:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 0x1b1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtd());
      }
      break;
    case 0x1b3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openuri(a0));
      }
      break;
    case 0x1b2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openmemory());
      }
      break;
    case 0x1b4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endattribute());
      }
      break;
    case 0x1b5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startpi(a0));
      }
      break;
    case 0x1b6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_text(a0));
      }
      break;
    case 0xe2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 0x1b7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss6b6b0982, "writeCData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss1695307d, "startDTD")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6454c9f8, "writeDTD")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss3c1810f2, "openMemory")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss41766610, "endCData")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss67e5bf6d, "writeComment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writecomment(a0));
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss6994ff13, "startAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss783b919c, "writeElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss066bb11d, "text")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss44c01b20, "startCData")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss168d5c21, "endPI")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss676f3a57, "writeDTDAttlist")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss0e528c55, "setIndentString")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6ef2f4af, "endElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss6221914b, "endComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss61a59c37, "writeRaw")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss5004e1c8, "startDocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss5c6641ba, "outputMemory")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss7f524842, "openURI")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss28588ebc, "endDTD")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss3f2511ba, "writeDTDEntity")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss7029ccc7, "endDTDElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss306ccccb, "writeAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss0ff886cb, "endAttribute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss5b36d24d, "startAttributens")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss6dc68bae, "writeDTDElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss105383ac, "writeAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss05a382d6, "endDTDEntity")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss391170aa, "writePI")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss310bf058, "writeElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss5183bea7, "startPI")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss0a2f63dc, "endDocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss24ea1add, "startDTDEntity")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss717efd62, "startElement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss4a119a1b, "setIndent")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss21ed1e97, "startElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss542b7d70, "startDTDAttlist")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss2ad1e88f, "endDTDAttlist")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss7145d508, "startDTDElement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss24ffa186, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss0bfb9ffe, "fullEndElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss7f0466ff, "startComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_XMLWriter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_XMLWriter = {
  c_XMLWriter::os_getInit,
  c_XMLWriter::os_get,
  c_XMLWriter::os_lval,
  c_XMLWriter::os_invoke,
  c_XMLWriter::os_constant,
};
Object co_DOMException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMException)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMException
Variant c_DOMException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMException
Variant c_DOMException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMException
Variant &c_DOMException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMException
void c_DOMException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMException
void c_DOMException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMException
Variant * c_DOMException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMException
Variant * c_DOMException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMException
Variant * c_DOMException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMException
Variant c_DOMException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMException
IMPLEMENT_CLASS(DOMException)
c_DOMException *c_DOMException::create(String a0, int64 a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMException::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_DOMException::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMException::cloneImpl() {
  c_DOMException *obj = NEW(c_DOMException)();
  cloneSet(obj);
  return obj;
}
void c_DOMException::cloneSet(c_DOMException *clone) {
  c_Exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMException
Variant c_DOMException::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMException
Variant c_DOMException::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMException
Variant c_DOMException::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMException
Variant c_DOMException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMException = {
  c_DOMException::os_getInit,
  c_DOMException::os_get,
  c_DOMException::os_lval,
  c_DOMException::os_invoke,
  c_DOMException::os_constant,
};
Object co_DOMXPath(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMXPath)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMXPath
Variant c_DOMXPath::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMXPath
Variant c_DOMXPath::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMXPath
Variant &c_DOMXPath::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMXPath
void c_DOMXPath::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMXPath
void c_DOMXPath::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMXPath
Variant * c_DOMXPath::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMXPath
Variant * c_DOMXPath::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMXPath
Variant * c_DOMXPath::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMXPath
Variant c_DOMXPath::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMXPath
IMPLEMENT_CLASS(DOMXPath)
c_DOMXPath *c_DOMXPath::create(Variant a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMXPath::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMXPath::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMXPath::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
void c_DOMXPath::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMXPath::cloneImpl() {
  c_DOMXPath *obj = NEW(c_DOMXPath)();
  cloneSet(obj);
  return obj;
}
void c_DOMXPath::cloneSet(c_DOMXPath *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMXPath
Variant c_DOMXPath::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_query(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_query(arg0, arg1));
        }
      }
      break;
    case 0x7d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_evaluate(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_evaluate(arg0, arg1));
        }
      }
      break;
    case 0x7e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_registerphpfunctions());
          CVarRef arg0((ad->getValue(pos)));
          return (t_registerphpfunctions(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x7f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_registernamespace(arg0, arg1));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerPHPFunctions")) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_registerphpfunctions());
          CVarRef arg0((ad->getValue(pos)));
          return (t_registerphpfunctions(arg0));
        }
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_query(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_query(arg0, arg1));
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registerNamespace")) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_registernamespace(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_evaluate(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_evaluate(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMXPath
Variant c_DOMXPath::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(a0));
        return (t_query(a0, a1));
      }
      break;
    case 0x7d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(a0));
        return (t_evaluate(a0, a1));
      }
      break;
    case 0x7e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        return (t_registerphpfunctions(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x7f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerPHPFunctions")) {
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(a0));
        return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registerNamespace")) {
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(a0));
        return (t_evaluate(a0, a1));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMXPath
Variant c_DOMXPath::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMXPath
Variant c_DOMXPath::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0x7c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 0x7d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      break;
    case 0x7e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x7f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss4c8b547e, "registerPHPFunctions")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss414da377, "query")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss797e4f18, "registerNamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss6f3c912f, "evaluate")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMXPath::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMXPath = {
  c_DOMXPath::os_getInit,
  c_DOMXPath::os_get,
  c_DOMXPath::os_lval,
  c_DOMXPath::os_invoke,
  c_DOMXPath::os_constant,
};
Object co_SoapServer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapServer)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapServer
Variant c_SoapServer::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapServer
Variant c_SoapServer::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapServer
Variant &c_SoapServer::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapServer
void c_SoapServer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapServer
void c_SoapServer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapServer
Variant * c_SoapServer::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapServer
Variant * c_SoapServer::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapServer
Variant * c_SoapServer::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapServer
Variant c_SoapServer::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapServer
IMPLEMENT_CLASS(SoapServer)
c_SoapServer *c_SoapServer::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapServer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_SoapServer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_SoapServer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_SoapServer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapServer::cloneImpl() {
  c_SoapServer *obj = NEW(c_SoapServer)();
  cloneSet(obj);
  return obj;
}
void c_SoapServer::cloneSet(c_SoapServer *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapServer
Variant c_SoapServer::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x173:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addfunction(arg0), null);
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x129:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 0x174:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addsoapheader(arg0), null);
        }
      }
      break;
    case 0x175:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setpersistence(arg0), null);
        }
      }
      break;
    case 0x176:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_handle(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t_handle(arg0), null);
        }
      }
      break;
    case 0x177:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setobject(arg0), null);
        }
      }
      break;
    case 0x178:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_fault(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_fault(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_fault(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fault(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 0x179:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setclass(count, arg0), null);
          return (t_setclass(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_fault(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_fault(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_fault(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_fault(arg0, arg1, arg2, arg3, arg4), null);
        }
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setpersistence(arg0), null);
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_handle(), null);
          CVarRef arg0((ad->getValue(pos)));
          return (t_handle(arg0), null);
        }
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_setclass(count, arg0), null);
          return (t_setclass(count,arg0, params.slice(1, count - 1, false)), null);
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setobject(arg0), null);
        }
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addsoapheader(arg0), null);
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_addfunction(arg0), null);
        }
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapServer
Variant c_SoapServer::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x173:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(a0), null);
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x129:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 0x174:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(a0), null);
      }
      break;
    case 0x175:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(a0), null);
      }
      break;
    case 0x176:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        return (t_handle(a0), null);
      }
      break;
    case 0x177:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(a0), null);
      }
      break;
    case 0x178:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(a0, a1), null);
        if (count == 3) return (t_fault(a0, a1, a2), null);
        if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x179:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setclass(count,a0, params), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(a0, a1), null);
        if (count == 3) return (t_fault(a0, a1, a2), null);
        if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, a0), null);
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_setclass(count,a0, params), null);
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(a0), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapServer
Variant c_SoapServer::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapServer
Variant c_SoapServer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x173:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addfunction(a0), null);
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x129:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 0x174:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addsoapheader(a0), null);
      }
      break;
    case 0x175:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setpersistence(a0), null);
      }
      break;
    case 0x176:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 0x177:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setobject(a0), null);
      }
      break;
    case 0x178:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 0x179:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss590fe203, "fault")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss1f596cd8, "setpersistence")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss1dd0e851_1, "getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss0babeace, "handle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss3b08f7cc, "setclass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss4fe626b9, "setobject")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss358b69c2, "addsoapheader")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss397d2d9f, "addfunction")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_addfunction(a0), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapServer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SoapServer = {
  c_SoapServer::os_getInit,
  c_SoapServer::os_get,
  c_SoapServer::os_lval,
  c_SoapServer::os_invoke,
  c_SoapServer::os_constant,
};
Object co_DOMNode(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNode)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNode
Variant c_DOMNode::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNode
Variant c_DOMNode::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNode
Variant &c_DOMNode::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNode
void c_DOMNode::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNode
void c_DOMNode::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNode
Variant * c_DOMNode::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNode
Variant * c_DOMNode::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNode
Variant * c_DOMNode::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNode
Variant c_DOMNode::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNode
IMPLEMENT_CLASS(DOMNode)
c_DOMNode *c_DOMNode::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNode::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNode::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNode::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_DOMNode::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNode::cloneImpl() {
  c_DOMNode *obj = NEW(c_DOMNode)();
  cloneSet(obj);
  return obj;
}
void c_DOMNode::cloneSet(c_DOMNode *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNode
Variant c_DOMNode::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNode
Variant c_DOMNode::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNode
Variant c_DOMNode::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMNode
Variant c_DOMNode::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNode::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMNode = {
  c_DOMNode::os_getInit,
  c_DOMNode::os_get,
  c_DOMNode::os_lval,
  c_DOMNode::os_invoke,
  c_DOMNode::os_constant,
};
Object co_DOMDocument(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocument)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocument
Variant c_DOMDocument::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocument
Variant c_DOMDocument::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocument
Variant &c_DOMDocument::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocument
void c_DOMDocument::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocument
void c_DOMDocument::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocument
Variant * c_DOMDocument::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocument
Variant * c_DOMDocument::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocument
Variant * c_DOMDocument::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocument
Variant c_DOMDocument::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocument
IMPLEMENT_CLASS(DOMDocument)
c_DOMDocument *c_DOMDocument::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMDocument::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMDocument::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMDocument::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
void c_DOMDocument::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocument::cloneImpl() {
  c_DOMDocument *obj = NEW(c_DOMDocument)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocument::cloneSet(c_DOMDocument *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocument
Variant c_DOMDocument::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      break;
    case 0x49:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcdatasection(arg0));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x4a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      break;
    case 0x4c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidatesource(arg0));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x4d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidate(arg0));
        }
      }
      break;
    case 0x4e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtml(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x4f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createentityreference(arg0));
        }
      }
      break;
    case 0x50:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidate(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x51:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_savexml());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_savexml(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_savexml(arg0, arg1));
        }
      }
      break;
    case 0x52:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createprocessinginstruction(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createprocessinginstruction(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      break;
    case 0x53:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_registernodeclass(arg0, arg1));
        }
      }
      break;
    case 0x54:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_load(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_load(arg0, arg1));
        }
      }
      break;
    case 0x55:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createattributens(arg0, arg1));
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x56:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createelement(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createelement(arg0, arg1));
        }
      }
      break;
    case 0x57:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_createelementns(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x58:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_importnode(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_importnode(arg0, arg1));
        }
      }
      break;
    case 0x59:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidatesource(arg0));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x5a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createtextnode(arg0));
        }
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x5b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 0x5c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_loadxml(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_loadxml(arg0, arg1));
        }
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x5d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_save(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_save(arg0, arg1));
        }
      }
      break;
    case 0x5e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createattribute(arg0));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x5f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_xinclude());
          CVarRef arg0((ad->getValue(pos)));
          return (t_xinclude(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x60:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtmlfile(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x61:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_savehtmlfile(arg0));
        }
      }
      break;
    case 0x62:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementbyid(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x63:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcomment(arg0));
        }
      }
      break;
    case 0x64:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 0x65:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getElementById")) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementbyid(arg0));
        }
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_xinclude());
          CVarRef arg0((ad->getValue(pos)));
          return (t_xinclude(arg0));
        }
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createCDATASection")) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcdatasection(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemaValidateSource")) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidatesource(arg0));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_save(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_save(arg0, arg1));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createAttributens")) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createattributens(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxNGValidate")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidate(arg0));
        }
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadHTML")) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtml(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createElement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createelement(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createelement(arg0, arg1));
        }
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxNGValidateSource")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_relaxngvalidatesource(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createAttribute")) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createattribute(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importNode")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_importnode(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_importnode(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadHTMLFile")) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_loadhtmlfile(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadXML")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_loadxml(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_loadxml(arg0, arg1));
        }
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createEntityReference")) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createentityreference(arg0));
        }
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createComment")) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createcomment(arg0));
        }
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemaValidate")) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_schemavalidate(arg0));
        }
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "saveHTMLFile")) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_savehtmlfile(arg0));
        }
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "saveHTML")) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t___construct(), null);
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1), null);
        }
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_load(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_load(arg0, arg1));
        }
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "saveXML")) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_savexml());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_savexml(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_savexml(arg0, arg1));
        }
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizeDocument")) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createElementNS")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t_createelementns(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createelementns(arg0, arg1, arg2));
        }
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createProcessingInstruction")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_createprocessinginstruction(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_createprocessinginstruction(arg0, arg1));
        }
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registerNodeClass")) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_registernodeclass(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createDocumentFragment")) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createTextNode")) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_createtextnode(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocument
Variant c_DOMDocument::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x49:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x4c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x4d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(a0));
      }
      break;
    case 0x4e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x4f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(a0));
      }
      break;
    case 0x50:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x51:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        if (count == 1) return (t_savexml(a0));
        return (t_savexml(a0, a1));
      }
      break;
    case 0x52:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(a0));
        return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      break;
    case 0x53:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(a0, a1));
      }
      break;
    case 0x54:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(a0));
        return (t_load(a0, a1));
      }
      break;
    case 0x55:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(a0, a1));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x56:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(a0));
        return (t_createelement(a0, a1));
      }
      break;
    case 0x57:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(a0, a1));
        return (t_createelementns(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x58:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(a0));
        return (t_importnode(a0, a1));
      }
      break;
    case 0x59:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x5a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x5b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 0x5c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(a0));
        return (t_loadxml(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x5d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(a0));
        return (t_save(a0, a1));
      }
      break;
    case 0x5e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(a0));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x5f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        return (t_xinclude(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x60:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x61:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(a0));
      }
      break;
    case 0x62:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x63:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(a0));
      }
      break;
    case 0x64:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 0x65:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getElementById")) {
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createCDATASection")) {
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemaValidateSource")) {
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(a0));
        return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createAttributens")) {
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxNGValidate")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadHTML")) {
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(a0));
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createElement")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(a0));
        return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxNGValidateSource")) {
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createAttribute")) {
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importNode")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(a0));
        return (t_importnode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadHTMLFile")) {
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadXML")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(a0));
        return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createEntityReference")) {
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createComment")) {
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemaValidate")) {
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "saveHTMLFile")) {
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "saveHTML")) {
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(a0));
        return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "saveXML")) {
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        if (count == 1) return (t_savexml(a0));
        return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizeDocument")) {
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createElementNS")) {
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(a0, a1));
        return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createProcessingInstruction")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(a0));
        return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registerNodeClass")) {
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createDocumentFragment")) {
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createTextNode")) {
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMDocument
Variant c_DOMDocument::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMDocument
Variant c_DOMDocument::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x49:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcdatasection(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_validate());
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x4c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidatesource(a0));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x4d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidate(a0));
      }
      break;
    case 0x4e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtml(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x4f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createentityreference(a0));
      }
      break;
    case 0x50:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidate(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x51:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 0x52:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    case 0x53:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernodeclass(a0, a1));
      }
      break;
    case 0x54:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 0x55:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattributens(a0, a1));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x56:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 0x57:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x58:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      break;
    case 0x59:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidatesource(a0));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x5a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createtextnode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x5b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtml());
      }
      break;
    case 0x5c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x5d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 0x5e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattribute(a0));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x5f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x60:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtmlfile(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x61:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtmlfile(a0));
      }
      break;
    case 0x62:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementbyid(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 0x63:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcomment(a0));
      }
      break;
    case 0x64:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalizedocument(), null);
      }
      break;
    case 0x65:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createdocumentfragment());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss6601e385, "getElementById")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss31b5b176, "xinclude")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss3ebf7f0d, "createCDATASection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcdatasection(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss7b13afef, "schemaValidateSource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidatesource(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss5b92faec, "save")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss58a514eb, "createAttributens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattributens(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss7cd10a1c, "relaxNGValidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss7c8404a2, "loadHTML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtml(a0));
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss35b39fa2, "createElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss6e006fac, "relaxNGValidateSource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss0fe9a82c, "createAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss47732bd1, "importNode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss13f14aaf, "loadHTMLFile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss2b7ae431, "loadXML")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss352f67ce, "createEntityReference")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createentityreference(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss2262f737, "validate")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_validate());
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss39033f39, "createComment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss5423a9b8, "schemaValidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss3ed3054d, "saveHTMLFile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtmlfile(a0));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss058310d3, "saveHTML")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_savehtml());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss4a0943df, "load")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss2223cd1b, "saveXML")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss4d01c296, "normalizeDocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss16b7ebeb, "createElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss39184593, "createProcessingInstruction")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss71e14c8b, "registerNodeClass")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_registernodeclass(a0, a1));
      }
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss0b15b908, "createDocumentFragment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createdocumentfragment());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss67aa2805, "createTextNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocument::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMDocument = {
  c_DOMDocument::os_getInit,
  c_DOMDocument::os_get,
  c_DOMDocument::os_lval,
  c_DOMDocument::os_invoke,
  c_DOMDocument::os_constant,
};
Object co_LibXMLError(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_LibXMLError)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LibXMLError
Variant c_LibXMLError::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_LibXMLError
Variant c_LibXMLError::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LibXMLError
Variant &c_LibXMLError::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_LibXMLError
void c_LibXMLError::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_LibXMLError
void c_LibXMLError::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_LibXMLError
Variant * c_LibXMLError::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LibXMLError
Variant * c_LibXMLError::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LibXMLError
Variant * c_LibXMLError::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_LibXMLError
Variant c_LibXMLError::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_LibXMLError
IMPLEMENT_CLASS(LibXMLError)
c_LibXMLError *c_LibXMLError::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_LibXMLError::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_LibXMLError::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_LibXMLError::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(), null);
}
void c_LibXMLError::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_LibXMLError::cloneImpl() {
  c_LibXMLError *obj = NEW(c_LibXMLError)();
  cloneSet(obj);
  return obj;
}
void c_LibXMLError::cloneSet(c_LibXMLError *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_LibXMLError
Variant c_LibXMLError::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_LibXMLError
Variant c_LibXMLError::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_LibXMLError
Variant c_LibXMLError::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_LibXMLError
Variant c_LibXMLError::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_LibXMLError::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_LibXMLError = {
  c_LibXMLError::os_getInit,
  c_LibXMLError::os_get,
  c_LibXMLError::os_lval,
  c_LibXMLError::os_invoke,
  c_LibXMLError::os_constant,
};
Object co_SoapFault(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapFault)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapFault
Variant c_SoapFault::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapFault
Variant c_SoapFault::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapFault
Variant &c_SoapFault::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapFault
void c_SoapFault::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapFault
void c_SoapFault::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapFault
Variant * c_SoapFault::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapFault
Variant * c_SoapFault::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapFault
Variant * c_SoapFault::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapFault
Variant c_SoapFault::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapFault
IMPLEMENT_CLASS(SoapFault)
c_SoapFault *c_SoapFault::create(Variant a0, String a1, String a2, Variant a3, String a4, Variant a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_SoapFault::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_SoapFault::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_SoapFault::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
void c_SoapFault::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapFault::cloneImpl() {
  c_SoapFault *obj = NEW(c_SoapFault)();
  cloneSet(obj);
  return obj;
}
void c_SoapFault::cloneSet(c_SoapFault *clone) {
  c_Exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapFault
Variant c_SoapFault::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count <= 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 5) return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
          CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_SoapFault
Variant c_SoapFault::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapFault
Variant c_SoapFault::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_SoapFault
Variant c_SoapFault::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x19:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    case 0x1b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 0x1c:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 0x1d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 0x1e:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 0x1f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 0x20:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x625661A755F425C0LL, NAMSTR(s_sys_ss55f425c0, "__init__")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___init__(), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x31D981FD9D2728E3LL, NAMSTR(s_sys_ss62d8d71d, "getLine")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x03CA4360169ECC8ALL, NAMSTR(s_sys_ss169ecc8a, "getTraceAsString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss1dc3d04f, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x71859D7313E682D2LL, NAMSTR(s_sys_ss13e682d2, "getMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed_1, "__tostring")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x6800B2B4C4EC4CBALL, NAMSTR(s_sys_ss3b13b346, "getTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3CE90CB8F0C9579ELL, NAMSTR(s_sys_ss0f36a862, "getFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  #endif
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapFault::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_SoapFault = {
  c_SoapFault::os_getInit,
  c_SoapFault::os_get,
  c_SoapFault::os_lval,
  c_SoapFault::os_invoke,
  c_SoapFault::os_constant,
};
Object co_DOMElement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMElement)())->dynCreate(params, init));
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMElement
Variant c_DOMElement::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMElement
Variant c_DOMElement::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMElement
Variant &c_DOMElement::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMElement
void c_DOMElement::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMElement
void c_DOMElement::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMElement
Variant * c_DOMElement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMElement
Variant * c_DOMElement::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMElement
Variant * c_DOMElement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMElement
Variant c_DOMElement::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMElement
IMPLEMENT_CLASS(DOMElement)
c_DOMElement *c_DOMElement::create(String a0, String a1, String a2) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2);
  return this;
}
ObjectData *c_DOMElement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2));
    } while (false);
  }
  return this;
}
void c_DOMElement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2));
  } while (false);
}
void c_DOMElement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else (t___construct(a0, a1, a2), null);
}
void c_DOMElement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMElement::cloneImpl() {
  c_DOMElement *obj = NEW(c_DOMElement)();
  cloneSet(obj);
  return obj;
}
void c_DOMElement::cloneSet(c_DOMElement *clone) {
  c_DOMNode::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMElement
Variant c_DOMElement::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      break;
    case 0x67:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setidattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      break;
    case 0x68:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getattributenodens(arg0, arg1));
        }
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2), null);
        }
      }
      break;
    case 0x69:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasattribute(arg0));
        }
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 0x6a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_hasattributens(arg0, arg1));
        }
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x6b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenodens(arg0));
        }
      }
      break;
    case 0x6c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 0x6d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getattributens(arg0, arg1));
        }
      }
      break;
    case 0x6e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_removeattributens(arg0, arg1));
        }
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x6f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattributenode(arg0));
        }
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x70:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setidattribute(arg0, arg1));
        }
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 0x71:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setidattributenode(arg0, arg1));
        }
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 0x72:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattributenode(arg0));
        }
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      break;
    case 0x73:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattribute(arg0));
        }
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x74:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenode(arg0));
        }
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_c14n());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_c14n(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14n(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14n(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14n(arg0, arg1, arg2, arg3));
        }
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a_1, "setAttribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattribute(arg0, arg1));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_replacechild(arg0, arg1));
        }
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___get(arg0));
        }
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeAttributeNS")) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_removeattributens(arg0, arg1));
        }
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setIDAttributeNS")) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setidattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_clonenode());
          CVarRef arg0((ad->getValue(pos)));
          return (t_clonenode(arg0));
        }
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___set(arg0, arg1));
        }
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setIDAttribute")) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setidattribute(arg0, arg1));
        }
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getAttributeNodeNS")) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getattributenodens(arg0, arg1));
        }
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getAttributeNS")) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getattributens(arg0, arg1));
        }
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28_1, "getAttribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattribute(arg0));
        }
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeAttribute")) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattribute(arg0));
        }
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_insertbefore(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_insertbefore(arg0, arg1));
        }
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getelementsbytagname(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_getelementsbytagnamens(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setIDAttributeNode")) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setidattributenode(arg0, arg1));
        }
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_appendchild(arg0));
        }
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setAttributeNodeNS")) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenodens(arg0));
        }
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasAttributeNS")) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_hasattributens(arg0, arg1));
        }
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setAttributeNS")) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_setattributens(arg0, arg1, arg2));
        }
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setAttributeNode")) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setattributenode(arg0));
        }
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupnamespaceuri(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removechild(arg0));
        }
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          return (t___construct(arg0, arg1, arg2), null);
        }
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_lookupprefix(arg0));
        }
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_isdefaultnamespace(arg0));
        }
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeAttributeNode")) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_removeattributenode(arg0));
        }
      }
      break;
    case 108:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasAttribute")) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_hasattribute(arg0));
        }
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_issamenode(arg0));
        }
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t_c14nfile(arg0));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 2) return (t_c14nfile(arg0, arg1));
          CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 3) return (t_c14nfile(arg0, arg1, arg2));
          CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
          if (count == 4) return (t_c14nfile(arg0, arg1, arg2, arg3));
          CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_c14nfile(arg0, arg1, arg2, arg3, arg4));
        }
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
          return (t_issupported(arg0, arg1));
        }
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getAttributeNode")) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_getattributenode(arg0));
        }
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_DOMElement
Variant c_DOMElement::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  #ifndef NOFMCGEN
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x67:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x68:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        return (t___construct(a0, a1, a2), null);
      }
      break;
    case 0x69:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(a0));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x6a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 0x6b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(a0));
      }
      break;
    case 0x6c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 0x6d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(a0, a1));
      }
      break;
    case 0x6e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(a0, a1));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 0x6f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 0x70:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 0x71:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x72:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      break;
    case 0x73:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 0x74:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        if (count == 1) return (t_c14n(a0));
        if (count == 2) return (t_c14n(a0, a1));
        if (count == 3) return (t_c14n(a0, a1, a2));
        return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a_1, "setAttribute")) {
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeAttributeNS")) {
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setIDAttributeNS")) {
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setIDAttribute")) {
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getAttributeNodeNS")) {
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getAttributeNS")) {
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28_1, "getAttribute")) {
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeAttribute")) {
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setIDAttributeNode")) {
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setAttributeNodeNS")) {
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasAttributeNS")) {
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setAttributeNS")) {
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setAttributeNode")) {
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeAttributeNode")) {
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasAttribute")) {
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        if (count == 2) return (t_c14nfile(a0, a1));
        if (count == 3) return (t_c14nfile(a0, a1, a2));
        if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getAttributeNode")) {
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMElement
Variant c_DOMElement::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  #ifndef NOFMCGEN
  #else
  #endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_DOMElement
Variant c_DOMElement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0x2d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      break;
    case 0x2e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 0x48:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      break;
    case 0x67:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 0x21:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 0x2f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 0x4b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 0x68:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 0x31:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      break;
    case 0x32:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 0x23:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 0x33:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 0x34:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 0x69:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattribute(a0));
      }
      break;
    case 0x35:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 0x6a:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributens(a0, a1));
      }
      break;
    case 0x37:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 0x36:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 0x6b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenodens(a0));
      }
      break;
    case 0x6c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 0x38:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 0x6d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributens(a0, a1));
      }
      break;
    case 0x6e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributens(a0, a1));
      }
      break;
    case 0x39:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 0x6f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenode(a0));
      }
      break;
    case 0x3a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 0x70:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattribute(a0, a1));
      }
      break;
    case 0x3b:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 0x3c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 0x71:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 0x29:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 0x72:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributenode(a0));
      }
      break;
    case 0x3d:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 0x3e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 0x3f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      break;
    case 0x73:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattribute(a0));
      }
      break;
    case 0x40:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 0x74:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenode(a0));
      }
      break;
    default:
      break;
  }
  #else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss3a7d1276, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss44f4ab8a_1, "setAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss2356d08e, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss74fa338f, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss1e1a0890, "removeAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss57ae11ef, "setIDAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributens(a0, a1, a2));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss5fb1cf6e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss7ccbfc6b, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss1eef29ea, "setIDAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattribute(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss5061a2e8, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlineno());
      }
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss237f13e8, "getAttributeNodeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss6d3f0899, "getAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributens(a0, a1));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss6612fc28_1, "getAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss39d1e1d1, "removeAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattribute(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss090a514f, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss6e7a3bcd, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss716ae343, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnodepath());
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss13546c36, "getElementsByTagName")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss35b7e836, "getElementsByTagNameNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss43f325b6, "setIDAttributeNode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setidattributenode(a0, a1));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss023e75cf, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_appendchild(a0));
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss306253d1, "setAttributeNodeNS")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenodens(a0));
      }
      break;
    case 85:
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss5311d955, "hasAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattributens(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss050e6ea9, "setAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss42cb6c5a, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_normalize(), null);
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss5cf34c5c, "setAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setattributenode(a0));
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss57c470a3, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss49ac9b23, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removechild(a0));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss6934829f, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_lookupprefix(a0));
      }
      break;
    case 100:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss6c87099c, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss2ea150ea, "removeAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_removeattributenode(a0));
      }
      break;
    case 108:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss46bb0014, "hasAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasattribute(a0));
      }
      break;
    case 111:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss35d13911, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issamenode(a0));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5533e10d, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss30c9a58b, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss14b7677a, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss5afa6a06, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildnodes());
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss44a54e02, "getAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  #endif
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMElement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  #ifndef NOFMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  #else
  #endif
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_DOMElement = {
  c_DOMElement::os_getInit,
  c_DOMElement::os_get,
  c_DOMElement::os_lval,
  c_DOMElement::os_invoke,
  c_DOMElement::os_constant,
};
Variant get_builtin_class_var_init(const char *s, const char *var) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_GET_CLASS_VAR_INIT(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_GET_CLASS_VAR_INIT(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_GET_CLASS_VAR_INIT(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_GET_CLASS_VAR_INIT(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_GET_CLASS_VAR_INIT(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_GET_CLASS_VAR_INIT(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_GET_CLASS_VAR_INIT(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_GET_CLASS_VAR_INIT(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_GET_CLASS_VAR_INIT(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_GET_CLASS_VAR_INIT(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_GET_CLASS_VAR_INIT(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_GET_CLASS_VAR_INIT(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_GET_CLASS_VAR_INIT(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_GET_CLASS_VAR_INIT(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_GET_CLASS_VAR_INIT(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_GET_CLASS_VAR_INIT(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_GET_CLASS_VAR_INIT(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_GET_CLASS_VAR_INIT(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_GET_CLASS_VAR_INIT(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_GET_CLASS_VAR_INIT(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_GET_CLASS_VAR_INIT(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_GET_CLASS_VAR_INIT(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_GET_CLASS_VAR_INIT(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 75:
      HASH_GET_CLASS_VAR_INIT(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_GET_CLASS_VAR_INIT(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_GET_CLASS_VAR_INIT(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_GET_CLASS_VAR_INIT(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_GET_CLASS_VAR_INIT(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_GET_CLASS_VAR_INIT(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_GET_CLASS_VAR_INIT(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_GET_CLASS_VAR_INIT(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_GET_CLASS_VAR_INIT(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_GET_CLASS_VAR_INIT(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_GET_CLASS_VAR_INIT(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_GET_CLASS_VAR_INIT(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_GET_CLASS_VAR_INIT(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_GET_CLASS_VAR_INIT(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_GET_CLASS_VAR_INIT(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_GET_CLASS_VAR_INIT(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_GET_CLASS_VAR_INIT(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_GET_CLASS_VAR_INIT(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_GET_CLASS_VAR_INIT(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_GET_CLASS_VAR_INIT(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_GET_CLASS_VAR_INIT(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_GET_CLASS_VAR_INIT(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_GET_CLASS_VAR_INIT(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_GET_CLASS_VAR_INIT(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_GET_CLASS_VAR_INIT(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_GET_CLASS_VAR_INIT(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_GET_CLASS_VAR_INIT(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_GET_CLASS_VAR_INIT(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_GET_CLASS_VAR_INIT(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_GET_CLASS_VAR_INIT(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_GET_CLASS_VAR_INIT(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_GET_CLASS_VAR_INIT(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_GET_CLASS_VAR_INIT(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_GET_CLASS_VAR_INIT(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_GET_CLASS_VAR_INIT(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_GET_CLASS_VAR_INIT(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_GET_CLASS_VAR_INIT(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_GET_CLASS_VAR_INIT(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_GET_CLASS_VAR_INIT(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_GET_CLASS_VAR_INIT(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_GET_CLASS_VAR_INIT(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_GET_CLASS_VAR_INIT(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_GET_CLASS_VAR_INIT(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_GET_CLASS_VAR_INIT(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_GET_CLASS_VAR_INIT(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_GET_CLASS_VAR_INIT(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_GET_CLASS_VAR_INIT(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_GET_CLASS_VAR_INIT(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_GET_CLASS_VAR_INIT(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_GET_CLASS_VAR_INIT(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_GET_CLASS_VAR_INIT(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_GET_CLASS_VAR_INIT(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_GET_CLASS_VAR_INIT(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_GET_CLASS_VAR_INIT(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_GET_CLASS_VAR_INIT(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_GET_CLASS_VAR_INIT(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_GET_CLASS_VAR_INIT(0x74419B70A46387FDLL, DOMImplementation);
      break;
    case 255:
      HASH_GET_CLASS_VAR_INIT(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Object create_builtin_object(const char *s, CArrRef params, bool init /* = true */,ObjectData* root /* = NULL*/) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_CREATE_OBJECT(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_CREATE_OBJECT(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_CREATE_OBJECT(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_CREATE_OBJECT(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_CREATE_OBJECT(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_CREATE_OBJECT(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_CREATE_OBJECT(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_CREATE_OBJECT(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_CREATE_OBJECT(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_CREATE_OBJECT(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_CREATE_OBJECT(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_CREATE_OBJECT(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_CREATE_OBJECT(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_CREATE_OBJECT(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_CREATE_OBJECT(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_CREATE_OBJECT(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_CREATE_OBJECT(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_CREATE_OBJECT(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_CREATE_OBJECT(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_CREATE_OBJECT(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_CREATE_OBJECT(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_CREATE_OBJECT(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_CREATE_OBJECT(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 75:
      HASH_CREATE_OBJECT(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_CREATE_OBJECT(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_CREATE_OBJECT(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_CREATE_OBJECT(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_CREATE_OBJECT(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_CREATE_OBJECT(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_CREATE_OBJECT(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_CREATE_OBJECT(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_CREATE_OBJECT(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_CREATE_OBJECT(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_CREATE_OBJECT(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_CREATE_OBJECT(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_CREATE_OBJECT(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_CREATE_OBJECT(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_CREATE_OBJECT(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_CREATE_OBJECT(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_CREATE_OBJECT(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_CREATE_OBJECT(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_CREATE_OBJECT(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_CREATE_OBJECT(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_CREATE_OBJECT(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_CREATE_OBJECT(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_CREATE_OBJECT(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_CREATE_OBJECT(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_CREATE_OBJECT(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_CREATE_OBJECT(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_CREATE_OBJECT(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_CREATE_OBJECT(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_CREATE_OBJECT(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_CREATE_OBJECT(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_CREATE_OBJECT(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_CREATE_OBJECT(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_CREATE_OBJECT(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_CREATE_OBJECT(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_CREATE_OBJECT(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_CREATE_OBJECT(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_CREATE_OBJECT(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_CREATE_OBJECT(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_CREATE_OBJECT(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_CREATE_OBJECT(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_CREATE_OBJECT(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_CREATE_OBJECT(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_CREATE_OBJECT(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_CREATE_OBJECT(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_CREATE_OBJECT(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_CREATE_OBJECT(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_CREATE_OBJECT(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_CREATE_OBJECT(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_CREATE_OBJECT(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_CREATE_OBJECT(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_CREATE_OBJECT(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_CREATE_OBJECT(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_CREATE_OBJECT(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_CREATE_OBJECT(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_CREATE_OBJECT(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_CREATE_OBJECT(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_CREATE_OBJECT(0x74419B70A46387FDLL, DOMImplementation);
      break;
    case 255:
      HASH_CREATE_OBJECT(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Variant invoke_builtin_static_method(const char *s, MethodIndex methodIndex, const char *method, CArrRef params, bool fatal) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_INVOKE_STATIC_METHOD(0x4DA860E5647C3908LL, ImageSprite, methodIndex);
      break;
    case 9:
      HASH_INVOKE_STATIC_METHOD(0x21EF70351574EC09LL, ReflectionFunction, methodIndex);
      break;
    case 11:
      HASH_INVOKE_STATIC_METHOD(0x4365BE9E5A85E60BLL, DOMNotation, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x69EDCA1CC29CFE0BLL, ErrorException, methodIndex);
      break;
    case 18:
      HASH_INVOKE_STATIC_METHOD(0x78B42582709BAF12LL, DebuggerProxy, methodIndex);
      break;
    case 19:
      HASH_INVOKE_STATIC_METHOD(0x6A76B9AABB7CC713LL, SimpleXMLElement, methodIndex);
      break;
    case 21:
      HASH_INVOKE_STATIC_METHOD(0x32E5C767255D2515LL, SoapFault, methodIndex);
      break;
    case 26:
      HASH_INVOKE_STATIC_METHOD(0x5CBA5B52C68B501ALL, DOMEntityReference, methodIndex);
      break;
    case 29:
      HASH_INVOKE_STATIC_METHOD(0x35A44A5E6AE2E71DLL, ReflectionClass, methodIndex);
      break;
    case 30:
      HASH_INVOKE_STATIC_METHOD(0x3DB8FB455A602A1ELL, DateTime, methodIndex);
      break;
    case 43:
      HASH_INVOKE_STATIC_METHOD(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator, methodIndex);
      break;
    case 49:
      HASH_INVOKE_STATIC_METHOD(0x7A394042E7488231LL, FilterIterator, methodIndex);
      break;
    case 50:
      HASH_INVOKE_STATIC_METHOD(0x365899865E2EAA32LL, RecursiveIteratorIterator, methodIndex);
      break;
    case 53:
      HASH_INVOKE_STATIC_METHOD(0x7909270014376235LL, SoapVar, methodIndex);
      break;
    case 55:
      HASH_INVOKE_STATIC_METHOD(0x7FF7A8442616EF37LL, DOMNodeIterator, methodIndex);
      break;
    case 56:
      HASH_INVOKE_STATIC_METHOD(0x672AD818DDE95538LL, ReflectionException, methodIndex);
      break;
    case 61:
      HASH_INVOKE_STATIC_METHOD(0x4C6991D3CF5CA03DLL, Collator, methodIndex);
      break;
    case 62:
      HASH_INVOKE_STATIC_METHOD(0x49FC1A1F7B878C3ELL, SoapServer, methodIndex);
      break;
    case 65:
      HASH_INVOKE_STATIC_METHOD(0x227C70ED5B143841LL, OutOfBoundsException, methodIndex);
      break;
    case 68:
      HASH_INVOKE_STATIC_METHOD(0x4253D8488B734244LL, PDOStatement, methodIndex);
      break;
    case 70:
      HASH_INVOKE_STATIC_METHOD(0x196F76C9C527B946LL, DOMNamedNodeMap, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x66282FC8E4EF4E46LL, BadFunctionCallException, methodIndex);
      break;
    case 73:
      HASH_INVOKE_STATIC_METHOD(0x5AA2EE582E0D3849LL, UnexpectedValueException, methodIndex);
      break;
    case 75:
      HASH_INVOKE_STATIC_METHOD(0x4860DC2F9B0E6D4BLL, LogicException, methodIndex);
      break;
    case 77:
      HASH_INVOKE_STATIC_METHOD(0x164F490DAC49174DLL, DOMText, methodIndex);
      break;
    case 78:
      HASH_INVOKE_STATIC_METHOD(0x308D1D59986A3D4ELL, SoapHeader, methodIndex);
      break;
    case 79:
      HASH_INVOKE_STATIC_METHOD(0x5BA243B9FBA7A64FLL, SplObjectStorage, methodIndex);
      break;
    case 80:
      HASH_INVOKE_STATIC_METHOD(0x52EA111229F87A50LL, Normalizer, methodIndex);
      break;
    case 83:
      HASH_INVOKE_STATIC_METHOD(0x02239AA5D64B1453LL, DOMCharacterData, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x6AF83706F76A9D53LL, RangeException, methodIndex);
      break;
    case 94:
      HASH_INVOKE_STATIC_METHOD(0x7754323897E8A15ELL, DirectoryIterator, methodIndex);
      break;
    case 97:
      HASH_INVOKE_STATIC_METHOD(0x70EBB2CC1FBF9761LL, DOMDocumentType, methodIndex);
      break;
    case 98:
      HASH_INVOKE_STATIC_METHOD(0x70747A09B3523662LL, DOMNode, methodIndex);
      break;
    case 99:
      HASH_INVOKE_STATIC_METHOD(0x7D1235273F521A63LL, DebuggerClient, methodIndex);
      break;
    case 101:
      HASH_INVOKE_STATIC_METHOD(0x2FF1EF6EBB3DA065LL, XMLWriter, methodIndex);
      break;
    case 104:
      HASH_INVOKE_STATIC_METHOD(0x7E07B9C27FE59D68LL, DOMComment, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x17A40D895C55D968LL, SoapParam, methodIndex);
      break;
    case 106:
      HASH_INVOKE_STATIC_METHOD(0x6A5B99D5B1A4566ALL, DOMException, methodIndex);
      break;
    case 107:
      HASH_INVOKE_STATIC_METHOD(0x3CAE91CFA2AAD16BLL, LengthException, methodIndex);
      break;
    case 115:
      HASH_INVOKE_STATIC_METHOD(0x3D5870E53BF89873LL, ArrayIterator, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x0B61E0BFCFA06573LL, ReflectionExtension, methodIndex);
      break;
    case 117:
      HASH_INVOKE_STATIC_METHOD(0x085A4F6FD393D475LL, InvalidArgumentException, methodIndex);
      break;
    case 122:
      HASH_INVOKE_STATIC_METHOD(0x41A9F7D81254DD7ALL, ReflectionObject, methodIndex);
      break;
    case 125:
      HASH_INVOKE_STATIC_METHOD(0x7AD161197633B87DLL, DOMDocumentFragment, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x2E899D2A2572EF7DLL, SQLite3Result, methodIndex);
      break;
    case 128:
      HASH_INVOKE_STATIC_METHOD(0x59B3EFD1CD987F80LL, DOMProcessingInstruction, methodIndex);
      break;
    case 130:
      HASH_INVOKE_STATIC_METHOD(0x33BD46E935281082LL, ReflectionFunctionAbstract, methodIndex);
      break;
    case 131:
      HASH_INVOKE_STATIC_METHOD(0x24DE53FD7D3E8383LL, DateTimeZone, methodIndex);
      break;
    case 132:
      HASH_INVOKE_STATIC_METHOD(0x70D4A29DE6A7BA84LL, DomainException, methodIndex);
      break;
    case 143:
      HASH_INVOKE_STATIC_METHOD(0x34C95AF311506C8FLL, Directory, methodIndex);
      break;
    case 144:
      HASH_INVOKE_STATIC_METHOD(0x06335FF83CDEA590LL, BadMethodCallException, methodIndex);
      break;
    case 147:
      HASH_INVOKE_STATIC_METHOD(0x2E7081C468A05993LL, ReflectionParameter, methodIndex);
      break;
    case 148:
      HASH_INVOKE_STATIC_METHOD(0x6FFDF8DF15CABE94LL, DOMCDATASection, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x6576EACCCE24D694LL, __PHP_Incomplete_Class, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x47D93E6F80B66A94LL, Exception, methodIndex);
      break;
    case 167:
      HASH_INVOKE_STATIC_METHOD(0x71089C29FE923FA7LL, SplFileInfo, methodIndex);
      break;
    case 168:
      HASH_INVOKE_STATIC_METHOD(0x7D46DB2E09C6DBA8LL, DOMXPath, methodIndex);
      break;
    case 169:
      HASH_INVOKE_STATIC_METHOD(0x1D35C3EFD00E11A9LL, SQLite3, methodIndex);
      break;
    case 170:
      HASH_INVOKE_STATIC_METHOD(0x67E31D42F2DFE4AALL, Locale, methodIndex);
      break;
    case 173:
      HASH_INVOKE_STATIC_METHOD(0x0A34015F67C804ADLL, PDO, methodIndex);
      break;
    case 175:
      HASH_INVOKE_STATIC_METHOD(0x2E650138BA043AAFLL, DOMDocument, methodIndex);
      break;
    case 176:
      HASH_INVOKE_STATIC_METHOD(0x43BBC8F6F28E44B0LL, ReflectionMethod, methodIndex);
      break;
    case 177:
      HASH_INVOKE_STATIC_METHOD(0x6DD772FA3B20B8B1LL, DOMNodeList, methodIndex);
      break;
    case 189:
      HASH_INVOKE_STATIC_METHOD(0x5D8785ACD19F77BDLL, PDOException, methodIndex);
      break;
    case 195:
      HASH_INVOKE_STATIC_METHOD(0x40B3C44077F5DDC3LL, DOMElement, methodIndex);
      break;
    case 200:
      HASH_INVOKE_STATIC_METHOD(0x2E363D51549781C8LL, AppendIterator, methodIndex);
      break;
    case 203:
      HASH_INVOKE_STATIC_METHOD(0x253AC17234FC8CCBLL, LibXMLError, methodIndex);
      break;
    case 208:
      HASH_INVOKE_STATIC_METHOD(0x3C122DF8859C72D0LL, Memcache, methodIndex);
      break;
    case 210:
      HASH_INVOKE_STATIC_METHOD(0x52E5CC58B841AED2LL, SQLite3Stmt, methodIndex);
      HASH_INVOKE_STATIC_METHOD(0x297ECCC7A259EDD2LL, SplFileObject, methodIndex);
      break;
    case 212:
      HASH_INVOKE_STATIC_METHOD(0x5E623FEAF7B068D4LL, UnderflowException, methodIndex);
      break;
    case 216:
      HASH_INVOKE_STATIC_METHOD(0x464D3427431A6ED8LL, RecursiveDirectoryIterator, methodIndex);
      break;
    case 217:
      HASH_INVOKE_STATIC_METHOD(0x0E4CCE95F6A727D9LL, OverflowException, methodIndex);
      break;
    case 218:
      HASH_INVOKE_STATIC_METHOD(0x7A52EBE538182BDALL, SoapClient, methodIndex);
      break;
    case 220:
      HASH_INVOKE_STATIC_METHOD(0x1078CB3118A8B3DCLL, RuntimeException, methodIndex);
      break;
    case 228:
      HASH_INVOKE_STATIC_METHOD(0x75AA2571BDB659E4LL, ReflectionProperty, methodIndex);
      break;
    case 244:
      HASH_INVOKE_STATIC_METHOD(0x297174231D4912F4LL, DOMAttr, methodIndex);
      break;
    case 247:
      HASH_INVOKE_STATIC_METHOD(0x3D69936178BA13F7LL, stdClass, methodIndex);
      break;
    case 252:
      HASH_INVOKE_STATIC_METHOD(0x622D4DF07E2A01FCLL, OutOfRangeException, methodIndex);
      break;
    case 253:
      HASH_INVOKE_STATIC_METHOD(0x74419B70A46387FDLL, DOMImplementation, methodIndex);
      break;
    case 255:
      HASH_INVOKE_STATIC_METHOD(0x624835B2D74B86FFLL, DOMEntity, methodIndex);
      break;
    default:
      break;
  }
  if (fatal) {
    return throw_missing_class(s);
  } else {
    #ifndef NOFMCGEN
    method = g_bypassMILR ? method : methodIndexLookupReverse(methodIndex);
    #endif
    raise_warning("call_user_func to non-existent class's method %s::%s", s, method);
    return false;
  }
}
Variant invoke_builtin_static_method_mil(const char *s, const char *method, CArrRef params, bool fatal) {
  bool foundClass = false;
  Variant r;
  if (eval_invoke_static_method_hook(r, s, method, params, foundClass)) return r;
  if (foundClass) return o_invoke_failed(s, method, fatal);
  MethodIndex methodIndex(MethodIndex::fail());
  if (RuntimeOption::FastMethodCall) {
    methodIndex = methodIndexExists(method);
    if (methodIndex.isFail()) {
      return o_invoke_failed(s, method, fatal);
    }
  }
  return invoke_builtin_static_method(s, methodIndex,method, params, fatal);
}
const ObjectStaticCallbacks * get_builtin_object_static_callbacks(const char *s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 75:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x74419B70A46387FDLL, DOMImplementation);
      break;
    case 255:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return NULL;
}
Variant get_builtin_static_property(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_get(prop);
  }
  return null;
}
Variant *get_builtin_static_property_lv(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return &cwo->os_lval(prop);
  }
  return NULL;
}
Variant get_builtin_class_constant(const char *s, const char *constant, bool fatal /* = true */) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_constant(constant);
  }
  if (fatal) {
    raise_error("Couldn't find constant %s::%s", s, constant);
  } else {
    raise_warning("Couldn't find constant %s::%s", s, constant);
  }
  return null;
}

///////////////////////////////////////////////////////////////////////////////
}

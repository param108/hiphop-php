/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/base/runtime_option.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
#include <sys/literal_strings.h>


using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

// Function Invoke Proxies

// Function Invoke Table
Variant i_utf8_encode(CArrRef params) {
  FUNCTION_INJECTION(utf8_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_encode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_utf8_encode(arg0));
  }
}
Variant i_hphp_splfileobject___construct(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("hphp_splfileobject___construct", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject___construct(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_dom_document_create_comment(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_comment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_comment(arg0, arg1));
  }
}
Variant i_func_get_args(CArrRef params) {
  FUNCTION_INJECTION(func_get_args);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_get_args", 0, 1);
  return (f_func_get_args());
}
Variant i_php_uname(CArrRef params) {
  FUNCTION_INJECTION(php_uname);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("php_uname", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_php_uname());
    CVarRef arg0((ad->getValue(pos)));
    return (f_php_uname(arg0));
  }
}
Variant i_posix_uname(CArrRef params) {
  FUNCTION_INJECTION(posix_uname);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_uname", 0, 1);
  return (f_posix_uname());
}
Variant i_curl_multi_remove_handle(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_remove_handle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_remove_handle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_multi_remove_handle(arg0, arg1));
  }
}
Variant i_memcache_get_server_status(CArrRef params) {
  FUNCTION_INJECTION(memcache_get_server_status);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get_server_status", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_get_server_status(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_get_server_status(arg0, arg1, arg2));
  }
}
Variant i_mysql_result(CArrRef params) {
  FUNCTION_INJECTION(mysql_result);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_result", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_result(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_result(arg0, arg1, arg2));
  }
}
Variant i_hphp_splfileobject_current(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_current(arg0));
  }
}
Variant i_hphp_splfileinfo_getgroup(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getgroup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getgroup", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getgroup(arg0));
  }
}
Variant i_register_shutdown_function(CArrRef params) {
  FUNCTION_INJECTION(register_shutdown_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_shutdown_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_shutdown_function(count, arg0), null);
    return (f_register_shutdown_function(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant i_pixelsetmagentaquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetmagentaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagentaquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetmagentaquantum(arg0, arg1), null);
  }
}
Variant i_newmagickwand(CArrRef params) {
  FUNCTION_INJECTION(newmagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newmagickwand", 0, 1);
  return (f_newmagickwand());
}
Variant i_natsort(CArrRef params) {
  FUNCTION_INJECTION(natsort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natsort", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_natsort(arg0));
  }
}
Variant i_socket_accept(CArrRef params) {
  FUNCTION_INJECTION(socket_accept);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_accept", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_accept(arg0));
  }
}
Variant i_vprintf(CArrRef params) {
  FUNCTION_INJECTION(vprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vprintf", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_vprintf(arg0, arg1));
  }
}
Variant i_collator_set_attribute(CArrRef params) {
  FUNCTION_INJECTION(collator_set_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_set_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_set_attribute(arg0, arg1, arg2));
  }
}
Variant i_ucwords(CArrRef params) {
  FUNCTION_INJECTION(ucwords);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucwords", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ucwords(arg0));
  }
}
Variant i_header(CArrRef params) {
  FUNCTION_INJECTION(header);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("header", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_header(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_header(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_header(arg0, arg1, arg2), null);
  }
}
Variant i_dom_element_has_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_has_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_has_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_has_attribute_ns(arg0, arg1, arg2));
  }
}
Variant i_date_default_timezone_set(CArrRef params) {
  FUNCTION_INJECTION(date_default_timezone_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_default_timezone_set", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_default_timezone_set(arg0));
  }
}
Variant i_is_object(CArrRef params) {
  FUNCTION_INJECTION(is_object);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_object", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_object(arg0));
  }
}
Variant i_magicksetimagebias(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagebias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebias", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagebias(arg0, arg1));
  }
}
Variant i_exif_imagetype(CArrRef params) {
  FUNCTION_INJECTION(exif_imagetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_imagetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_exif_imagetype(arg0));
  }
}
Variant i_imagegrabscreen(CArrRef params) {
  FUNCTION_INJECTION(imagegrabscreen);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagegrabscreen", 0, 1);
  return (f_imagegrabscreen());
}
Variant i_bcmod(CArrRef params) {
  FUNCTION_INJECTION(bcmod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("bcmod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcmod(arg0, arg1));
  }
}
Variant i_chr(CArrRef params) {
  FUNCTION_INJECTION(chr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chr", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_chr(arg0));
  }
}
Variant i_drawsetfontstretch(CArrRef params) {
  FUNCTION_INJECTION(drawsetfontstretch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstretch", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontstretch(arg0, arg1), null);
  }
}
Variant i_posix_setsid(CArrRef params) {
  FUNCTION_INJECTION(posix_setsid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_setsid", 0, 1);
  return (f_posix_setsid());
}
Variant i_hphp_splfileinfo_setfileclass(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_setfileclass);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setfileclass", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_setfileclass(arg0, arg1), null);
  }
}
Variant i_posix_getpwnam(CArrRef params) {
  FUNCTION_INJECTION(posix_getpwnam);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwnam", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getpwnam(arg0));
  }
}
Variant i_mcrypt_enc_get_supported_key_sizes(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_supported_key_sizes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_supported_key_sizes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_supported_key_sizes(arg0));
  }
}
Variant i_phpinfo(CArrRef params) {
  FUNCTION_INJECTION(phpinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpinfo", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_phpinfo());
    CVarRef arg0((ad->getValue(pos)));
    return (f_phpinfo(arg0));
  }
}
Variant i_evhttp_async_get(CArrRef params) {
  FUNCTION_INJECTION(evhttp_async_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_async_get", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_evhttp_async_get(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_evhttp_async_get(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_async_get(arg0, arg1, arg2));
  }
}
Variant i_ldap_parse_result(CArrRef params) {
  FUNCTION_INJECTION(ldap_parse_result);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("ldap_parse_result", count, 3, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_parse_result(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_parse_result(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_parse_result(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ldap_parse_result(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_drawgettextantialias(CArrRef params) {
  FUNCTION_INJECTION(drawgettextantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextantialias", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextantialias(arg0));
  }
}
Variant i_array_fill_keys(CArrRef params) {
  FUNCTION_INJECTION(array_fill_keys);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_fill_keys", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_fill_keys(arg0, arg1));
  }
}
Variant i_openssl_seal(CArrRef params) {
  FUNCTION_INJECTION(openssl_seal);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_seal", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_seal(arg0, arg1, arg2, arg3));
  }
}
Variant i_socket_clear_error(CArrRef params) {
  FUNCTION_INJECTION(socket_clear_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_clear_error", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_socket_clear_error(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_clear_error(arg0), null);
  }
}
Variant i_die(CArrRef params) {
  FUNCTION_INJECTION(die);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("die", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_die());
    CVarRef arg0((ad->getValue(pos)));
    return (f_die(arg0));
  }
}
Variant i_diskfreespace(CArrRef params) {
  FUNCTION_INJECTION(diskfreespace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("diskfreespace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_diskfreespace(arg0));
  }
}
Variant i_xml_set_start_namespace_decl_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_start_namespace_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_start_namespace_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_start_namespace_decl_handler(arg0, arg1));
  }
}
Variant i_decbin(CArrRef params) {
  FUNCTION_INJECTION(decbin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decbin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_decbin(arg0));
  }
}
Variant i_sizeof(CArrRef params) {
  FUNCTION_INJECTION(sizeof);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sizeof", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sizeof(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sizeof(arg0, arg1));
  }
}
Variant i_mb_convert_case(CArrRef params) {
  FUNCTION_INJECTION(mb_convert_case);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_case", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_convert_case(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_convert_case(arg0, arg1, arg2));
  }
}
Variant i_fb_set_taint(CArrRef params) {
  FUNCTION_INJECTION(fb_set_taint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_set_taint", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_set_taint(arg0, arg1), null);
  }
}
Variant i_dir(CArrRef params) {
  FUNCTION_INJECTION(dir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dir(arg0));
  }
}
Variant i_array_combine(CArrRef params) {
  FUNCTION_INJECTION(array_combine);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_combine", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_combine(arg0, arg1));
  }
}
Variant i_strpos(CArrRef params) {
  FUNCTION_INJECTION(strpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strpos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strpos(arg0, arg1, arg2));
  }
}
Variant i_array_reverse(CArrRef params) {
  FUNCTION_INJECTION(array_reverse);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_reverse", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_reverse(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_reverse(arg0, arg1));
  }
}
Variant i_strrev(CArrRef params) {
  FUNCTION_INJECTION(strrev);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strrev", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strrev(arg0));
  }
}
Variant i_msg_set_queue(CArrRef params) {
  FUNCTION_INJECTION(msg_set_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("msg_set_queue", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_msg_set_queue(arg0, arg1));
  }
}
Variant i_cos(CArrRef params) {
  FUNCTION_INJECTION(cos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cos", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_cos(arg0));
  }
}
Variant i_hphp_recursivedirectoryiterator_valid(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_valid(arg0));
  }
}
Variant i_bcmul(CArrRef params) {
  FUNCTION_INJECTION(bcmul);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcmul", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcmul(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcmul(arg0, arg1, arg2));
  }
}
Variant i_openlog(CArrRef params) {
  FUNCTION_INJECTION(openlog);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openlog", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openlog(arg0, arg1, arg2));
  }
}
Variant i_get_include_path(CArrRef params) {
  FUNCTION_INJECTION(get_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_include_path", 0, 1);
  return (f_get_include_path());
}
Variant i_socket_select(CArrRef params) {
  FUNCTION_INJECTION(socket_select);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("socket_select", count, 4, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_socket_select(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_select(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magickraiseimage(CArrRef params) {
  FUNCTION_INJECTION(magickraiseimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickraiseimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickraiseimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_gzputs(CArrRef params) {
  FUNCTION_INJECTION(gzputs);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzputs", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzputs(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzputs(arg0, arg1, arg2));
  }
}
Variant i_strpbrk(CArrRef params) {
  FUNCTION_INJECTION(strpbrk);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strpbrk", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strpbrk(arg0, arg1));
  }
}
Variant i_shm_remove_var(CArrRef params) {
  FUNCTION_INJECTION(shm_remove_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_remove_var", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_remove_var(arg0, arg1));
  }
}
Variant i_posix_setuid(CArrRef params) {
  FUNCTION_INJECTION(posix_setuid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setuid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_setuid(arg0));
  }
}
Variant i_pixelgetyellow(CArrRef params) {
  FUNCTION_INJECTION(pixelgetyellow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellow", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetyellow(arg0));
  }
}
Variant i_convert_uudecode(CArrRef params) {
  FUNCTION_INJECTION(convert_uudecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uudecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_convert_uudecode(arg0));
  }
}
Variant i_htmlspecialchars_decode(CArrRef params) {
  FUNCTION_INJECTION(htmlspecialchars_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("htmlspecialchars_decode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_htmlspecialchars_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_htmlspecialchars_decode(arg0, arg1));
  }
}
Variant i_xmlwriter_end_document(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_document);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_document", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_document(arg0));
  }
}
Variant i_magickgetimagehistogram(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagehistogram);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagehistogram", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagehistogram(arg0));
  }
}
Variant i_preg_last_error(CArrRef params) {
  FUNCTION_INJECTION(preg_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("preg_last_error", 0, 1);
  return (f_preg_last_error());
}
Variant i_end(CArrRef params) {
  FUNCTION_INJECTION(end);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("end", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_end(arg0));
  }
}
Variant i_stream_get_line(CArrRef params) {
  FUNCTION_INJECTION(stream_get_line);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_line", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_get_line(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_get_line(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_get_line(arg0, arg1, arg2));
  }
}
Variant i_deg2rad(CArrRef params) {
  FUNCTION_INJECTION(deg2rad);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("deg2rad", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_deg2rad(arg0));
  }
}
Variant i_magickrollimage(CArrRef params) {
  FUNCTION_INJECTION(magickrollimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrollimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickrollimage(arg0, arg1, arg2));
  }
}
Variant i_ldap_sort(CArrRef params) {
  FUNCTION_INJECTION(ldap_sort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_sort", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_sort(arg0, arg1, arg2));
  }
}
Variant i_imagetruecolortopalette(CArrRef params) {
  FUNCTION_INJECTION(imagetruecolortopalette);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagetruecolortopalette", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagetruecolortopalette(arg0, arg1, arg2));
  }
}
Variant i_defined(CArrRef params) {
  FUNCTION_INJECTION(defined);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("defined", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_defined(arg0));
  }
}
Variant i_magickgetimageunits(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageunits", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageunits(arg0));
  }
}
Variant i_magicksetimageblueprimary(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageblueprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageblueprimary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageblueprimary(arg0, arg1, arg2));
  }
}
Variant i_session_name(CArrRef params) {
  FUNCTION_INJECTION(session_name);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_name", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_name());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_name(arg0));
  }
}
Variant i_get_class_vars(CArrRef params) {
  FUNCTION_INJECTION(get_class_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_vars", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_class_vars(arg0));
  }
}
Variant i_syslog(CArrRef params) {
  FUNCTION_INJECTION(syslog);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("syslog", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_syslog(arg0, arg1));
  }
}
Variant i_array_unique(CArrRef params) {
  FUNCTION_INJECTION(array_unique);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_unique", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_unique(arg0));
  }
}
Variant i_bcpow(CArrRef params) {
  FUNCTION_INJECTION(bcpow);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcpow", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcpow(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcpow(arg0, arg1, arg2));
  }
}
Variant i_pixelgetopacityquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetopacityquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacityquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetopacityquantum(arg0));
  }
}
Variant i_php_check_syntax(CArrRef params) {
  FUNCTION_INJECTION(php_check_syntax);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("php_check_syntax", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_php_check_syntax(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_php_check_syntax(arg0, arg1));
  }
}
Variant i_mysql_connect_with_db(CArrRef params) {
  FUNCTION_INJECTION(mysql_connect_with_db);
  int count __attribute__((__unused__)) = params.size();
  if (count > 8) return throw_toomany_arguments("mysql_connect_with_db", 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_connect_with_db());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_connect_with_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_connect_with_db(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_connect_with_db(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_connect_with_db(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_drawgetstrokemiterlimit(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokemiterlimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokemiterlimit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokemiterlimit(arg0));
  }
}
Variant i_hphp_splfileobject_fpassthru(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fpassthru);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fpassthru", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fpassthru(arg0));
  }
}
Variant i_intl_error_name(CArrRef params) {
  FUNCTION_INJECTION(intl_error_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_error_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_intl_error_name(arg0));
  }
}
Variant i_pixelsetquantumcolor(CArrRef params) {
  FUNCTION_INJECTION(pixelsetquantumcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("pixelsetquantumcolor", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_pixelsetquantumcolor(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetquantumcolor(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_gztell(CArrRef params) {
  FUNCTION_INJECTION(gztell);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gztell", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gztell(arg0));
  }
}
Variant i_strval(CArrRef params) {
  FUNCTION_INJECTION(strval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strval(arg0));
  }
}
Variant i_evhttp_recv(CArrRef params) {
  FUNCTION_INJECTION(evhttp_recv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("evhttp_recv", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_evhttp_recv(arg0));
  }
}
Variant i_dom_node_replace_child(CArrRef params) {
  FUNCTION_INJECTION(dom_node_replace_child);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_replace_child", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_replace_child(arg0, arg1, arg2));
  }
}
Variant i_strspn(CArrRef params) {
  FUNCTION_INJECTION(strspn);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strspn", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strspn(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_strspn(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strspn(arg0, arg1, arg2, arg3));
  }
}
Variant i_ini_restore(CArrRef params) {
  FUNCTION_INJECTION(ini_restore);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_restore", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ini_restore(arg0), null);
  }
}
Variant i_ldap_dn2ufn(CArrRef params) {
  FUNCTION_INJECTION(ldap_dn2ufn);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_dn2ufn", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_dn2ufn(arg0));
  }
}
Variant i_ceil(CArrRef params) {
  FUNCTION_INJECTION(ceil);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ceil", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ceil(arg0));
  }
}
Variant i_xmlwriter_end_dtd_attlist(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd_attlist);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_attlist", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd_attlist(arg0));
  }
}
Variant i_phpversion(CArrRef params) {
  FUNCTION_INJECTION(phpversion);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpversion", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_phpversion());
    CVarRef arg0((ad->getValue(pos)));
    return (f_phpversion(arg0));
  }
}
Variant i_stream_filter_remove(CArrRef params) {
  FUNCTION_INJECTION(stream_filter_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_filter_remove", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_filter_remove(arg0));
  }
}
Variant i_mcrypt_generic(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_generic", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_generic(arg0, arg1));
  }
}
Variant i_is_file(CArrRef params) {
  FUNCTION_INJECTION(is_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_file(arg0));
  }
}
Variant i_xml_set_end_namespace_decl_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_end_namespace_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_end_namespace_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_end_namespace_decl_handler(arg0, arg1));
  }
}
Variant i_openssl_x509_export_to_file(CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export_to_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_x509_export_to_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_export_to_file(arg0, arg1, arg2));
  }
}
Variant i_imagesetstyle(CArrRef params) {
  FUNCTION_INJECTION(imagesetstyle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetstyle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetstyle(arg0, arg1));
  }
}
Variant i_drawcolor(CArrRef params) {
  FUNCTION_INJECTION(drawcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawcolor", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcolor(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_get_headers(CArrRef params) {
  FUNCTION_INJECTION(get_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_headers", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_get_headers(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_headers(arg0, arg1));
  }
}
Variant i_mysql_drop_db(CArrRef params) {
  FUNCTION_INJECTION(mysql_drop_db);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_drop_db", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_drop_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_drop_db(arg0, arg1));
  }
}
Variant i_spl_object_hash(CArrRef params) {
  FUNCTION_INJECTION(spl_object_hash);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("spl_object_hash", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_spl_object_hash(arg0));
  }
}
Variant i_magickresampleimage(CArrRef params) {
  FUNCTION_INJECTION(magickresampleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresampleimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickresampleimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_i18n_loc_get_default(CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_get_default);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_default", 0, 1);
  return (f_i18n_loc_get_default());
}
Variant i_strtok(CArrRef params) {
  FUNCTION_INJECTION(strtok);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtok", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strtok(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strtok(arg0, arg1));
  }
}
Variant i_array_key_exists(CArrRef params) {
  FUNCTION_INJECTION(array_key_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_key_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_key_exists(arg0, arg1));
  }
}
Variant i_exp(CArrRef params) {
  FUNCTION_INJECTION(exp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exp", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_exp(arg0));
  }
}
Variant i_strstr(CArrRef params) {
  FUNCTION_INJECTION(strstr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strstr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strstr(arg0, arg1));
  }
}
Variant i_realpath(CArrRef params) {
  FUNCTION_INJECTION(realpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("realpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_realpath(arg0));
  }
}
Variant i_memcache_setoptimeout(CArrRef params) {
  FUNCTION_INJECTION(memcache_setoptimeout);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("memcache_setoptimeout", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_setoptimeout(arg0, arg1));
  }
}
Variant i_stream_filter_append(CArrRef params) {
  FUNCTION_INJECTION(stream_filter_append);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_append", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_filter_append(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_filter_append(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_filter_append(arg0, arg1, arg2, arg3));
  }
}
Variant i_dom_characterdata_insert_data(CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_insert_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_insert_data", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_insert_data(arg0, arg1, arg2));
  }
}
Variant i_hphp_get_property(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_get_property", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_get_property(arg0, arg1, arg2));
  }
}
Variant i_dom_characterdata_replace_data(CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_replace_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_characterdata_replace_data", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_replace_data(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickgetcharheight(CArrRef params) {
  FUNCTION_INJECTION(magickgetcharheight);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharheight", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetcharheight(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetcharheight(arg0, arg1, arg2, arg3));
  }
}
Variant i_imagerotate(CArrRef params) {
  FUNCTION_INJECTION(imagerotate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("imagerotate", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_imagerotate(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagerotate(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickcompositeimage(CArrRef params) {
  FUNCTION_INJECTION(magickcompositeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcompositeimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcompositeimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_openssl_sign(CArrRef params) {
  FUNCTION_INJECTION(openssl_sign);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_sign", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_sign(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_sign(arg0, arg1, arg2, arg3));
  }
}
Variant i_version_compare(CArrRef params) {
  FUNCTION_INJECTION(version_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("version_compare", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_version_compare(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_version_compare(arg0, arg1, arg2));
  }
}
Variant i_timezone_name_get(CArrRef params) {
  FUNCTION_INJECTION(timezone_name_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_name_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_timezone_name_get(arg0));
  }
}
Variant i_posix_getpgid(CArrRef params) {
  FUNCTION_INJECTION(posix_getpgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpgid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getpgid(arg0));
  }
}
Variant i_dom_node_has_attributes(CArrRef params) {
  FUNCTION_INJECTION(dom_node_has_attributes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_attributes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_node_has_attributes(arg0));
  }
}
Variant i_dom_text_is_whitespace_in_element_content(CArrRef params) {
  FUNCTION_INJECTION(dom_text_is_whitespace_in_element_content);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_text_is_whitespace_in_element_content", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_text_is_whitespace_in_element_content(arg0));
  }
}
Variant i_imagestring(CArrRef params) {
  FUNCTION_INJECTION(imagestring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestring", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagestring(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_mcrypt_list_modes(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_list_modes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_modes", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mcrypt_list_modes());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_list_modes(arg0));
  }
}
Variant i_session_unregister(CArrRef params) {
  FUNCTION_INJECTION(session_unregister);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_unregister", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_unregister(arg0));
  }
}
Variant i_mcrypt_list_algorithms(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_list_algorithms);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_algorithms", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mcrypt_list_algorithms());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_list_algorithms(arg0));
  }
}
Variant i_mcrypt_get_cipher_name(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_cipher_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_get_cipher_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_get_cipher_name(arg0));
  }
}
Variant i_idn_to_unicode(CArrRef params) {
  FUNCTION_INJECTION(idn_to_unicode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_unicode", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idn_to_unicode(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_idn_to_unicode(arg0, arg1));
  }
}
Variant i_lchown(CArrRef params) {
  FUNCTION_INJECTION(lchown);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchown", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_lchown(arg0, arg1));
  }
}
Variant i_drawcomposite(CArrRef params) {
  FUNCTION_INJECTION(drawcomposite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawcomposite", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcomposite(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_dechex(CArrRef params) {
  FUNCTION_INJECTION(dechex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dechex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dechex(arg0));
  }
}
Variant i_imagecolortransparent(CArrRef params) {
  FUNCTION_INJECTION(imagecolortransparent);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagecolortransparent", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagecolortransparent(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolortransparent(arg0, arg1));
  }
}
Variant i_socket_get_option(CArrRef params) {
  FUNCTION_INJECTION(socket_get_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_get_option", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_get_option(arg0, arg1, arg2));
  }
}
Variant i_stream_filter_register(CArrRef params) {
  FUNCTION_INJECTION(stream_filter_register);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_filter_register", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_filter_register(arg0, arg1));
  }
}
Variant i_apache_response_headers(CArrRef params) {
  FUNCTION_INJECTION(apache_response_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_response_headers", 0, 1);
  return (f_apache_response_headers());
}
Variant i_array_merge(CArrRef params) {
  FUNCTION_INJECTION(array_merge);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_merge(count, arg0));
    return (f_array_merge(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_md5(CArrRef params) {
  FUNCTION_INJECTION(md5);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_md5(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_md5(arg0, arg1));
  }
}
Variant i_session_write_close(CArrRef params) {
  FUNCTION_INJECTION(session_write_close);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_write_close", 0, 1);
  return (f_session_write_close(), null);
}
Variant i_dom_namednodemap_item(CArrRef params) {
  FUNCTION_INJECTION(dom_namednodemap_item);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_item", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_namednodemap_item(arg0, arg1));
  }
}
Variant i_bcsub(CArrRef params) {
  FUNCTION_INJECTION(bcsub);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcsub", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcsub(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcsub(arg0, arg1, arg2));
  }
}
Variant i_xmlwriter_flush(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_flush", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xmlwriter_flush(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_flush(arg0, arg1));
  }
}
Variant i_sha1_file(CArrRef params) {
  FUNCTION_INJECTION(sha1_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sha1_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sha1_file(arg0, arg1));
  }
}
Variant i_posix_ctermid(CArrRef params) {
  FUNCTION_INJECTION(posix_ctermid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_ctermid", 0, 1);
  return (f_posix_ctermid());
}
Variant i_date(CArrRef params) {
  FUNCTION_INJECTION(date);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("date", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_date(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date(arg0, arg1));
  }
}
Variant i_evhttp_post(CArrRef params) {
  FUNCTION_INJECTION(evhttp_post);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_post", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_evhttp_post(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_evhttp_post(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_post(arg0, arg1, arg2, arg3));
  }
}
Variant i_ldap_connect(CArrRef params) {
  FUNCTION_INJECTION(ldap_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("ldap_connect", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ldap_connect());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_ldap_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_connect(arg0, arg1));
  }
}
Variant i_shuffle(CArrRef params) {
  FUNCTION_INJECTION(shuffle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shuffle", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_shuffle(arg0));
  }
}
Variant i_mcrypt_module_get_algo_block_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_get_algo_block_size);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_block_size", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_get_algo_block_size(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_get_algo_block_size(arg0, arg1));
  }
}
Variant i_hphp_splfileobject_ftruncate(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_ftruncate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_ftruncate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_ftruncate(arg0, arg1));
  }
}
Variant i_key(CArrRef params) {
  FUNCTION_INJECTION(key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("key", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_key(arg0));
  }
}
Variant i_xmlwriter_start_dtd_entity(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd_entity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_start_dtd_entity", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd_entity(arg0, arg1, arg2));
  }
}
Variant i_readfile(CArrRef params) {
  FUNCTION_INJECTION(readfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("readfile", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_readfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_readfile(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_readfile(arg0, arg1, arg2));
  }
}
Variant i_atan(CArrRef params) {
  FUNCTION_INJECTION(atan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_atan(arg0));
  }
}
Variant i_magickmodulateimage(CArrRef params) {
  FUNCTION_INJECTION(magickmodulateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmodulateimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmodulateimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_mysql_set_charset(CArrRef params) {
  FUNCTION_INJECTION(mysql_set_charset);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_set_charset", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_set_charset(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_set_charset(arg0, arg1));
  }
}
Variant i_fb_unset_taint(CArrRef params) {
  FUNCTION_INJECTION(fb_unset_taint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_unset_taint", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_unset_taint(arg0, arg1), null);
  }
}
Variant i_dom_document_xinclude(CArrRef params) {
  FUNCTION_INJECTION(dom_document_xinclude);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_document_xinclude", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_document_xinclude(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_xinclude(arg0, arg1));
  }
}
Variant i_drawgetfontweight(CArrRef params) {
  FUNCTION_INJECTION(drawgetfontweight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontweight", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontweight(arg0));
  }
}
Variant i_magickgetimageheight(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageheight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageheight", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageheight(arg0));
  }
}
Variant i_posix_getpgrp(CArrRef params) {
  FUNCTION_INJECTION(posix_getpgrp);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpgrp", 0, 1);
  return (f_posix_getpgrp());
}
Variant i_i18n_loc_get_error_code(CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_error_code", 0, 1);
  return (f_i18n_loc_get_error_code());
}
Variant i_hash_file(CArrRef params) {
  FUNCTION_INJECTION(hash_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_file(arg0, arg1, arg2));
  }
}
Variant i_is_callable(CArrRef params) {
  FUNCTION_INJECTION(is_callable);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("is_callable", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_is_callable(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_is_callable(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_is_callable(arg0, arg1, arg2));
  }
}
Variant i_asin(CArrRef params) {
  FUNCTION_INJECTION(asin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_asin(arg0));
  }
}
Variant i_openssl_public_encrypt(CArrRef params) {
  FUNCTION_INJECTION(openssl_public_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_encrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_public_encrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_public_encrypt(arg0, arg1, arg2, arg3));
  }
}
Variant i_curl_multi_init(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_init);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("curl_multi_init", 0, 1);
  return (f_curl_multi_init());
}
Variant i_posix_getpwuid(CArrRef params) {
  FUNCTION_INJECTION(posix_getpwuid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwuid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getpwuid(arg0));
  }
}
Variant i_json_encode(CArrRef params) {
  FUNCTION_INJECTION(json_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("json_encode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_json_encode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_json_encode(arg0, arg1));
  }
}
Variant i_show_source(CArrRef params) {
  FUNCTION_INJECTION(show_source);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("show_source", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_show_source(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_show_source(arg0, arg1));
  }
}
Variant i_mcrypt_module_self_test(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_self_test);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_self_test", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_self_test(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_self_test(arg0, arg1));
  }
}
Variant i_sscanf(CArrRef params) {
  FUNCTION_INJECTION(sscanf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("sscanf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_sscanf(count, arg0, arg1));
    return (f_sscanf(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_chop(CArrRef params) {
  FUNCTION_INJECTION(chop);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("chop", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_chop(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chop(arg0, arg1));
  }
}
Variant i_mb_convert_variables(CArrRef params) {
  FUNCTION_INJECTION(mb_convert_variables);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("mb_convert_variables", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_convert_variables(count, arg0, arg1, arg2));
    return (f_mb_convert_variables(count,arg0, arg1, ref(arg2), params.slice(3, count - 3, false)));
  }
}
Variant i_hphp_recursivedirectoryiterator_getsubpathname(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_getsubpathname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpathname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_getsubpathname(arg0));
  }
}
Variant i_socket_close(CArrRef params) {
  FUNCTION_INJECTION(socket_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_close(arg0), null);
  }
}
Variant i_max(CArrRef params) {
  FUNCTION_INJECTION(max);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("max", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_max(count, arg0));
    return (f_max(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_magickadaptivethresholdimage(CArrRef params) {
  FUNCTION_INJECTION(magickadaptivethresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickadaptivethresholdimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickadaptivethresholdimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_each(CArrRef params) {
  FUNCTION_INJECTION(each);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("each", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_each(arg0));
  }
}
Variant i_magickremoveimageprofiles(CArrRef params) {
  FUNCTION_INJECTION(magickremoveimageprofiles);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimageprofiles", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickremoveimageprofiles(arg0));
  }
}
Variant i_drawgettextalignment(CArrRef params) {
  FUNCTION_INJECTION(drawgettextalignment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextalignment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextalignment(arg0));
  }
}
Variant i_xbox_send_message(CArrRef params) {
  FUNCTION_INJECTION(xbox_send_message);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xbox_send_message", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_xbox_send_message(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xbox_send_message(arg0, arg1, arg2, arg3));
  }
}
Variant i_thrift_protocol_write_binary(CArrRef params) {
  FUNCTION_INJECTION(thrift_protocol_write_binary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("thrift_protocol_write_binary", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_thrift_protocol_write_binary(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant i_wandgetexceptiontype(CArrRef params) {
  FUNCTION_INJECTION(wandgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandgetexceptiontype(arg0));
  }
}
Variant i_drawpathellipticarcabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathellipticarcabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcabsolute", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathellipticarcabsolute(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7), null);
  }
}
Variant i_pixelsetgreen(CArrRef params) {
  FUNCTION_INJECTION(pixelsetgreen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreen", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetgreen(arg0, arg1), null);
  }
}
Variant i_magickgetimagecolorspace(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecolorspace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolorspace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecolorspace(arg0));
  }
}
Variant i_pixelsetalphaquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetalphaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalphaquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetalphaquantum(arg0, arg1), null);
  }
}
Variant i_stream_bucket_append(CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_append);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_append", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_bucket_append(arg0, arg1), null);
  }
}
Variant i_msg_stat_queue(CArrRef params) {
  FUNCTION_INJECTION(msg_stat_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_stat_queue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_msg_stat_queue(arg0));
  }
}
Variant i_system(CArrRef params) {
  FUNCTION_INJECTION(system);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("system", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_system(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_system(arg0, arg1));
  }
}
Variant i_mb_parse_str(CArrRef params) {
  FUNCTION_INJECTION(mb_parse_str);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_parse_str", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_parse_str(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_mb_parse_str(arg0, arg1));
  }
}
Variant i_dom_characterdata_append_data(CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_append_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_characterdata_append_data", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_append_data(arg0, arg1));
  }
}
Variant i_log(CArrRef params) {
  FUNCTION_INJECTION(log);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("log", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_log(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_log(arg0, arg1));
  }
}
Variant i_memcache_decrement(CArrRef params) {
  FUNCTION_INJECTION(memcache_decrement);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_decrement", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_decrement(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_decrement(arg0, arg1, arg2));
  }
}
Variant i_drawskewx(CArrRef params) {
  FUNCTION_INJECTION(drawskewx);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewx", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawskewx(arg0, arg1), null);
  }
}
Variant i_min(CArrRef params) {
  FUNCTION_INJECTION(min);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("min", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_min(count, arg0));
    return (f_min(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_curl_multi_getcontent(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_getcontent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_getcontent", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_multi_getcontent(arg0));
  }
}
Variant i_drawskewy(CArrRef params) {
  FUNCTION_INJECTION(drawskewy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewy", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawskewy(arg0, arg1), null);
  }
}
Variant i_is_uploaded_file(CArrRef params) {
  FUNCTION_INJECTION(is_uploaded_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_uploaded_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_uploaded_file(arg0));
  }
}
Variant i_magicksetresourcelimit(CArrRef params) {
  FUNCTION_INJECTION(magicksetresourcelimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetresourcelimit", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetresourcelimit(arg0, arg1));
  }
}
Variant i_date_timezone_get(CArrRef params) {
  FUNCTION_INJECTION(date_timezone_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_timezone_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_timezone_get(arg0));
  }
}
Variant i_hphp_splfileobject_fwrite(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fwrite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fwrite", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fwrite(arg0, arg1, arg2));
  }
}
Variant i_apache_get_rewrite_rules(CArrRef params) {
  FUNCTION_INJECTION(apache_get_rewrite_rules);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_rewrite_rules", 0, 1);
  return (f_apache_get_rewrite_rules());
}
Variant i_is_string(CArrRef params) {
  FUNCTION_INJECTION(is_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_string(arg0));
  }
}
Variant i_pcntl_wtermsig(CArrRef params) {
  FUNCTION_INJECTION(pcntl_wtermsig);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wtermsig", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wtermsig(arg0));
  }
}
Variant i_stream_context_get_default(CArrRef params) {
  FUNCTION_INJECTION(stream_context_get_default);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("stream_context_get_default", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_stream_context_get_default());
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_context_get_default(arg0));
  }
}
Variant i_drawpathlinetorelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetorelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetorelative", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetorelative(arg0, arg1, arg2), null);
  }
}
Variant i_urlencode(CArrRef params) {
  FUNCTION_INJECTION(urlencode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urlencode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_urlencode(arg0));
  }
}
Variant i_mb_preferred_mime_name(CArrRef params) {
  FUNCTION_INJECTION(mb_preferred_mime_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_preferred_mime_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_preferred_mime_name(arg0));
  }
}
Variant i_pixelgetgreenquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetgreenquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreenquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetgreenquantum(arg0));
  }
}
Variant i_magicksetfilename(CArrRef params) {
  FUNCTION_INJECTION(magicksetfilename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetfilename", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magicksetfilename(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetfilename(arg0, arg1));
  }
}
Variant i_magickappendimages(CArrRef params) {
  FUNCTION_INJECTION(magickappendimages);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickappendimages", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickappendimages(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickappendimages(arg0, arg1));
  }
}
Variant i_pcntl_wifstopped(CArrRef params) {
  FUNCTION_INJECTION(pcntl_wifstopped);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifstopped", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wifstopped(arg0));
  }
}
Variant i_mb_ereg_search(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_ereg_search());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_ereg_search(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search(arg0, arg1));
  }
}
Variant i_rewind(CArrRef params) {
  FUNCTION_INJECTION(rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rewind(arg0));
  }
}
Variant i_chunk_split(CArrRef params) {
  FUNCTION_INJECTION(chunk_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("chunk_split", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_chunk_split(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_chunk_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chunk_split(arg0, arg1, arg2));
  }
}
Variant i_mb_list_encodings_alias_names(CArrRef params) {
  FUNCTION_INJECTION(mb_list_encodings_alias_names);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_encodings_alias_names", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_list_encodings_alias_names());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_list_encodings_alias_names(arg0));
  }
}
Variant i_i18n_loc_set_attribute(CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_set_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("i18n_loc_set_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_i18n_loc_set_attribute(arg0, arg1));
  }
}
Variant i_pixelsynciterator(CArrRef params) {
  FUNCTION_INJECTION(pixelsynciterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelsynciterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelsynciterator(arg0));
  }
}
Variant i_openssl_error_string(CArrRef params) {
  FUNCTION_INJECTION(openssl_error_string);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("openssl_error_string", 0, 1);
  return (f_openssl_error_string());
}
Variant i_ismagickwand(CArrRef params) {
  FUNCTION_INJECTION(ismagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ismagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ismagickwand(arg0));
  }
}
Variant i_dom_element_has_attribute(CArrRef params) {
  FUNCTION_INJECTION(dom_element_has_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_has_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_has_attribute(arg0, arg1));
  }
}
Variant i_strrchr(CArrRef params) {
  FUNCTION_INJECTION(strrchr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strrchr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strrchr(arg0, arg1));
  }
}
Variant i_xmlwriter_start_dtd_element(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_element", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd_element(arg0, arg1));
  }
}
Variant i_str_ireplace(CArrRef params) {
  FUNCTION_INJECTION(str_ireplace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_ireplace", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_str_ireplace(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_str_ireplace(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickpainttransparentimage(CArrRef params) {
  FUNCTION_INJECTION(magickpainttransparentimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("magickpainttransparentimage", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickpainttransparentimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_magickpainttransparentimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpainttransparentimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawsettextundercolor(CArrRef params) {
  FUNCTION_INJECTION(drawsettextundercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextundercolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextundercolor(arg0, arg1), null);
  }
}
Variant i_memcache_get_version(CArrRef params) {
  FUNCTION_INJECTION(memcache_get_version);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_get_version", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_memcache_get_version(arg0));
  }
}
Variant i_hphp_splfileobject_getflags(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_getflags);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getflags", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_getflags(arg0));
  }
}
Variant i_hphp_recursivedirectoryiterator_rewind(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_rewind(arg0), null);
  }
}
Variant i_magickgetstringwidth(CArrRef params) {
  FUNCTION_INJECTION(magickgetstringwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringwidth", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetstringwidth(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetstringwidth(arg0, arg1, arg2, arg3));
  }
}
Variant i_echo(CArrRef params) {
  FUNCTION_INJECTION(echo);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("echo", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_echo(count, arg0), null);
    return (f_echo(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant i_ldap_parse_reference(CArrRef params) {
  FUNCTION_INJECTION(ldap_parse_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_parse_reference", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ldap_parse_reference(arg0, arg1, arg2));
  }
}
Variant i_ctype_xdigit(CArrRef params) {
  FUNCTION_INJECTION(ctype_xdigit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_xdigit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_xdigit(arg0));
  }
}
Variant i_gmstrftime(CArrRef params) {
  FUNCTION_INJECTION(gmstrftime);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmstrftime", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gmstrftime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gmstrftime(arg0, arg1));
  }
}
Variant i_hphp_recursiveiteratoriterator_next(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_next(arg0), null);
  }
}
Variant i_stream_socket_get_name(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_get_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_get_name", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_get_name(arg0, arg1));
  }
}
Variant i_socket_set_option(CArrRef params) {
  FUNCTION_INJECTION(socket_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_set_option", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_set_option(arg0, arg1, arg2, arg3));
  }
}
Variant i_array_multisort(CArrRef params) {
  FUNCTION_INJECTION(array_multisort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_multisort", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_array_multisort(count, arg0));
    return (f_array_multisort(count,ref(arg0), params.slice(1, count - 1, false)));
  }
}
Variant i_imagepsbbox(CArrRef params) {
  FUNCTION_INJECTION(imagepsbbox);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("imagepsbbox", count, 3, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_imagepsbbox(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_imagepsbbox(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_imagepsbbox(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsbbox(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_drawpathlinetoverticalabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetoverticalabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalabsolute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetoverticalabsolute(arg0, arg1), null);
  }
}
Variant i_mailparse_msg_get_structure(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_get_structure);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_structure", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_get_structure(arg0));
  }
}
Variant i_mb_ereg(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_ereg(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_mb_ereg(arg0, arg1, arg2));
  }
}
Variant i_decoct(CArrRef params) {
  FUNCTION_INJECTION(decoct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decoct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_decoct(arg0));
  }
}
Variant i_xml_parse(CArrRef params) {
  FUNCTION_INJECTION(xml_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xml_parse", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xml_parse(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parse(arg0, arg1, arg2));
  }
}
Variant i_xml_get_current_line_number(CArrRef params) {
  FUNCTION_INJECTION(xml_get_current_line_number);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_line_number", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_current_line_number(arg0));
  }
}
Variant i_drawaffine(CArrRef params) {
  FUNCTION_INJECTION(drawaffine);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawaffine", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawaffine(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant i_session_destroy(CArrRef params) {
  FUNCTION_INJECTION(session_destroy);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_destroy", 0, 1);
  return (f_session_destroy());
}
Variant i_magicksetimagewhitepoint(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagewhitepoint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagewhitepoint", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagewhitepoint(arg0, arg1, arg2));
  }
}
Variant i_dom_document_get_elements_by_tag_name(CArrRef params) {
  FUNCTION_INJECTION(dom_document_get_elements_by_tag_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_elements_by_tag_name", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_get_elements_by_tag_name(arg0, arg1));
  }
}
Variant i_gzclose(CArrRef params) {
  FUNCTION_INJECTION(gzclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzclose(arg0));
  }
}
Variant i_imagecolorat(CArrRef params) {
  FUNCTION_INJECTION(imagecolorat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagecolorat", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorat(arg0, arg1, arg2));
  }
}
Variant i_magickgetimageextrema(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageextrema);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimageextrema", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickgetimageextrema(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimageextrema(arg0, arg1));
  }
}
Variant i_dom_node_insert_before(CArrRef params) {
  FUNCTION_INJECTION(dom_node_insert_before);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_node_insert_before", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_node_insert_before(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_insert_before(arg0, arg1, arg2));
  }
}
Variant i_ord(CArrRef params) {
  FUNCTION_INJECTION(ord);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ord", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ord(arg0));
  }
}
Variant i_mktime(CArrRef params) {
  FUNCTION_INJECTION(mktime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mktime", 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mktime());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mktime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mktime(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mktime(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mktime(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mktime(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mktime(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_sem_get(CArrRef params) {
  FUNCTION_INJECTION(sem_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("sem_get", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sem_get(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_sem_get(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_sem_get(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sem_get(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawsetstrokelinejoin(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokelinejoin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinejoin", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokelinejoin(arg0, arg1), null);
  }
}
Variant i_array_intersect(CArrRef params) {
  FUNCTION_INJECTION(array_intersect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_intersect(count, arg0, arg1));
    return (f_array_intersect(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_mailparse_msg_extract_whole_part_file(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_extract_whole_part_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_whole_part_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mailparse_msg_extract_whole_part_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_extract_whole_part_file(arg0, arg1, arg2));
  }
}
Variant i_mb_strrichr(CArrRef params) {
  FUNCTION_INJECTION(mb_strrichr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrichr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strrichr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strrichr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strrichr(arg0, arg1, arg2, arg3));
  }
}
Variant i_socket_sendto(CArrRef params) {
  FUNCTION_INJECTION(socket_sendto);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_sendto", count, 5, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_socket_sendto(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_sendto(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_memcache_flush(CArrRef params) {
  FUNCTION_INJECTION(memcache_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("memcache_flush", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_flush(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_flush(arg0, arg1));
  }
}
Variant i_mb_output_handler(CArrRef params) {
  FUNCTION_INJECTION(mb_output_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mb_output_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_output_handler(arg0, arg1));
  }
}
Variant i_fclose(CArrRef params) {
  FUNCTION_INJECTION(fclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fclose(arg0));
  }
}
Variant i_drawpathcurvetoquadraticbeziersmoothabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbeziersmoothabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothabsolute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbeziersmoothabsolute(arg0, arg1, arg2), null);
  }
}
Variant i_function_exists(CArrRef params) {
  FUNCTION_INJECTION(function_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("function_exists", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_function_exists(arg0));
  }
}
Variant i_ctype_alpha(CArrRef params) {
  FUNCTION_INJECTION(ctype_alpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_alpha(arg0));
  }
}
Variant i_pos(CArrRef params) {
  FUNCTION_INJECTION(pos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pos", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_pos(arg0));
  }
}
Variant i_pagelet_server_is_enabled(CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_is_enabled);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pagelet_server_is_enabled", 0, 1);
  return (f_pagelet_server_is_enabled());
}
Variant i_xbox_get_thread_timeout(CArrRef params) {
  FUNCTION_INJECTION(xbox_get_thread_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_timeout", 0, 1);
  return (f_xbox_get_thread_timeout());
}
Variant i_imagecolorexactalpha(CArrRef params) {
  FUNCTION_INJECTION(imagecolorexactalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorexactalpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorexactalpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_pow(CArrRef params) {
  FUNCTION_INJECTION(pow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pow", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pow(arg0, arg1));
  }
}
Variant i_pixelgetredquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetredquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetredquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetredquantum(arg0));
  }
}
Variant i_imagecolorsforindex(CArrRef params) {
  FUNCTION_INJECTION(imagecolorsforindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolorsforindex", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorsforindex(arg0, arg1));
  }
}
Variant i_libxml_set_streams_context(CArrRef params) {
  FUNCTION_INJECTION(libxml_set_streams_context);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("libxml_set_streams_context", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_libxml_set_streams_context(arg0), null);
  }
}
Variant i_dom_node_clone_node(CArrRef params) {
  FUNCTION_INJECTION(dom_node_clone_node);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_node_clone_node", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_node_clone_node(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_clone_node(arg0, arg1));
  }
}
Variant i_image_type_to_mime_type(CArrRef params) {
  FUNCTION_INJECTION(image_type_to_mime_type);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("image_type_to_mime_type", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_image_type_to_mime_type(arg0));
  }
}
Variant i_socket_create(CArrRef params) {
  FUNCTION_INJECTION(socket_create);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_create", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_create(arg0, arg1, arg2));
  }
}
Variant i_xmlwriter_write_pi(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_pi);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_pi", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_pi(arg0, arg1, arg2));
  }
}
Variant i_posix_getppid(CArrRef params) {
  FUNCTION_INJECTION(posix_getppid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getppid", 0, 1);
  return (f_posix_getppid());
}
Variant i_mb_stripos(CArrRef params) {
  FUNCTION_INJECTION(mb_stripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stripos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_stripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_stripos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_stripos(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickpingimage(CArrRef params) {
  FUNCTION_INJECTION(magickpingimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpingimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpingimage(arg0, arg1));
  }
}
Variant i_bcpowmod(CArrRef params) {
  FUNCTION_INJECTION(bcpowmod);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("bcpowmod", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_bcpowmod(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcpowmod(arg0, arg1, arg2, arg3));
  }
}
Variant i_timezone_offset_get(CArrRef params) {
  FUNCTION_INJECTION(timezone_offset_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("timezone_offset_get", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_timezone_offset_get(arg0, arg1));
  }
}
Variant i_dom_document_create_text_node(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_text_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_text_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_text_node(arg0, arg1));
  }
}
Variant i_getrandmax(CArrRef params) {
  FUNCTION_INJECTION(getrandmax);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getrandmax", 0, 1);
  return (f_getrandmax());
}
Variant i_hphp_splfileobject_fseek(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fseek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fseek", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fseek(arg0, arg1, arg2));
  }
}
Variant i_ctype_alnum(CArrRef params) {
  FUNCTION_INJECTION(ctype_alnum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alnum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_alnum(arg0));
  }
}
Variant i_tan(CArrRef params) {
  FUNCTION_INJECTION(tan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_tan(arg0));
  }
}
Variant i_set_exception_handler(CArrRef params) {
  FUNCTION_INJECTION(set_exception_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_exception_handler", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_exception_handler(arg0));
  }
}
Variant i_imagegrabwindow(CArrRef params) {
  FUNCTION_INJECTION(imagegrabwindow);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegrabwindow", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegrabwindow(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegrabwindow(arg0, arg1));
  }
}
Variant i_memcache_add(CArrRef params) {
  FUNCTION_INJECTION(memcache_add);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_add", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_memcache_add(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_add(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_add(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magickstereoimage(CArrRef params) {
  FUNCTION_INJECTION(magickstereoimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickstereoimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickstereoimage(arg0, arg1));
  }
}
Variant i_magickgetimagescene(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagescene);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagescene", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagescene(arg0));
  }
}
Variant i_hphp_splfileinfo_isfile(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isfile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isfile", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isfile(arg0));
  }
}
Variant i_openssl_csr_sign(CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_sign);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_csr_sign", count, 4, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_csr_sign(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_openssl_csr_sign(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_sign(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_openssl_pkcs12_export(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs12_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export", count, 4, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_pkcs12_export(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs12_export(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magickgetquantumdepth(CArrRef params) {
  FUNCTION_INJECTION(magickgetquantumdepth);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetquantumdepth", 0, 1);
  return (f_magickgetquantumdepth());
}
Variant i_socket_listen(CArrRef params) {
  FUNCTION_INJECTION(socket_listen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_listen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_listen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_listen(arg0, arg1));
  }
}
Variant i_parse_str(CArrRef params) {
  FUNCTION_INJECTION(parse_str);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_str", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_str(arg0), null);
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_parse_str(arg0, arg1), null);
  }
}
Variant i_sin(CArrRef params) {
  FUNCTION_INJECTION(sin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sin(arg0));
  }
}
Variant i_dom_node_append_child(CArrRef params) {
  FUNCTION_INJECTION(dom_node_append_child);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_append_child", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_append_child(arg0, arg1));
  }
}
Variant i_cosh(CArrRef params) {
  FUNCTION_INJECTION(cosh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cosh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_cosh(arg0));
  }
}
Variant i_copy(CArrRef params) {
  FUNCTION_INJECTION(copy);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("copy", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_copy(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_copy(arg0, arg1, arg2));
  }
}
Variant i_imagechar(CArrRef params) {
  FUNCTION_INJECTION(imagechar);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagechar", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagechar(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_magicksetimagebackgroundcolor(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagebackgroundcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebackgroundcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagebackgroundcolor(arg0, arg1));
  }
}
Variant i_ldap_mod_add(CArrRef params) {
  FUNCTION_INJECTION(ldap_mod_add);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_add", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_mod_add(arg0, arg1, arg2));
  }
}
Variant i_fb_thrift_serialize(CArrRef params) {
  FUNCTION_INJECTION(fb_thrift_serialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_thrift_serialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_thrift_serialize(arg0));
  }
}
Variant i_posix_ttyname(CArrRef params) {
  FUNCTION_INJECTION(posix_ttyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_ttyname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_ttyname(arg0));
  }
}
Variant i_filectime(CArrRef params) {
  FUNCTION_INJECTION(filectime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filectime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filectime(arg0));
  }
}
Variant i_newpixelwand(CArrRef params) {
  FUNCTION_INJECTION(newpixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("newpixelwand", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_newpixelwand());
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixelwand(arg0));
  }
}
Variant i_pcntl_wait(CArrRef params) {
  FUNCTION_INJECTION(pcntl_wait);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pcntl_wait", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_pcntl_wait(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_wait(arg0, arg1));
  }
}
Variant i_hypot(CArrRef params) {
  FUNCTION_INJECTION(hypot);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hypot", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hypot(arg0, arg1));
  }
}
Variant i_parse_url(CArrRef params) {
  FUNCTION_INJECTION(parse_url);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_url", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_url(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_parse_url(arg0, arg1));
  }
}
Variant i_magickreadimageblob(CArrRef params) {
  FUNCTION_INJECTION(magickreadimageblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimageblob", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimageblob(arg0, arg1));
  }
}
Variant i_eregi(CArrRef params) {
  FUNCTION_INJECTION(eregi);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("eregi", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_eregi(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_eregi(arg0, arg1, arg2));
  }
}
Variant i_pixelsetcolorcount(CArrRef params) {
  FUNCTION_INJECTION(pixelsetcolorcount);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolorcount", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcolorcount(arg0, arg1), null);
  }
}
Variant i_drawpathcurvetoquadraticbezierrelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbezierrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierrelative", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbezierrelative(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_posix_getgroups(CArrRef params) {
  FUNCTION_INJECTION(posix_getgroups);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgroups", 0, 1);
  return (f_posix_getgroups());
}
Variant i_fileinode(CArrRef params) {
  FUNCTION_INJECTION(fileinode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileinode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileinode(arg0));
  }
}
Variant i_magickgetnumberimages(CArrRef params) {
  FUNCTION_INJECTION(magickgetnumberimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetnumberimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetnumberimages(arg0));
  }
}
Variant i_magickgetimagesblob(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagesblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagesblob(arg0));
  }
}
Variant i_magickcontrastimage(CArrRef params) {
  FUNCTION_INJECTION(magickcontrastimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcontrastimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcontrastimage(arg0, arg1));
  }
}
Variant i_pcntl_setpriority(CArrRef params) {
  FUNCTION_INJECTION(pcntl_setpriority);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_setpriority", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pcntl_setpriority(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pcntl_setpriority(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_setpriority(arg0, arg1, arg2));
  }
}
Variant i_drawgetfontstretch(CArrRef params) {
  FUNCTION_INJECTION(drawgetfontstretch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstretch", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontstretch(arg0));
  }
}
Variant i_bcscale(CArrRef params) {
  FUNCTION_INJECTION(bcscale);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bcscale", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_bcscale(arg0));
  }
}
Variant i_imageconvolution(CArrRef params) {
  FUNCTION_INJECTION(imageconvolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imageconvolution", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageconvolution(arg0, arg1, arg2, arg3));
  }
}
Variant i_utf8_decode(CArrRef params) {
  FUNCTION_INJECTION(utf8_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_decode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_utf8_decode(arg0));
  }
}
Variant i_ldap_unbind(CArrRef params) {
  FUNCTION_INJECTION(ldap_unbind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_unbind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_unbind(arg0));
  }
}
Variant i_newpixelregioniterator(CArrRef params) {
  FUNCTION_INJECTION(newpixelregioniterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("newpixelregioniterator", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_newpixelregioniterator(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_array_intersect_assoc(CArrRef params) {
  FUNCTION_INJECTION(array_intersect_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_intersect_assoc(count, arg0, arg1));
    return (f_array_intersect_assoc(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_ob_get_level(CArrRef params) {
  FUNCTION_INJECTION(ob_get_level);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_level", 0, 1);
  return (f_ob_get_level());
}
Variant i_hebrev(CArrRef params) {
  FUNCTION_INJECTION(hebrev);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrev", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hebrev(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hebrev(arg0, arg1));
  }
}
Variant i_socket_set_block(CArrRef params) {
  FUNCTION_INJECTION(socket_set_block);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_block", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_set_block(arg0));
  }
}
Variant i_mcrypt_module_close(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_module_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_module_close(arg0));
  }
}
Variant i_mb_strwidth(CArrRef params) {
  FUNCTION_INJECTION(mb_strwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strwidth", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strwidth(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strwidth(arg0, arg1));
  }
}
Variant i_clonemagickwand(CArrRef params) {
  FUNCTION_INJECTION(clonemagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonemagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clonemagickwand(arg0));
  }
}
Variant i_pixelgetred(CArrRef params) {
  FUNCTION_INJECTION(pixelgetred);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetred", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetred(arg0));
  }
}
Variant i_dom_document_create_processing_instruction(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_processing_instruction);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_processing_instruction", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_create_processing_instruction(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_processing_instruction(arg0, arg1, arg2));
  }
}
Variant i_ip2long(CArrRef params) {
  FUNCTION_INJECTION(ip2long);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ip2long", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ip2long(arg0));
  }
}
Variant i_mb_stristr(CArrRef params) {
  FUNCTION_INJECTION(mb_stristr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stristr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_stristr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_stristr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_stristr(arg0, arg1, arg2, arg3));
  }
}
Variant i_array_diff_ukey(CArrRef params) {
  FUNCTION_INJECTION(array_diff_ukey);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_ukey", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_diff_ukey(count, arg0, arg1, arg2));
    return (f_array_diff_ukey(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_isdrawingwand(CArrRef params) {
  FUNCTION_INJECTION(isdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("isdrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_isdrawingwand(arg0));
  }
}
Variant i_magicksetimagemattecolor(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagemattecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagemattecolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagemattecolor(arg0, arg1));
  }
}
Variant i_closedir(CArrRef params) {
  FUNCTION_INJECTION(closedir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("closedir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_closedir(arg0), null);
  }
}
Variant i_fb_call_user_func_safe_return(CArrRef params) {
  FUNCTION_INJECTION(fb_call_user_func_safe_return);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fb_call_user_func_safe_return", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_call_user_func_safe_return(count, arg0, arg1));
    return (f_fb_call_user_func_safe_return(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_magickwriteimagesfile(CArrRef params) {
  FUNCTION_INJECTION(magickwriteimagesfile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagesfile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimagesfile(arg0, arg1));
  }
}
Variant i_magickdescribeimage(CArrRef params) {
  FUNCTION_INJECTION(magickdescribeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdescribeimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickdescribeimage(arg0));
  }
}
Variant i_imageftbbox(CArrRef params) {
  FUNCTION_INJECTION(imageftbbox);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("imageftbbox", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_imageftbbox(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageftbbox(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magicksetlastiterator(CArrRef params) {
  FUNCTION_INJECTION(magicksetlastiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetlastiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicksetlastiterator(arg0), null);
  }
}
Variant i_hphp_output_global_state(CArrRef params) {
  FUNCTION_INJECTION(hphp_output_global_state);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphp_output_global_state", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_hphp_output_global_state());
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_output_global_state(arg0));
  }
}
Variant i_imagefontheight(CArrRef params) {
  FUNCTION_INJECTION(imagefontheight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontheight", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagefontheight(arg0));
  }
}
Variant i_putenv(CArrRef params) {
  FUNCTION_INJECTION(putenv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("putenv", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_putenv(arg0));
  }
}
Variant i_magickedgeimage(CArrRef params) {
  FUNCTION_INJECTION(magickedgeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickedgeimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickedgeimage(arg0, arg1));
  }
}
Variant i_xml_error_string(CArrRef params) {
  FUNCTION_INJECTION(xml_error_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_error_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_error_string(arg0));
  }
}
Variant i_array_rand(CArrRef params) {
  FUNCTION_INJECTION(array_rand);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_rand", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_rand(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_rand(arg0, arg1));
  }
}
Variant i_ldap_mod_del(CArrRef params) {
  FUNCTION_INJECTION(ldap_mod_del);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_del", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_mod_del(arg0, arg1, arg2));
  }
}
Variant i_range(CArrRef params) {
  FUNCTION_INJECTION(range);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("range", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_range(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_range(arg0, arg1, arg2));
  }
}
Variant i_levenshtein(CArrRef params) {
  FUNCTION_INJECTION(levenshtein);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("levenshtein", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_levenshtein(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_levenshtein(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_levenshtein(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_levenshtein(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_curl_multi_close(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_multi_close(arg0));
  }
}
Variant i_drawgetfillalpha(CArrRef params) {
  FUNCTION_INJECTION(drawgetfillalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillalpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillalpha(arg0));
  }
}
Variant i_hash_hmac(CArrRef params) {
  FUNCTION_INJECTION(hash_hmac);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_hash_hmac(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_hmac(arg0, arg1, arg2, arg3));
  }
}
Variant i_get_html_translation_table(CArrRef params) {
  FUNCTION_INJECTION(get_html_translation_table);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_html_translation_table", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_html_translation_table());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_get_html_translation_table(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_html_translation_table(arg0, arg1));
  }
}
Variant i_user_error(CArrRef params) {
  FUNCTION_INJECTION(user_error);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("user_error", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_user_error(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_user_error(arg0, arg1));
  }
}
Variant i_feof(CArrRef params) {
  FUNCTION_INJECTION(feof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("feof", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_feof(arg0));
  }
}
Variant i_filemtime(CArrRef params) {
  FUNCTION_INJECTION(filemtime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filemtime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filemtime(arg0));
  }
}
Variant i_microtime(CArrRef params) {
  FUNCTION_INJECTION(microtime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("microtime", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_microtime());
    CVarRef arg0((ad->getValue(pos)));
    return (f_microtime(arg0));
  }
}
Variant i_zend_version(CArrRef params) {
  FUNCTION_INJECTION(zend_version);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_version", 0, 1);
  return (f_zend_version());
}
Variant i_openssl_x509_free(CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_x509_free(arg0), null);
  }
}
Variant i_fb_call_user_func_safe(CArrRef params) {
  FUNCTION_INJECTION(fb_call_user_func_safe);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("fb_call_user_func_safe", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fb_call_user_func_safe(count, arg0));
    return (f_fb_call_user_func_safe(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_var_export(CArrRef params) {
  FUNCTION_INJECTION(var_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("var_export", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_var_export(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_var_export(arg0, arg1));
  }
}
Variant i_mb_strcut(CArrRef params) {
  FUNCTION_INJECTION(mb_strcut);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strcut", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strcut(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strcut(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strcut(arg0, arg1, arg2, arg3));
  }
}
Variant i_xmlwriter_end_comment(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_comment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_comment(arg0));
  }
}
Variant i_xmlwriter_end_dtd_element(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_element", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd_element(arg0));
  }
}
Variant i_dom_text_split_text(CArrRef params) {
  FUNCTION_INJECTION(dom_text_split_text);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_text_split_text", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_text_split_text(arg0, arg1));
  }
}
Variant i_openssl_pkey_export_to_file(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export_to_file", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_pkey_export_to_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_pkey_export_to_file(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkey_export_to_file(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphp_get_original_class_name(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_original_class_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_original_class_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_original_class_name(arg0));
  }
}
Variant i_imagecolorclosesthwb(CArrRef params) {
  FUNCTION_INJECTION(imagecolorclosesthwb);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosesthwb", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorclosesthwb(arg0, arg1, arg2, arg3));
  }
}
Variant i_ldap_get_attributes(CArrRef params) {
  FUNCTION_INJECTION(ldap_get_attributes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_attributes", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_attributes(arg0, arg1));
  }
}
Variant i_date_modify(CArrRef params) {
  FUNCTION_INJECTION(date_modify);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_modify", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_modify(arg0, arg1), null);
  }
}
Variant i_hphp_splfileinfo_setinfoclass(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_setinfoclass);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setinfoclass", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_setinfoclass(arg0, arg1), null);
  }
}
Variant i_umask(CArrRef params) {
  FUNCTION_INJECTION(umask);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("umask", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_umask());
    CVarRef arg0((ad->getValue(pos)));
    return (f_umask(arg0));
  }
}
Variant i_xml_get_current_column_number(CArrRef params) {
  FUNCTION_INJECTION(xml_get_current_column_number);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_column_number", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_current_column_number(arg0));
  }
}
Variant i_pixelsetblue(CArrRef params) {
  FUNCTION_INJECTION(pixelsetblue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblue", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetblue(arg0, arg1), null);
  }
}
Variant i_mb_http_output(CArrRef params) {
  FUNCTION_INJECTION(mb_http_output);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_output", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_http_output());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_http_output(arg0));
  }
}
Variant i_flock(CArrRef params) {
  FUNCTION_INJECTION(flock);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("flock", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_flock(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_flock(arg0, arg1, arg2));
  }
}
Variant i_hphp_splfileobject_ftell(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_ftell);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_ftell", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_ftell(arg0));
  }
}
Variant i_pcntl_wifexited(CArrRef params) {
  FUNCTION_INJECTION(pcntl_wifexited);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifexited", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wifexited(arg0));
  }
}
Variant i_magicksetformat(CArrRef params) {
  FUNCTION_INJECTION(magicksetformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetformat", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetformat(arg0, arg1));
  }
}
Variant i_array_map(CArrRef params) {
  FUNCTION_INJECTION(array_map);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_map", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_map(count, arg0, arg1));
    return (f_array_map(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_magicksharpenimage(CArrRef params) {
  FUNCTION_INJECTION(magicksharpenimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicksharpenimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magicksharpenimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksharpenimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_is_infinite(CArrRef params) {
  FUNCTION_INJECTION(is_infinite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_infinite", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_infinite(arg0));
  }
}
Variant i_date_timezone_set(CArrRef params) {
  FUNCTION_INJECTION(date_timezone_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_timezone_set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_timezone_set(arg0, arg1), null);
  }
}
Variant i_mb_ereg_search_init(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_init);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_ereg_search_init", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_ereg_search_init(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_ereg_search_init(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search_init(arg0, arg1, arg2));
  }
}
Variant i_drawcircle(CArrRef params) {
  FUNCTION_INJECTION(drawcircle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawcircle", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcircle(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_is_readable(CArrRef params) {
  FUNCTION_INJECTION(is_readable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_readable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_readable(arg0));
  }
}
Variant i_image_type_to_extension(CArrRef params) {
  FUNCTION_INJECTION(image_type_to_extension);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("image_type_to_extension", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_image_type_to_extension(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_image_type_to_extension(arg0, arg1));
  }
}
Variant i_printf(CArrRef params) {
  FUNCTION_INJECTION(printf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("printf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_printf(count, arg0));
    return (f_printf(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_magicksetimagecompression(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecompression);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompression", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecompression(arg0, arg1));
  }
}
Variant i_mcrypt_decrypt(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_decrypt", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_decrypt(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_decrypt(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_hphp_directoryiterator_next(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_next(arg0), null);
  }
}
Variant i_natcasesort(CArrRef params) {
  FUNCTION_INJECTION(natcasesort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natcasesort", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_natcasesort(arg0));
  }
}
Variant i_intl_get_error_message(CArrRef params) {
  FUNCTION_INJECTION(intl_get_error_message);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_message", 0, 1);
  return (f_intl_get_error_message());
}
Variant i_memcache_get(CArrRef params) {
  FUNCTION_INJECTION(memcache_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_get(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_memcache_get(arg0, arg1, arg2));
  }
}
Variant i_array_chunk(CArrRef params) {
  FUNCTION_INJECTION(array_chunk);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_chunk", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_chunk(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_chunk(arg0, arg1, arg2));
  }
}
Variant i_collator_asort(CArrRef params) {
  FUNCTION_INJECTION(collator_asort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_asort", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_collator_asort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_asort(arg0, arg1, arg2));
  }
}
Variant i_imagefilledpolygon(CArrRef params) {
  FUNCTION_INJECTION(imagefilledpolygon);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefilledpolygon", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledpolygon(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawpoppattern(CArrRef params) {
  FUNCTION_INJECTION(drawpoppattern);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpoppattern", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpoppattern(arg0), null);
  }
}
Variant i_magickgetimagewidth(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagewidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewidth", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagewidth(arg0));
  }
}
Variant i_drawgetfontfamily(CArrRef params) {
  FUNCTION_INJECTION(drawgetfontfamily);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontfamily", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontfamily(arg0));
  }
}
Variant i_dl(CArrRef params) {
  FUNCTION_INJECTION(dl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dl", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dl(arg0));
  }
}
Variant i_touch(CArrRef params) {
  FUNCTION_INJECTION(touch);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("touch", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_touch(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_touch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_touch(arg0, arg1, arg2));
  }
}
Variant i_hphp_recursivedirectoryiterator___tostring(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator___tostring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator___tostring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator___tostring(arg0));
  }
}
Variant i_magicksetimagebordercolor(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagebordercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebordercolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagebordercolor(arg0, arg1));
  }
}
Variant i_hphp_directoryiterator_rewind(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_rewind(arg0), null);
  }
}
Variant i_magickspliceimage(CArrRef params) {
  FUNCTION_INJECTION(magickspliceimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickspliceimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickspliceimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_define(CArrRef params) {
  FUNCTION_INJECTION(define);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("define", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_define(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_define(arg0, arg1, arg2));
  }
}
Variant i_headers_sent(CArrRef params) {
  FUNCTION_INJECTION(headers_sent);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("headers_sent", 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_headers_sent());
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count == 1) return (f_headers_sent(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_headers_sent(arg0, arg1));
  }
}
Variant i_stream_context_get_options(CArrRef params) {
  FUNCTION_INJECTION(stream_context_get_options);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_context_get_options", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_context_get_options(arg0));
  }
}
Variant i_file(CArrRef params) {
  FUNCTION_INJECTION(file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("file", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_file(arg0, arg1, arg2));
  }
}
Variant i_memcache_get_extended_stats(CArrRef params) {
  FUNCTION_INJECTION(memcache_get_extended_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_extended_stats", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_get_extended_stats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_get_extended_stats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_get_extended_stats(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_get_extended_stats(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphp_crash_log(CArrRef params) {
  FUNCTION_INJECTION(hphp_crash_log);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_crash_log", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_crash_log(arg0, arg1), null);
  }
}
Variant i_imagecolorresolvealpha(CArrRef params) {
  FUNCTION_INJECTION(imagecolorresolvealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorresolvealpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorresolvealpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_strtr(CArrRef params) {
  FUNCTION_INJECTION(strtr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strtr", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strtr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strtr(arg0, arg1, arg2));
  }
}
Variant i_posix_strerror(CArrRef params) {
  FUNCTION_INJECTION(posix_strerror);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_strerror", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_strerror(arg0));
  }
}
Variant i_libxml_use_internal_errors(CArrRef params) {
  FUNCTION_INJECTION(libxml_use_internal_errors);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_use_internal_errors", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_libxml_use_internal_errors());
    CVarRef arg0((ad->getValue(pos)));
    return (f_libxml_use_internal_errors(arg0));
  }
}
Variant i_end_user_func_async(CArrRef params) {
  FUNCTION_INJECTION(end_user_func_async);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("end_user_func_async", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_end_user_func_async(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_end_user_func_async(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_end_user_func_async(arg0, arg1, arg2));
  }
}
Variant i_openssl_get_publickey(CArrRef params) {
  FUNCTION_INJECTION(openssl_get_publickey);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_get_publickey", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_get_publickey(arg0));
  }
}
Variant i_dom_node_lookup_prefix(CArrRef params) {
  FUNCTION_INJECTION(dom_node_lookup_prefix);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_prefix", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_lookup_prefix(arg0, arg1));
  }
}
Variant i_time_nanosleep(CArrRef params) {
  FUNCTION_INJECTION(time_nanosleep);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("time_nanosleep", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_time_nanosleep(arg0, arg1));
  }
}
Variant i_magicksetimageunits(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageunits", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageunits(arg0, arg1));
  }
}
Variant i_floor(CArrRef params) {
  FUNCTION_INJECTION(floor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_floor(arg0));
  }
}
Variant i_array_pad(CArrRef params) {
  FUNCTION_INJECTION(array_pad);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_pad", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_pad(arg0, arg1, arg2));
  }
}
Variant i_sem_release(CArrRef params) {
  FUNCTION_INJECTION(sem_release);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_release", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sem_release(arg0));
  }
}
Variant i_hphp_splfileinfo_getctime(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getctime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getctime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getctime(arg0));
  }
}
Variant i_highlight_string(CArrRef params) {
  FUNCTION_INJECTION(highlight_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_string", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_highlight_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_highlight_string(arg0, arg1));
  }
}
Variant i_hphp_invoke(CArrRef params) {
  FUNCTION_INJECTION(hphp_invoke);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_invoke", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_invoke(arg0, arg1));
  }
}
Variant i_imageloadfont(CArrRef params) {
  FUNCTION_INJECTION(imageloadfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageloadfont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imageloadfont(arg0));
  }
}
Variant i_xmlwriter_start_element(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_element", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_element(arg0, arg1));
  }
}
Variant i_localeconv(CArrRef params) {
  FUNCTION_INJECTION(localeconv);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("localeconv", 0, 1);
  return (f_localeconv());
}
Variant i_exif_thumbnail(CArrRef params) {
  FUNCTION_INJECTION(exif_thumbnail);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_thumbnail", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_exif_thumbnail(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_exif_thumbnail(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_exif_thumbnail(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_exif_thumbnail(arg0, arg1, arg2, arg3));
  }
}
Variant i_collator_get_error_message(CArrRef params) {
  FUNCTION_INJECTION(collator_get_error_message);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_message", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_get_error_message(arg0));
  }
}
Variant i_mysql_get_proto_info(CArrRef params) {
  FUNCTION_INJECTION(mysql_get_proto_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_proto_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_get_proto_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_get_proto_info(arg0));
  }
}
Variant i_imagefontwidth(CArrRef params) {
  FUNCTION_INJECTION(imagefontwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontwidth", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagefontwidth(arg0));
  }
}
Variant i_substr_compare(CArrRef params) {
  FUNCTION_INJECTION(substr_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("substr_compare", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_substr_compare(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_substr_compare(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr_compare(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_xbox_post_message(CArrRef params) {
  FUNCTION_INJECTION(xbox_post_message);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xbox_post_message", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xbox_post_message(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xbox_post_message(arg0, arg1));
  }
}
Variant i_fb_rename_function(CArrRef params) {
  FUNCTION_INJECTION(fb_rename_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_rename_function", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_rename_function(arg0, arg1));
  }
}
Variant i_array_walk_recursive(CArrRef params) {
  FUNCTION_INJECTION(array_walk_recursive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk_recursive", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_walk_recursive(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_walk_recursive(arg0, arg1, arg2));
  }
}
Variant i_mysql_list_processes(CArrRef params) {
  FUNCTION_INJECTION(mysql_list_processes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_processes", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_list_processes());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_list_processes(arg0));
  }
}
Variant i_imagedashedline(CArrRef params) {
  FUNCTION_INJECTION(imagedashedline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagedashedline", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagedashedline(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_magickgetimagedelay(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagedelay);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedelay", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagedelay(arg0));
  }
}
Variant i_pi(CArrRef params) {
  FUNCTION_INJECTION(pi);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pi", 0, 1);
  return (f_pi());
}
Variant i_mb_substr_count(CArrRef params) {
  FUNCTION_INJECTION(mb_substr_count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_substr_count", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_substr_count(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_substr_count(arg0, arg1, arg2));
  }
}
Variant i_hphp_splfileinfo_getinode(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getinode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getinode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getinode(arg0));
  }
}
Variant i_magickgettextdescent(CArrRef params) {
  FUNCTION_INJECTION(magickgettextdescent);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextdescent", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgettextdescent(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgettextdescent(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawsetstrokealpha(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokealpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokealpha(arg0, arg1), null);
  }
}
Variant i_apc_delete_file(CArrRef params) {
  FUNCTION_INJECTION(apc_delete_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_delete_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_delete_file(arg0, arg1));
  }
}
Variant i_strrpos(CArrRef params) {
  FUNCTION_INJECTION(strrpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strrpos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strrpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strrpos(arg0, arg1, arg2));
  }
}
Variant i_array_diff_assoc(CArrRef params) {
  FUNCTION_INJECTION(array_diff_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_diff_assoc(count, arg0, arg1));
    return (f_array_diff_assoc(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_magickclippathimage(CArrRef params) {
  FUNCTION_INJECTION(magickclippathimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickclippathimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickclippathimage(arg0, arg1, arg2));
  }
}
Variant i_xmlwriter_write_element(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_element);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xmlwriter_write_element", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xmlwriter_write_element(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_element(arg0, arg1, arg2));
  }
}
Variant i_dom_document_schema_validate_xml(CArrRef params) {
  FUNCTION_INJECTION(dom_document_schema_validate_xml);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_xml", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_schema_validate_xml(arg0, arg1));
  }
}
Variant i_ascii2ebcdic(CArrRef params) {
  FUNCTION_INJECTION(ascii2ebcdic);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ascii2ebcdic", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ascii2ebcdic(arg0));
  }
}
Variant i_ereg(CArrRef params) {
  FUNCTION_INJECTION(ereg);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("ereg", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_ereg(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ereg(arg0, arg1, arg2));
  }
}
Variant i_curl_multi_info_read(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_info_read);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_info_read", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_curl_multi_info_read(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_curl_multi_info_read(arg0, arg1));
  }
}
Variant i_magickthresholdimage(CArrRef params) {
  FUNCTION_INJECTION(magickthresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickthresholdimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickthresholdimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickthresholdimage(arg0, arg1, arg2));
  }
}
Variant i_msg_remove_queue(CArrRef params) {
  FUNCTION_INJECTION(msg_remove_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_remove_queue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_msg_remove_queue(arg0));
  }
}
Variant i_mb_strlen(CArrRef params) {
  FUNCTION_INJECTION(mb_strlen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strlen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strlen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strlen(arg0, arg1));
  }
}
Variant i_drawgetclippath(CArrRef params) {
  FUNCTION_INJECTION(drawgetclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclippath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetclippath(arg0));
  }
}
Variant i_imagecopy(CArrRef params) {
  FUNCTION_INJECTION(imagecopy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagecopy", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopy(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_pixelsetcolor(CArrRef params) {
  FUNCTION_INJECTION(pixelsetcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcolor(arg0, arg1), null);
  }
}
Variant i_time_sleep_until(CArrRef params) {
  FUNCTION_INJECTION(time_sleep_until);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("time_sleep_until", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_time_sleep_until(arg0));
  }
}
Variant i_session_unset(CArrRef params) {
  FUNCTION_INJECTION(session_unset);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_unset", 0, 1);
  return (f_session_unset());
}
Variant i_mb_ereg_replace(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_ereg_replace", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_ereg_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_replace(arg0, arg1, arg2, arg3));
  }
}
Variant i_openssl_csr_get_public_key(CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_get_public_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_csr_get_public_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_csr_get_public_key(arg0));
  }
}
Variant i_magickfximage(CArrRef params) {
  FUNCTION_INJECTION(magickfximage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickfximage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickfximage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickfximage(arg0, arg1, arg2));
  }
}
Variant i_tmpfile(CArrRef params) {
  FUNCTION_INJECTION(tmpfile);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("tmpfile", 0, 1);
  return (f_tmpfile());
}
Variant i_hash(CArrRef params) {
  FUNCTION_INJECTION(hash);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash(arg0, arg1, arg2));
  }
}
Variant i_uasort(CArrRef params) {
  FUNCTION_INJECTION(uasort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uasort", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_uasort(arg0, arg1));
  }
}
Variant i_pixelgetalpha(CArrRef params) {
  FUNCTION_INJECTION(pixelgetalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetalpha(arg0));
  }
}
Variant i_drawsettextencoding(CArrRef params) {
  FUNCTION_INJECTION(drawsettextencoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextencoding", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextencoding(arg0, arg1), null);
  }
}
Variant i_apache_request_headers(CArrRef params) {
  FUNCTION_INJECTION(apache_request_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_request_headers", 0, 1);
  return (f_apache_request_headers());
}
Variant i_is_subclass_of(CArrRef params) {
  FUNCTION_INJECTION(is_subclass_of);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_subclass_of", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_is_subclass_of(arg0, arg1));
  }
}
Variant i_pixelgetmagentaquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetmagentaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagentaquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetmagentaquantum(arg0));
  }
}
Variant i_hphp_get_static_property(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_static_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_get_static_property", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_get_static_property(arg0, arg1));
  }
}
Variant i_array_pop(CArrRef params) {
  FUNCTION_INJECTION(array_pop);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_pop", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_array_pop(arg0));
  }
}
Variant i_magickgetimagecolors(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecolors);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolors", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecolors(arg0));
  }
}
Variant i_session_regenerate_id(CArrRef params) {
  FUNCTION_INJECTION(session_regenerate_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_regenerate_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_regenerate_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_regenerate_id(arg0));
  }
}
Variant i_class_exists(CArrRef params) {
  FUNCTION_INJECTION(class_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_exists", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_class_exists(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_class_exists(arg0, arg1));
  }
}
Variant i_getallheaders(CArrRef params) {
  FUNCTION_INJECTION(getallheaders);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getallheaders", 0, 1);
  return (f_getallheaders());
}
Variant i_get_extension_funcs(CArrRef params) {
  FUNCTION_INJECTION(get_extension_funcs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_extension_funcs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_extension_funcs(arg0));
  }
}
Variant i_imagecolordeallocate(CArrRef params) {
  FUNCTION_INJECTION(imagecolordeallocate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolordeallocate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolordeallocate(arg0, arg1));
  }
}
Variant i_closelog(CArrRef params) {
  FUNCTION_INJECTION(closelog);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("closelog", 0, 1);
  return (f_closelog());
}
Variant i_drawpathlinetoabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetoabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetoabsolute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetoabsolute(arg0, arg1, arg2), null);
  }
}
Variant i_mcrypt_enc_get_iv_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_iv_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_iv_size", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_iv_size(arg0));
  }
}
Variant i_json_decode(CArrRef params) {
  FUNCTION_INJECTION(json_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("json_decode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_json_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_json_decode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_json_decode(arg0, arg1, arg2));
  }
}
Variant i_preg_replace(CArrRef params) {
  FUNCTION_INJECTION(preg_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace", count, 3, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_preg_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_replace(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_preg_replace(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_hphp_splfileinfo_getmtime(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getmtime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getmtime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getmtime(arg0));
  }
}
Variant i_fmod(CArrRef params) {
  FUNCTION_INJECTION(fmod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fmod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fmod(arg0, arg1));
  }
}
Variant i_curl_errno(CArrRef params) {
  FUNCTION_INJECTION(curl_errno);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_errno", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_errno(arg0));
  }
}
Variant i_pagelet_server_task_start(CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_task_start);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pagelet_server_task_start", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pagelet_server_task_start(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pagelet_server_task_start(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pagelet_server_task_start(arg0, arg1, arg2));
  }
}
Variant i_hash_init(CArrRef params) {
  FUNCTION_INJECTION(hash_init);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("hash_init", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hash_init(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_hash_init(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_init(arg0, arg1, arg2));
  }
}
Variant i_mb_strripos(CArrRef params) {
  FUNCTION_INJECTION(mb_strripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strripos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strripos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strripos(arg0, arg1, arg2, arg3));
  }
}
Variant i_mysql_fetch_row(CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_row);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_row", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_fetch_row(arg0));
  }
}
Variant i_hphp_splfileobject_setcsvcontrol(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_setcsvcontrol);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_setcsvcontrol", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_setcsvcontrol(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_ob_get_flush(CArrRef params) {
  FUNCTION_INJECTION(ob_get_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_flush", 0, 1);
  return (f_ob_get_flush());
}
Variant i_curl_error(CArrRef params) {
  FUNCTION_INJECTION(curl_error);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_error", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_error(arg0));
  }
}
Variant i_set_magic_quotes_runtime(CArrRef params) {
  FUNCTION_INJECTION(set_magic_quotes_runtime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_magic_quotes_runtime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_magic_quotes_runtime(arg0));
  }
}
Variant i_magickcharcoalimage(CArrRef params) {
  FUNCTION_INJECTION(magickcharcoalimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcharcoalimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcharcoalimage(arg0, arg1, arg2));
  }
}
Variant i_scandir(CArrRef params) {
  FUNCTION_INJECTION(scandir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("scandir", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_scandir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_scandir(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_scandir(arg0, arg1, arg2));
  }
}
Variant i_magickmosaicimages(CArrRef params) {
  FUNCTION_INJECTION(magickmosaicimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmosaicimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickmosaicimages(arg0));
  }
}
Variant i_timezone_transitions_get(CArrRef params) {
  FUNCTION_INJECTION(timezone_transitions_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_transitions_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_timezone_transitions_get(arg0));
  }
}
Variant i_drawsetfontweight(CArrRef params) {
  FUNCTION_INJECTION(drawsetfontweight);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontweight", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontweight(arg0, arg1), null);
  }
}
Variant i_popdrawingwand(CArrRef params) {
  FUNCTION_INJECTION(popdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("popdrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_popdrawingwand(arg0), null);
  }
}
Variant i_collator_sort_with_sort_keys(CArrRef params) {
  FUNCTION_INJECTION(collator_sort_with_sort_keys);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_sort_with_sort_keys", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_collator_sort_with_sort_keys(arg0, arg1));
  }
}
Variant i_socket_shutdown(CArrRef params) {
  FUNCTION_INJECTION(socket_shutdown);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_shutdown", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_shutdown(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_shutdown(arg0, arg1));
  }
}
Variant i_mcrypt_create_iv(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_create_iv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_create_iv", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_create_iv(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_create_iv(arg0, arg1));
  }
}
Variant i_eval(CArrRef params) {
  FUNCTION_INJECTION(eval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("eval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_eval(arg0));
  }
}
Variant i_bindec(CArrRef params) {
  FUNCTION_INJECTION(bindec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bindec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_bindec(arg0));
  }
}
Variant i_fileperms(CArrRef params) {
  FUNCTION_INJECTION(fileperms);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileperms", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileperms(arg0));
  }
}
Variant i_hphp_splfileobject_fstat(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fstat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fstat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fstat(arg0));
  }
}
Variant i_unserialize(CArrRef params) {
  FUNCTION_INJECTION(unserialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unserialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_unserialize(arg0));
  }
}
Variant i_urldecode(CArrRef params) {
  FUNCTION_INJECTION(urldecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urldecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_urldecode(arg0));
  }
}
Variant i_magickannotateimage(CArrRef params) {
  FUNCTION_INJECTION(magickannotateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickannotateimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickannotateimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_mailparse_msg_create(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mailparse_msg_create", 0, 1);
  return (f_mailparse_msg_create());
}
Variant i_session_set_cookie_params(CArrRef params) {
  FUNCTION_INJECTION(session_set_cookie_params);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("session_set_cookie_params", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_session_set_cookie_params(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_session_set_cookie_params(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_session_set_cookie_params(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_session_set_cookie_params(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_session_set_cookie_params(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_apache_get_modules(CArrRef params) {
  FUNCTION_INJECTION(apache_get_modules);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_modules", 0, 1);
  return (f_apache_get_modules());
}
Variant i_drawellipse(CArrRef params) {
  FUNCTION_INJECTION(drawellipse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawellipse", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawellipse(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant i_xmlwriter_write_element_ns(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_element_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("xmlwriter_write_element_ns", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_xmlwriter_write_element_ns(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_element_ns(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magicksetcompressionquality(CArrRef params) {
  FUNCTION_INJECTION(magicksetcompressionquality);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetcompressionquality", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetcompressionquality(arg0, arg1));
  }
}
Variant i_magickaddnoiseimage(CArrRef params) {
  FUNCTION_INJECTION(magickaddnoiseimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddnoiseimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickaddnoiseimage(arg0, arg1));
  }
}
Variant i_magickgetimagewhitepoint(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagewhitepoint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewhitepoint", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagewhitepoint(arg0));
  }
}
Variant i_magickseparateimagechannel(CArrRef params) {
  FUNCTION_INJECTION(magickseparateimagechannel);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickseparateimagechannel", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickseparateimagechannel(arg0, arg1));
  }
}
Variant i_array_push(CArrRef params) {
  FUNCTION_INJECTION(array_push);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_push", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_push(count, arg0, arg1));
    return (f_array_push(count,ref(arg0), arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_flush(CArrRef params) {
  FUNCTION_INJECTION(flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("flush", 0, 1);
  return (f_flush(), null);
}
Variant i_connection_aborted(CArrRef params) {
  FUNCTION_INJECTION(connection_aborted);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_aborted", 0, 1);
  return (f_connection_aborted());
}
Variant i_uksort(CArrRef params) {
  FUNCTION_INJECTION(uksort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uksort", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_uksort(arg0, arg1));
  }
}
Variant i_mysql_set_timeout(CArrRef params) {
  FUNCTION_INJECTION(mysql_set_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mysql_set_timeout", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_set_timeout());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_set_timeout(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_set_timeout(arg0, arg1));
  }
}
Variant i_hash_update_stream(CArrRef params) {
  FUNCTION_INJECTION(hash_update_stream);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_stream", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash_update_stream(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_update_stream(arg0, arg1, arg2));
  }
}
Variant i_ob_start(CArrRef params) {
  FUNCTION_INJECTION(ob_start);
  int count __attribute__((__unused__)) = params.size();
  if (count > 3) return throw_toomany_arguments("ob_start", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ob_start());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_ob_start(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_ob_start(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ob_start(arg0, arg1, arg2));
  }
}
Variant i_mysql_get_host_info(CArrRef params) {
  FUNCTION_INJECTION(mysql_get_host_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_host_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_get_host_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_get_host_info(arg0));
  }
}
Variant i_mb_language(CArrRef params) {
  FUNCTION_INJECTION(mb_language);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_language", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_language());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_language(arg0));
  }
}
Variant i_pixelgetnextiteratorrow(CArrRef params) {
  FUNCTION_INJECTION(pixelgetnextiteratorrow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetnextiteratorrow", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetnextiteratorrow(arg0));
  }
}
Variant i_ldap_next_reference(CArrRef params) {
  FUNCTION_INJECTION(ldap_next_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_reference", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_next_reference(arg0, arg1));
  }
}
Variant i_socket_get_status(CArrRef params) {
  FUNCTION_INJECTION(socket_get_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_get_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_get_status(arg0));
  }
}
Variant i_checkdnsrr(CArrRef params) {
  FUNCTION_INJECTION(checkdnsrr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("checkdnsrr", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_checkdnsrr(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_checkdnsrr(arg0, arg1));
  }
}
Variant i_openssl_verify(CArrRef params) {
  FUNCTION_INJECTION(openssl_verify);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_verify", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_verify(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_verify(arg0, arg1, arg2, arg3));
  }
}
Variant i_curl_exec(CArrRef params) {
  FUNCTION_INJECTION(curl_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_exec(arg0));
  }
}
Variant i_magickgetexceptiontype(CArrRef params) {
  FUNCTION_INJECTION(magickgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetexceptiontype(arg0));
  }
}
Variant i_array_sum(CArrRef params) {
  FUNCTION_INJECTION(array_sum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_sum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_sum(arg0));
  }
}
Variant i_unregister_tick_function(CArrRef params) {
  FUNCTION_INJECTION(unregister_tick_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unregister_tick_function", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_unregister_tick_function(arg0), null);
  }
}
Variant i_newpixelwandarray(CArrRef params) {
  FUNCTION_INJECTION(newpixelwandarray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwandarray", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixelwandarray(arg0));
  }
}
Variant i_magickgetversion(CArrRef params) {
  FUNCTION_INJECTION(magickgetversion);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversion", 0, 1);
  return (f_magickgetversion());
}
Variant i_imagelayereffect(CArrRef params) {
  FUNCTION_INJECTION(imagelayereffect);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagelayereffect", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagelayereffect(arg0, arg1));
  }
}
Variant i_apache_reset_timeout(CArrRef params) {
  FUNCTION_INJECTION(apache_reset_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_reset_timeout", 0, 1);
  return (f_apache_reset_timeout());
}
Variant i_glob(CArrRef params) {
  FUNCTION_INJECTION(glob);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("glob", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_glob(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_glob(arg0, arg1));
  }
}
Variant i_exec(CArrRef params) {
  FUNCTION_INJECTION(exec);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("exec", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_exec(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_exec(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_exec(arg0, arg1, arg2));
  }
}
Variant i_apd_continue(CArrRef params) {
  FUNCTION_INJECTION(apd_continue);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_continue", 0, 1);
  return (f_apd_continue());
}
Variant i_magickgetimagedepth(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagedepth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimagedepth", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickgetimagedepth(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagedepth(arg0, arg1));
  }
}
Variant i_pclose(CArrRef params) {
  FUNCTION_INJECTION(pclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pclose(arg0));
  }
}
Variant i_get_parent_class(CArrRef params) {
  FUNCTION_INJECTION(get_parent_class);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_parent_class", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_parent_class());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_parent_class(arg0));
  }
}
Variant i_mb_strpos(CArrRef params) {
  FUNCTION_INJECTION(mb_strpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strpos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strpos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strpos(arg0, arg1, arg2, arg3));
  }
}
Variant i_xmlwriter_write_dtd_attlist(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd_attlist);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_attlist", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd_attlist(arg0, arg1, arg2));
  }
}
Variant i_xml_set_element_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_element_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_set_element_handler", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_element_handler(arg0, arg1, arg2));
  }
}
Variant i_drawgetstrokeopacity(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokeopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeopacity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokeopacity(arg0));
  }
}
Variant i_ldap_get_entries(CArrRef params) {
  FUNCTION_INJECTION(ldap_get_entries);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_entries", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_entries(arg0, arg1));
  }
}
Variant i_ob_iconv_handler(CArrRef params) {
  FUNCTION_INJECTION(ob_iconv_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_iconv_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ob_iconv_handler(arg0, arg1));
  }
}
Variant i_hphp_throw_fatal_error(CArrRef params) {
  FUNCTION_INJECTION(hphp_throw_fatal_error);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_throw_fatal_error", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_throw_fatal_error(arg0), null);
  }
}
Variant i_pathinfo(CArrRef params) {
  FUNCTION_INJECTION(pathinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pathinfo", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pathinfo(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pathinfo(arg0, arg1));
  }
}
Variant i_magickaffinetransformimage(CArrRef params) {
  FUNCTION_INJECTION(magickaffinetransformimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaffinetransformimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickaffinetransformimage(arg0, arg1));
  }
}
Variant i_fb_stubout_intercept_handler(CArrRef params) {
  FUNCTION_INJECTION(fb_stubout_intercept_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_stubout_intercept_handler", count, 5, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_stubout_intercept_handler(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_ob_get_status(CArrRef params) {
  FUNCTION_INJECTION(ob_get_status);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_get_status", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ob_get_status());
    CVarRef arg0((ad->getValue(pos)));
    return (f_ob_get_status(arg0));
  }
}
Variant i_collator_create(CArrRef params) {
  FUNCTION_INJECTION(collator_create);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_create", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_create(arg0));
  }
}
Variant i_exit(CArrRef params) {
  FUNCTION_INJECTION(exit);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("exit", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_exit());
    CVarRef arg0((ad->getValue(pos)));
    return (f_exit(arg0));
  }
}
Variant i_memcache_debug(CArrRef params) {
  FUNCTION_INJECTION(memcache_debug);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_debug", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_memcache_debug(arg0));
  }
}
Variant i_apc_sma_info(CArrRef params) {
  FUNCTION_INJECTION(apc_sma_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_sma_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_sma_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_apc_sma_info(arg0));
  }
}
Variant i_ldap_bind(CArrRef params) {
  FUNCTION_INJECTION(ldap_bind);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("ldap_bind", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_ldap_bind(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_ldap_bind(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_bind(arg0, arg1, arg2));
  }
}
Variant i_pixelsetbluequantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetbluequantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetbluequantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetbluequantum(arg0, arg1), null);
  }
}
Variant i_magickreadimagefile(CArrRef params) {
  FUNCTION_INJECTION(magickreadimagefile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimagefile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimagefile(arg0, arg1));
  }
}
Variant i_session_is_registered(CArrRef params) {
  FUNCTION_INJECTION(session_is_registered);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_is_registered", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_is_registered(arg0));
  }
}
Variant i_ebcdic2ascii(CArrRef params) {
  FUNCTION_INJECTION(ebcdic2ascii);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ebcdic2ascii", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ebcdic2ascii(arg0));
  }
}
Variant i_mysql_real_escape_string(CArrRef params) {
  FUNCTION_INJECTION(mysql_real_escape_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_real_escape_string", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_real_escape_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_real_escape_string(arg0, arg1));
  }
}
Variant i_magickframeimage(CArrRef params) {
  FUNCTION_INJECTION(magickframeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickframeimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickframeimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_pixelgetblue(CArrRef params) {
  FUNCTION_INJECTION(pixelgetblue);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetblue(arg0));
  }
}
Variant i_imagefill(CArrRef params) {
  FUNCTION_INJECTION(imagefill);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefill", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefill(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphp_set_property(CArrRef params) {
  FUNCTION_INJECTION(hphp_set_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_set_property", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_set_property(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_readgzfile(CArrRef params) {
  FUNCTION_INJECTION(readgzfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("readgzfile", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_readgzfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_readgzfile(arg0, arg1));
  }
}
Variant i_memcache_set(CArrRef params) {
  FUNCTION_INJECTION(memcache_set);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_set", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_memcache_set(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_set(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_set(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magicksampleimage(CArrRef params) {
  FUNCTION_INJECTION(magicksampleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksampleimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksampleimage(arg0, arg1, arg2));
  }
}
Variant i_mysql_escape_string(CArrRef params) {
  FUNCTION_INJECTION(mysql_escape_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_escape_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_escape_string(arg0));
  }
}
Variant i_idn_to_utf8(CArrRef params) {
  FUNCTION_INJECTION(idn_to_utf8);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_utf8", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idn_to_utf8(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_idn_to_utf8(arg0, arg1));
  }
}
Variant i_sql_regcase(CArrRef params) {
  FUNCTION_INJECTION(sql_regcase);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sql_regcase", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sql_regcase(arg0));
  }
}
Variant i_in_array(CArrRef params) {
  FUNCTION_INJECTION(in_array);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("in_array", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_in_array(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_in_array(arg0, arg1, arg2));
  }
}
Variant i_drawpathcurvetoquadraticbezierabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbezierabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierabsolute", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbezierabsolute(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_apache_getenv(CArrRef params) {
  FUNCTION_INJECTION(apache_getenv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apache_getenv", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apache_getenv(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apache_getenv(arg0, arg1));
  }
}
Variant i_socket_set_timeout(CArrRef params) {
  FUNCTION_INJECTION(socket_set_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_set_timeout", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_set_timeout(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_set_timeout(arg0, arg1, arg2));
  }
}
Variant i_bin2hex(CArrRef params) {
  FUNCTION_INJECTION(bin2hex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bin2hex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_bin2hex(arg0));
  }
}
Variant i_error_get_last(CArrRef params) {
  FUNCTION_INJECTION(error_get_last);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("error_get_last", 0, 1);
  return (f_error_get_last());
}
Variant i_is_link(CArrRef params) {
  FUNCTION_INJECTION(is_link);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_link", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_link(arg0));
  }
}
Variant i_set_file_buffer(CArrRef params) {
  FUNCTION_INJECTION(set_file_buffer);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("set_file_buffer", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_set_file_buffer(arg0, arg1));
  }
}
Variant i_magicksetimageredprimary(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageredprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageredprimary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageredprimary(arg0, arg1, arg2));
  }
}
Variant i_i18n_loc_set_default(CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_set_default);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_default", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_i18n_loc_set_default(arg0));
  }
}
Variant i_ftok(CArrRef params) {
  FUNCTION_INJECTION(ftok);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftok", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ftok(arg0, arg1));
  }
}
Variant i_mysql_list_fields(CArrRef params) {
  FUNCTION_INJECTION(mysql_list_fields);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_list_fields", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_list_fields(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_list_fields(arg0, arg1, arg2));
  }
}
Variant i_stream_wrapper_register(CArrRef params) {
  FUNCTION_INJECTION(stream_wrapper_register);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_wrapper_register", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_wrapper_register(arg0, arg1));
  }
}
Variant i_pixelsetredquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetredquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetredquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetredquantum(arg0, arg1), null);
  }
}
Variant i_xhprof_disable(CArrRef params) {
  FUNCTION_INJECTION(xhprof_disable);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_disable", 0, 1);
  return (f_xhprof_disable());
}
Variant i_magickgammaimage(CArrRef params) {
  FUNCTION_INJECTION(magickgammaimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickgammaimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickgammaimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgammaimage(arg0, arg1, arg2));
  }
}
Variant i_pixelsetcyan(CArrRef params) {
  FUNCTION_INJECTION(pixelsetcyan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyan", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcyan(arg0, arg1), null);
  }
}
Variant i_mb_decode_mimeheader(CArrRef params) {
  FUNCTION_INJECTION(mb_decode_mimeheader);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_decode_mimeheader", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_decode_mimeheader(arg0));
  }
}
Variant i_key_exists(CArrRef params) {
  FUNCTION_INJECTION(key_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("key_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_key_exists(arg0, arg1));
  }
}
Variant i_htmlentities(CArrRef params) {
  FUNCTION_INJECTION(htmlentities);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlentities", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_htmlentities(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_htmlentities(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_htmlentities(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_htmlentities(arg0, arg1, arg2, arg3));
  }
}
Variant i_rad2deg(CArrRef params) {
  FUNCTION_INJECTION(rad2deg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rad2deg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rad2deg(arg0));
  }
}
Variant i_xmlwriter_start_dtd(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("xmlwriter_start_dtd", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xmlwriter_start_dtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_xmlwriter_start_dtd(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawpathstart(CArrRef params) {
  FUNCTION_INJECTION(drawpathstart);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathstart", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpathstart(arg0), null);
  }
}
Variant i_proc_nice(CArrRef params) {
  FUNCTION_INJECTION(proc_nice);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_nice", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_proc_nice(arg0));
  }
}
Variant i_hphp_thread_is_warmup_enabled(CArrRef params) {
  FUNCTION_INJECTION(hphp_thread_is_warmup_enabled);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_is_warmup_enabled", 0, 1);
  return (f_hphp_thread_is_warmup_enabled());
}
Variant i_mysql_pconnect_with_db(CArrRef params) {
  FUNCTION_INJECTION(mysql_pconnect_with_db);
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_pconnect_with_db", 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_pconnect_with_db());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_pconnect_with_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_pconnect_with_db(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_pconnect_with_db(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_pconnect_with_db(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_imagepsslantfont(CArrRef params) {
  FUNCTION_INJECTION(imagepsslantfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsslantfont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsslantfont(arg0, arg1));
  }
}
Variant i_magickgetimagemattecolor(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagemattecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemattecolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagemattecolor(arg0));
  }
}
Variant i_mb_strstr(CArrRef params) {
  FUNCTION_INJECTION(mb_strstr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strstr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strstr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strstr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strstr(arg0, arg1, arg2, arg3));
  }
}
Variant i_pixelgetblack(CArrRef params) {
  FUNCTION_INJECTION(pixelgetblack);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblack", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetblack(arg0));
  }
}
Variant i_mysql_field_table(CArrRef params) {
  FUNCTION_INJECTION(mysql_field_table);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_table", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_table(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_table(arg0, arg1));
  }
}
Variant i_magicksetimagescene(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagescene);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagescene", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagescene(arg0, arg1));
  }
}
Variant i_magickgetimagerenderingintent(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagerenderingintent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagerenderingintent", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagerenderingintent(arg0));
  }
}
Variant i_setlocale(CArrRef params) {
  FUNCTION_INJECTION(setlocale);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("setlocale", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_setlocale(count, arg0, arg1));
    return (f_setlocale(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_drawpushclippath(CArrRef params) {
  FUNCTION_INJECTION(drawpushclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpushclippath", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpushclippath(arg0, arg1), null);
  }
}
Variant i_drawpopclippath(CArrRef params) {
  FUNCTION_INJECTION(drawpopclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopclippath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpopclippath(arg0), null);
  }
}
Variant i_nl2br(CArrRef params) {
  FUNCTION_INJECTION(nl2br);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl2br", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_nl2br(arg0));
  }
}
Variant i_hphp_splfileinfo_getperms(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getperms);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getperms", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getperms(arg0));
  }
}
Variant i_drawsetfillopacity(CArrRef params) {
  FUNCTION_INJECTION(drawsetfillopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillopacity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillopacity(arg0, arg1), null);
  }
}
Variant i_mb_substitute_character(CArrRef params) {
  FUNCTION_INJECTION(mb_substitute_character);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_substitute_character", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_substitute_character());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_substitute_character(arg0));
  }
}
Variant i_setrawcookie(CArrRef params) {
  FUNCTION_INJECTION(setrawcookie);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setrawcookie", count, 1, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_setrawcookie(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_setrawcookie(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_setrawcookie(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_setrawcookie(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_setrawcookie(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_setrawcookie(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_setrawcookie(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_evhttp_get(CArrRef params) {
  FUNCTION_INJECTION(evhttp_get);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_get", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_evhttp_get(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_evhttp_get(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_get(arg0, arg1, arg2));
  }
}
Variant i_getimagesize(CArrRef params) {
  FUNCTION_INJECTION(getimagesize);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getimagesize", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_getimagesize(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_getimagesize(arg0, arg1));
  }
}
Variant i_ldap_modify(CArrRef params) {
  FUNCTION_INJECTION(ldap_modify);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_modify", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_modify(arg0, arg1, arg2));
  }
}
Variant i_ldap_search(CArrRef params) {
  FUNCTION_INJECTION(ldap_search);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_search", count, 3, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_search(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_search(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_search(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_ldap_search(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_ldap_search(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_search(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_strcasecmp(CArrRef params) {
  FUNCTION_INJECTION(strcasecmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcasecmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcasecmp(arg0, arg1));
  }
}
Variant i_magickgetimagesignature(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagesignature);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesignature", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagesignature(arg0));
  }
}
Variant i_get_class_methods(CArrRef params) {
  FUNCTION_INJECTION(get_class_methods);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_methods", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_class_methods(arg0));
  }
}
Variant i_fopen(CArrRef params) {
  FUNCTION_INJECTION(fopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fopen", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fopen(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fopen(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fopen(arg0, arg1, arg2, arg3));
  }
}
Variant i_fb_const_fetch(CArrRef params) {
  FUNCTION_INJECTION(fb_const_fetch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_const_fetch", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_const_fetch(arg0));
  }
}
Variant i_mcrypt_generic_end(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic_end);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_end", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_generic_end(arg0));
  }
}
Variant i_openssl_pkey_free(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_free(arg0), null);
  }
}
Variant i_readlink(CArrRef params) {
  FUNCTION_INJECTION(readlink);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readlink", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_readlink(arg0));
  }
}
Variant i_header_remove(CArrRef params) {
  FUNCTION_INJECTION(header_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("header_remove", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_header_remove(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_header_remove(arg0), null);
  }
}
Variant i_magickechoimagesblob(CArrRef params) {
  FUNCTION_INJECTION(magickechoimagesblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimagesblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickechoimagesblob(arg0));
  }
}
Variant i_mailparse_msg_parse(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_parse", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_parse(arg0, arg1));
  }
}
Variant i_xmlwriter_text(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_text);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_text", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_text(arg0, arg1));
  }
}
Variant i_pixelsetindex(CArrRef params) {
  FUNCTION_INJECTION(pixelsetindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetindex", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetindex(arg0, arg1), null);
  }
}
Variant i_php_sapi_name(CArrRef params) {
  FUNCTION_INJECTION(php_sapi_name);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_sapi_name", 0, 1);
  return (f_php_sapi_name());
}
Variant i_mcrypt_enc_get_key_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_key_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_key_size", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_key_size(arg0));
  }
}
Variant i_mysql_num_fields(CArrRef params) {
  FUNCTION_INJECTION(mysql_num_fields);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_fields", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_num_fields(arg0));
  }
}
Variant i_dom_xpath_register_php_functions(CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_register_php_functions);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_xpath_register_php_functions", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_xpath_register_php_functions(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_register_php_functions(arg0, arg1));
  }
}
Variant i_magicksteganoimage(CArrRef params) {
  FUNCTION_INJECTION(magicksteganoimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksteganoimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksteganoimage(arg0, arg1, arg2));
  }
}
Variant i_magicksetfirstiterator(CArrRef params) {
  FUNCTION_INJECTION(magicksetfirstiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetfirstiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicksetfirstiterator(arg0), null);
  }
}
Variant i_pixelgetcolorasstring(CArrRef params) {
  FUNCTION_INJECTION(pixelgetcolorasstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorasstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcolorasstring(arg0));
  }
}
Variant i_magickremoveimage(CArrRef params) {
  FUNCTION_INJECTION(magickremoveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickremoveimage(arg0));
  }
}
Variant i_file_exists(CArrRef params) {
  FUNCTION_INJECTION(file_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("file_exists", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_file_exists(arg0));
  }
}
Variant i_call_user_func_array(CArrRef params) {
  FUNCTION_INJECTION(call_user_func_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_func_array(arg0, arg1));
  }
}
Variant i_restore_include_path(CArrRef params) {
  FUNCTION_INJECTION(restore_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_include_path", 0, 1);
  return (f_restore_include_path(), null);
}
Variant i_memcache_set_compress_threshold(CArrRef params) {
  FUNCTION_INJECTION(memcache_set_compress_threshold);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_set_compress_threshold", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_set_compress_threshold(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_set_compress_threshold(arg0, arg1, arg2));
  }
}
Variant i_dom_element_set_id_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_id_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_id_attribute_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_id_attribute_ns(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawgettextundercolor(CArrRef params) {
  FUNCTION_INJECTION(drawgettextundercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextundercolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextundercolor(arg0));
  }
}
Variant i_array_shift(CArrRef params) {
  FUNCTION_INJECTION(array_shift);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_shift", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_array_shift(arg0));
  }
}
Variant i_magicksetimageformat(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageformat", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageformat(arg0, arg1));
  }
}
Variant i_xmlwriter_open_memory(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_open_memory);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xmlwriter_open_memory", 0, 1);
  return (f_xmlwriter_open_memory());
}
Variant i_drawsetstrokemiterlimit(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokemiterlimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokemiterlimit", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokemiterlimit(arg0, arg1), null);
  }
}
Variant i_mb_convert_kana(CArrRef params) {
  FUNCTION_INJECTION(mb_convert_kana);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_convert_kana", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_convert_kana(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_convert_kana(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_convert_kana(arg0, arg1, arg2));
  }
}
Variant i_token_name(CArrRef params) {
  FUNCTION_INJECTION(token_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_token_name(arg0));
  }
}
Variant i_preg_quote(CArrRef params) {
  FUNCTION_INJECTION(preg_quote);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("preg_quote", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_preg_quote(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_quote(arg0, arg1));
  }
}
Variant i_hphp_service_thread_started(CArrRef params) {
  FUNCTION_INJECTION(hphp_service_thread_started);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_service_thread_started", 0, 1);
  return (f_hphp_service_thread_started(), null);
}
Variant i_magickconvolveimage(CArrRef params) {
  FUNCTION_INJECTION(magickconvolveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickconvolveimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickconvolveimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickconvolveimage(arg0, arg1, arg2));
  }
}
Variant i_curl_getinfo(CArrRef params) {
  FUNCTION_INJECTION(curl_getinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_getinfo", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_curl_getinfo(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_getinfo(arg0, arg1));
  }
}
Variant i_pfsockopen(CArrRef params) {
  FUNCTION_INJECTION(pfsockopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("pfsockopen", count, 1, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pfsockopen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pfsockopen(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_pfsockopen(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_pfsockopen(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pfsockopen(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_dom_element_get_elements_by_tag_name_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_elements_by_tag_name_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_elements_by_tag_name_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_elements_by_tag_name_ns(arg0, arg1, arg2));
  }
}
Variant i_ucfirst(CArrRef params) {
  FUNCTION_INJECTION(ucfirst);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucfirst", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ucfirst(arg0));
  }
}
Variant i_hphp_splfileinfo_isreadable(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isreadable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isreadable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isreadable(arg0));
  }
}
Variant i_chroot(CArrRef params) {
  FUNCTION_INJECTION(chroot);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chroot", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_chroot(arg0));
  }
}
Variant i_chdir(CArrRef params) {
  FUNCTION_INJECTION(chdir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chdir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_chdir(arg0));
  }
}
Variant i_socket_write(CArrRef params) {
  FUNCTION_INJECTION(socket_write);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_write", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_write(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_write(arg0, arg1, arg2));
  }
}
Variant i_forward_static_call_array(CArrRef params) {
  FUNCTION_INJECTION(forward_static_call_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("forward_static_call_array", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_forward_static_call_array(arg0, arg1));
  }
}
Variant i_stream_bucket_new(CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_new);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_new", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_bucket_new(arg0, arg1));
  }
}
Variant i_magickflipimage(CArrRef params) {
  FUNCTION_INJECTION(magickflipimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflipimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickflipimage(arg0));
  }
}
Variant i_timezone_identifiers_list(CArrRef params) {
  FUNCTION_INJECTION(timezone_identifiers_list);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_identifiers_list", 0, 1);
  return (f_timezone_identifiers_list());
}
Variant i_array_diff_key(CArrRef params) {
  FUNCTION_INJECTION(array_diff_key);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_key", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_diff_key(count, arg0, arg1));
    return (f_array_diff_key(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_session_encode(CArrRef params) {
  FUNCTION_INJECTION(session_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_encode", 0, 1);
  return (f_session_encode());
}
Variant i_fread(CArrRef params) {
  FUNCTION_INJECTION(fread);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fread", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fread(arg0, arg1));
  }
}
Variant i_override_function(CArrRef params) {
  FUNCTION_INJECTION(override_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("override_function", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_override_function(arg0, arg1, arg2));
  }
}
Variant i_is_long(CArrRef params) {
  FUNCTION_INJECTION(is_long);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_long", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_long(arg0));
  }
}
Variant i_pixelsetred(CArrRef params) {
  FUNCTION_INJECTION(pixelsetred);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetred", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetred(arg0, arg1), null);
  }
}
Variant i_mailparse_uudecode_all(CArrRef params) {
  FUNCTION_INJECTION(mailparse_uudecode_all);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_uudecode_all", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_uudecode_all(arg0));
  }
}
Variant i_drawsetvectorgraphics(CArrRef params) {
  FUNCTION_INJECTION(drawsetvectorgraphics);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetvectorgraphics", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetvectorgraphics(arg0, arg1));
  }
}
Variant i_ctype_upper(CArrRef params) {
  FUNCTION_INJECTION(ctype_upper);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_upper", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_upper(arg0));
  }
}
Variant i_get_declared_classes(CArrRef params) {
  FUNCTION_INJECTION(get_declared_classes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_classes", 0, 1);
  return (f_get_declared_classes());
}
Variant i_drawgetstrokelinejoin(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokelinejoin);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinejoin", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokelinejoin(arg0));
  }
}
Variant i_popen(CArrRef params) {
  FUNCTION_INJECTION(popen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("popen", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_popen(arg0, arg1));
  }
}
Variant i_ldap_next_entry(CArrRef params) {
  FUNCTION_INJECTION(ldap_next_entry);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_entry", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_next_entry(arg0, arg1));
  }
}
Variant i_mailparse_msg_parse_file(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_parse_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_parse_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_parse_file(arg0));
  }
}
Variant i_get_loaded_extensions(CArrRef params) {
  FUNCTION_INJECTION(get_loaded_extensions);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_loaded_extensions", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_loaded_extensions());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_loaded_extensions(arg0));
  }
}
Variant i_magickdrawimage(CArrRef params) {
  FUNCTION_INJECTION(magickdrawimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickdrawimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickdrawimage(arg0, arg1));
  }
}
Variant i_mcrypt_cbc(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_cbc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cbc", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_cbc(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_cbc(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_session_set_save_handler(CArrRef params) {
  FUNCTION_INJECTION(session_set_save_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("session_set_save_handler", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_session_set_save_handler(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_dom_element_get_attribute(CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute(arg0, arg1));
  }
}
Variant i_imagecreatetruecolor(CArrRef params) {
  FUNCTION_INJECTION(imagecreatetruecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreatetruecolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecreatetruecolor(arg0, arg1));
  }
}
Variant i_intl_is_failure(CArrRef params) {
  FUNCTION_INJECTION(intl_is_failure);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_is_failure", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_intl_is_failure(arg0));
  }
}
Variant i_inet_ntop(CArrRef params) {
  FUNCTION_INJECTION(inet_ntop);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_ntop", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_inet_ntop(arg0));
  }
}
Variant i_magickreadimage(CArrRef params) {
  FUNCTION_INJECTION(magickreadimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimage(arg0, arg1));
  }
}
Variant i_dom_node_is_default_namespace(CArrRef params) {
  FUNCTION_INJECTION(dom_node_is_default_namespace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_default_namespace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_is_default_namespace(arg0, arg1));
  }
}
Variant i_curl_init(CArrRef params) {
  FUNCTION_INJECTION(curl_init);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_init", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_curl_init());
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_init(arg0));
  }
}
Variant i_mcrypt_cfb(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_cfb);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cfb", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_cfb(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_cfb(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_dom_document_create_document_fragment(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_document_fragment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_create_document_fragment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_create_document_fragment(arg0));
  }
}
Variant i_set_time_limit(CArrRef params) {
  FUNCTION_INJECTION(set_time_limit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_time_limit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_time_limit(arg0), null);
  }
}
Variant i_libxml_get_errors(CArrRef params) {
  FUNCTION_INJECTION(libxml_get_errors);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_errors", 0, 1);
  return (f_libxml_get_errors());
}
Variant i_get_magic_quotes_gpc(CArrRef params) {
  FUNCTION_INJECTION(get_magic_quotes_gpc);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_gpc", 0, 1);
  return (f_get_magic_quotes_gpc());
}
Variant i_proc_get_status(CArrRef params) {
  FUNCTION_INJECTION(proc_get_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_get_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_proc_get_status(arg0));
  }
}
Variant i_log10(CArrRef params) {
  FUNCTION_INJECTION(log10);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log10", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_log10(arg0));
  }
}
Variant i_hphp_directoryiterator_seek(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_directoryiterator_seek(arg0, arg1), null);
  }
}
Variant i_ldap_get_values(CArrRef params) {
  FUNCTION_INJECTION(ldap_get_values);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_values(arg0, arg1, arg2));
  }
}
Variant i_is_soap_fault(CArrRef params) {
  FUNCTION_INJECTION(is_soap_fault);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_soap_fault", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_soap_fault(arg0));
  }
}
Variant i_magickgetimagechannelmean(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagechannelmean);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagechannelmean", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagechannelmean(arg0, arg1));
  }
}
Variant i_disk_total_space(CArrRef params) {
  FUNCTION_INJECTION(disk_total_space);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_total_space", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_disk_total_space(arg0));
  }
}
Variant i_imagegd(CArrRef params) {
  FUNCTION_INJECTION(imagegd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegd", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegd(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegd(arg0, arg1));
  }
}
Variant i_socket_set_blocking(CArrRef params) {
  FUNCTION_INJECTION(socket_set_blocking);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("socket_set_blocking", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_set_blocking(arg0, arg1));
  }
}
Variant i_dom_element_get_elements_by_tag_name(CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_elements_by_tag_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_elements_by_tag_name", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_elements_by_tag_name(arg0, arg1));
  }
}
Variant i_posix_mknod(CArrRef params) {
  FUNCTION_INJECTION(posix_mknod);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("posix_mknod", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_posix_mknod(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_posix_mknod(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_mknod(arg0, arg1, arg2, arg3));
  }
}
Variant i_apc_define_constants(CArrRef params) {
  FUNCTION_INJECTION(apc_define_constants);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_define_constants", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apc_define_constants(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_define_constants(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_define_constants(arg0, arg1, arg2, arg3));
  }
}
Variant i_posix_kill(CArrRef params) {
  FUNCTION_INJECTION(posix_kill);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_kill", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_kill(arg0, arg1));
  }
}
Variant i_drawgetstrokealpha(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokealpha", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokealpha(arg0));
  }
}
Variant i_mcrypt_get_block_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_block_size);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_get_block_size", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_get_block_size(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_get_block_size(arg0, arg1));
  }
}
Variant i_magickmorphimages(CArrRef params) {
  FUNCTION_INJECTION(magickmorphimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmorphimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmorphimages(arg0, arg1));
  }
}
Variant i_getlastmod(CArrRef params) {
  FUNCTION_INJECTION(getlastmod);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getlastmod", 0, 1);
  return (f_getlastmod());
}
Variant i_magickquantizeimage(CArrRef params) {
  FUNCTION_INJECTION(magickquantizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickquantizeimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_imagesavealpha(CArrRef params) {
  FUNCTION_INJECTION(imagesavealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesavealpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesavealpha(arg0, arg1));
  }
}
Variant i_drawsetfontfamily(CArrRef params) {
  FUNCTION_INJECTION(drawsetfontfamily);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontfamily", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontfamily(arg0, arg1));
  }
}
Variant i_drawsettextantialias(CArrRef params) {
  FUNCTION_INJECTION(drawsettextantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsettextantialias", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_drawsettextantialias(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextantialias(arg0, arg1), null);
  }
}
Variant i_pixelsetgreenquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetgreenquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreenquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetgreenquantum(arg0, arg1), null);
  }
}
Variant i_bcsqrt(CArrRef params) {
  FUNCTION_INJECTION(bcsqrt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("bcsqrt", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_bcsqrt(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcsqrt(arg0, arg1));
  }
}
Variant i_pcntl_signal(CArrRef params) {
  FUNCTION_INJECTION(pcntl_signal);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_signal", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_pcntl_signal(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_signal(arg0, arg1, arg2));
  }
}
Variant i_mcrypt_ecb(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_ecb);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ecb", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_ecb(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_ecb(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_pixelsetcyanquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetcyanquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyanquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetcyanquantum(arg0, arg1), null);
  }
}
Variant i_array_walk(CArrRef params) {
  FUNCTION_INJECTION(array_walk);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_walk(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_walk(arg0, arg1, arg2));
  }
}
Variant i_getmxrr(CArrRef params) {
  FUNCTION_INJECTION(getmxrr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("getmxrr", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_getmxrr(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_getmxrr(arg0, arg1, arg2));
  }
}
Variant i_magickqueryfonts(CArrRef params) {
  FUNCTION_INJECTION(magickqueryfonts);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryfonts", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryfonts(arg0));
  }
}
Variant i_floatval(CArrRef params) {
  FUNCTION_INJECTION(floatval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floatval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_floatval(arg0));
  }
}
Variant i_dom_element_get_attribute_node_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute_node_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_node_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute_node_ns(arg0, arg1, arg2));
  }
}
Variant i_xml_set_object(CArrRef params) {
  FUNCTION_INJECTION(xml_set_object);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_object", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_xml_set_object(arg0, arg1));
  }
}
Variant i_ctype_print(CArrRef params) {
  FUNCTION_INJECTION(ctype_print);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_print", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_print(arg0));
  }
}
Variant i_gzwrite(CArrRef params) {
  FUNCTION_INJECTION(gzwrite);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzwrite", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzwrite(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzwrite(arg0, arg1, arg2));
  }
}
Variant i_hphp_splfileinfo___tostring(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo___tostring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo___tostring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo___tostring(arg0));
  }
}
Variant i_magickaddimage(CArrRef params) {
  FUNCTION_INJECTION(magickaddimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickaddimage(arg0, arg1));
  }
}
Variant i_clearstatcache(CArrRef params) {
  FUNCTION_INJECTION(clearstatcache);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("clearstatcache", 0, 1);
  return (f_clearstatcache(), null);
}
Variant i_chgrp(CArrRef params) {
  FUNCTION_INJECTION(chgrp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chgrp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chgrp(arg0, arg1));
  }
}
Variant i_virtual(CArrRef params) {
  FUNCTION_INJECTION(virtual);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("virtual", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_virtual(arg0));
  }
}
Variant i_reset(CArrRef params) {
  FUNCTION_INJECTION(reset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("reset", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_reset(arg0));
  }
}
Variant i_set_include_path(CArrRef params) {
  FUNCTION_INJECTION(set_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_include_path", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_set_include_path(arg0));
  }
}
Variant i_hphp_recursivedirectoryiterator_next(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_next(arg0), null);
  }
}
Variant i_openssl_x509_export(CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_x509_export(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_export(arg0, arg1, arg2));
  }
}
Variant i_magickcolorizeimage(CArrRef params) {
  FUNCTION_INJECTION(magickcolorizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcolorizeimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcolorizeimage(arg0, arg1, arg2));
  }
}
Variant i_imagettftext(CArrRef params) {
  FUNCTION_INJECTION(imagettftext);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagettftext", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagettftext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_mb_strrchr(CArrRef params) {
  FUNCTION_INJECTION(mb_strrchr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrchr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strrchr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strrchr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strrchr(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickgetimageprofile(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageprofile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimageprofile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimageprofile(arg0, arg1));
  }
}
Variant i_file_put_contents(CArrRef params) {
  FUNCTION_INJECTION(file_put_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("file_put_contents", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_file_put_contents(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_file_put_contents(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_file_put_contents(arg0, arg1, arg2, arg3));
  }
}
Variant i_iconv_mime_encode(CArrRef params) {
  FUNCTION_INJECTION(iconv_mime_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_mime_encode", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_mime_encode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_mime_encode(arg0, arg1, arg2));
  }
}
Variant i_log1p(CArrRef params) {
  FUNCTION_INJECTION(log1p);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log1p", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_log1p(arg0));
  }
}
Variant i_fwrite(CArrRef params) {
  FUNCTION_INJECTION(fwrite);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fwrite", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fwrite(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fwrite(arg0, arg1, arg2));
  }
}
Variant i_atan2(CArrRef params) {
  FUNCTION_INJECTION(atan2);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("atan2", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_atan2(arg0, arg1));
  }
}
Variant i_is_a(CArrRef params) {
  FUNCTION_INJECTION(is_a);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_a", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_is_a(arg0, arg1));
  }
}
Variant i_idate(CArrRef params) {
  FUNCTION_INJECTION(idate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_idate(arg0, arg1));
  }
}
Variant i_posix_initgroups(CArrRef params) {
  FUNCTION_INJECTION(posix_initgroups);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_initgroups", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_initgroups(arg0, arg1));
  }
}
Variant i_arsort(CArrRef params) {
  FUNCTION_INJECTION(arsort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("arsort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_arsort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_arsort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_arsort(arg0, arg1, arg2));
  }
}
Variant i_dom_characterdata_substring_data(CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_substring_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_substring_data", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_substring_data(arg0, arg1, arg2));
  }
}
Variant i_gethostbyaddr(CArrRef params) {
  FUNCTION_INJECTION(gethostbyaddr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyaddr", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gethostbyaddr(arg0));
  }
}
Variant i_apc_delete(CArrRef params) {
  FUNCTION_INJECTION(apc_delete);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_delete(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_delete(arg0, arg1));
  }
}
Variant i_magicklevelimage(CArrRef params) {
  FUNCTION_INJECTION(magicklevelimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("magicklevelimage", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_magicklevelimage(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicklevelimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_openssl_x509_parse(CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_x509_parse", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_x509_parse(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_parse(arg0, arg1));
  }
}
Variant i_dom_nodelist_item(CArrRef params) {
  FUNCTION_INJECTION(dom_nodelist_item);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_nodelist_item", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_nodelist_item(arg0, arg1));
  }
}
Variant i_magickcommentimage(CArrRef params) {
  FUNCTION_INJECTION(magickcommentimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcommentimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcommentimage(arg0, arg1));
  }
}
Variant i_hphp_splfileinfo_islink(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_islink);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_islink", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_islink(arg0));
  }
}
Variant i_magicksetimagedelay(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagedelay);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedelay", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagedelay(arg0, arg1));
  }
}
Variant i_magickposterizeimage(CArrRef params) {
  FUNCTION_INJECTION(magickposterizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickposterizeimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickposterizeimage(arg0, arg1, arg2));
  }
}
Variant i_dom_namednodemap_get_named_item(CArrRef params) {
  FUNCTION_INJECTION(dom_namednodemap_get_named_item);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_get_named_item", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_namednodemap_get_named_item(arg0, arg1));
  }
}
Variant i_dom_element_get_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute_ns(arg0, arg1, arg2));
  }
}
Variant i_stream_socket_accept(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_accept);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_socket_accept", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_socket_accept(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_socket_accept(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_stream_socket_accept(arg0, arg1, arg2));
  }
}
Variant i_magickqueryconfigureoption(CArrRef params) {
  FUNCTION_INJECTION(magickqueryconfigureoption);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoption", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryconfigureoption(arg0));
  }
}
Variant i_magickevaluateimage(CArrRef params) {
  FUNCTION_INJECTION(magickevaluateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickevaluateimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickevaluateimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickevaluateimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_imagesx(CArrRef params) {
  FUNCTION_INJECTION(imagesx);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesx", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagesx(arg0));
  }
}
Variant i_imagesy(CArrRef params) {
  FUNCTION_INJECTION(imagesy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesy", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagesy(arg0));
  }
}
Variant i_mysql_get_client_info(CArrRef params) {
  FUNCTION_INJECTION(mysql_get_client_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mysql_get_client_info", 0, 1);
  return (f_mysql_get_client_info());
}
Variant i_fb_crossall_query(CArrRef params) {
  FUNCTION_INJECTION(fb_crossall_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("fb_crossall_query", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fb_crossall_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fb_crossall_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fb_crossall_query(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_fb_crossall_query(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_fb_crossall_query(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_crossall_query(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_fseek(CArrRef params) {
  FUNCTION_INJECTION(fseek);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fseek", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fseek(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fseek(arg0, arg1, arg2));
  }
}
Variant i_call_user_func_array_async(CArrRef params) {
  FUNCTION_INJECTION(call_user_func_array_async);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array_async", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_func_array_async(arg0, arg1));
  }
}
Variant i_apc_compile_file(CArrRef params) {
  FUNCTION_INJECTION(apc_compile_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_compile_file", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_compile_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_compile_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_compile_file(arg0, arg1, arg2));
  }
}
Variant i_memcache_set_server_params(CArrRef params) {
  FUNCTION_INJECTION(memcache_set_server_params);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 7) return throw_wrong_arguments("memcache_set_server_params", count, 2, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_set_server_params(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_set_server_params(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_set_server_params(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_memcache_set_server_params(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_memcache_set_server_params(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_set_server_params(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_magicksetpassphrase(CArrRef params) {
  FUNCTION_INJECTION(magicksetpassphrase);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetpassphrase", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetpassphrase(arg0, arg1));
  }
}
Variant i_mysql_info(CArrRef params) {
  FUNCTION_INJECTION(mysql_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_info(arg0));
  }
}
Variant i_is_writable(CArrRef params) {
  FUNCTION_INJECTION(is_writable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_writable(arg0));
  }
}
Variant i_magickrotateimage(CArrRef params) {
  FUNCTION_INJECTION(magickrotateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrotateimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickrotateimage(arg0, arg1, arg2));
  }
}
Variant i_fgetcsv(CArrRef params) {
  FUNCTION_INJECTION(fgetcsv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("fgetcsv", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fgetcsv(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fgetcsv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fgetcsv(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fgetcsv(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickcolorfloodfillimage(CArrRef params) {
  FUNCTION_INJECTION(magickcolorfloodfillimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickcolorfloodfillimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcolorfloodfillimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_atanh(CArrRef params) {
  FUNCTION_INJECTION(atanh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atanh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_atanh(arg0));
  }
}
Variant i_imagecopyresized(CArrRef params) {
  FUNCTION_INJECTION(imagecopyresized);
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresized", count, 10, 10, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopyresized(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
  }
}
Variant i_fpassthru(CArrRef params) {
  FUNCTION_INJECTION(fpassthru);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fpassthru", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fpassthru(arg0));
  }
}
Variant i_magickblackthresholdimage(CArrRef params) {
  FUNCTION_INJECTION(magickblackthresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickblackthresholdimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickblackthresholdimage(arg0, arg1));
  }
}
Variant i_mcrypt_encrypt(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_encrypt", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_encrypt(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_encrypt(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magicksetimagegreenprimary(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagegreenprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagegreenprimary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagegreenprimary(arg0, arg1, arg2));
  }
}
Variant i_xmlwriter_start_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_attribute_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_attribute_ns(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickgetimageinterlacescheme(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageinterlacescheme", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageinterlacescheme(arg0));
  }
}
Variant i_apache_child_terminate(CArrRef params) {
  FUNCTION_INJECTION(apache_child_terminate);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_child_terminate", 0, 1);
  return (f_apache_child_terminate());
}
Variant i_array_merge_recursive(CArrRef params) {
  FUNCTION_INJECTION(array_merge_recursive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge_recursive", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_merge_recursive(count, arg0));
    return (f_array_merge_recursive(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_array_uintersect(CArrRef params) {
  FUNCTION_INJECTION(array_uintersect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_uintersect(count, arg0, arg1, arg2));
    return (f_array_uintersect(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_xml_set_unparsed_entity_decl_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_unparsed_entity_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_unparsed_entity_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_unparsed_entity_decl_handler(arg0, arg1));
  }
}
Variant i_ob_get_contents(CArrRef params) {
  FUNCTION_INJECTION(ob_get_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_contents", 0, 1);
  return (f_ob_get_contents());
}
Variant i_pixelgetcyan(CArrRef params) {
  FUNCTION_INJECTION(pixelgetcyan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcyan(arg0));
  }
}
Variant i_stream_select(CArrRef params) {
  FUNCTION_INJECTION(stream_select);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("stream_select", count, 4, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_stream_select(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_select(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_get_resource_type(CArrRef params) {
  FUNCTION_INJECTION(get_resource_type);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_resource_type", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_resource_type(arg0));
  }
}
Variant i_dangling_server_proxy_old_request(CArrRef params) {
  FUNCTION_INJECTION(dangling_server_proxy_old_request);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("dangling_server_proxy_old_request", 0, 1);
  return (f_dangling_server_proxy_old_request());
}
Variant i_magickgetimagefilename(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagefilename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagefilename", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagefilename(arg0));
  }
}
Variant i_exif_tagname(CArrRef params) {
  FUNCTION_INJECTION(exif_tagname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_tagname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_exif_tagname(arg0));
  }
}
Variant i_dom_document_create_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_create_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_attribute_ns(arg0, arg1, arg2));
  }
}
Variant i_drawsetfillalpha(CArrRef params) {
  FUNCTION_INJECTION(drawsetfillalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillalpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillalpha(arg0, arg1), null);
  }
}
Variant i_mb_convert_encoding(CArrRef params) {
  FUNCTION_INJECTION(mb_convert_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_encoding", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_convert_encoding(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_convert_encoding(arg0, arg1, arg2));
  }
}
Variant i_wandgetexceptionstring(CArrRef params) {
  FUNCTION_INJECTION(wandgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandgetexceptionstring(arg0));
  }
}
Variant i_proc_open(CArrRef params) {
  FUNCTION_INJECTION(proc_open);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("proc_open", count, 3, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_proc_open(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_proc_open(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_proc_open(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_proc_open(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_hphp_splfileobject_fgetss(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgetss);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_fgetss", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fgetss(arg0, arg1));
  }
}
Variant i_clearpixeliterator(CArrRef params) {
  FUNCTION_INJECTION(clearpixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clearpixeliterator(arg0), null);
  }
}
Variant i_socket_server(CArrRef params) {
  FUNCTION_INJECTION(socket_server);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("socket_server", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_server(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_socket_server(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_socket_server(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_server(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickremoveimageprofile(CArrRef params) {
  FUNCTION_INJECTION(magickremoveimageprofile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickremoveimageprofile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickremoveimageprofile(arg0, arg1));
  }
}
Variant i_xmlwriter_write_dtd_element(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_element", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd_element(arg0, arg1, arg2));
  }
}
Variant i_drawpushdefs(CArrRef params) {
  FUNCTION_INJECTION(drawpushdefs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpushdefs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpushdefs(arg0), null);
  }
}
Variant i_image2wbmp(CArrRef params) {
  FUNCTION_INJECTION(image2wbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("image2wbmp", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_image2wbmp(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_image2wbmp(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_image2wbmp(arg0, arg1, arg2));
  }
}
Variant i_join(CArrRef params) {
  FUNCTION_INJECTION(join);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("join", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_join(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_join(arg0, arg1));
  }
}
Variant i_magicksetimage(CArrRef params) {
  FUNCTION_INJECTION(magicksetimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimage(arg0, arg1));
  }
}
Variant i_openssl_free_key(CArrRef params) {
  FUNCTION_INJECTION(openssl_free_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_free_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_free_key(arg0), null);
  }
}
Variant i_preg_grep(CArrRef params) {
  FUNCTION_INJECTION(preg_grep);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("preg_grep", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_preg_grep(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_grep(arg0, arg1, arg2));
  }
}
Variant i_is_float(CArrRef params) {
  FUNCTION_INJECTION(is_float);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_float", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_float(arg0));
  }
}
Variant i_stream_socket_pair(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_pair);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("stream_socket_pair", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_pair(arg0, arg1, arg2));
  }
}
Variant i_get_required_files(CArrRef params) {
  FUNCTION_INJECTION(get_required_files);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_required_files", 0, 1);
  return (f_get_required_files());
}
Variant i_mysql_fetch_field(CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_field);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_field", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_fetch_field(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_fetch_field(arg0, arg1));
  }
}
Variant i_chmod(CArrRef params) {
  FUNCTION_INJECTION(chmod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chmod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chmod(arg0, arg1));
  }
}
Variant i_magickgettextascent(CArrRef params) {
  FUNCTION_INJECTION(magickgettextascent);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextascent", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgettextascent(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgettextascent(arg0, arg1, arg2, arg3));
  }
}
Variant i_mb_regex_encoding(CArrRef params) {
  FUNCTION_INJECTION(mb_regex_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_regex_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_regex_encoding(arg0));
  }
}
Variant i_mail(CArrRef params) {
  FUNCTION_INJECTION(mail);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mail", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mail(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mail(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mail(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_mcrypt_enc_self_test(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_self_test);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_self_test", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_self_test(arg0));
  }
}
Variant i_ignore_user_abort(CArrRef params) {
  FUNCTION_INJECTION(ignore_user_abort);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ignore_user_abort", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ignore_user_abort());
    CVarRef arg0((ad->getValue(pos)));
    return (f_ignore_user_abort(arg0));
  }
}
Variant i_imagesetthickness(CArrRef params) {
  FUNCTION_INJECTION(imagesetthickness);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetthickness", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetthickness(arg0, arg1));
  }
}
Variant i_str_pad(CArrRef params) {
  FUNCTION_INJECTION(str_pad);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("str_pad", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_str_pad(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_str_pad(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_pad(arg0, arg1, arg2, arg3));
  }
}
Variant i_openssl_pkcs7_decrypt(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_pkcs7_decrypt", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_pkcs7_decrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_decrypt(arg0, arg1, arg2, arg3));
  }
}
Variant i_pagelet_server_task_result(CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_task_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("pagelet_server_task_result", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_pagelet_server_task_result(arg0, arg1, arg2));
  }
}
Variant i_asinh(CArrRef params) {
  FUNCTION_INJECTION(asinh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asinh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_asinh(arg0));
  }
}
Variant i_mailparse_msg_extract_part(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_extract_part);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mailparse_msg_extract_part(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_extract_part(arg0, arg1, arg2));
  }
}
Variant i_magickgetimagecompose(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecompose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecompose(arg0));
  }
}
Variant i_hphp_splfileinfo_getpath(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getpath(arg0));
  }
}
Variant i_magickcropimage(CArrRef params) {
  FUNCTION_INJECTION(magickcropimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcropimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcropimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_ob_gzhandler(CArrRef params) {
  FUNCTION_INJECTION(ob_gzhandler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_gzhandler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ob_gzhandler(arg0, arg1));
  }
}
Variant i_dom_document_normalize_document(CArrRef params) {
  FUNCTION_INJECTION(dom_document_normalize_document);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_normalize_document", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_normalize_document(arg0));
  }
}
Variant i_drawcomment(CArrRef params) {
  FUNCTION_INJECTION(drawcomment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawcomment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawcomment(arg0, arg1), null);
  }
}
Variant i_call_user_method(CArrRef params) {
  FUNCTION_INJECTION(call_user_method);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("call_user_method", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_call_user_method(count, arg0, arg1));
    return (f_call_user_method(count,arg0, ref(arg1), params.slice(2, count - 2, false)));
  }
}
Variant i_parse_hdf_file(CArrRef params) {
  FUNCTION_INJECTION(parse_hdf_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_file", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_parse_hdf_file(arg0));
  }
}
Variant i_mb_split(CArrRef params) {
  FUNCTION_INJECTION(mb_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_split", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_split(arg0, arg1, arg2));
  }
}
Variant i_imagepolygon(CArrRef params) {
  FUNCTION_INJECTION(imagepolygon);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagepolygon", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepolygon(arg0, arg1, arg2, arg3));
  }
}
Variant i_mysql_field_name(CArrRef params) {
  FUNCTION_INJECTION(mysql_field_name);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_name", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_name(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_name(arg0, arg1));
  }
}
Variant i_fputs(CArrRef params) {
  FUNCTION_INJECTION(fputs);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fputs", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fputs(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fputs(arg0, arg1, arg2));
  }
}
Variant i_imagecolorallocatealpha(CArrRef params) {
  FUNCTION_INJECTION(imagecolorallocatealpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorallocatealpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorallocatealpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_substr_count(CArrRef params) {
  FUNCTION_INJECTION(substr_count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("substr_count", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_substr_count(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_substr_count(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr_count(arg0, arg1, arg2, arg3));
  }
}
Variant i_ldap_first_reference(CArrRef params) {
  FUNCTION_INJECTION(ldap_first_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_reference", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_first_reference(arg0, arg1));
  }
}
Variant i_clock_settime(CArrRef params) {
  FUNCTION_INJECTION(clock_settime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_settime", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_clock_settime(arg0, arg1, arg2));
  }
}
Variant i_dom_namednodemap_get_named_item_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_namednodemap_get_named_item_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_namednodemap_get_named_item_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_namednodemap_get_named_item_ns(arg0, arg1, arg2));
  }
}
Variant i_ftruncate(CArrRef params) {
  FUNCTION_INJECTION(ftruncate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftruncate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ftruncate(arg0, arg1));
  }
}
Variant i_curl_version(CArrRef params) {
  FUNCTION_INJECTION(curl_version);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_version", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_curl_version());
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_version(arg0));
  }
}
Variant i_pixelgetbluequantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetbluequantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetbluequantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetbluequantum(arg0));
  }
}
Variant i_print(CArrRef params) {
  FUNCTION_INJECTION(print);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("print", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_print(arg0));
  }
}
Variant i_mysql_unbuffered_query(CArrRef params) {
  FUNCTION_INJECTION(mysql_unbuffered_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_unbuffered_query", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_unbuffered_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_unbuffered_query(arg0, arg1));
  }
}
Variant i_dom_characterdata_delete_data(CArrRef params) {
  FUNCTION_INJECTION(dom_characterdata_delete_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_delete_data", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_characterdata_delete_data(arg0, arg1, arg2));
  }
}
Variant i_hphp_recursiveiteratoriterator___construct(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_recursiveiteratoriterator___construct", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_recursiveiteratoriterator___construct(arg0, arg1, arg2, arg3));
  }
}
Variant i_hash_final(CArrRef params) {
  FUNCTION_INJECTION(hash_final);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hash_final", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hash_final(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_final(arg0, arg1));
  }
}
Variant i_imagecolorresolve(CArrRef params) {
  FUNCTION_INJECTION(imagecolorresolve);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorresolve", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorresolve(arg0, arg1, arg2, arg3));
  }
}
Variant i_dom_document_import_node(CArrRef params) {
  FUNCTION_INJECTION(dom_document_import_node);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_import_node", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_import_node(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_import_node(arg0, arg1, arg2));
  }
}
Variant i_date_date_set(CArrRef params) {
  FUNCTION_INJECTION(date_date_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("date_date_set", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_date_set(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_pixelsetyellow(CArrRef params) {
  FUNCTION_INJECTION(pixelsetyellow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellow", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetyellow(arg0, arg1), null);
  }
}
Variant i_furchash_hphp_ext_supported(CArrRef params) {
  FUNCTION_INJECTION(furchash_hphp_ext_supported);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("furchash_hphp_ext_supported", 0, 1);
  return (f_furchash_hphp_ext_supported());
}
Variant i_inet_pton(CArrRef params) {
  FUNCTION_INJECTION(inet_pton);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_pton", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_inet_pton(arg0));
  }
}
Variant i_mcrypt_get_key_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_key_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_key_size", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_get_key_size(arg0, arg1));
  }
}
Variant i_drawsettextalignment(CArrRef params) {
  FUNCTION_INJECTION(drawsettextalignment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextalignment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextalignment(arg0, arg1), null);
  }
}
Variant i_magickgetimageredprimary(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageredprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageredprimary", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageredprimary(arg0));
  }
}
Variant i_addslashes(CArrRef params) {
  FUNCTION_INJECTION(addslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("addslashes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_addslashes(arg0));
  }
}
Variant i_ldap_count_entries(CArrRef params) {
  FUNCTION_INJECTION(ldap_count_entries);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_count_entries", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_count_entries(arg0, arg1));
  }
}
Variant i_ereg_replace(CArrRef params) {
  FUNCTION_INJECTION(ereg_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ereg_replace", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ereg_replace(arg0, arg1, arg2));
  }
}
Variant i_hphp_recursivedirectoryiterator_getchildren(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_getchildren);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getchildren", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_getchildren(arg0));
  }
}
Variant i_call_user_func_async(CArrRef params) {
  FUNCTION_INJECTION(call_user_func_async);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func_async", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_call_user_func_async(count, arg0));
    return (f_call_user_func_async(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_drawrender(CArrRef params) {
  FUNCTION_INJECTION(drawrender);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawrender", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawrender(arg0));
  }
}
Variant i_fb_rpc_intercept_handler(CArrRef params) {
  FUNCTION_INJECTION(fb_rpc_intercept_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_rpc_intercept_handler", count, 5, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_rpc_intercept_handler(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_fb_intercept(CArrRef params) {
  FUNCTION_INJECTION(fb_intercept);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_intercept", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_intercept(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_intercept(arg0, arg1, arg2));
  }
}
Variant i_magickgetversionnumber(CArrRef params) {
  FUNCTION_INJECTION(magickgetversionnumber);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionnumber", 0, 1);
  return (f_magickgetversionnumber());
}
Variant i_array_splice(CArrRef params) {
  FUNCTION_INJECTION(array_splice);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_splice", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_splice(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_array_splice(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_splice(arg0, arg1, arg2, arg3));
  }
}
Variant i_ftell(CArrRef params) {
  FUNCTION_INJECTION(ftell);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ftell", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ftell(arg0));
  }
}
Variant i_magicksetimagedepth(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagedepth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magicksetimagedepth", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magicksetimagedepth(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagedepth(arg0, arg1, arg2));
  }
}
Variant i_apc_load_constants(CArrRef params) {
  FUNCTION_INJECTION(apc_load_constants);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_load_constants", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_load_constants(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_load_constants(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_load_constants(arg0, arg1, arg2));
  }
}
Variant i___halt_compiler(CArrRef params) {
  FUNCTION_INJECTION(__halt_compiler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("__halt_compiler", 0, 1);
  return (f___halt_compiler(), null);
}
Variant i_magicklabelimage(CArrRef params) {
  FUNCTION_INJECTION(magicklabelimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicklabelimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicklabelimage(arg0, arg1));
  }
}
Variant i_hphp_log(CArrRef params) {
  FUNCTION_INJECTION(hphp_log);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_log", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_log(arg0, arg1));
  }
}
Variant i_stream_get_contents(CArrRef params) {
  FUNCTION_INJECTION(stream_get_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_contents", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_get_contents(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_get_contents(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_get_contents(arg0, arg1, arg2));
  }
}
Variant i_imagecreatefromjpeg(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromjpeg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromjpeg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromjpeg(arg0));
  }
}
Variant i_chown(CArrRef params) {
  FUNCTION_INJECTION(chown);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chown", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_chown(arg0, arg1));
  }
}
Variant i_hash_hmac_file(CArrRef params) {
  FUNCTION_INJECTION(hash_hmac_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac_file", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_hash_hmac_file(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_hmac_file(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickechoimageblob(CArrRef params) {
  FUNCTION_INJECTION(magickechoimageblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimageblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickechoimageblob(arg0));
  }
}
Variant i_link(CArrRef params) {
  FUNCTION_INJECTION(link);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("link", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_link(arg0, arg1));
  }
}
Variant i_fb_utf8ize(CArrRef params) {
  FUNCTION_INJECTION(fb_utf8ize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_utf8ize", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_fb_utf8ize(arg0));
  }
}
Variant i_drawsetfillpatternurl(CArrRef params) {
  FUNCTION_INJECTION(drawsetfillpatternurl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillpatternurl", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillpatternurl(arg0, arg1));
  }
}
Variant i_iconv(CArrRef params) {
  FUNCTION_INJECTION(iconv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("iconv", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv(arg0, arg1, arg2));
  }
}
Variant i_highlight_file(CArrRef params) {
  FUNCTION_INJECTION(highlight_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_highlight_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_highlight_file(arg0, arg1));
  }
}
Variant i_iconv_mime_decode_headers(CArrRef params) {
  FUNCTION_INJECTION(iconv_mime_decode_headers);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode_headers", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iconv_mime_decode_headers(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_iconv_mime_decode_headers(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_mime_decode_headers(arg0, arg1, arg2));
  }
}
Variant i_ini_get_all(CArrRef params) {
  FUNCTION_INJECTION(ini_get_all);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ini_get_all", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ini_get_all());
    CVarRef arg0((ad->getValue(pos)));
    return (f_ini_get_all(arg0));
  }
}
Variant i_collator_get_strength(CArrRef params) {
  FUNCTION_INJECTION(collator_get_strength);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_strength", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_get_strength(arg0));
  }
}
Variant i_ldap_get_values_len(CArrRef params) {
  FUNCTION_INJECTION(ldap_get_values_len);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values_len", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_values_len(arg0, arg1, arg2));
  }
}
Variant i_hphp_splfileinfo_getrealpath(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getrealpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getrealpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getrealpath(arg0));
  }
}
Variant i_openssl_pkcs7_verify(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_verify);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("openssl_pkcs7_verify", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_pkcs7_verify(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_pkcs7_verify(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_openssl_pkcs7_verify(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_openssl_pkcs7_verify(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_verify(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_hphp_directoryiterator_current(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_current(arg0));
  }
}
Variant i_hphp_splfileobject_fgetcsv(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgetcsv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fgetcsv", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fgetcsv(arg0, arg1, arg2, arg3));
  }
}
Variant i_furchash_hphp_ext(CArrRef params) {
  FUNCTION_INJECTION(furchash_hphp_ext);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("furchash_hphp_ext", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_furchash_hphp_ext(arg0, arg1, arg2));
  }
}
Variant i_stream_socket_recvfrom(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_recvfrom);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_recvfrom", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_socket_recvfrom(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_recvfrom(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_recvfrom(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawgetcliprule(CArrRef params) {
  FUNCTION_INJECTION(drawgetcliprule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetcliprule", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetcliprule(arg0));
  }
}
Variant i_apc_filehits(CArrRef params) {
  FUNCTION_INJECTION(apc_filehits);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apc_filehits", 0, 1);
  return (f_apc_filehits());
}
Variant i_pixelgetexceptionstring(CArrRef params) {
  FUNCTION_INJECTION(pixelgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetexceptionstring(arg0));
  }
}
Variant i_mcrypt_ofb(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_ofb);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ofb", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_mcrypt_ofb(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_ofb(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_imageantialias(CArrRef params) {
  FUNCTION_INJECTION(imageantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imageantialias", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageantialias(arg0, arg1));
  }
}
Variant i_hphp_splfileinfo_openfile(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_openfile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileinfo_openfile", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_openfile(arg0, arg1, arg2, arg3));
  }
}
Variant i_dom_document_validate(CArrRef params) {
  FUNCTION_INJECTION(dom_document_validate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_validate", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_validate(arg0));
  }
}
Variant i_idn_to_ascii(CArrRef params) {
  FUNCTION_INJECTION(idn_to_ascii);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_ascii", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_idn_to_ascii(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_idn_to_ascii(arg0, arg1));
  }
}
Variant i_error_log(CArrRef params) {
  FUNCTION_INJECTION(error_log);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("error_log", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_error_log(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_error_log(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_error_log(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_error_log(arg0, arg1, arg2, arg3));
  }
}
Variant i_hash_update(CArrRef params) {
  FUNCTION_INJECTION(hash_update);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hash_update", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_update(arg0, arg1));
  }
}
Variant i_ob_flush(CArrRef params) {
  FUNCTION_INJECTION(ob_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_flush", 0, 1);
  return (f_ob_flush(), null);
}
Variant i_md5_file(CArrRef params) {
  FUNCTION_INJECTION(md5_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5_file", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_md5_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_md5_file(arg0, arg1));
  }
}
Variant i_drawgetexception(CArrRef params) {
  FUNCTION_INJECTION(drawgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetexception(arg0));
  }
}
Variant i_file_get_contents(CArrRef params) {
  FUNCTION_INJECTION(file_get_contents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("file_get_contents", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_file_get_contents(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_file_get_contents(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_file_get_contents(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_file_get_contents(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_file_get_contents(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_uniqid(CArrRef params) {
  FUNCTION_INJECTION(uniqid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("uniqid", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_uniqid());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_uniqid(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_uniqid(arg0, arg1));
  }
}
Variant i_strncasecmp(CArrRef params) {
  FUNCTION_INJECTION(strncasecmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncasecmp", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strncasecmp(arg0, arg1, arg2));
  }
}
Variant i_magicksetimagepixels(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagepixels);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("magicksetimagepixels", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagepixels(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_drawgetfillopacity(CArrRef params) {
  FUNCTION_INJECTION(drawgetfillopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillopacity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillopacity(arg0));
  }
}
Variant i_xml_parser_create_ns(CArrRef params) {
  FUNCTION_INJECTION(xml_parser_create_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("xml_parser_create_ns", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_xml_parser_create_ns());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_xml_parser_create_ns(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parser_create_ns(arg0, arg1));
  }
}
Variant i_ldap_delete(CArrRef params) {
  FUNCTION_INJECTION(ldap_delete);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_delete", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_delete(arg0, arg1));
  }
}
Variant i_fnmatch(CArrRef params) {
  FUNCTION_INJECTION(fnmatch);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fnmatch", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fnmatch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fnmatch(arg0, arg1, arg2));
  }
}
Variant i_hphp_splfileobject_eof(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_eof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_eof", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_eof(arg0));
  }
}
Variant i_metaphone(CArrRef params) {
  FUNCTION_INJECTION(metaphone);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("metaphone", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_metaphone(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_metaphone(arg0, arg1));
  }
}
Variant i_mysql_errno(CArrRef params) {
  FUNCTION_INJECTION(mysql_errno);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_errno", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_errno());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_errno(arg0));
  }
}
Variant i_stream_wrapper_unregister(CArrRef params) {
  FUNCTION_INJECTION(stream_wrapper_unregister);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_unregister", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_wrapper_unregister(arg0));
  }
}
Variant i_magickcyclecolormapimage(CArrRef params) {
  FUNCTION_INJECTION(magickcyclecolormapimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcyclecolormapimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcyclecolormapimage(arg0, arg1));
  }
}
Variant i_hphp_recursiveiteratoriterator_current(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_current(arg0));
  }
}
Variant i_restore_error_handler(CArrRef params) {
  FUNCTION_INJECTION(restore_error_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_error_handler", 0, 1);
  return (f_restore_error_handler());
}
Variant i_hphp_recursivedirectoryiterator___construct(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_recursivedirectoryiterator___construct", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_recursivedirectoryiterator___construct(arg0, arg1, arg2));
  }
}
Variant i_magicksetimagevirtualpixelmethod(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagevirtualpixelmethod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagevirtualpixelmethod", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagevirtualpixelmethod(arg0, arg1));
  }
}
Variant i_socket_getpeername(CArrRef params) {
  FUNCTION_INJECTION(socket_getpeername);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getpeername", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_getpeername(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_getpeername(arg0, arg1, arg2));
  }
}
Variant i_memcache_close(CArrRef params) {
  FUNCTION_INJECTION(memcache_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_memcache_close(arg0));
  }
}
Variant i_mysql_error(CArrRef params) {
  FUNCTION_INJECTION(mysql_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_error", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_error());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_error(arg0));
  }
}
Variant i_drawtranslate(CArrRef params) {
  FUNCTION_INJECTION(drawtranslate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawtranslate", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawtranslate(arg0, arg1, arg2), null);
  }
}
Variant i_mysql_list_dbs(CArrRef params) {
  FUNCTION_INJECTION(mysql_list_dbs);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_dbs", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_list_dbs());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_list_dbs(arg0));
  }
}
Variant i_imagefilter(CArrRef params) {
  FUNCTION_INJECTION(imagefilter);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("imagefilter", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_imagefilter(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_imagefilter(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_imagefilter(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_imagefilter(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilter(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_base64_encode(CArrRef params) {
  FUNCTION_INJECTION(base64_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("base64_encode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_base64_encode(arg0));
  }
}
Variant i_dom_xpath_query(CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_query", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_xpath_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_query(arg0, arg1, arg2));
  }
}
Variant i_hphpd_install_user_command(CArrRef params) {
  FUNCTION_INJECTION(hphpd_install_user_command);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphpd_install_user_command", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphpd_install_user_command(arg0, arg1));
  }
}
Variant i_dom_element_set_id_attribute_node(CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_id_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute_node", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_id_attribute_node(arg0, arg1, arg2));
  }
}
Variant i_is_null(CArrRef params) {
  FUNCTION_INJECTION(is_null);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_null", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_null(arg0));
  }
}
Variant i_octdec(CArrRef params) {
  FUNCTION_INJECTION(octdec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("octdec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_octdec(arg0));
  }
}
Variant i_drawsetclippath(CArrRef params) {
  FUNCTION_INJECTION(drawsetclippath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclippath", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetclippath(arg0, arg1));
  }
}
Variant i_magickconstituteimage(CArrRef params) {
  FUNCTION_INJECTION(magickconstituteimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickconstituteimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickconstituteimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_pcntl_wexitstatus(CArrRef params) {
  FUNCTION_INJECTION(pcntl_wexitstatus);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wexitstatus", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wexitstatus(arg0));
  }
}
Variant i_iterator_apply(CArrRef params) {
  FUNCTION_INJECTION(iterator_apply);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iterator_apply", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iterator_apply(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iterator_apply(arg0, arg1, arg2));
  }
}
Variant i_apache_setenv(CArrRef params) {
  FUNCTION_INJECTION(apache_setenv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("apache_setenv", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apache_setenv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apache_setenv(arg0, arg1, arg2));
  }
}
Variant i_dom_node_is_same_node(CArrRef params) {
  FUNCTION_INJECTION(dom_node_is_same_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_same_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_is_same_node(arg0, arg1));
  }
}
Variant i_clonedrawingwand(CArrRef params) {
  FUNCTION_INJECTION(clonedrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonedrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clonedrawingwand(arg0));
  }
}
Variant i_ob_get_clean(CArrRef params) {
  FUNCTION_INJECTION(ob_get_clean);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_clean", 0, 1);
  return (f_ob_get_clean());
}
Variant i_expm1(CArrRef params) {
  FUNCTION_INJECTION(expm1);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("expm1", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_expm1(arg0));
  }
}
Variant i_ldap_first_entry(CArrRef params) {
  FUNCTION_INJECTION(ldap_first_entry);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_entry", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_first_entry(arg0, arg1));
  }
}
Variant i_curl_multi_select(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_select);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_select", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_curl_multi_select(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_multi_select(arg0, arg1));
  }
}
Variant i_magickswirlimage(CArrRef params) {
  FUNCTION_INJECTION(magickswirlimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickswirlimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickswirlimage(arg0, arg1));
  }
}
Variant i_mb_ereg_search_regs(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_regs);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_regs", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_ereg_search_regs());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_ereg_search_regs(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search_regs(arg0, arg1));
  }
}
Variant i_ldap_errno(CArrRef params) {
  FUNCTION_INJECTION(ldap_errno);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_errno", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_errno(arg0));
  }
}
Variant i_mysql_get_server_info(CArrRef params) {
  FUNCTION_INJECTION(mysql_get_server_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_server_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_get_server_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_get_server_info(arg0));
  }
}
Variant i_mailparse_rfc822_parse_addresses(CArrRef params) {
  FUNCTION_INJECTION(mailparse_rfc822_parse_addresses);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_rfc822_parse_addresses", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_rfc822_parse_addresses(arg0));
  }
}
Variant i_magickgetimagemimetype(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagemimetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemimetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagemimetype(arg0));
  }
}
Variant i_soundex(CArrRef params) {
  FUNCTION_INJECTION(soundex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("soundex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_soundex(arg0));
  }
}
Variant i_magickgetimageformat(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageformat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageformat(arg0));
  }
}
Variant i_mcrypt_module_get_supported_key_sizes(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_get_supported_key_sizes);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_supported_key_sizes", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_get_supported_key_sizes(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_get_supported_key_sizes(arg0, arg1));
  }
}
Variant i_preg_replace_callback(CArrRef params) {
  FUNCTION_INJECTION(preg_replace_callback);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace_callback", count, 3, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_preg_replace_callback(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_replace_callback(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_preg_replace_callback(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_dom_document_create_element(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_element);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_element", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_create_element(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_element(arg0, arg1, arg2));
  }
}
Variant i_ldap_error(CArrRef params) {
  FUNCTION_INJECTION(ldap_error);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_error", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_error(arg0));
  }
}
Variant i_xmlwriter_full_end_element(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_full_end_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_full_end_element", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_full_end_element(arg0));
  }
}
Variant i_ctype_graph(CArrRef params) {
  FUNCTION_INJECTION(ctype_graph);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_graph", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_graph(arg0));
  }
}
Variant i_session_register(CArrRef params) {
  FUNCTION_INJECTION(session_register);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("session_register", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_session_register(count, arg0));
    return (f_session_register(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_asort(CArrRef params) {
  FUNCTION_INJECTION(asort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("asort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_asort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_asort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_asort(arg0, arg1, arg2));
  }
}
Variant i_apd_echo(CArrRef params) {
  FUNCTION_INJECTION(apd_echo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("apd_echo", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_apd_echo(arg0));
  }
}
Variant i_rewinddir(CArrRef params) {
  FUNCTION_INJECTION(rewinddir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewinddir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rewinddir(arg0), null);
  }
}
Variant i_ob_implicit_flush(CArrRef params) {
  FUNCTION_INJECTION(ob_implicit_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_implicit_flush", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_ob_implicit_flush(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_ob_implicit_flush(arg0), null);
  }
}
Variant i_pcntl_signal_dispatch(CArrRef params) {
  FUNCTION_INJECTION(pcntl_signal_dispatch);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_signal_dispatch", 0, 1);
  return (f_pcntl_signal_dispatch());
}
Variant i_session_get_cookie_params(CArrRef params) {
  FUNCTION_INJECTION(session_get_cookie_params);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_get_cookie_params", 0, 1);
  return (f_session_get_cookie_params());
}
Variant i_pixelgetiteratorexceptionstring(CArrRef params) {
  FUNCTION_INJECTION(pixelgetiteratorexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetiteratorexceptionstring(arg0));
  }
}
Variant i_stream_socket_client(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_client);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("stream_socket_client", count, 1, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_socket_client(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_socket_client(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_client(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_stream_socket_client(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_stream_socket_client(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_client(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_drawsetstrokedasharray(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokedasharray);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokedasharray", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_drawsetstrokedasharray(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokedasharray(arg0, arg1), null);
  }
}
Variant i_mysql_free_result(CArrRef params) {
  FUNCTION_INJECTION(mysql_free_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_free_result", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_free_result(arg0));
  }
}
Variant i_is_real(CArrRef params) {
  FUNCTION_INJECTION(is_real);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_real", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_real(arg0));
  }
}
Variant i_mcrypt_enc_is_block_algorithm_mode(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_is_block_algorithm_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm_mode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_is_block_algorithm_mode(arg0));
  }
}
Variant i_array_slice(CArrRef params) {
  FUNCTION_INJECTION(array_slice);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_slice", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_slice(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_array_slice(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_slice(arg0, arg1, arg2, arg3));
  }
}
Variant i_count_chars(CArrRef params) {
  FUNCTION_INJECTION(count_chars);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count_chars", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_count_chars(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_count_chars(arg0, arg1));
  }
}
Variant i_hphp_splfileobject_getmaxlinelen(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_getmaxlinelen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getmaxlinelen", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_getmaxlinelen(arg0));
  }
}
Variant i_array_uintersect_uassoc(CArrRef params) {
  FUNCTION_INJECTION(array_uintersect_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_uintersect_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_array_uintersect_uassoc(count, arg0, arg1, arg2, arg3));
    return (f_array_uintersect_uassoc(count,arg0, arg1, arg2, arg3, params.slice(4, count - 4, false)));
  }
}
Variant i_drawsetstrokewidth(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokewidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokewidth", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokewidth(arg0, arg1), null);
  }
}
Variant i_posix_mkfifo(CArrRef params) {
  FUNCTION_INJECTION(posix_mkfifo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_mkfifo", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_mkfifo(arg0, arg1));
  }
}
Variant i_array_count_values(CArrRef params) {
  FUNCTION_INJECTION(array_count_values);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_count_values", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_count_values(arg0));
  }
}
Variant i_memcache_connect(CArrRef params) {
  FUNCTION_INJECTION(memcache_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_connect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_connect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_connect(arg0, arg1, arg2, arg3));
  }
}
Variant i_pixelgetexception(CArrRef params) {
  FUNCTION_INJECTION(pixelgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetexception(arg0));
  }
}
Variant i_mkdir(CArrRef params) {
  FUNCTION_INJECTION(mkdir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("mkdir", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mkdir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mkdir(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mkdir(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mkdir(arg0, arg1, arg2, arg3));
  }
}
Variant i_magicksetsize(CArrRef params) {
  FUNCTION_INJECTION(magicksetsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsize", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetsize(arg0, arg1, arg2));
  }
}
Variant i_debug_zval_dump(CArrRef params) {
  FUNCTION_INJECTION(debug_zval_dump);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("debug_zval_dump", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_debug_zval_dump(arg0), null);
  }
}
Variant i_iconv_substr(CArrRef params) {
  FUNCTION_INJECTION(iconv_substr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_substr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_substr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_iconv_substr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_substr(arg0, arg1, arg2, arg3));
  }
}
Variant i_xml_set_external_entity_ref_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_external_entity_ref_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_external_entity_ref_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_external_entity_ref_handler(arg0, arg1));
  }
}
Variant i_mb_decode_numericentity(CArrRef params) {
  FUNCTION_INJECTION(mb_decode_numericentity);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_decode_numericentity", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_decode_numericentity(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_decode_numericentity(arg0, arg1, arg2));
  }
}
Variant i_ldap_next_attribute(CArrRef params) {
  FUNCTION_INJECTION(ldap_next_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_next_attribute(arg0, arg1));
  }
}
Variant i_hphp_splfileobject_fflush(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fflush);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fflush", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fflush(arg0));
  }
}
Variant i_imagejpeg(CArrRef params) {
  FUNCTION_INJECTION(imagejpeg);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagejpeg", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagejpeg(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagejpeg(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagejpeg(arg0, arg1, arg2));
  }
}
Variant i_imagesetbrush(CArrRef params) {
  FUNCTION_INJECTION(imagesetbrush);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetbrush", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetbrush(arg0, arg1));
  }
}
Variant i_mb_strtoupper(CArrRef params) {
  FUNCTION_INJECTION(mb_strtoupper);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtoupper", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strtoupper(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strtoupper(arg0, arg1));
  }
}
Variant i_usleep(CArrRef params) {
  FUNCTION_INJECTION(usleep);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("usleep", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_usleep(arg0), null);
  }
}
Variant i_mb_strrpos(CArrRef params) {
  FUNCTION_INJECTION(mb_strrpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrpos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_strrpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_strrpos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strrpos(arg0, arg1, arg2, arg3));
  }
}
Variant i_collator_compare(CArrRef params) {
  FUNCTION_INJECTION(collator_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_compare", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_compare(arg0, arg1, arg2));
  }
}
Variant i_extract(CArrRef params) {
  FUNCTION_INJECTION(extract);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("extract", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_extract(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_extract(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_extract(arg0, arg1, arg2));
  }
}
Variant i_session_decode(CArrRef params) {
  FUNCTION_INJECTION(session_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_decode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_decode(arg0));
  }
}
Variant i_get_browser(CArrRef params) {
  FUNCTION_INJECTION(get_browser);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_browser", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_browser());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_get_browser(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_browser(arg0, arg1));
  }
}
Variant i_html_entity_decode(CArrRef params) {
  FUNCTION_INJECTION(html_entity_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("html_entity_decode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_html_entity_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_html_entity_decode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_html_entity_decode(arg0, arg1, arg2));
  }
}
Variant i_spl_classes(CArrRef params) {
  FUNCTION_INJECTION(spl_classes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("spl_classes", 0, 1);
  return (f_spl_classes());
}
Variant i_preg_split(CArrRef params) {
  FUNCTION_INJECTION(preg_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("preg_split", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_preg_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_preg_split(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_split(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickpreviewimages(CArrRef params) {
  FUNCTION_INJECTION(magickpreviewimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpreviewimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpreviewimages(arg0, arg1));
  }
}
Variant i_zend_logo_guid(CArrRef params) {
  FUNCTION_INJECTION(zend_logo_guid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_logo_guid", 0, 1);
  return (f_zend_logo_guid());
}
Variant i_magickgetimagesize(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagesize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagesize(arg0));
  }
}
Variant i_apd_set_browser_trace(CArrRef params) {
  FUNCTION_INJECTION(apd_set_browser_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_set_browser_trace", 0, 1);
  return (f_apd_set_browser_trace(), null);
}
Variant i_xhprof_sample_enable(CArrRef params) {
  FUNCTION_INJECTION(xhprof_sample_enable);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_enable", 0, 1);
  return (f_xhprof_sample_enable(), null);
}
Variant i_hphp_splfileobject_key(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_key(arg0));
  }
}
Variant i_mb_http_input(CArrRef params) {
  FUNCTION_INJECTION(mb_http_input);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_input", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_http_input());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_http_input(arg0));
  }
}
Variant i_gzinflate(CArrRef params) {
  FUNCTION_INJECTION(gzinflate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzinflate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzinflate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzinflate(arg0, arg1));
  }
}
Variant i_openssl_pkcs7_sign(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_sign);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 7) return throw_wrong_arguments("openssl_pkcs7_sign", count, 5, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_openssl_pkcs7_sign(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_openssl_pkcs7_sign(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_sign(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_assert(CArrRef params) {
  FUNCTION_INJECTION(assert);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("assert", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_assert(arg0));
  }
}
Variant i_stream_get_wrappers(CArrRef params) {
  FUNCTION_INJECTION(stream_get_wrappers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_wrappers", 0, 1);
  return (f_stream_get_wrappers());
}
Variant i_gzfile(CArrRef params) {
  FUNCTION_INJECTION(gzfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzfile", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzfile(arg0, arg1));
  }
}
Variant i_session_id(CArrRef params) {
  FUNCTION_INJECTION(session_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_id(arg0));
  }
}
Variant i_stream_socket_sendto(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_sendto);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_sendto", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_socket_sendto(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_sendto(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_sendto(arg0, arg1, arg2, arg3));
  }
}
Variant i_gzpassthru(CArrRef params) {
  FUNCTION_INJECTION(gzpassthru);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzpassthru", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzpassthru(arg0));
  }
}
Variant i_stream_bucket_make_writeable(CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_make_writeable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_bucket_make_writeable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_bucket_make_writeable(arg0));
  }
}
Variant i_posix_setegid(CArrRef params) {
  FUNCTION_INJECTION(posix_setegid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setegid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_setegid(arg0));
  }
}
Variant i_drawgetexceptionstring(CArrRef params) {
  FUNCTION_INJECTION(drawgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetexceptionstring(arg0));
  }
}
Variant i_hash_algos(CArrRef params) {
  FUNCTION_INJECTION(hash_algos);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hash_algos", 0, 1);
  return (f_hash_algos());
}
Variant i_drawsetstrokeantialias(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokeantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokeantialias", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_drawsetstrokeantialias(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokeantialias(arg0, arg1), null);
  }
}
Variant i_destroypixelwand(CArrRef params) {
  FUNCTION_INJECTION(destroypixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixelwand(arg0), null);
  }
}
Variant i_fstat(CArrRef params) {
  FUNCTION_INJECTION(fstat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fstat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fstat(arg0));
  }
}
Variant i_magicksetimageresolution(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageresolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageresolution", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageresolution(arg0, arg1, arg2));
  }
}
Variant i_mysql_db_name(CArrRef params) {
  FUNCTION_INJECTION(mysql_db_name);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_name", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_db_name(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_db_name(arg0, arg1, arg2));
  }
}
Variant i_is_finite(CArrRef params) {
  FUNCTION_INJECTION(is_finite);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_finite", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_finite(arg0));
  }
}
Variant i_pixelgetyellowquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetyellowquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellowquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetyellowquantum(arg0));
  }
}
Variant i_ksort(CArrRef params) {
  FUNCTION_INJECTION(ksort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ksort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_ksort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ksort(arg0, arg1));
  }
}
Variant i_thrift_protocol_read_binary(CArrRef params) {
  FUNCTION_INJECTION(thrift_protocol_read_binary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("thrift_protocol_read_binary", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_thrift_protocol_read_binary(arg0, arg1, arg2));
  }
}
Variant i_get_included_files(CArrRef params) {
  FUNCTION_INJECTION(get_included_files);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_included_files", 0, 1);
  return (f_get_included_files());
}
Variant i_strip_tags(CArrRef params) {
  FUNCTION_INJECTION(strip_tags);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strip_tags", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strip_tags(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strip_tags(arg0, arg1));
  }
}
Variant i_mb_ereg_search_getpos(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_getpos);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getpos", 0, 1);
  return (f_mb_ereg_search_getpos());
}
Variant i_pixelgetcyanquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetcyanquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyanquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcyanquantum(arg0));
  }
}
Variant i_magickgetexception(CArrRef params) {
  FUNCTION_INJECTION(magickgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetexception(arg0));
  }
}
Variant i_ctype_punct(CArrRef params) {
  FUNCTION_INJECTION(ctype_punct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_punct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_punct(arg0));
  }
}
Variant i_next(CArrRef params) {
  FUNCTION_INJECTION(next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("next", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_next(arg0));
  }
}
Variant i_shm_detach(CArrRef params) {
  FUNCTION_INJECTION(shm_detach);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_detach", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_shm_detach(arg0));
  }
}
Variant i_shm_attach(CArrRef params) {
  FUNCTION_INJECTION(shm_attach);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("shm_attach", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_shm_attach(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_shm_attach(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_attach(arg0, arg1, arg2));
  }
}
Variant i_magickflattenimages(CArrRef params) {
  FUNCTION_INJECTION(magickflattenimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflattenimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickflattenimages(arg0));
  }
}
Variant i_dom_document_save_html_file(CArrRef params) {
  FUNCTION_INJECTION(dom_document_save_html_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_save_html_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_save_html_file(arg0, arg1));
  }
}
Variant i_similar_text(CArrRef params) {
  FUNCTION_INJECTION(similar_text);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("similar_text", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_similar_text(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_similar_text(arg0, arg1, arg2));
  }
}
Variant i_hphp_get_thread_id(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_thread_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_get_thread_id", 0, 1);
  return (f_hphp_get_thread_id());
}
Variant i_imagecreatefromgd2part(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgd2part);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecreatefromgd2part", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecreatefromgd2part(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_dom_element_set_attribute(CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute(arg0, arg1, arg2));
  }
}
Variant i_iterator_to_array(CArrRef params) {
  FUNCTION_INJECTION(iterator_to_array);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iterator_to_array", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iterator_to_array(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iterator_to_array(arg0, arg1));
  }
}
Variant i_iconv_get_encoding(CArrRef params) {
  FUNCTION_INJECTION(iconv_get_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("iconv_get_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_iconv_get_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_iconv_get_encoding(arg0));
  }
}
Variant i_getmyinode(CArrRef params) {
  FUNCTION_INJECTION(getmyinode);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyinode", 0, 1);
  return (f_getmyinode());
}
Variant i_gzgetc(CArrRef params) {
  FUNCTION_INJECTION(gzgetc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzgetc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzgetc(arg0));
  }
}
Variant i_hphp_set_static_property(CArrRef params) {
  FUNCTION_INJECTION(hphp_set_static_property);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_set_static_property", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_set_static_property(arg0, arg1, arg2), null);
  }
}
Variant i_unlink(CArrRef params) {
  FUNCTION_INJECTION(unlink);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("unlink", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_unlink(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_unlink(arg0, arg1));
  }
}
Variant i_mcrypt_module_open(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_open);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("mcrypt_module_open", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_open(arg0, arg1, arg2, arg3));
  }
}
Variant i_token_get_all(CArrRef params) {
  FUNCTION_INJECTION(token_get_all);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_get_all", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_token_get_all(arg0));
  }
}
Variant i_base_convert(CArrRef params) {
  FUNCTION_INJECTION(base_convert);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("base_convert", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_base_convert(arg0, arg1, arg2));
  }
}
Variant i_gethostbynamel(CArrRef params) {
  FUNCTION_INJECTION(gethostbynamel);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbynamel", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gethostbynamel(arg0));
  }
}
Variant i_var_dump(CArrRef params) {
  FUNCTION_INJECTION(var_dump);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("var_dump", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_var_dump(count, arg0), null);
    return (f_var_dump(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant i_xmlwriter_start_attribute(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_attribute(arg0, arg1));
  }
}
Variant i_pack(CArrRef params) {
  FUNCTION_INJECTION(pack);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("pack", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pack(count, arg0));
    return (f_pack(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_gzgets(CArrRef params) {
  FUNCTION_INJECTION(gzgets);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzgets", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzgets(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzgets(arg0, arg1));
  }
}
Variant i_apache_get_version(CArrRef params) {
  FUNCTION_INJECTION(apache_get_version);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_version", 0, 1);
  return (f_apache_get_version());
}
Variant i_array_intersect_uassoc(CArrRef params) {
  FUNCTION_INJECTION(array_intersect_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_intersect_uassoc(count, arg0, arg1, arg2));
    return (f_array_intersect_uassoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_basename(CArrRef params) {
  FUNCTION_INJECTION(basename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("basename", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_basename(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_basename(arg0, arg1));
  }
}
Variant i_krsort(CArrRef params) {
  FUNCTION_INJECTION(krsort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("krsort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_krsort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_krsort(arg0, arg1));
  }
}
Variant i_clock_gettime(CArrRef params) {
  FUNCTION_INJECTION(clock_gettime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_gettime", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_clock_gettime(arg0, arg1, arg2));
  }
}
Variant i_pushdrawingwand(CArrRef params) {
  FUNCTION_INJECTION(pushdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pushdrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pushdrawingwand(arg0), null);
  }
}
Variant i_imageline(CArrRef params) {
  FUNCTION_INJECTION(imageline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageline", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageline(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_socket_read(CArrRef params) {
  FUNCTION_INJECTION(socket_read);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_read", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_read(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_read(arg0, arg1, arg2));
  }
}
Variant i_xmlwriter_write_dtd_entity(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd_entity);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 7) return throw_wrong_arguments("xmlwriter_write_dtd_entity", count, 3, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd_entity(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_mysql_tablename(CArrRef params) {
  FUNCTION_INJECTION(mysql_tablename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_tablename", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_tablename(arg0, arg1));
  }
}
Variant i_collator_sort(CArrRef params) {
  FUNCTION_INJECTION(collator_sort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_sort", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_collator_sort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_sort(arg0, arg1, arg2));
  }
}
Variant i_magickwriteimage(CArrRef params) {
  FUNCTION_INJECTION(magickwriteimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimage(arg0, arg1));
  }
}
Variant i_mcrypt_module_get_algo_key_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_get_algo_key_size);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_key_size", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_get_algo_key_size(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_get_algo_key_size(arg0, arg1));
  }
}
Variant i_hash_update_file(CArrRef params) {
  FUNCTION_INJECTION(hash_update_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_hash_update_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hash_update_file(arg0, arg1, arg2));
  }
}
Variant i_magickembossimage(CArrRef params) {
  FUNCTION_INJECTION(magickembossimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickembossimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickembossimage(arg0, arg1, arg2));
  }
}
Variant i_forward_static_call(CArrRef params) {
  FUNCTION_INJECTION(forward_static_call);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("forward_static_call", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_forward_static_call(count, arg0));
    return (f_forward_static_call(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_gzencode(CArrRef params) {
  FUNCTION_INJECTION(gzencode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzencode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzencode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_gzencode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzencode(arg0, arg1, arg2));
  }
}
Variant i_checkdate(CArrRef params) {
  FUNCTION_INJECTION(checkdate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("checkdate", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_checkdate(arg0, arg1, arg2));
  }
}
Variant i_magickimplodeimage(CArrRef params) {
  FUNCTION_INJECTION(magickimplodeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickimplodeimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickimplodeimage(arg0, arg1));
  }
}
Variant i_magickgetimageindex(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageindex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageindex(arg0));
  }
}
Variant i_ctype_lower(CArrRef params) {
  FUNCTION_INJECTION(ctype_lower);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_lower", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_lower(arg0));
  }
}
Variant i_imagepsloadfont(CArrRef params) {
  FUNCTION_INJECTION(imagepsloadfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsloadfont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagepsloadfont(arg0));
  }
}
Variant i_iconv_mime_decode(CArrRef params) {
  FUNCTION_INJECTION(iconv_mime_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iconv_mime_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_iconv_mime_decode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_mime_decode(arg0, arg1, arg2));
  }
}
Variant i_hphp_recursiveiteratoriterator_key(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_key(arg0));
  }
}
Variant i_mcrypt_module_is_block_algorithm(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_is_block_algorithm);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_is_block_algorithm(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_is_block_algorithm(arg0, arg1));
  }
}
Variant i_wandgetexception(CArrRef params) {
  FUNCTION_INJECTION(wandgetexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandgetexception(arg0));
  }
}
Variant i_fsockopen(CArrRef params) {
  FUNCTION_INJECTION(fsockopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("fsockopen", count, 1, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fsockopen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fsockopen(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fsockopen(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_fsockopen(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fsockopen(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_usort(CArrRef params) {
  FUNCTION_INJECTION(usort);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("usort", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_usort(arg0, arg1));
  }
}
Variant i_pixelsetiteratorrow(CArrRef params) {
  FUNCTION_INJECTION(pixelsetiteratorrow);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetiteratorrow", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetiteratorrow(arg0, arg1));
  }
}
Variant i_call_user_func_serialized(CArrRef params) {
  FUNCTION_INJECTION(call_user_func_serialized);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("call_user_func_serialized", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_call_user_func_serialized(arg0));
  }
}
Variant i_hphp_splfileinfo_iswritable(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_iswritable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_iswritable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_iswritable(arg0));
  }
}
Variant i_dom_document_create_attribute(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_attribute(arg0, arg1));
  }
}
Variant i_ldap_get_option(CArrRef params) {
  FUNCTION_INJECTION(ldap_get_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_option", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_ldap_get_option(arg0, arg1, arg2));
  }
}
Variant i_socket_recv(CArrRef params) {
  FUNCTION_INJECTION(socket_recv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_recv", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_recv(arg0, arg1, arg2, arg3));
  }
}
Variant i_sys_getloadavg(CArrRef params) {
  FUNCTION_INJECTION(sys_getloadavg);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_getloadavg", 0, 1);
  return (f_sys_getloadavg());
}
Variant i_evhttp_async_post(CArrRef params) {
  FUNCTION_INJECTION(evhttp_async_post);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_async_post", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_evhttp_async_post(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_evhttp_async_post(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_async_post(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphp_recursivedirectoryiterator_seek(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_recursivedirectoryiterator_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_recursivedirectoryiterator_seek(arg0, arg1), null);
  }
}
Variant i_array_values(CArrRef params) {
  FUNCTION_INJECTION(array_values);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_values", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_values(arg0));
  }
}
Variant i_ctype_digit(CArrRef params) {
  FUNCTION_INJECTION(ctype_digit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_digit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_digit(arg0));
  }
}
Variant i_ob_get_length(CArrRef params) {
  FUNCTION_INJECTION(ob_get_length);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_length", 0, 1);
  return (f_ob_get_length());
}
Variant i_magicksolarizeimage(CArrRef params) {
  FUNCTION_INJECTION(magicksolarizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksolarizeimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksolarizeimage(arg0, arg1));
  }
}
Variant i_ob_list_handlers(CArrRef params) {
  FUNCTION_INJECTION(ob_list_handlers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_list_handlers", 0, 1);
  return (f_ob_list_handlers());
}
Variant i_array_uintersect_assoc(CArrRef params) {
  FUNCTION_INJECTION(array_uintersect_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_uintersect_assoc(count, arg0, arg1, arg2));
    return (f_array_uintersect_assoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_openssl_x509_read(CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_read);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_read", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_x509_read(arg0));
  }
}
Variant i_magickgetimagecolormapcolor(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecolormapcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagecolormapcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagecolormapcolor(arg0, arg1));
  }
}
Variant i_hphp_splfileobject_getcvscontrol(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_getcvscontrol);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getcvscontrol", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_getcvscontrol(arg0));
  }
}
Variant i_settype(CArrRef params) {
  FUNCTION_INJECTION(settype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("settype", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_settype(arg0, arg1));
  }
}
Variant i_posix_access(CArrRef params) {
  FUNCTION_INJECTION(posix_access);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("posix_access", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_posix_access(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_access(arg0, arg1));
  }
}
Variant i_explode(CArrRef params) {
  FUNCTION_INJECTION(explode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("explode", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_explode(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_explode(arg0, arg1, arg2));
  }
}
Variant i_fb_load_local_databases(CArrRef params) {
  FUNCTION_INJECTION(fb_load_local_databases);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_load_local_databases", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_load_local_databases(arg0), null);
  }
}
Variant i_imagecreatefromgd(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgd);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromgd(arg0));
  }
}
Variant i_proc_close(CArrRef params) {
  FUNCTION_INJECTION(proc_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_proc_close(arg0));
  }
}
Variant i_magickgaussianblurimage(CArrRef params) {
  FUNCTION_INJECTION(magickgaussianblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgaussianblurimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgaussianblurimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgaussianblurimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_apd_set_session_trace_socket(CArrRef params) {
  FUNCTION_INJECTION(apd_set_session_trace_socket);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("apd_set_session_trace_socket", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apd_set_session_trace_socket(arg0, arg1, arg2, arg3));
  }
}
Variant i_openssl_pkcs12_export_to_file(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs12_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export_to_file", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_pkcs12_export_to_file(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs12_export_to_file(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_mailparse_msg_free(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_free(arg0));
  }
}
Variant i_openssl_private_decrypt(CArrRef params) {
  FUNCTION_INJECTION(openssl_private_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_decrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_private_decrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_private_decrypt(arg0, arg1, arg2, arg3));
  }
}
Variant i_dom_document_save(CArrRef params) {
  FUNCTION_INJECTION(dom_document_save);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_save", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_document_save(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_save(arg0, arg1, arg2));
  }
}
Variant i_hphp_get_extension_info(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_extension_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_extension_info", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_extension_info(arg0));
  }
}
Variant i_output_add_rewrite_var(CArrRef params) {
  FUNCTION_INJECTION(output_add_rewrite_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("output_add_rewrite_var", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_output_add_rewrite_var(arg0, arg1));
  }
}
Variant i_xmlwriter_write_cdata(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_cdata);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_cdata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_cdata(arg0, arg1));
  }
}
Variant i_mb_list_mime_names(CArrRef params) {
  FUNCTION_INJECTION(mb_list_mime_names);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_mime_names", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_list_mime_names());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_list_mime_names(arg0));
  }
}
Variant i_ispixelwand(CArrRef params) {
  FUNCTION_INJECTION(ispixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixelwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ispixelwand(arg0));
  }
}
Variant i_xmlwriter_end_dtd(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd(arg0));
  }
}
Variant i_curl_close(CArrRef params) {
  FUNCTION_INJECTION(curl_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_close(arg0));
  }
}
Variant i_array_udiff(CArrRef params) {
  FUNCTION_INJECTION(array_udiff);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_udiff(count, arg0, arg1, arg2));
    return (f_array_udiff(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_session_cache_limiter(CArrRef params) {
  FUNCTION_INJECTION(session_cache_limiter);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_limiter", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_cache_limiter());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_cache_limiter(arg0));
  }
}
Variant i_stream_context_create(CArrRef params) {
  FUNCTION_INJECTION(stream_context_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("stream_context_create", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_stream_context_create());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_stream_context_create(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_context_create(arg0, arg1));
  }
}
Variant i_drawgetstrokedashoffset(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokedashoffset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedashoffset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokedashoffset(arg0));
  }
}
Variant i_openssl_pkey_get_public(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_get_public);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_public", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_get_public(arg0));
  }
}
Variant i_interface_exists(CArrRef params) {
  FUNCTION_INJECTION(interface_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("interface_exists", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_interface_exists(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_interface_exists(arg0, arg1));
  }
}
Variant i_hphp_directoryiterator___construct(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator___construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_directoryiterator___construct(arg0, arg1));
  }
}
Variant i_drawpathmovetorelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathmovetorelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetorelative", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathmovetorelative(arg0, arg1, arg2), null);
  }
}
Variant i_apache_get_config(CArrRef params) {
  FUNCTION_INJECTION(apache_get_config);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_config", 0, 1);
  return (f_apache_get_config());
}
Variant i_curl_copy_handle(CArrRef params) {
  FUNCTION_INJECTION(curl_copy_handle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_copy_handle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_curl_copy_handle(arg0));
  }
}
Variant i_drawgetvectorgraphics(CArrRef params) {
  FUNCTION_INJECTION(drawgetvectorgraphics);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetvectorgraphics", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetvectorgraphics(arg0));
  }
}
Variant i_drawpathfinish(CArrRef params) {
  FUNCTION_INJECTION(drawpathfinish);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathfinish", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpathfinish(arg0), null);
  }
}
Variant i_png2wbmp(CArrRef params) {
  FUNCTION_INJECTION(png2wbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("png2wbmp", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_png2wbmp(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_drawmatte(CArrRef params) {
  FUNCTION_INJECTION(drawmatte);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawmatte", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawmatte(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_imagecolormatch(CArrRef params) {
  FUNCTION_INJECTION(imagecolormatch);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolormatch", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolormatch(arg0, arg1));
  }
}
Variant i_drawrectangle(CArrRef params) {
  FUNCTION_INJECTION(drawrectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawrectangle", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawrectangle(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_fb_parallel_query(CArrRef params) {
  FUNCTION_INJECTION(fb_parallel_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("fb_parallel_query", count, 1, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fb_parallel_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fb_parallel_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fb_parallel_query(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_fb_parallel_query(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_fb_parallel_query(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_fb_parallel_query(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_parallel_query(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_dom_document_create_entity_reference(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_entity_reference);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_entity_reference", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_entity_reference(arg0, arg1));
  }
}
Variant i_mcrypt_enc_get_block_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_block_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_block_size", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_block_size(arg0));
  }
}
Variant i_stream_context_set_option(CArrRef params) {
  FUNCTION_INJECTION(stream_context_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_context_set_option", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_context_set_option(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_context_set_option(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_context_set_option(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawpathcurvetorelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetorelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetorelative", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetorelative(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant i_phpcredits(CArrRef params) {
  FUNCTION_INJECTION(phpcredits);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpcredits", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_phpcredits());
    CVarRef arg0((ad->getValue(pos)));
    return (f_phpcredits(arg0));
  }
}
Variant i_drawgetfillrule(CArrRef params) {
  FUNCTION_INJECTION(drawgetfillrule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillrule", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillrule(arg0));
  }
}
Variant i_parse_hdf_string(CArrRef params) {
  FUNCTION_INJECTION(parse_hdf_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_parse_hdf_string(arg0));
  }
}
Variant i_xmlwriter_end_cdata(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_cdata);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_cdata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_cdata(arg0));
  }
}
Variant i_magickgetversionstring(CArrRef params) {
  FUNCTION_INJECTION(magickgetversionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionstring", 0, 1);
  return (f_magickgetversionstring());
}
Variant i_pcntl_fork(CArrRef params) {
  FUNCTION_INJECTION(pcntl_fork);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_fork", 0, 1);
  return (f_pcntl_fork());
}
Variant i_dom_node_normalize(CArrRef params) {
  FUNCTION_INJECTION(dom_node_normalize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_normalize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_node_normalize(arg0));
  }
}
Variant i_doubleval(CArrRef params) {
  FUNCTION_INJECTION(doubleval);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("doubleval", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_doubleval(arg0));
  }
}
Variant i_assert_options(CArrRef params) {
  FUNCTION_INJECTION(assert_options);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("assert_options", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_assert_options(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_assert_options(arg0, arg1));
  }
}
Variant i_magickhasnextimage(CArrRef params) {
  FUNCTION_INJECTION(magickhasnextimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhasnextimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickhasnextimage(arg0));
  }
}
Variant i_rmdir(CArrRef params) {
  FUNCTION_INJECTION(rmdir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rmdir", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_rmdir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rmdir(arg0, arg1));
  }
}
Variant i_drawgetstrokelinecap(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokelinecap);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinecap", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokelinecap(arg0));
  }
}
Variant i_hphp_clear_unflushed(CArrRef params) {
  FUNCTION_INJECTION(hphp_clear_unflushed);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_clear_unflushed", 0, 1);
  return (f_hphp_clear_unflushed(), null);
}
Variant i_magickscaleimage(CArrRef params) {
  FUNCTION_INJECTION(magickscaleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickscaleimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickscaleimage(arg0, arg1, arg2));
  }
}
Variant i_pixelgetblackquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetblackquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblackquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetblackquantum(arg0));
  }
}
Variant i_magicknewimage(CArrRef params) {
  FUNCTION_INJECTION(magicknewimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicknewimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magicknewimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicknewimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_destroypixelwands(CArrRef params) {
  FUNCTION_INJECTION(destroypixelwands);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwands", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixelwands(arg0), null);
  }
}
Variant i_shm_remove(CArrRef params) {
  FUNCTION_INJECTION(shm_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_remove", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_shm_remove(arg0));
  }
}
Variant i_hphp_splfileobject_setflags(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_setflags);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setflags", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_setflags(arg0, arg1), null);
  }
}
Variant i_date_sun_info(CArrRef params) {
  FUNCTION_INJECTION(date_sun_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("date_sun_info", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_sun_info(arg0, arg1, arg2));
  }
}
Variant i_hphp_directoryiterator_valid(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_valid(arg0));
  }
}
Variant i_magickresizeimage(CArrRef params) {
  FUNCTION_INJECTION(magickresizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresizeimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickresizeimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_parse_ini_file(CArrRef params) {
  FUNCTION_INJECTION(parse_ini_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_file", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_ini_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_parse_ini_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_parse_ini_file(arg0, arg1, arg2));
  }
}
Variant i_stream_get_meta_data(CArrRef params) {
  FUNCTION_INJECTION(stream_get_meta_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_get_meta_data", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_get_meta_data(arg0));
  }
}
Variant i_imagepsencodefont(CArrRef params) {
  FUNCTION_INJECTION(imagepsencodefont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsencodefont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsencodefont(arg0, arg1));
  }
}
Variant i_ldap_set_option(CArrRef params) {
  FUNCTION_INJECTION(ldap_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_set_option", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_set_option(arg0, arg1, arg2));
  }
}
Variant i_magickgetsize(CArrRef params) {
  FUNCTION_INJECTION(magickgetsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetsize(arg0));
  }
}
Variant i_memory_get_peak_usage(CArrRef params) {
  FUNCTION_INJECTION(memory_get_peak_usage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_peak_usage", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_memory_get_peak_usage());
    CVarRef arg0((ad->getValue(pos)));
    return (f_memory_get_peak_usage(arg0));
  }
}
Variant i_pcntl_exec(CArrRef params) {
  FUNCTION_INJECTION(pcntl_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_exec", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_pcntl_exec(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_pcntl_exec(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_exec(arg0, arg1, arg2), null);
  }
}
Variant i_xmlwriter_set_indent_string(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_set_indent_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent_string", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_set_indent_string(arg0, arg1));
  }
}
Variant i_php_strip_whitespace(CArrRef params) {
  FUNCTION_INJECTION(php_strip_whitespace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("php_strip_whitespace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_php_strip_whitespace(arg0));
  }
}
Variant i_strcoll(CArrRef params) {
  FUNCTION_INJECTION(strcoll);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcoll", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcoll(arg0, arg1));
  }
}
Variant i_write_hdf_file(CArrRef params) {
  FUNCTION_INJECTION(write_hdf_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("write_hdf_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_write_hdf_file(arg0, arg1));
  }
}
Variant i_socket_send(CArrRef params) {
  FUNCTION_INJECTION(socket_send);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_send", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_send(arg0, arg1, arg2, arg3));
  }
}
Variant i_zlib_get_coding_type(CArrRef params) {
  FUNCTION_INJECTION(zlib_get_coding_type);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zlib_get_coding_type", 0, 1);
  return (f_zlib_get_coding_type());
}
Variant i_hphp_splfileobject_fscanf(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fscanf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fscanf", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_fscanf(arg0, arg1, arg2, arg3));
  }
}
Variant i_mb_ereg_search_getregs(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_getregs);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getregs", 0, 1);
  return (f_mb_ereg_search_getregs());
}
Variant i_mb_eregi(CArrRef params) {
  FUNCTION_INJECTION(mb_eregi);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_eregi", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_eregi(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_mb_eregi(arg0, arg1, arg2));
  }
}
Variant i_pixelgetgreen(CArrRef params) {
  FUNCTION_INJECTION(pixelgetgreen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreen", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetgreen(arg0));
  }
}
Variant i_mysql_client_encoding(CArrRef params) {
  FUNCTION_INJECTION(mysql_client_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_client_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_client_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_client_encoding(arg0));
  }
}
Variant i_zend_thread_id(CArrRef params) {
  FUNCTION_INJECTION(zend_thread_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_thread_id", 0, 1);
  return (f_zend_thread_id());
}
Variant i_ldap_mod_replace(CArrRef params) {
  FUNCTION_INJECTION(ldap_mod_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_replace", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_mod_replace(arg0, arg1, arg2));
  }
}
Variant i_collator_get_error_code(CArrRef params) {
  FUNCTION_INJECTION(collator_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_code", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_collator_get_error_code(arg0));
  }
}
Variant i_stream_filter_prepend(CArrRef params) {
  FUNCTION_INJECTION(stream_filter_prepend);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_prepend", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_filter_prepend(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_filter_prepend(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_filter_prepend(arg0, arg1, arg2, arg3));
  }
}
Variant i_substr(CArrRef params) {
  FUNCTION_INJECTION(substr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("substr", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_substr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr(arg0, arg1, arg2));
  }
}
Variant i_magickcombineimages(CArrRef params) {
  FUNCTION_INJECTION(magickcombineimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcombineimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcombineimages(arg0, arg1));
  }
}
Variant i_pixelgetexceptiontype(CArrRef params) {
  FUNCTION_INJECTION(pixelgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetexceptiontype(arg0));
  }
}
Variant i_unpack(CArrRef params) {
  FUNCTION_INJECTION(unpack);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("unpack", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_unpack(arg0, arg1));
  }
}
Variant i_hphp_splfileinfo_isdir(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isdir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isdir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isdir(arg0));
  }
}
Variant i_magickgetimagepixels(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagepixels);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("magickgetimagepixels", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetimagepixels(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_array_product(CArrRef params) {
  FUNCTION_INJECTION(array_product);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_product", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_product(arg0));
  }
}
Variant i_substr_replace(CArrRef params) {
  FUNCTION_INJECTION(substr_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("substr_replace", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_substr_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_substr_replace(arg0, arg1, arg2, arg3));
  }
}
Variant i_xbox_get_thread_time(CArrRef params) {
  FUNCTION_INJECTION(xbox_get_thread_time);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_time", 0, 1);
  return (f_xbox_get_thread_time());
}
Variant i_xmlwriter_write_dtd(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_dtd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("xmlwriter_write_dtd", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_xmlwriter_write_dtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_xmlwriter_write_dtd(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_xmlwriter_write_dtd(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_dtd(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_mysql_select_db(CArrRef params) {
  FUNCTION_INJECTION(mysql_select_db);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_select_db", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_select_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_select_db(arg0, arg1));
  }
}
Variant i_fb_get_taint(CArrRef params) {
  FUNCTION_INJECTION(fb_get_taint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_get_taint", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_get_taint(arg0));
  }
}
Variant i_use_soap_error_handler(CArrRef params) {
  FUNCTION_INJECTION(use_soap_error_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("use_soap_error_handler", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_use_soap_error_handler());
    CVarRef arg0((ad->getValue(pos)));
    return (f_use_soap_error_handler(arg0));
  }
}
Variant i_debug_backtrace(CArrRef params) {
  FUNCTION_INJECTION(debug_backtrace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("debug_backtrace", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_debug_backtrace());
    CVarRef arg0((ad->getValue(pos)));
    return (f_debug_backtrace(arg0));
  }
}
Variant i_drawpathcurvetosmoothrelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetosmoothrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothrelative", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetosmoothrelative(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_mailparse_determine_best_xfer_encoding(CArrRef params) {
  FUNCTION_INJECTION(mailparse_determine_best_xfer_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_determine_best_xfer_encoding", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_determine_best_xfer_encoding(arg0));
  }
}
Variant i_imagettfbbox(CArrRef params) {
  FUNCTION_INJECTION(imagettfbbox);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagettfbbox", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagettfbbox(arg0, arg1, arg2, arg3));
  }
}
Variant i_mb_internal_encoding(CArrRef params) {
  FUNCTION_INJECTION(mb_internal_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_internal_encoding", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_internal_encoding());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_internal_encoding(arg0));
  }
}
Variant i_msg_get_queue(CArrRef params) {
  FUNCTION_INJECTION(msg_get_queue);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("msg_get_queue", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_msg_get_queue(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_msg_get_queue(arg0, arg1));
  }
}
Variant i_posix_getegid(CArrRef params) {
  FUNCTION_INJECTION(posix_getegid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getegid", 0, 1);
  return (f_posix_getegid());
}
Variant i_magickmedianfilterimage(CArrRef params) {
  FUNCTION_INJECTION(magickmedianfilterimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmedianfilterimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmedianfilterimage(arg0, arg1));
  }
}
Variant i_xbox_task_result(CArrRef params) {
  FUNCTION_INJECTION(xbox_task_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xbox_task_result", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_xbox_task_result(arg0, arg1, arg2));
  }
}
Variant i_mcrypt_generic_deinit(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic_deinit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_deinit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_generic_deinit(arg0));
  }
}
Variant i_method_exists(CArrRef params) {
  FUNCTION_INJECTION(method_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("method_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_method_exists(arg0, arg1));
  }
}
Variant i_money_format(CArrRef params) {
  FUNCTION_INJECTION(money_format);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("money_format", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_money_format(arg0, arg1));
  }
}
Variant i_clearmagickwand(CArrRef params) {
  FUNCTION_INJECTION(clearmagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearmagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clearmagickwand(arg0), null);
  }
}
Variant i_dom_element_remove_attribute_node(CArrRef params) {
  FUNCTION_INJECTION(dom_element_remove_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_remove_attribute_node(arg0, arg1));
  }
}
Variant i_array_udiff_assoc(CArrRef params) {
  FUNCTION_INJECTION(array_udiff_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff_assoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_udiff_assoc(count, arg0, arg1, arg2));
    return (f_array_udiff_assoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_xml_parser_free(CArrRef params) {
  FUNCTION_INJECTION(xml_parser_free);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_parser_free", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_parser_free(arg0));
  }
}
Variant i_is_resource(CArrRef params) {
  FUNCTION_INJECTION(is_resource);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_resource", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_resource(arg0));
  }
}
Variant i_hphp_splfileinfo_getsize(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getsize(arg0));
  }
}
Variant i_posix_seteuid(CArrRef params) {
  FUNCTION_INJECTION(posix_seteuid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_seteuid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_seteuid(arg0));
  }
}
Variant i_magicksetinterlacescheme(CArrRef params) {
  FUNCTION_INJECTION(magicksetinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetinterlacescheme", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetinterlacescheme(arg0, arg1));
  }
}
Variant i_str_shuffle(CArrRef params) {
  FUNCTION_INJECTION(str_shuffle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_shuffle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_str_shuffle(arg0));
  }
}
Variant i_mcrypt_enc_is_block_algorithm(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_is_block_algorithm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_is_block_algorithm(arg0));
  }
}
Variant i_call_user_func_array_rpc(CArrRef params) {
  FUNCTION_INJECTION(call_user_func_array_rpc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("call_user_func_array_rpc", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_func_array_rpc(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_fb_serialize(CArrRef params) {
  FUNCTION_INJECTION(fb_serialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_serialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_serialize(arg0));
  }
}
Variant i_magickgetcopyright(CArrRef params) {
  FUNCTION_INJECTION(magickgetcopyright);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetcopyright", 0, 1);
  return (f_magickgetcopyright());
}
Variant i_magickstripimage(CArrRef params) {
  FUNCTION_INJECTION(magickstripimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickstripimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickstripimage(arg0));
  }
}
Variant i_base64_decode(CArrRef params) {
  FUNCTION_INJECTION(base64_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("base64_decode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_base64_decode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_base64_decode(arg0, arg1));
  }
}
Variant i_rand(CArrRef params) {
  FUNCTION_INJECTION(rand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("rand", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_rand());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_rand(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rand(arg0, arg1));
  }
}
Variant i_crc32(CArrRef params) {
  FUNCTION_INJECTION(crc32);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("crc32", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_crc32(arg0));
  }
}
Variant i_stream_encoding(CArrRef params) {
  FUNCTION_INJECTION(stream_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_encoding", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_encoding(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_encoding(arg0, arg1));
  }
}
Variant i_drawgetstrokedasharray(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokedasharray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedasharray", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokedasharray(arg0));
  }
}
Variant i_magickgetimagedispose(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagedispose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedispose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagedispose(arg0));
  }
}
Variant i_drawpopdefs(CArrRef params) {
  FUNCTION_INJECTION(drawpopdefs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopdefs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpopdefs(arg0), null);
  }
}
Variant i_xml_parser_create(CArrRef params) {
  FUNCTION_INJECTION(xml_parser_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("xml_parser_create", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_xml_parser_create());
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_parser_create(arg0));
  }
}
Variant i_session_save_path(CArrRef params) {
  FUNCTION_INJECTION(session_save_path);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_save_path", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_save_path());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_save_path(arg0));
  }
}
Variant i_pcntl_wifsignaled(CArrRef params) {
  FUNCTION_INJECTION(pcntl_wifsignaled);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifsignaled", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wifsignaled(arg0));
  }
}
Variant i_openssl_pkcs7_encrypt(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs7_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_pkcs7_encrypt", count, 4, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_openssl_pkcs7_encrypt(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_openssl_pkcs7_encrypt(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs7_encrypt(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_read_exif_data(CArrRef params) {
  FUNCTION_INJECTION(read_exif_data);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("read_exif_data", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_read_exif_data(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_read_exif_data(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_read_exif_data(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_read_exif_data(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawsetstrokeopacity(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokeopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokeopacity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokeopacity(arg0, arg1), null);
  }
}
Variant i_drawroundrectangle(CArrRef params) {
  FUNCTION_INJECTION(drawroundrectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawroundrectangle", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawroundrectangle(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant i_hphp_directoryiterator_isdot(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_isdot);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_isdot", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_isdot(arg0));
  }
}
Variant i_drawgetstrokewidth(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokewidth);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokewidth", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokewidth(arg0));
  }
}
Variant i_date_create(CArrRef params) {
  FUNCTION_INJECTION(date_create);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("date_create", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_date_create());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_date_create(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_create(arg0, arg1));
  }
}
Variant i_strcspn(CArrRef params) {
  FUNCTION_INJECTION(strcspn);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strcspn", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strcspn(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_strcspn(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcspn(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawgetclipunits(CArrRef params) {
  FUNCTION_INJECTION(drawgetclipunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclipunits", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetclipunits(arg0));
  }
}
Variant i_sem_acquire(CArrRef params) {
  FUNCTION_INJECTION(sem_acquire);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_acquire", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sem_acquire(arg0));
  }
}
Variant i_socket_strerror(CArrRef params) {
  FUNCTION_INJECTION(socket_strerror);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_strerror", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_strerror(arg0));
  }
}
Variant i_magickgetstringheight(CArrRef params) {
  FUNCTION_INJECTION(magickgetstringheight);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringheight", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetstringheight(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetstringheight(arg0, arg1, arg2, arg3));
  }
}
Variant i_dom_document_relaxng_validate_xml(CArrRef params) {
  FUNCTION_INJECTION(dom_document_relaxng_validate_xml);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_xml", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_relaxng_validate_xml(arg0, arg1));
  }
}
Variant i_rawurlencode(CArrRef params) {
  FUNCTION_INJECTION(rawurlencode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurlencode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rawurlencode(arg0));
  }
}
Variant i_strtotime(CArrRef params) {
  FUNCTION_INJECTION(strtotime);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtotime", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strtotime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strtotime(arg0, arg1));
  }
}
Variant i_dom_element_set_id_attribute(CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_id_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_id_attribute(arg0, arg1, arg2));
  }
}
Variant i_hphp_recursivedirectoryiterator_getsubpath(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_getsubpath);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_getsubpath(arg0));
  }
}
Variant i_apc_clear_cache(CArrRef params) {
  FUNCTION_INJECTION(apc_clear_cache);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_clear_cache", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_clear_cache());
    CVarRef arg0((ad->getValue(pos)));
    return (f_apc_clear_cache(arg0));
  }
}
Variant i_dirname(CArrRef params) {
  FUNCTION_INJECTION(dirname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dirname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dirname(arg0));
  }
}
Variant i_strnatcasecmp(CArrRef params) {
  FUNCTION_INJECTION(strnatcasecmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcasecmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strnatcasecmp(arg0, arg1));
  }
}
Variant i_magicksetsamplingfactors(CArrRef params) {
  FUNCTION_INJECTION(magicksetsamplingfactors);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsamplingfactors", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetsamplingfactors(arg0, arg1, arg2));
  }
}
Variant i_openssl_pkey_get_private(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_get_private);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_pkey_get_private", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_pkey_get_private(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkey_get_private(arg0, arg1));
  }
}
Variant i_magickaverageimages(CArrRef params) {
  FUNCTION_INJECTION(magickaverageimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickaverageimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickaverageimages(arg0));
  }
}
Variant i_iconv_strrpos(CArrRef params) {
  FUNCTION_INJECTION(iconv_strrpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_strrpos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_strrpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_strrpos(arg0, arg1, arg2));
  }
}
Variant i_collator_get_locale(CArrRef params) {
  FUNCTION_INJECTION(collator_get_locale);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("collator_get_locale", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_collator_get_locale(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_get_locale(arg0, arg1));
  }
}
Variant i_drawsetviewbox(CArrRef params) {
  FUNCTION_INJECTION(drawsetviewbox);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawsetviewbox", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetviewbox(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_magicksetimagecompressionquality(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecompressionquality);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompressionquality", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecompressionquality(arg0, arg1));
  }
}
Variant i_mysql_ping(CArrRef params) {
  FUNCTION_INJECTION(mysql_ping);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_ping", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_ping());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_ping(arg0));
  }
}
Variant i_xml_get_current_byte_index(CArrRef params) {
  FUNCTION_INJECTION(xml_get_current_byte_index);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_byte_index", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_current_byte_index(arg0));
  }
}
Variant i_magicktransformimage(CArrRef params) {
  FUNCTION_INJECTION(magicktransformimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktransformimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktransformimage(arg0, arg1, arg2));
  }
}
Variant i_drawgetstrokeantialias(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokeantialias);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeantialias", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokeantialias(arg0));
  }
}
Variant i_ini_alter(CArrRef params) {
  FUNCTION_INJECTION(ini_alter);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_alter", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ini_alter(arg0, arg1));
  }
}
Variant i_get_class(CArrRef params) {
  FUNCTION_INJECTION(get_class);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_class", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_class());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_class(arg0));
  }
}
Variant i_magicksetimageprofile(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageprofile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageprofile", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageprofile(arg0, arg1, arg2));
  }
}
Variant i_mysql_field_seek(CArrRef params) {
  FUNCTION_INJECTION(mysql_field_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_seek", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_seek(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_seek(arg0, arg1));
  }
}
Variant i_drawgetfontsize(CArrRef params) {
  FUNCTION_INJECTION(drawgetfontsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontsize(arg0));
  }
}
Variant i_mysql_num_rows(CArrRef params) {
  FUNCTION_INJECTION(mysql_num_rows);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_rows", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_num_rows(arg0));
  }
}
Variant i_hphp_recursiveiteratoriterator_rewind(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_rewind(arg0), null);
  }
}
Variant i_magickgetimageresolution(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageresolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageresolution", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageresolution(arg0));
  }
}
Variant i_array_diff(CArrRef params) {
  FUNCTION_INJECTION(array_diff);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_diff(count, arg0, arg1));
    return (f_array_diff(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_xmlwriter_open_uri(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_open_uri);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_open_uri", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_open_uri(arg0));
  }
}
Variant i_magickgetimagetype(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagetype(arg0));
  }
}
Variant i_simplexml_load_string(CArrRef params) {
  FUNCTION_INJECTION(simplexml_load_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_string", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_simplexml_load_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_simplexml_load_string(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_simplexml_load_string(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_simplexml_load_string(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_simplexml_load_string(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_magickunsharpmaskimage(CArrRef params) {
  FUNCTION_INJECTION(magickunsharpmaskimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("magickunsharpmaskimage", count, 5, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_magickunsharpmaskimage(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickunsharpmaskimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_quoted_printable_encode(CArrRef params) {
  FUNCTION_INJECTION(quoted_printable_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_encode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_quoted_printable_encode(arg0));
  }
}
Variant i_gettype(CArrRef params) {
  FUNCTION_INJECTION(gettype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gettype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gettype(arg0));
  }
}
Variant i_magickgetimagebackgroundcolor(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagebackgroundcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebackgroundcolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagebackgroundcolor(arg0));
  }
}
Variant i_hphp_splfileobject_setmaxlinelen(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_setmaxlinelen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setmaxlinelen", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_setmaxlinelen(arg0, arg1), null);
  }
}
Variant i_array_intersect_key(CArrRef params) {
  FUNCTION_INJECTION(array_intersect_key);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_key", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_intersect_key(count, arg0, arg1));
    return (f_array_intersect_key(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_array_change_key_case(CArrRef params) {
  FUNCTION_INJECTION(array_change_key_case);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_change_key_case", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_change_key_case(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_change_key_case(arg0, arg1));
  }
}
Variant i_ldap_first_attribute(CArrRef params) {
  FUNCTION_INJECTION(ldap_first_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_first_attribute(arg0, arg1));
  }
}
Variant i_gettimeofday(CArrRef params) {
  FUNCTION_INJECTION(gettimeofday);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("gettimeofday", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_gettimeofday());
    CVarRef arg0((ad->getValue(pos)));
    return (f_gettimeofday(arg0));
  }
}
Variant i_xmlwriter_end_element(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_element);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_element", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_element(arg0));
  }
}
Variant i_drawpoint(CArrRef params) {
  FUNCTION_INJECTION(drawpoint);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpoint", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpoint(arg0, arg1, arg2), null);
  }
}
Variant i_strnatcmp(CArrRef params) {
  FUNCTION_INJECTION(strnatcmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strnatcmp(arg0, arg1));
  }
}
Variant i_property_exists(CArrRef params) {
  FUNCTION_INJECTION(property_exists);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("property_exists", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_property_exists(arg0, arg1));
  }
}
Variant i_mysql_affected_rows(CArrRef params) {
  FUNCTION_INJECTION(mysql_affected_rows);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_affected_rows", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_affected_rows());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_affected_rows(arg0));
  }
}
Variant i_magickdespeckleimage(CArrRef params) {
  FUNCTION_INJECTION(magickdespeckleimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdespeckleimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickdespeckleimage(arg0));
  }
}
Variant i_imagecopymergegray(CArrRef params) {
  FUNCTION_INJECTION(imagecopymergegray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymergegray", count, 9, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopymergegray(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant i_ctype_cntrl(CArrRef params) {
  FUNCTION_INJECTION(ctype_cntrl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_cntrl", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_cntrl(arg0));
  }
}
Variant i_hphp_splfileobject_next(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_next);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_next", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_next(arg0), null);
  }
}
Variant i_is_array(CArrRef params) {
  FUNCTION_INJECTION(is_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_array", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_array(arg0));
  }
}
Variant i_rename(CArrRef params) {
  FUNCTION_INJECTION(rename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("rename", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_rename(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rename(arg0, arg1, arg2));
  }
}
Variant i_date_format(CArrRef params) {
  FUNCTION_INJECTION(date_format);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_format", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_format(arg0, arg1));
  }
}
Variant i_hphp_splfileobject_fgetc(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgetc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgetc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fgetc(arg0));
  }
}
Variant i_magickshaveimage(CArrRef params) {
  FUNCTION_INJECTION(magickshaveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickshaveimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickshaveimage(arg0, arg1, arg2));
  }
}
Variant i_dom_element_set_attribute_node_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute_node_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node_ns", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute_node_ns(arg0, arg1));
  }
}
Variant i_xmlwriter_output_memory(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_output_memory);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_output_memory", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xmlwriter_output_memory(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_output_memory(arg0, arg1));
  }
}
Variant i_ob_end_flush(CArrRef params) {
  FUNCTION_INJECTION(ob_end_flush);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_flush", 0, 1);
  return (f_ob_end_flush());
}
Variant i_magickwhitethresholdimage(CArrRef params) {
  FUNCTION_INJECTION(magickwhitethresholdimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwhitethresholdimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwhitethresholdimage(arg0, arg1));
  }
}
Variant i_drawpolyline(CArrRef params) {
  FUNCTION_INJECTION(drawpolyline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolyline", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpolyline(arg0, arg1), null);
  }
}
Variant i_hphp_splfileobject_fgets(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_fgets);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgets", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_fgets(arg0));
  }
}
Variant i_hphp_get_function_info(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_function_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_function_info", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_function_info(arg0));
  }
}
Variant i_prev(CArrRef params) {
  FUNCTION_INJECTION(prev);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("prev", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_prev(arg0));
  }
}
Variant i_imagegammacorrect(CArrRef params) {
  FUNCTION_INJECTION(imagegammacorrect);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagegammacorrect", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegammacorrect(arg0, arg1, arg2));
  }
}
Variant i_str_replace(CArrRef params) {
  FUNCTION_INJECTION(str_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_replace", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_str_replace(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_str_replace(arg0, arg1, arg2, arg3));
  }
}
Variant i_dom_node_lookup_namespace_uri(CArrRef params) {
  FUNCTION_INJECTION(dom_node_lookup_namespace_uri);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_namespace_uri", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_lookup_namespace_uri(arg0, arg1));
  }
}
Variant i_fb_unserialize(CArrRef params) {
  FUNCTION_INJECTION(fb_unserialize);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_unserialize", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_unserialize(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_unserialize(arg0, arg1, arg2));
  }
}
Variant i_clock_getres(CArrRef params) {
  FUNCTION_INJECTION(clock_getres);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_getres", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_clock_getres(arg0, arg1, arg2));
  }
}
Variant i_magicktrimimage(CArrRef params) {
  FUNCTION_INJECTION(magicktrimimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktrimimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktrimimage(arg0, arg1));
  }
}
Variant i_hphp_splfileinfo_getpathinfo(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getpathinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getpathinfo", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_getpathinfo(arg0, arg1));
  }
}
Variant i_magickgetimagegamma(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagegamma);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegamma", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagegamma(arg0));
  }
}
Variant i_newdrawingwand(CArrRef params) {
  FUNCTION_INJECTION(newdrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newdrawingwand", 0, 1);
  return (f_newdrawingwand());
}
Variant i_gzrewind(CArrRef params) {
  FUNCTION_INJECTION(gzrewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzrewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzrewind(arg0));
  }
}
Variant i_ldap_explode_dn(CArrRef params) {
  FUNCTION_INJECTION(ldap_explode_dn);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_explode_dn", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_explode_dn(arg0, arg1));
  }
}
Variant i_posix_times(CArrRef params) {
  FUNCTION_INJECTION(posix_times);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_times", 0, 1);
  return (f_posix_times());
}
Variant i_drawgetfillcolor(CArrRef params) {
  FUNCTION_INJECTION(drawgetfillcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillcolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfillcolor(arg0));
  }
}
Variant i_dom_document_save_html(CArrRef params) {
  FUNCTION_INJECTION(dom_document_save_html);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_save_html", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_document_save_html(arg0));
  }
}
Variant i_mb_strtolower(CArrRef params) {
  FUNCTION_INJECTION(mb_strtolower);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtolower", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_strtolower(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strtolower(arg0, arg1));
  }
}
Variant i_localtime(CArrRef params) {
  FUNCTION_INJECTION(localtime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("localtime", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_localtime());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_localtime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_localtime(arg0, arg1));
  }
}
Variant i_fb_thrift_unserialize(CArrRef params) {
  FUNCTION_INJECTION(fb_thrift_unserialize);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_thrift_unserialize", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fb_thrift_unserialize(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_fb_thrift_unserialize(arg0, arg1, arg2));
  }
}
Variant i_sha1(CArrRef params) {
  FUNCTION_INJECTION(sha1);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sha1(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sha1(arg0, arg1));
  }
}
Variant i_collator_set_strength(CArrRef params) {
  FUNCTION_INJECTION(collator_set_strength);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_set_strength", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_set_strength(arg0, arg1));
  }
}
Variant i_implode(CArrRef params) {
  FUNCTION_INJECTION(implode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("implode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_implode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_implode(arg0, arg1));
  }
}
Variant i_date_isodate_set(CArrRef params) {
  FUNCTION_INJECTION(date_isodate_set);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_isodate_set", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_date_isodate_set(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_isodate_set(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_magickpaintopaqueimage(CArrRef params) {
  FUNCTION_INJECTION(magickpaintopaqueimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickpaintopaqueimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickpaintopaqueimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickpaintopaqueimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_mb_strimwidth(CArrRef params) {
  FUNCTION_INJECTION(mb_strimwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_strimwidth", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_strimwidth(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mb_strimwidth(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_strimwidth(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_drawsetfont(CArrRef params) {
  FUNCTION_INJECTION(drawsetfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfont(arg0, arg1));
  }
}
Variant i_xml_set_default_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_default_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_default_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_default_handler(arg0, arg1));
  }
}
Variant i_magickchopimage(CArrRef params) {
  FUNCTION_INJECTION(magickchopimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickchopimage", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickchopimage(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_wordwrap(CArrRef params) {
  FUNCTION_INJECTION(wordwrap);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("wordwrap", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_wordwrap(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_wordwrap(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_wordwrap(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_wordwrap(arg0, arg1, arg2, arg3));
  }
}
Variant i_gzgetss(CArrRef params) {
  FUNCTION_INJECTION(gzgetss);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzgetss", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzgetss(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_gzgetss(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzgetss(arg0, arg1, arg2));
  }
}
Variant i_magickgetimagevirtualpixelmethod(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagevirtualpixelmethod);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagevirtualpixelmethod", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagevirtualpixelmethod(arg0));
  }
}
Variant i_imagedestroy(CArrRef params) {
  FUNCTION_INJECTION(imagedestroy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagedestroy", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagedestroy(arg0));
  }
}
Variant i_timezone_open(CArrRef params) {
  FUNCTION_INJECTION(timezone_open);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_open", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_timezone_open(arg0));
  }
}
Variant i_ob_clean(CArrRef params) {
  FUNCTION_INJECTION(ob_clean);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_clean", 0, 1);
  return (f_ob_clean(), null);
}
Variant i_mb_ereg_search_pos(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_pos);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_pos", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_ereg_search_pos());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_ereg_search_pos(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_search_pos(arg0, arg1));
  }
}
Variant i_bccomp(CArrRef params) {
  FUNCTION_INJECTION(bccomp);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bccomp", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bccomp(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bccomp(arg0, arg1, arg2));
  }
}
Variant i_gzdecode(CArrRef params) {
  FUNCTION_INJECTION(gzdecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzdecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzdecode(arg0));
  }
}
Variant i_magicksetimagecompose(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecompose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompose", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecompose(arg0, arg1));
  }
}
Variant i_apc_bin_dump(CArrRef params) {
  FUNCTION_INJECTION(apc_bin_dump);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_bin_dump", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_bin_dump());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_apc_bin_dump(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_dump(arg0, arg1));
  }
}
Variant i_ini_get(CArrRef params) {
  FUNCTION_INJECTION(ini_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ini_get(arg0));
  }
}
Variant i_mb_ereg_search_setpos(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_search_setpos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_ereg_search_setpos", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_ereg_search_setpos(arg0));
  }
}
Variant i_stream_copy_to_stream(CArrRef params) {
  FUNCTION_INJECTION(stream_copy_to_stream);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_copy_to_stream", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_copy_to_stream(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_copy_to_stream(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_copy_to_stream(arg0, arg1, arg2, arg3));
  }
}
Variant i_xml_get_error_code(CArrRef params) {
  FUNCTION_INJECTION(xml_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_error_code", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xml_get_error_code(arg0));
  }
}
Variant i_pcntl_alarm(CArrRef params) {
  FUNCTION_INJECTION(pcntl_alarm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_alarm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_alarm(arg0));
  }
}
Variant i_drawpolygon(CArrRef params) {
  FUNCTION_INJECTION(drawpolygon);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolygon", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpolygon(arg0, arg1), null);
  }
}
Variant i_mysql_connect(CArrRef params) {
  FUNCTION_INJECTION(mysql_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_connect", 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_connect());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_connect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_connect(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_connect(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_mysql_connect(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_connect(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_xmlwriter_write_raw(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_raw);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_raw", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_raw(arg0, arg1));
  }
}
Variant i_fgetss(CArrRef params) {
  FUNCTION_INJECTION(fgetss);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("fgetss", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fgetss(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_fgetss(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fgetss(arg0, arg1, arg2));
  }
}
Variant i_drawarc(CArrRef params) {
  FUNCTION_INJECTION(drawarc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawarc", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawarc(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant i_set_error_handler(CArrRef params) {
  FUNCTION_INJECTION(set_error_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("set_error_handler", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_set_error_handler(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_set_error_handler(arg0, arg1));
  }
}
Variant i_str_word_count(CArrRef params) {
  FUNCTION_INJECTION(str_word_count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("str_word_count", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_str_word_count(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_str_word_count(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_word_count(arg0, arg1, arg2));
  }
}
Variant i_drawsetcliprule(CArrRef params) {
  FUNCTION_INJECTION(drawsetcliprule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetcliprule", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetcliprule(arg0, arg1), null);
  }
}
Variant i_openssl_pkcs12_read(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkcs12_read);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openssl_pkcs12_read", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkcs12_read(arg0, arg1, arg2));
  }
}
Variant i_ldap_list(CArrRef params) {
  FUNCTION_INJECTION(ldap_list);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_list", count, 3, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_list(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_list(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_list(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_ldap_list(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_ldap_list(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_list(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_func_num_args(CArrRef params) {
  FUNCTION_INJECTION(func_num_args);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_num_args", 0, 1);
  return (f_func_num_args());
}
Variant i_drawsettextdecoration(CArrRef params) {
  FUNCTION_INJECTION(drawsettextdecoration);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextdecoration", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsettextdecoration(arg0, arg1), null);
  }
}
Variant i_str_rot13(CArrRef params) {
  FUNCTION_INJECTION(str_rot13);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_rot13", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_str_rot13(arg0));
  }
}
Variant i_openssl_pkey_new(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_new);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("openssl_pkey_new", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_openssl_pkey_new());
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_new(arg0));
  }
}
Variant i_magicksetimageindex(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageindex", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageindex(arg0, arg1));
  }
}
Variant i_ldap_rename(CArrRef params) {
  FUNCTION_INJECTION(ldap_rename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("ldap_rename", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_rename(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_ldap_start_tls(CArrRef params) {
  FUNCTION_INJECTION(ldap_start_tls);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_start_tls", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_start_tls(arg0));
  }
}
Variant i_tanh(CArrRef params) {
  FUNCTION_INJECTION(tanh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tanh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_tanh(arg0));
  }
}
Variant i_drawscale(CArrRef params) {
  FUNCTION_INJECTION(drawscale);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawscale", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawscale(arg0, arg1, arg2), null);
  }
}
Variant i_drawrotate(CArrRef params) {
  FUNCTION_INJECTION(drawrotate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawrotate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawrotate(arg0, arg1), null);
  }
}
Variant i_getservbyname(CArrRef params) {
  FUNCTION_INJECTION(getservbyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyname", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_getservbyname(arg0, arg1));
  }
}
Variant i_compact(CArrRef params) {
  FUNCTION_INJECTION(compact);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("compact", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_compact(count, arg0));
    return (f_compact(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_hphp_splfileobject_valid(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_valid(arg0));
  }
}
Variant i_imagecolorclosest(CArrRef params) {
  FUNCTION_INJECTION(imagecolorclosest);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosest", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorclosest(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickwriteimages(CArrRef params) {
  FUNCTION_INJECTION(magickwriteimages);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magickwriteimages", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magickwriteimages(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_magickwriteimages(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimages(arg0, arg1, arg2));
  }
}
Variant i_pixelsetalpha(CArrRef params) {
  FUNCTION_INJECTION(pixelsetalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalpha", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetalpha(arg0, arg1), null);
  }
}
Variant i_magicksetimageiterations(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageiterations);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageiterations", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageiterations(arg0, arg1));
  }
}
Variant i_drawpathmovetoabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathmovetoabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetoabsolute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathmovetoabsolute(arg0, arg1, arg2), null);
  }
}
Variant i_quotemeta(CArrRef params) {
  FUNCTION_INJECTION(quotemeta);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quotemeta", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_quotemeta(arg0));
  }
}
Variant i_parse_ini_string(CArrRef params) {
  FUNCTION_INJECTION(parse_ini_string);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_string", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_parse_ini_string(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_parse_ini_string(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_parse_ini_string(arg0, arg1, arg2));
  }
}
Variant i_imagefilltoborder(CArrRef params) {
  FUNCTION_INJECTION(imagefilltoborder);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagefilltoborder", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilltoborder(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_xml_set_notation_decl_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_notation_decl_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_notation_decl_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_notation_decl_handler(arg0, arg1));
  }
}
Variant i_is_writeable(CArrRef params) {
  FUNCTION_INJECTION(is_writeable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writeable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_writeable(arg0));
  }
}
Variant i_magickgetwandsize(CArrRef params) {
  FUNCTION_INJECTION(magickgetwandsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetwandsize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetwandsize(arg0));
  }
}
Variant i_hphp_directoryiterator___tostring(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator___tostring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator___tostring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator___tostring(arg0));
  }
}
Variant i_memcache_add_server(CArrRef params) {
  FUNCTION_INJECTION(memcache_add_server);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 10) return throw_wrong_arguments("memcache_add_server", count, 2, 10, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_add_server(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_add_server(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_add_server(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 8) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 9) return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_add_server(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
  }
}
Variant i_dom_node_remove_child(CArrRef params) {
  FUNCTION_INJECTION(dom_node_remove_child);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_remove_child", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_remove_child(arg0, arg1));
  }
}
Variant i_imageinterlace(CArrRef params) {
  FUNCTION_INJECTION(imageinterlace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imageinterlace", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imageinterlace(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageinterlace(arg0, arg1));
  }
}
Variant i_preg_match_all(CArrRef params) {
  FUNCTION_INJECTION(preg_match_all);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_match_all", count, 3, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_preg_match_all(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_match_all(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_match_all(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_proc_terminate(CArrRef params) {
  FUNCTION_INJECTION(proc_terminate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("proc_terminate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_proc_terminate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_proc_terminate(arg0, arg1));
  }
}
Variant i_apc_bin_loadfile(CArrRef params) {
  FUNCTION_INJECTION(apc_bin_loadfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_bin_loadfile", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_bin_loadfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_bin_loadfile(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_bin_loadfile(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_loadfile(arg0, arg1, arg2, arg3));
  }
}
Variant i_posix_getcwd(CArrRef params) {
  FUNCTION_INJECTION(posix_getcwd);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getcwd", 0, 1);
  return (f_posix_getcwd());
}
Variant i_drawpathcurvetoabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetoabsolute", count, 7, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoabsolute(arg0, arg1, arg2, arg3, arg4, arg5, arg6), null);
  }
}
Variant i_hphp_set_error_page(CArrRef params) {
  FUNCTION_INJECTION(hphp_set_error_page);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_set_error_page", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_set_error_page(arg0), null);
  }
}
Variant i_preg_match(CArrRef params) {
  FUNCTION_INJECTION(preg_match);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("preg_match", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_preg_match(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_preg_match(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_preg_match(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_preg_match(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_timezone_abbreviations_list(CArrRef params) {
  FUNCTION_INJECTION(timezone_abbreviations_list);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_abbreviations_list", 0, 1);
  return (f_timezone_abbreviations_list());
}
Variant i_magickradialblurimage(CArrRef params) {
  FUNCTION_INJECTION(magickradialblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickradialblurimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickradialblurimage(arg0, arg1));
  }
}
Variant i_posix_geteuid(CArrRef params) {
  FUNCTION_INJECTION(posix_geteuid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_geteuid", 0, 1);
  return (f_posix_geteuid());
}
Variant i_mysql_fetch_lengths(CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_lengths);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_lengths", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_fetch_lengths(arg0));
  }
}
Variant i_magickwriteimagefile(CArrRef params) {
  FUNCTION_INJECTION(magickwriteimagefile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagefile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwriteimagefile(arg0, arg1));
  }
}
Variant i_serialize(CArrRef params) {
  FUNCTION_INJECTION(serialize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("serialize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_serialize(arg0));
  }
}
Variant i_exif_read_data(CArrRef params) {
  FUNCTION_INJECTION(exif_read_data);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_read_data", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_exif_read_data(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_exif_read_data(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_exif_read_data(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_exif_read_data(arg0, arg1, arg2, arg3));
  }
}
Variant i_pixelgetiteratorexceptiontype(CArrRef params) {
  FUNCTION_INJECTION(pixelgetiteratorexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetiteratorexceptiontype(arg0));
  }
}
Variant i_destroydrawingwand(CArrRef params) {
  FUNCTION_INJECTION(destroydrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroydrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroydrawingwand(arg0), null);
  }
}
Variant i_lstat(CArrRef params) {
  FUNCTION_INJECTION(lstat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("lstat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_lstat(arg0));
  }
}
Variant i_apache_note(CArrRef params) {
  FUNCTION_INJECTION(apache_note);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apache_note", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apache_note(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apache_note(arg0, arg1));
  }
}
Variant i_drawgetexceptiontype(CArrRef params) {
  FUNCTION_INJECTION(drawgetexceptiontype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptiontype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetexceptiontype(arg0));
  }
}
Variant i_drawbezier(CArrRef params) {
  FUNCTION_INJECTION(drawbezier);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawbezier", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawbezier(arg0, arg1), null);
  }
}
Variant i_xmlwriter_start_comment(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_comment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_start_comment(arg0));
  }
}
Variant i_ldap_set_rebind_proc(CArrRef params) {
  FUNCTION_INJECTION(ldap_set_rebind_proc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_set_rebind_proc", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_set_rebind_proc(arg0, arg1));
  }
}
Variant i_drawsetstrokecolor(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokecolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokecolor(arg0, arg1), null);
  }
}
Variant i_drawpathlinetohorizontalrelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetohorizontalrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalrelative", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetohorizontalrelative(arg0, arg1), null);
  }
}
Variant i_gmmktime(CArrRef params) {
  FUNCTION_INJECTION(gmmktime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("gmmktime", 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_gmmktime());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_gmmktime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_gmmktime(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_gmmktime(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_gmmktime(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_gmmktime(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gmmktime(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_gmdate(CArrRef params) {
  FUNCTION_INJECTION(gmdate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmdate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gmdate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gmdate(arg0, arg1));
  }
}
Variant i_posix_getgid(CArrRef params) {
  FUNCTION_INJECTION(posix_getgid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgid", 0, 1);
  return (f_posix_getgid());
}
Variant i_sinh(CArrRef params) {
  FUNCTION_INJECTION(sinh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sinh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sinh(arg0));
  }
}
Variant i_apc_fetch(CArrRef params) {
  FUNCTION_INJECTION(apc_fetch);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_fetch", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_fetch(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_fetch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_fetch(arg0, arg1, arg2));
  }
}
Variant i_fileowner(CArrRef params) {
  FUNCTION_INJECTION(fileowner);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileowner", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileowner(arg0));
  }
}
Variant i_imagecopymerge(CArrRef params) {
  FUNCTION_INJECTION(imagecopymerge);
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymerge", count, 9, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopymerge(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant i_magickclipimage(CArrRef params) {
  FUNCTION_INJECTION(magickclipimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickclipimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickclipimage(arg0));
  }
}
Variant i_intl_get_error_code(CArrRef params) {
  FUNCTION_INJECTION(intl_get_error_code);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_code", 0, 1);
  return (f_intl_get_error_code());
}
Variant i_imagestringup(CArrRef params) {
  FUNCTION_INJECTION(imagestringup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestringup", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagestringup(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_mt_getrandmax(CArrRef params) {
  FUNCTION_INJECTION(mt_getrandmax);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mt_getrandmax", 0, 1);
  return (f_mt_getrandmax());
}
Variant i_magickgetresourcelimit(CArrRef params) {
  FUNCTION_INJECTION(magickgetresourcelimit);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetresourcelimit", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetresourcelimit(arg0));
  }
}
Variant i_hphp_splfileinfo_getlinktarget(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getlinktarget);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getlinktarget", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getlinktarget(arg0));
  }
}
Variant i_imagecolorexact(CArrRef params) {
  FUNCTION_INJECTION(imagecolorexact);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorexact", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorexact(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphp_recursivedirectoryiterator_current(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_current", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_current(arg0));
  }
}
Variant i_setcookie(CArrRef params) {
  FUNCTION_INJECTION(setcookie);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setcookie", count, 1, 7, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_setcookie(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_setcookie(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_setcookie(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_setcookie(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_setcookie(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_setcookie(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_setcookie(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
  }
}
Variant i_fileatime(CArrRef params) {
  FUNCTION_INJECTION(fileatime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileatime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fileatime(arg0));
  }
}
Variant i_apd_stop_trace(CArrRef params) {
  FUNCTION_INJECTION(apd_stop_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_stop_trace", 0, 1);
  return (f_apd_stop_trace(), null);
}
Variant i_hphpd_break(CArrRef params) {
  FUNCTION_INJECTION(hphpd_break);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphpd_break", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_hphpd_break(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphpd_break(arg0), null);
  }
}
Variant i_addcslashes(CArrRef params) {
  FUNCTION_INJECTION(addcslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("addcslashes", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_addcslashes(arg0, arg1));
  }
}
Variant i_magicksetimageoption(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageoption);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magicksetimageoption", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageoption(arg0, arg1, arg2, arg3));
  }
}
Variant i_xmlwriter_write_comment(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_comment);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_comment", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_comment(arg0, arg1));
  }
}
Variant i_drawgetfontstyle(CArrRef params) {
  FUNCTION_INJECTION(drawgetfontstyle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstyle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfontstyle(arg0));
  }
}
Variant i_dom_element_set_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_attribute_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute_ns(arg0, arg1, arg2, arg3));
  }
}
Variant i_dom_xpath_evaluate(CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_evaluate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_evaluate", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dom_xpath_evaluate(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_evaluate(arg0, arg1, arg2));
  }
}
Variant i_strtoupper(CArrRef params) {
  FUNCTION_INJECTION(strtoupper);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtoupper", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strtoupper(arg0));
  }
}
Variant i_xml_set_processing_instruction_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_processing_instruction_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_processing_instruction_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_processing_instruction_handler(arg0, arg1));
  }
}
Variant i_apd_breakpoint(CArrRef params) {
  FUNCTION_INJECTION(apd_breakpoint);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_breakpoint", 0, 1);
  return (f_apd_breakpoint());
}
Variant i_memcache_delete(CArrRef params) {
  FUNCTION_INJECTION(memcache_delete);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_delete", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_delete(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_delete(arg0, arg1, arg2));
  }
}
Variant i_magickgetimageblueprimary(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageblueprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblueprimary", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageblueprimary(arg0));
  }
}
Variant i_magickspreadimage(CArrRef params) {
  FUNCTION_INJECTION(magickspreadimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickspreadimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickspreadimage(arg0, arg1));
  }
}
Variant i_array_fill(CArrRef params) {
  FUNCTION_INJECTION(array_fill);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_fill", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_fill(arg0, arg1, arg2));
  }
}
Variant i_dom_element_set_attribute_node(CArrRef params) {
  FUNCTION_INJECTION(dom_element_set_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_set_attribute_node(arg0, arg1));
  }
}
Variant i_memcache_replace(CArrRef params) {
  FUNCTION_INJECTION(memcache_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_replace", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_memcache_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_memcache_replace(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_replace(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_stream_set_write_buffer(CArrRef params) {
  FUNCTION_INJECTION(stream_set_write_buffer);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_write_buffer", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_set_write_buffer(arg0, arg1));
  }
}
Variant i_mb_list_encodings(CArrRef params) {
  FUNCTION_INJECTION(mb_list_encodings);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_list_encodings", 0, 1);
  return (f_mb_list_encodings());
}
Variant i_sleep(CArrRef params) {
  FUNCTION_INJECTION(sleep);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sleep", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sleep(arg0));
  }
}
Variant i_cleardrawingwand(CArrRef params) {
  FUNCTION_INJECTION(cleardrawingwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cleardrawingwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_cleardrawingwand(arg0), null);
  }
}
Variant i_imagecolorset(CArrRef params) {
  FUNCTION_INJECTION(imagecolorset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorset", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorset(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_openssl_x509_checkpurpose(CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_checkpurpose);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_x509_checkpurpose", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_x509_checkpurpose(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_x509_checkpurpose(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_checkpurpose(arg0, arg1, arg2, arg3));
  }
}
Variant i_drawpathcurvetosmoothabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetosmoothabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothabsolute", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetosmoothabsolute(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_array_intersect_ukey(CArrRef params) {
  FUNCTION_INJECTION(array_intersect_ukey);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_ukey", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_intersect_ukey(count, arg0, arg1, arg2));
    return (f_array_intersect_ukey(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_timezone_name_from_abbr(CArrRef params) {
  FUNCTION_INJECTION(timezone_name_from_abbr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("timezone_name_from_abbr", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_timezone_name_from_abbr(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_timezone_name_from_abbr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_timezone_name_from_abbr(arg0, arg1, arg2));
  }
}
Variant i_imagefilledellipse(CArrRef params) {
  FUNCTION_INJECTION(imagefilledellipse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledellipse", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledellipse(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_pcntl_wstopsig(CArrRef params) {
  FUNCTION_INJECTION(pcntl_wstopsig);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wstopsig", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pcntl_wstopsig(arg0));
  }
}
Variant i_get_defined_vars(CArrRef params) {
  FUNCTION_INJECTION(get_defined_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_vars", 0, 1);
  return (f_get_defined_vars());
}
Variant i_memory_get_usage(CArrRef params) {
  FUNCTION_INJECTION(memory_get_usage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_usage", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_memory_get_usage());
    CVarRef arg0((ad->getValue(pos)));
    return (f_memory_get_usage(arg0));
  }
}
Variant i_intval(CArrRef params) {
  FUNCTION_INJECTION(intval);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("intval", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_intval(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_intval(arg0, arg1));
  }
}
Variant i_pagelet_server_task_status(CArrRef params) {
  FUNCTION_INJECTION(pagelet_server_task_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pagelet_server_task_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pagelet_server_task_status(arg0));
  }
}
Variant i_dom_document_get_elements_by_tag_name_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_document_get_elements_by_tag_name_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_get_elements_by_tag_name_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_get_elements_by_tag_name_ns(arg0, arg1, arg2));
  }
}
Variant i_iconv_set_encoding(CArrRef params) {
  FUNCTION_INJECTION(iconv_set_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("iconv_set_encoding", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_set_encoding(arg0, arg1));
  }
}
Variant i_magickmattefloodfillimage(CArrRef params) {
  FUNCTION_INJECTION(magickmattefloodfillimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmattefloodfillimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmattefloodfillimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_mailparse_msg_get_part(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_get_part);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_get_part", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_get_part(arg0, arg1));
  }
}
Variant i_mb_check_encoding(CArrRef params) {
  FUNCTION_INJECTION(mb_check_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_check_encoding", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_check_encoding());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mb_check_encoding(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_check_encoding(arg0, arg1));
  }
}
Variant i_ldap_get_dn(CArrRef params) {
  FUNCTION_INJECTION(ldap_get_dn);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_dn", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_get_dn(arg0, arg1));
  }
}
Variant i_newpixeliterator(CArrRef params) {
  FUNCTION_INJECTION(newpixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixeliterator(arg0));
  }
}
Variant i_magicksetimagefilename(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagefilename);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetimagefilename", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magicksetimagefilename(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagefilename(arg0, arg1));
  }
}
Variant i_call_user_func(CArrRef params) {
  FUNCTION_INJECTION(call_user_func);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_call_user_func(count, arg0));
    return (f_call_user_func(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_mysql_list_tables(CArrRef params) {
  FUNCTION_INJECTION(mysql_list_tables);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_list_tables", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_list_tables(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_list_tables(arg0, arg1));
  }
}
Variant i_magickgetinterlacescheme(CArrRef params) {
  FUNCTION_INJECTION(magickgetinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetinterlacescheme", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetinterlacescheme(arg0));
  }
}
Variant i_ltrim(CArrRef params) {
  FUNCTION_INJECTION(ltrim);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ltrim", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_ltrim(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ltrim(arg0, arg1));
  }
}
Variant i_magicktextureimage(CArrRef params) {
  FUNCTION_INJECTION(magicktextureimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktextureimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktextureimage(arg0, arg1));
  }
}
Variant i_mb_ereg_match(CArrRef params) {
  FUNCTION_INJECTION(mb_ereg_match);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg_match", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_ereg_match(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_ereg_match(arg0, arg1, arg2));
  }
}
Variant i_mt_srand(CArrRef params) {
  FUNCTION_INJECTION(mt_srand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mt_srand", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mt_srand(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_mt_srand(arg0), null);
  }
}
Variant i_imagecolorallocate(CArrRef params) {
  FUNCTION_INJECTION(imagecolorallocate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorallocate", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorallocate(arg0, arg1, arg2, arg3));
  }
}
Variant i_define_syslog_variables(CArrRef params) {
  FUNCTION_INJECTION(define_syslog_variables);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("define_syslog_variables", 0, 1);
  return (f_define_syslog_variables(), null);
}
Variant i_fb_get_code_coverage(CArrRef params) {
  FUNCTION_INJECTION(fb_get_code_coverage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("fb_get_code_coverage", 0, 1);
  return (f_fb_get_code_coverage());
}
Variant i_mcrypt_enc_get_modes_name(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_modes_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_modes_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_modes_name(arg0));
  }
}
Variant i_array_flip(CArrRef params) {
  FUNCTION_INJECTION(array_flip);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_flip", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_array_flip(arg0));
  }
}
Variant i_count(CArrRef params) {
  FUNCTION_INJECTION(count);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_count(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_count(arg0, arg1));
  }
}
Variant i_lcg_value(CArrRef params) {
  FUNCTION_INJECTION(lcg_value);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("lcg_value", 0, 1);
  return (f_lcg_value());
}
Variant i_php_logo_guid(CArrRef params) {
  FUNCTION_INJECTION(php_logo_guid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_logo_guid", 0, 1);
  return (f_php_logo_guid());
}
Variant i_time(CArrRef params) {
  FUNCTION_INJECTION(time);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("time", 0, 1);
  return (f_time());
}
Variant i_magickcoalesceimages(CArrRef params) {
  FUNCTION_INJECTION(magickcoalesceimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickcoalesceimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickcoalesceimages(arg0));
  }
}
Variant i_pixelgetquantumcolor(CArrRef params) {
  FUNCTION_INJECTION(pixelgetquantumcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetquantumcolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetquantumcolor(arg0));
  }
}
Variant i_openssl_private_encrypt(CArrRef params) {
  FUNCTION_INJECTION(openssl_private_encrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_encrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_private_encrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_private_encrypt(arg0, arg1, arg2, arg3));
  }
}
Variant i_xhprof_enable(CArrRef params) {
  FUNCTION_INJECTION(xhprof_enable);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xhprof_enable", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xhprof_enable(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xhprof_enable(arg0, arg1), null);
  }
}
Variant i_hphp_splfileinfo_gettype(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_gettype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_gettype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_gettype(arg0));
  }
}
Variant i_xhprof_run_trace(CArrRef params) {
  FUNCTION_INJECTION(xhprof_run_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xhprof_run_trace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xhprof_run_trace(arg0, arg1));
  }
}
Variant i_xmlwriter_start_document(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_document);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("xmlwriter_start_document", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_xmlwriter_start_document(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_xmlwriter_start_document(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_xmlwriter_start_document(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_document(arg0, arg1, arg2, arg3));
  }
}
Variant i_libxml_clear_errors(CArrRef params) {
  FUNCTION_INJECTION(libxml_clear_errors);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_clear_errors", 0, 1);
  return (f_libxml_clear_errors(), null);
}
Variant i_magicknormalizeimage(CArrRef params) {
  FUNCTION_INJECTION(magicknormalizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknormalizeimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicknormalizeimage(arg0));
  }
}
Variant i_magickgetformat(CArrRef params) {
  FUNCTION_INJECTION(magickgetformat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetformat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetformat(arg0));
  }
}
Variant i_hphp_get_class_info(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_class_info);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_class_info", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_class_info(arg0));
  }
}
Variant i_dom_element_remove_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_element_remove_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_remove_attribute_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_remove_attribute_ns(arg0, arg1, arg2));
  }
}
Variant i_mailparse_msg_get_part_data(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_get_part_data);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_part_data", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mailparse_msg_get_part_data(arg0));
  }
}
Variant i_openssl_csr_new(CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_new);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_csr_new", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_csr_new(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_csr_new(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_new(arg0, arg1, arg2, arg3));
  }
}
Variant i_xbox_task_start(CArrRef params) {
  FUNCTION_INJECTION(xbox_task_start);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_start", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xbox_task_start(arg0));
  }
}
Variant i_newpixelwands(CArrRef params) {
  FUNCTION_INJECTION(newpixelwands);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwands", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_newpixelwands(arg0));
  }
}
Variant i_mb_get_info(CArrRef params) {
  FUNCTION_INJECTION(mb_get_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_get_info", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_get_info());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_get_info(arg0));
  }
}
Variant i_posix_getrlimit(CArrRef params) {
  FUNCTION_INJECTION(posix_getrlimit);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getrlimit", 0, 1);
  return (f_posix_getrlimit());
}
Variant i_getcwd(CArrRef params) {
  FUNCTION_INJECTION(getcwd);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getcwd", 0, 1);
  return (f_getcwd());
}
Variant i_fputcsv(CArrRef params) {
  FUNCTION_INJECTION(fputcsv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fputcsv", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fputcsv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_fputcsv(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fputcsv(arg0, arg1, arg2, arg3));
  }
}
Variant i_stream_bucket_prepend(CArrRef params) {
  FUNCTION_INJECTION(stream_bucket_prepend);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_prepend", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_bucket_prepend(arg0, arg1), null);
  }
}
Variant i_apache_get_scoreboard(CArrRef params) {
  FUNCTION_INJECTION(apache_get_scoreboard);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_scoreboard", 0, 1);
  return (f_apache_get_scoreboard());
}
Variant i_sprintf(CArrRef params) {
  FUNCTION_INJECTION(sprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("sprintf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_sprintf(count, arg0));
    return (f_sprintf(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_ldap_err2str(CArrRef params) {
  FUNCTION_INJECTION(ldap_err2str);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_err2str", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_err2str(arg0));
  }
}
Variant i_memcache_get_stats(CArrRef params) {
  FUNCTION_INJECTION(memcache_get_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_stats", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_get_stats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_get_stats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_get_stats(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_get_stats(arg0, arg1, arg2, arg3));
  }
}
Variant i_xmlwriter_end_attribute(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_attribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_attribute(arg0));
  }
}
Variant i_imagecharup(CArrRef params) {
  FUNCTION_INJECTION(imagecharup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagecharup", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecharup(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_fflush(CArrRef params) {
  FUNCTION_INJECTION(fflush);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fflush", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fflush(arg0));
  }
}
Variant i_magickwaveimage(CArrRef params) {
  FUNCTION_INJECTION(magickwaveimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickwaveimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickwaveimage(arg0, arg1, arg2));
  }
}
Variant i_imagepsfreefont(CArrRef params) {
  FUNCTION_INJECTION(imagepsfreefont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsfreefont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagepsfreefont(arg0));
  }
}
Variant i_dom_node_is_supported(CArrRef params) {
  FUNCTION_INJECTION(dom_node_is_supported);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_is_supported", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_node_is_supported(arg0, arg1, arg2));
  }
}
Variant i_magickgetsamplingfactors(CArrRef params) {
  FUNCTION_INJECTION(magickgetsamplingfactors);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsamplingfactors", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetsamplingfactors(arg0));
  }
}
Variant i_mt_rand(CArrRef params) {
  FUNCTION_INJECTION(mt_rand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mt_rand", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mt_rand());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mt_rand(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mt_rand(arg0, arg1));
  }
}
Variant i_hphp_splfileinfo_getpathname(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getpathname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpathname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getpathname(arg0));
  }
}
Variant i_magickflopimage(CArrRef params) {
  FUNCTION_INJECTION(magickflopimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflopimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickflopimage(arg0));
  }
}
Variant i_register_cleanup_function(CArrRef params) {
  FUNCTION_INJECTION(register_cleanup_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_cleanup_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_cleanup_function(count, arg0), null);
    return (f_register_cleanup_function(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant i_getenv(CArrRef params) {
  FUNCTION_INJECTION(getenv);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getenv", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_getenv(arg0));
  }
}
Variant i_is_dir(CArrRef params) {
  FUNCTION_INJECTION(is_dir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_dir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_dir(arg0));
  }
}
Variant i_get_defined_functions(CArrRef params) {
  FUNCTION_INJECTION(get_defined_functions);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_functions", 0, 1);
  return (f_get_defined_functions());
}
Variant i_stream_set_timeout(CArrRef params) {
  FUNCTION_INJECTION(stream_set_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stream_set_timeout", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_set_timeout(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_set_timeout(arg0, arg1, arg2));
  }
}
Variant i_magickenhanceimage(CArrRef params) {
  FUNCTION_INJECTION(magickenhanceimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickenhanceimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickenhanceimage(arg0));
  }
}
Variant i_memcache_increment(CArrRef params) {
  FUNCTION_INJECTION(memcache_increment);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_increment", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_memcache_increment(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_increment(arg0, arg1, arg2));
  }
}
Variant i_pixelsetblack(CArrRef params) {
  FUNCTION_INJECTION(pixelsetblack);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblack", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetblack(arg0, arg1), null);
  }
}
Variant i_magickgetcharwidth(CArrRef params) {
  FUNCTION_INJECTION(magickgetcharwidth);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharwidth", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetcharwidth(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetcharwidth(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickshearimage(CArrRef params) {
  FUNCTION_INJECTION(magickshearimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickshearimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickshearimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_stream_socket_enable_crypto(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_enable_crypto);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_enable_crypto", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stream_socket_enable_crypto(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_enable_crypto(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_enable_crypto(arg0, arg1, arg2, arg3));
  }
}
Variant i_stream_socket_server(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_server);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("stream_socket_server", count, 1, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_socket_server(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_stream_socket_server(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_stream_socket_server(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_stream_socket_server(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_server(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_apd_set_pprof_trace(CArrRef params) {
  FUNCTION_INJECTION(apd_set_pprof_trace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apd_set_pprof_trace", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apd_set_pprof_trace());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_apd_set_pprof_trace(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apd_set_pprof_trace(arg0, arg1));
  }
}
Variant i_ini_set(CArrRef params) {
  FUNCTION_INJECTION(ini_set);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ini_set(arg0, arg1));
  }
}
Variant i_sort(CArrRef params) {
  FUNCTION_INJECTION(sort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("sort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_sort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_sort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_sort(arg0, arg1, arg2));
  }
}
Variant i_drawgetfont(CArrRef params) {
  FUNCTION_INJECTION(drawgetfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfont", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetfont(arg0));
  }
}
Variant i_readdir(CArrRef params) {
  FUNCTION_INJECTION(readdir);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readdir", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_readdir(arg0));
  }
}
Variant i_mysql_close(CArrRef params) {
  FUNCTION_INJECTION(mysql_close);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_close", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_close());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_close(arg0));
  }
}
Variant i_magicksetimagerenderingintent(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagerenderingintent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagerenderingintent", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagerenderingintent(arg0, arg1));
  }
}
Variant i_magickreducenoiseimage(CArrRef params) {
  FUNCTION_INJECTION(magickreducenoiseimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreducenoiseimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreducenoiseimage(arg0, arg1));
  }
}
Variant i_magickblurimage(CArrRef params) {
  FUNCTION_INJECTION(magickblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickblurimage", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickblurimage(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickblurimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphpd_get_user_commands(CArrRef params) {
  FUNCTION_INJECTION(hphpd_get_user_commands);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphpd_get_user_commands", 0, 1);
  return (f_hphpd_get_user_commands());
}
Variant i_magicktintimage(CArrRef params) {
  FUNCTION_INJECTION(magicktintimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktintimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicktintimage(arg0, arg1, arg2));
  }
}
Variant i_rawurldecode(CArrRef params) {
  FUNCTION_INJECTION(rawurldecode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurldecode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_rawurldecode(arg0));
  }
}
Variant i_strftime(CArrRef params) {
  FUNCTION_INJECTION(strftime);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strftime", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_strftime(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strftime(arg0, arg1));
  }
}
Variant i_xmlwriter_start_element_ns(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_element_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_element_ns", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_element_ns(arg0, arg1, arg2, arg3));
  }
}
Variant i_imagecolorstotal(CArrRef params) {
  FUNCTION_INJECTION(imagecolorstotal);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecolorstotal", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecolorstotal(arg0));
  }
}
Variant i_hphp_splfileinfo_getowner(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getowner);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getowner", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getowner(arg0));
  }
}
Variant i_write_hdf_string(CArrRef params) {
  FUNCTION_INJECTION(write_hdf_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("write_hdf_string", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_write_hdf_string(arg0));
  }
}
Variant i_dom_node_has_child_nodes(CArrRef params) {
  FUNCTION_INJECTION(dom_node_has_child_nodes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_child_nodes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_node_has_child_nodes(arg0));
  }
}
Variant i_apc_bin_dumpfile(CArrRef params) {
  FUNCTION_INJECTION(apc_bin_dumpfile);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("apc_bin_dumpfile", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_apc_bin_dumpfile(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_apc_bin_dumpfile(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_dumpfile(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_xml_parse_into_struct(CArrRef params) {
  FUNCTION_INJECTION(xml_parse_into_struct);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xml_parse_into_struct", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_xml_parse_into_struct(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_xml_parse_into_struct(arg0, arg1, arg2, arg3));
  }
}
Variant i_icu_transliterate(CArrRef params) {
  FUNCTION_INJECTION(icu_transliterate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("icu_transliterate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_icu_transliterate(arg0, arg1));
  }
}
Variant i_mb_eregi_replace(CArrRef params) {
  FUNCTION_INJECTION(mb_eregi_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_eregi_replace", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_eregi_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_eregi_replace(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphp_splfileinfo_getatime(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getatime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getatime", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getatime(arg0));
  }
}
Variant i_array_unshift(CArrRef params) {
  FUNCTION_INJECTION(array_unshift);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_unshift", count+1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_unshift(count, arg0, arg1));
    return (f_array_unshift(count,ref(arg0), arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_stat(CArrRef params) {
  FUNCTION_INJECTION(stat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stat", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stat(arg0));
  }
}
Variant i_posix_getpid(CArrRef params) {
  FUNCTION_INJECTION(posix_getpid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpid", 0, 1);
  return (f_posix_getpid());
}
Variant i_hphp_directoryiterator_key(CArrRef params) {
  FUNCTION_INJECTION(hphp_directoryiterator_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_directoryiterator_key(arg0));
  }
}
Variant i_get_current_user(CArrRef params) {
  FUNCTION_INJECTION(get_current_user);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_current_user", 0, 1);
  return (f_get_current_user());
}
Variant i_filesize(CArrRef params) {
  FUNCTION_INJECTION(filesize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filesize", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filesize(arg0));
  }
}
Variant i_round(CArrRef params) {
  FUNCTION_INJECTION(round);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("round", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_round(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_round(arg0, arg1));
  }
}
Variant i_pdo_drivers(CArrRef params) {
  FUNCTION_INJECTION(pdo_drivers);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pdo_drivers", 0, 1);
  return (f_pdo_drivers());
}
Variant i_sqrt(CArrRef params) {
  FUNCTION_INJECTION(sqrt);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sqrt", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sqrt(arg0));
  }
}
Variant i_ldap_close(CArrRef params) {
  FUNCTION_INJECTION(ldap_close);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_close", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_close(arg0));
  }
}
Variant i_memcache_pconnect(CArrRef params) {
  FUNCTION_INJECTION(memcache_pconnect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_pconnect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_memcache_pconnect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_memcache_pconnect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_memcache_pconnect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_memcache_pconnect(arg0, arg1, arg2, arg3));
  }
}
Variant i_mcrypt_enc_get_algorithms_name(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_get_algorithms_name);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_algorithms_name", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_get_algorithms_name(arg0));
  }
}
Variant i_hphp_splfileobject_rewind(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_rewind);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_rewind", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileobject_rewind(arg0), null);
  }
}
Variant i_fprintf(CArrRef params) {
  FUNCTION_INJECTION(fprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fprintf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fprintf(count, arg0, arg1));
    return (f_fprintf(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_extension_loaded(CArrRef params) {
  FUNCTION_INJECTION(extension_loaded);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("extension_loaded", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_extension_loaded(arg0));
  }
}
Variant i_mb_detect_order(CArrRef params) {
  FUNCTION_INJECTION(mb_detect_order);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_detect_order", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_detect_order());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_detect_order(arg0));
  }
}
Variant i_magickmapimage(CArrRef params) {
  FUNCTION_INJECTION(magickmapimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickmapimage", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmapimage(arg0, arg1, arg2));
  }
}
Variant i_get_magic_quotes_runtime(CArrRef params) {
  FUNCTION_INJECTION(get_magic_quotes_runtime);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_runtime", 0, 1);
  return (f_get_magic_quotes_runtime());
}
Variant i_pixelsetopacityquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetopacityquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacityquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetopacityquantum(arg0, arg1), null);
  }
}
Variant i_ctype_space(CArrRef params) {
  FUNCTION_INJECTION(ctype_space);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_space", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ctype_space(arg0));
  }
}
Variant i_destroymagickwand(CArrRef params) {
  FUNCTION_INJECTION(destroymagickwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroymagickwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroymagickwand(arg0), null);
  }
}
Variant i_mcrypt_generic_init(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_generic_init);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mcrypt_generic_init", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_generic_init(arg0, arg1, arg2));
  }
}
Variant i_quoted_printable_decode(CArrRef params) {
  FUNCTION_INJECTION(quoted_printable_decode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_decode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_quoted_printable_decode(arg0));
  }
}
Variant i_hphp_splfileinfo_getfileinfo(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getfileinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getfileinfo", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_getfileinfo(arg0, arg1));
  }
}
Variant i_get_cfg_var(CArrRef params) {
  FUNCTION_INJECTION(get_cfg_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_cfg_var", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_cfg_var(arg0));
  }
}
Variant i_imagerectangle(CArrRef params) {
  FUNCTION_INJECTION(imagerectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagerectangle", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagerectangle(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_call_user_func_rpc(CArrRef params) {
  FUNCTION_INJECTION(call_user_func_rpc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5) return throw_missing_arguments("call_user_func_rpc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_call_user_func_rpc(count, arg0, arg1, arg2, arg3, arg4));
    return (f_call_user_func_rpc(count,arg0, arg1, arg2, arg3, arg4, params.slice(5, count - 5, false)));
  }
}
Variant i_pixelgetalphaquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelgetalphaquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalphaquantum", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetalphaquantum(arg0));
  }
}
Variant i_fb_renamed_functions(CArrRef params) {
  FUNCTION_INJECTION(fb_renamed_functions);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_renamed_functions", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fb_renamed_functions(arg0), null);
  }
}
Variant i_imagepsextendfont(CArrRef params) {
  FUNCTION_INJECTION(imagepsextendfont);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsextendfont", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepsextendfont(arg0, arg1));
  }
}
Variant i_magickgetimageblob(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageblob);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblob", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageblob(arg0));
  }
}
Variant i_stream_get_filters(CArrRef params) {
  FUNCTION_INJECTION(stream_get_filters);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_filters", 0, 1);
  return (f_stream_get_filters());
}
Variant i_magickqueryfontmetrics(CArrRef params) {
  FUNCTION_INJECTION(magickqueryfontmetrics);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickqueryfontmetrics", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickqueryfontmetrics(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickqueryfontmetrics(arg0, arg1, arg2, arg3));
  }
}
Variant i_ispixeliterator(CArrRef params) {
  FUNCTION_INJECTION(ispixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ispixeliterator(arg0));
  }
}
Variant i_imagefilledarc(CArrRef params) {
  FUNCTION_INJECTION(imagefilledarc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagefilledarc", count, 9, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledarc(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant i_getdate(CArrRef params) {
  FUNCTION_INJECTION(getdate);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getdate", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_getdate());
    CVarRef arg0((ad->getValue(pos)));
    return (f_getdate(arg0));
  }
}
Variant i_xmlwriter_write_attribute(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_attribute", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_attribute(arg0, arg1, arg2));
  }
}
Variant i_imagearc(CArrRef params) {
  FUNCTION_INJECTION(imagearc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagearc", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagearc(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_magickreadimages(CArrRef params) {
  FUNCTION_INJECTION(magickreadimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimages", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickreadimages(arg0, arg1));
  }
}
Variant i_drawgetgravity(CArrRef params) {
  FUNCTION_INJECTION(drawgetgravity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetgravity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetgravity(arg0));
  }
}
Variant i_connection_status(CArrRef params) {
  FUNCTION_INJECTION(connection_status);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_status", 0, 1);
  return (f_connection_status());
}
Variant i_imagecreatefromgd2(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgd2);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd2", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromgd2(arg0));
  }
}
Variant i_stream_socket_shutdown(CArrRef params) {
  FUNCTION_INJECTION(stream_socket_shutdown);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_shutdown", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_socket_shutdown(arg0, arg1));
  }
}
Variant i_pixelresetiterator(CArrRef params) {
  FUNCTION_INJECTION(pixelresetiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelresetiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelresetiterator(arg0), null);
  }
}
Variant i_msg_send(CArrRef params) {
  FUNCTION_INJECTION(msg_send);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("msg_send", count, 3, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_msg_send(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_msg_send(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_msg_send(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_msg_send(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_getmygid(CArrRef params) {
  FUNCTION_INJECTION(getmygid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmygid", 0, 1);
  return (f_getmygid());
}
Variant i_dom_document_get_element_by_id(CArrRef params) {
  FUNCTION_INJECTION(dom_document_get_element_by_id);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_element_by_id", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_get_element_by_id(arg0, arg1));
  }
}
Variant i_array_udiff_uassoc(CArrRef params) {
  FUNCTION_INJECTION(array_udiff_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_udiff_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (f_array_udiff_uassoc(count, arg0, arg1, arg2, arg3));
    return (f_array_udiff_uassoc(count,arg0, arg1, arg2, arg3, params.slice(4, count - 4, false)));
  }
}
Variant i_strptime(CArrRef params) {
  FUNCTION_INJECTION(strptime);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strptime", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strptime(arg0, arg1));
  }
}
Variant i_array_diff_uassoc(CArrRef params) {
  FUNCTION_INJECTION(array_diff_uassoc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_uassoc", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_array_diff_uassoc(count, arg0, arg1, arg2));
    return (f_array_diff_uassoc(count,arg0, arg1, arg2, params.slice(3, count - 3, false)));
  }
}
Variant i_xml_set_character_data_handler(CArrRef params) {
  FUNCTION_INJECTION(xml_set_character_data_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_character_data_handler", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_set_character_data_handler(arg0, arg1));
  }
}
Variant i_pcntl_waitpid(CArrRef params) {
  FUNCTION_INJECTION(pcntl_waitpid);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_waitpid", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_pcntl_waitpid(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_waitpid(arg0, arg1, arg2));
  }
}
Variant i_array_replace_recursive(CArrRef params) {
  FUNCTION_INJECTION(array_replace_recursive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace_recursive", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_replace_recursive(count, arg0));
    return (f_array_replace_recursive(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_gd_info(CArrRef params) {
  FUNCTION_INJECTION(gd_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("gd_info", 0, 1);
  return (f_gd_info());
}
Variant i_stream_get_transports(CArrRef params) {
  FUNCTION_INJECTION(stream_get_transports);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_transports", 0, 1);
  return (f_stream_get_transports());
}
Variant i_drawsetstrokepatternurl(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokepatternurl);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokepatternurl", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokepatternurl(arg0, arg1));
  }
}
Variant i_ldap_add(CArrRef params) {
  FUNCTION_INJECTION(ldap_add);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_add", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_add(arg0, arg1, arg2));
  }
}
Variant i_acosh(CArrRef params) {
  FUNCTION_INJECTION(acosh);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acosh", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_acosh(arg0));
  }
}
Variant i_drawsetfillrule(CArrRef params) {
  FUNCTION_INJECTION(drawsetfillrule);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillrule", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillrule(arg0, arg1), null);
  }
}
Variant i_posix_getlogin(CArrRef params) {
  FUNCTION_INJECTION(posix_getlogin);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getlogin", 0, 1);
  return (f_posix_getlogin());
}
Variant i_posix_getsid(CArrRef params) {
  FUNCTION_INJECTION(posix_getsid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getsid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getsid(arg0));
  }
}
Variant i_imagegd2(CArrRef params) {
  FUNCTION_INJECTION(imagegd2);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagegd2", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegd2(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagegd2(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_imagegd2(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegd2(arg0, arg1, arg2, arg3));
  }
}
Variant i_imagecreate(CArrRef params) {
  FUNCTION_INJECTION(imagecreate);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreate", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecreate(arg0, arg1));
  }
}
Variant i_socket_create_pair(CArrRef params) {
  FUNCTION_INJECTION(socket_create_pair);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_create_pair", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_create_pair(arg0, arg1, arg2, arg3));
  }
}
Variant i_openssl_x509_check_private_key(CArrRef params) {
  FUNCTION_INJECTION(openssl_x509_check_private_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("openssl_x509_check_private_key", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_x509_check_private_key(arg0, arg1));
  }
}
Variant i_collator_get_attribute(CArrRef params) {
  FUNCTION_INJECTION(collator_get_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_get_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_collator_get_attribute(arg0, arg1));
  }
}
Variant i_shm_put_var(CArrRef params) {
  FUNCTION_INJECTION(shm_put_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("shm_put_var", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_put_var(arg0, arg1, arg2));
  }
}
Variant i_debug_print_backtrace(CArrRef params) {
  FUNCTION_INJECTION(debug_print_backtrace);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("debug_print_backtrace", 0, 1);
  return (f_debug_print_backtrace(), null);
}
Variant i_hphp_splfileobject_seek(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_seek(arg0, arg1), null);
  }
}
Variant i_stream_set_blocking(CArrRef params) {
  FUNCTION_INJECTION(stream_set_blocking);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_blocking", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_set_blocking(arg0, arg1));
  }
}
Variant i_ezmlm_hash(CArrRef params) {
  FUNCTION_INJECTION(ezmlm_hash);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ezmlm_hash", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ezmlm_hash(arg0));
  }
}
Variant i_xml_parser_get_option(CArrRef params) {
  FUNCTION_INJECTION(xml_parser_get_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_parser_get_option", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parser_get_option(arg0, arg1));
  }
}
Variant i_array_search(CArrRef params) {
  FUNCTION_INJECTION(array_search);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_search", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_search(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_search(arg0, arg1, arg2));
  }
}
Variant i_is_int(CArrRef params) {
  FUNCTION_INJECTION(is_int);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_int", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_int(arg0));
  }
}
Variant i_dangling_server_proxy_new_request(CArrRef params) {
  FUNCTION_INJECTION(dangling_server_proxy_new_request);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dangling_server_proxy_new_request", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dangling_server_proxy_new_request(arg0));
  }
}
Variant i_xmlwriter_end_dtd_entity(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_dtd_entity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_entity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_dtd_entity(arg0));
  }
}
Variant i_trim(CArrRef params) {
  FUNCTION_INJECTION(trim);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trim", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_trim(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_trim(arg0, arg1));
  }
}
Variant i_drawpathclose(CArrRef params) {
  FUNCTION_INJECTION(drawpathclose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathclose", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawpathclose(arg0), null);
  }
}
Variant i_magickprofileimage(CArrRef params) {
  FUNCTION_INJECTION(magickprofileimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickprofileimage", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_magickprofileimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickprofileimage(arg0, arg1, arg2));
  }
}
Variant i_connection_timeout(CArrRef params) {
  FUNCTION_INJECTION(connection_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_timeout", 0, 1);
  return (f_connection_timeout());
}
Variant i_mysql_data_seek(CArrRef params) {
  FUNCTION_INJECTION(mysql_data_seek);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_data_seek", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_data_seek(arg0, arg1));
  }
}
Variant i_pixelgetindex(CArrRef params) {
  FUNCTION_INJECTION(pixelgetindex);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetindex", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetindex(arg0));
  }
}
Variant i_class_implements(CArrRef params) {
  FUNCTION_INJECTION(class_implements);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_implements", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_class_implements(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_class_implements(arg0, arg1));
  }
}
Variant i_hebrevc(CArrRef params) {
  FUNCTION_INJECTION(hebrevc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrevc", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_hebrevc(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hebrevc(arg0, arg1));
  }
}
Variant i_get_meta_tags(CArrRef params) {
  FUNCTION_INJECTION(get_meta_tags);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_meta_tags", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_get_meta_tags(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_get_meta_tags(arg0, arg1));
  }
}
Variant i_magicknextimage(CArrRef params) {
  FUNCTION_INJECTION(magicknextimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknextimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magicknextimage(arg0));
  }
}
Variant i_hphp_recursivedirectoryiterator_key(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_key);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_key", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_key(arg0));
  }
}
Variant i_mysql_create_db(CArrRef params) {
  FUNCTION_INJECTION(mysql_create_db);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_create_db", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_create_db(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_create_db(arg0, arg1));
  }
}
Variant i_mysql_stat(CArrRef params) {
  FUNCTION_INJECTION(mysql_stat);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_stat", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_stat());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_stat(arg0));
  }
}
Variant i_get_object_vars(CArrRef params) {
  FUNCTION_INJECTION(get_object_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_object_vars", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_object_vars(arg0));
  }
}
Variant i_msg_receive(CArrRef params) {
  FUNCTION_INJECTION(msg_receive);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 8) return throw_wrong_arguments("msg_receive", count, 5, 8, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_msg_receive(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_msg_receive(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_msg_receive(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_msg_receive(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_is_integer(CArrRef params) {
  FUNCTION_INJECTION(is_integer);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_integer", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_integer(arg0));
  }
}
Variant i_posix_getuid(CArrRef params) {
  FUNCTION_INJECTION(posix_getuid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getuid", 0, 1);
  return (f_posix_getuid());
}
Variant i_imagecreatefromgif(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromgif);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgif", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromgif(arg0));
  }
}
Variant i_mb_send_mail(CArrRef params) {
  FUNCTION_INJECTION(mb_send_mail);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_send_mail", count, 3, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_mb_send_mail(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mb_send_mail(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_send_mail(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_hphp_splfileinfo___construct(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo___construct);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo___construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo___construct(arg0, arg1));
  }
}
Variant i_register_postsend_function(CArrRef params) {
  FUNCTION_INJECTION(register_postsend_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_postsend_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_postsend_function(count, arg0), null);
    return (f_register_postsend_function(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant i_getrusage(CArrRef params) {
  FUNCTION_INJECTION(getrusage);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getrusage", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_getrusage());
    CVarRef arg0((ad->getValue(pos)));
    return (f_getrusage(arg0));
  }
}
Variant i_long2ip(CArrRef params) {
  FUNCTION_INJECTION(long2ip);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("long2ip", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_long2ip(arg0));
  }
}
Variant i_evhttp_set_cache(CArrRef params) {
  FUNCTION_INJECTION(evhttp_set_cache);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("evhttp_set_cache", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_evhttp_set_cache(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_evhttp_set_cache(arg0, arg1, arg2), null);
  }
}
Variant i_magickoilpaintimage(CArrRef params) {
  FUNCTION_INJECTION(magickoilpaintimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickoilpaintimage", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickoilpaintimage(arg0, arg1));
  }
}
Variant i_strripos(CArrRef params) {
  FUNCTION_INJECTION(strripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strripos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_strripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strripos(arg0, arg1, arg2));
  }
}
Variant i_magicksetimagecolormapcolor(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecolormapcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagecolormapcolor", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecolormapcolor(arg0, arg1, arg2));
  }
}
Variant i_magickgetfilename(CArrRef params) {
  FUNCTION_INJECTION(magickgetfilename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetfilename", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetfilename(arg0));
  }
}
Variant i_magicksetimagegamma(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagegamma);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagegamma", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagegamma(arg0, arg1));
  }
}
Variant i_mysql_pconnect(CArrRef params) {
  FUNCTION_INJECTION(mysql_pconnect);
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mysql_pconnect", 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_pconnect());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_mysql_pconnect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_pconnect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mysql_pconnect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mysql_pconnect(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_mysql_pconnect(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_pconnect(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_stripos(CArrRef params) {
  FUNCTION_INJECTION(stripos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stripos", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_stripos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stripos(arg0, arg1, arg2));
  }
}
Variant i_http_build_query(CArrRef params) {
  FUNCTION_INJECTION(http_build_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("http_build_query", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_http_build_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_http_build_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_http_build_query(arg0, arg1, arg2));
  }
}
Variant i_apc_add(CArrRef params) {
  FUNCTION_INJECTION(apc_add);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_add", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apc_add(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_add(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_add(arg0, arg1, arg2, arg3));
  }
}
Variant i_iconv_strlen(CArrRef params) {
  FUNCTION_INJECTION(iconv_strlen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iconv_strlen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_iconv_strlen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_strlen(arg0, arg1));
  }
}
Variant i_vsprintf(CArrRef params) {
  FUNCTION_INJECTION(vsprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vsprintf", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_vsprintf(arg0, arg1));
  }
}
Variant i_imageistruecolor(CArrRef params) {
  FUNCTION_INJECTION(imageistruecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageistruecolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imageistruecolor(arg0));
  }
}
Variant i_mailparse_msg_extract_part_file(CArrRef params) {
  FUNCTION_INJECTION(mailparse_msg_extract_part_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mailparse_msg_extract_part_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_msg_extract_part_file(arg0, arg1, arg2));
  }
}
Variant i_dom_xpath_register_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_xpath_register_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_xpath_register_ns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_xpath_register_ns(arg0, arg1, arg2));
  }
}
Variant i_is_nan(CArrRef params) {
  FUNCTION_INJECTION(is_nan);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_nan", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_nan(arg0));
  }
}
Variant i_imagegif(CArrRef params) {
  FUNCTION_INJECTION(imagegif);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegif", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagegif(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagegif(arg0, arg1));
  }
}
Variant i_eregi_replace(CArrRef params) {
  FUNCTION_INJECTION(eregi_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("eregi_replace", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_eregi_replace(arg0, arg1, arg2));
  }
}
Variant i_magickgetimageiterations(CArrRef params) {
  FUNCTION_INJECTION(magickgetimageiterations);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageiterations", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimageiterations(arg0));
  }
}
Variant i_register_tick_function(CArrRef params) {
  FUNCTION_INJECTION(register_tick_function);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_tick_function", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_register_tick_function(count, arg0));
    return (f_register_tick_function(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_pixelsetblackquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetblackquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblackquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetblackquantum(arg0, arg1), null);
  }
}
Variant i_jpeg2wbmp(CArrRef params) {
  FUNCTION_INJECTION(jpeg2wbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("jpeg2wbmp", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_jpeg2wbmp(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_mcrypt_get_iv_size(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_get_iv_size);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_iv_size", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_get_iv_size(arg0, arg1));
  }
}
Variant i_mysql_fetch_array(CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_array);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_array", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_fetch_array(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_fetch_array(arg0, arg1));
  }
}
Variant i_magickpreviousimage(CArrRef params) {
  FUNCTION_INJECTION(magickpreviousimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickpreviousimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickpreviousimage(arg0));
  }
}
Variant i_magickborderimage(CArrRef params) {
  FUNCTION_INJECTION(magickborderimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickborderimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickborderimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_mcrypt_module_is_block_mode(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_is_block_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_mode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_is_block_mode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_is_block_mode(arg0, arg1));
  }
}
Variant i_mb_substr(CArrRef params) {
  FUNCTION_INJECTION(mb_substr);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_substr", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_substr(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_substr(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_substr(arg0, arg1, arg2, arg3));
  }
}
Variant i_get_defined_constants(CArrRef params) {
  FUNCTION_INJECTION(get_defined_constants);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_defined_constants", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_get_defined_constants());
    CVarRef arg0((ad->getValue(pos)));
    return (f_get_defined_constants(arg0));
  }
}
Variant i_mcrypt_enc_is_block_mode(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_enc_is_block_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_mode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mcrypt_enc_is_block_mode(arg0));
  }
}
Variant i_mailparse_stream_encode(CArrRef params) {
  FUNCTION_INJECTION(mailparse_stream_encode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mailparse_stream_encode", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mailparse_stream_encode(arg0, arg1, arg2));
  }
}
Variant i_drawsetstrokedashoffset(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokedashoffset);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokedashoffset", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokedashoffset(arg0, arg1), null);
  }
}
Variant i_php_ini_scanned_files(CArrRef params) {
  FUNCTION_INJECTION(php_ini_scanned_files);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_ini_scanned_files", 0, 1);
  return (f_php_ini_scanned_files());
}
Variant i_disk_free_space(CArrRef params) {
  FUNCTION_INJECTION(disk_free_space);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_free_space", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_disk_free_space(arg0));
  }
}
Variant i_pixelsetyellowquantum(CArrRef params) {
  FUNCTION_INJECTION(pixelsetyellowquantum);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellowquantum", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetyellowquantum(arg0, arg1), null);
  }
}
Variant i_dom_document_create_element_ns(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_element_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("dom_document_create_element_ns", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_dom_document_create_element_ns(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_element_ns(arg0, arg1, arg2, arg3));
  }
}
Variant i_openssl_public_decrypt(CArrRef params) {
  FUNCTION_INJECTION(openssl_public_decrypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_decrypt", count, 3, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_openssl_public_decrypt(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_public_decrypt(arg0, arg1, arg2, arg3));
  }
}
Variant i_convert_uuencode(CArrRef params) {
  FUNCTION_INJECTION(convert_uuencode);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uuencode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_convert_uuencode(arg0));
  }
}
Variant i_magickequalizeimage(CArrRef params) {
  FUNCTION_INJECTION(magickequalizeimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickequalizeimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickequalizeimage(arg0));
  }
}
Variant i_mysql_field_len(CArrRef params) {
  FUNCTION_INJECTION(mysql_field_len);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_len", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_len(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_len(arg0, arg1));
  }
}
Variant i_drawsetclipunits(CArrRef params) {
  FUNCTION_INJECTION(drawsetclipunits);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclipunits", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetclipunits(arg0, arg1), null);
  }
}
Variant i_mdecrypt_generic(CArrRef params) {
  FUNCTION_INJECTION(mdecrypt_generic);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mdecrypt_generic", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mdecrypt_generic(arg0, arg1));
  }
}
Variant i_getprotobyname(CArrRef params) {
  FUNCTION_INJECTION(getprotobyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobyname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_getprotobyname(arg0));
  }
}
Variant i_xmlwriter_start_pi(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_pi);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_pi", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_pi(arg0, arg1));
  }
}
Variant i_mysql_field_type(CArrRef params) {
  FUNCTION_INJECTION(mysql_field_type);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_type", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_type(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_type(arg0, arg1));
  }
}
Variant i_apc_cas(CArrRef params) {
  FUNCTION_INJECTION(apc_cas);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("apc_cas", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_apc_cas(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_cas(arg0, arg1, arg2, arg3));
  }
}
Variant i_getopt(CArrRef params) {
  FUNCTION_INJECTION(getopt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getopt", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_getopt(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_getopt(arg0, arg1));
  }
}
Variant i_clearpixelwand(CArrRef params) {
  FUNCTION_INJECTION(clearpixelwand);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixelwand", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_clearpixelwand(arg0), null);
  }
}
Variant i_drawsetgravity(CArrRef params) {
  FUNCTION_INJECTION(drawsetgravity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetgravity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetgravity(arg0, arg1), null);
  }
}
Variant i_magickgetimagecompressionquality(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecompressionquality);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompressionquality", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecompressionquality(arg0));
  }
}
Variant i_magickquantizeimages(CArrRef params) {
  FUNCTION_INJECTION(magickquantizeimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimages", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickquantizeimages(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_mysql_insert_id(CArrRef params) {
  FUNCTION_INJECTION(mysql_insert_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_insert_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_insert_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_insert_id(arg0));
  }
}
Variant i_hphp_thread_set_warmup_enabled(CArrRef params) {
  FUNCTION_INJECTION(hphp_thread_set_warmup_enabled);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_set_warmup_enabled", 0, 1);
  return (f_hphp_thread_set_warmup_enabled(), null);
}
Variant i_stream_context_set_param(CArrRef params) {
  FUNCTION_INJECTION(stream_context_set_param);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_context_set_param", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_context_set_param(arg0, arg1));
  }
}
Variant i_drawpathlinetohorizontalabsolute(CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetohorizontalabsolute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalabsolute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetohorizontalabsolute(arg0, arg1), null);
  }
}
Variant i_openssl_csr_export(CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_csr_export(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_export(arg0, arg1, arg2));
  }
}
Variant i_socket_connect(CArrRef params) {
  FUNCTION_INJECTION(socket_connect);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_connect", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_connect(arg0, arg1, arg2));
  }
}
Variant i_stripslashes(CArrRef params) {
  FUNCTION_INJECTION(stripslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripslashes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stripslashes(arg0));
  }
}
Variant i_magickhaspreviousimage(CArrRef params) {
  FUNCTION_INJECTION(magickhaspreviousimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhaspreviousimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickhaspreviousimage(arg0));
  }
}
Variant i_drawgetstrokecolor(CArrRef params) {
  FUNCTION_INJECTION(drawgetstrokecolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokecolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgetstrokecolor(arg0));
  }
}
Variant i_imagecreatefromwbmp(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromwbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromwbmp", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromwbmp(arg0));
  }
}
Variant i_str_repeat(CArrRef params) {
  FUNCTION_INJECTION(str_repeat);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("str_repeat", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_repeat(arg0, arg1));
  }
}
Variant i_stream_resolve_include_path(CArrRef params) {
  FUNCTION_INJECTION(stream_resolve_include_path);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_resolve_include_path", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_stream_resolve_include_path(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_resolve_include_path(arg0, arg1));
  }
}
Variant i_ldap_read(CArrRef params) {
  FUNCTION_INJECTION(ldap_read);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_read", count, 3, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_ldap_read(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_ldap_read(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_ldap_read(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (f_ldap_read(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (f_ldap_read(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_read(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
  }
}
Variant i_apc_dec(CArrRef params) {
  FUNCTION_INJECTION(apc_dec);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_dec", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_dec(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_dec(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_dec(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_dec(arg0, arg1, arg2, arg3));
  }
}
Variant i_posix_get_last_error(CArrRef params) {
  FUNCTION_INJECTION(posix_get_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_get_last_error", 0, 1);
  return (f_posix_get_last_error());
}
Variant i_iptcparse(CArrRef params) {
  FUNCTION_INJECTION(iptcparse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iptcparse", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_iptcparse(arg0));
  }
}
Variant i_iterator_count(CArrRef params) {
  FUNCTION_INJECTION(iterator_count);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iterator_count", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_iterator_count(arg0));
  }
}
Variant i_curl_setopt_array(CArrRef params) {
  FUNCTION_INJECTION(curl_setopt_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_setopt_array", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_setopt_array(arg0, arg1));
  }
}
Variant i_socket_recvfrom(CArrRef params) {
  FUNCTION_INJECTION(socket_recvfrom);
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_recvfrom", count, 5, 6, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 5) return (f_socket_recvfrom(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_recvfrom(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_imagepstext(CArrRef params) {
  FUNCTION_INJECTION(imagepstext);
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 12) return throw_wrong_arguments("imagepstext", count, 8, 12, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 8) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 9) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 10) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
    CVarRef arg10((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 11) return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10));
    CVarRef arg11((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepstext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11));
  }
}
Variant i_mb_encode_mimeheader(CArrRef params) {
  FUNCTION_INJECTION(mb_encode_mimeheader);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("mb_encode_mimeheader", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_encode_mimeheader(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_encode_mimeheader(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_mb_encode_mimeheader(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_mb_encode_mimeheader(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_encode_mimeheader(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_socket_getsockname(CArrRef params) {
  FUNCTION_INJECTION(socket_getsockname);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getsockname", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_getsockname(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_socket_getsockname(arg0, arg1, arg2));
  }
}
Variant i_imagecreatefromstring(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromstring(arg0));
  }
}
Variant i_vfprintf(CArrRef params) {
  FUNCTION_INJECTION(vfprintf);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("vfprintf", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_vfprintf(arg0, arg1, arg2));
  }
}
Variant i_magickcompareimages(CArrRef params) {
  FUNCTION_INJECTION(magickcompareimages);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickcompareimages", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickcompareimages(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickcompareimages(arg0, arg1, arg2, arg3));
  }
}
Variant i_fscanf(CArrRef params) {
  FUNCTION_INJECTION(fscanf);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fscanf", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_fscanf(count, arg0, arg1));
    return (f_fscanf(count,arg0, arg1, params.slice(2, count - 2, false)));
  }
}
Variant i_stristr(CArrRef params) {
  FUNCTION_INJECTION(stristr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stristr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stristr(arg0, arg1));
  }
}
Variant i_xml_parser_set_option(CArrRef params) {
  FUNCTION_INJECTION(xml_parser_set_option);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_parser_set_option", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xml_parser_set_option(arg0, arg1, arg2));
  }
}
Variant i_dom_document_schema_validate_file(CArrRef params) {
  FUNCTION_INJECTION(dom_document_schema_validate_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_schema_validate_file(arg0, arg1));
  }
}
Variant i_magicksetimageinterlacescheme(CArrRef params) {
  FUNCTION_INJECTION(magicksetimageinterlacescheme);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageinterlacescheme", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimageinterlacescheme(arg0, arg1));
  }
}
Variant i_dom_element_get_attribute_node(CArrRef params) {
  FUNCTION_INJECTION(dom_element_get_attribute_node);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute_node", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_get_attribute_node(arg0, arg1));
  }
}
Variant i_dom_document_create_cdatasection(CArrRef params) {
  FUNCTION_INJECTION(dom_document_create_cdatasection);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_cdatasection", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_create_cdatasection(arg0, arg1));
  }
}
Variant i_destroypixeliterator(CArrRef params) {
  FUNCTION_INJECTION(destroypixeliterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixeliterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixeliterator(arg0), null);
  }
}
Variant i_magicksetimagetype(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagetype", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagetype(arg0, arg1));
  }
}
Variant i_hphp_recursiveiteratoriterator_getinneriterator(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_getinneriterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_getinneriterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_getinneriterator(arg0));
  }
}
Variant i_date_sunrise(CArrRef params) {
  FUNCTION_INJECTION(date_sunrise);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunrise", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_date_sunrise(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_date_sunrise(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_date_sunrise(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_date_sunrise(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_date_sunrise(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_sunrise(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_magickgethomeurl(CArrRef params) {
  FUNCTION_INJECTION(magickgethomeurl);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgethomeurl", 0, 1);
  return (f_magickgethomeurl());
}
Variant i_mb_detect_encoding(CArrRef params) {
  FUNCTION_INJECTION(mb_detect_encoding);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_detect_encoding", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mb_detect_encoding(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mb_detect_encoding(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_detect_encoding(arg0, arg1, arg2));
  }
}
Variant i_wandhasexception(CArrRef params) {
  FUNCTION_INJECTION(wandhasexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandhasexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_wandhasexception(arg0));
  }
}
Variant i_error_reporting(CArrRef params) {
  FUNCTION_INJECTION(error_reporting);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("error_reporting", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_error_reporting());
    CVarRef arg0((ad->getValue(pos)));
    return (f_error_reporting(arg0));
  }
}
Variant i_imagepalettecopy(CArrRef params) {
  FUNCTION_INJECTION(imagepalettecopy);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepalettecopy", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepalettecopy(arg0, arg1), null);
  }
}
Variant i_hphp_splfileinfo_isexecutable(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_isexecutable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isexecutable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_isexecutable(arg0));
  }
}
Variant i_rename_function(CArrRef params) {
  FUNCTION_INJECTION(rename_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("rename_function", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rename_function(arg0, arg1));
  }
}
Variant i_gzcompress(CArrRef params) {
  FUNCTION_INJECTION(gzcompress);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzcompress", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzcompress(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzcompress(arg0, arg1));
  }
}
Variant i_gzeof(CArrRef params) {
  FUNCTION_INJECTION(gzeof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzeof", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gzeof(arg0));
  }
}
Variant i_bcadd(CArrRef params) {
  FUNCTION_INJECTION(bcadd);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcadd", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcadd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcadd(arg0, arg1, arg2));
  }
}
Variant i_curl_setopt(CArrRef params) {
  FUNCTION_INJECTION(curl_setopt);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("curl_setopt", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_setopt(arg0, arg1, arg2));
  }
}
Variant i_imagealphablending(CArrRef params) {
  FUNCTION_INJECTION(imagealphablending);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagealphablending", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagealphablending(arg0, arg1));
  }
}
Variant i_pixelgetmagenta(CArrRef params) {
  FUNCTION_INJECTION(pixelgetmagenta);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagenta", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetmagenta(arg0));
  }
}
Variant i_drawannotation(CArrRef params) {
  FUNCTION_INJECTION(drawannotation);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawannotation", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawannotation(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_getmypid(CArrRef params) {
  FUNCTION_INJECTION(getmypid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmypid", 0, 1);
  return (f_getmypid());
}
Variant i_magicksetimagedispose(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagedispose);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedispose", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagedispose(arg0, arg1));
  }
}
Variant i_drawsetfontsize(CArrRef params) {
  FUNCTION_INJECTION(drawsetfontsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontsize", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontsize(arg0, arg1), null);
  }
}
Variant i_gethostbyname(CArrRef params) {
  FUNCTION_INJECTION(gethostbyname);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_gethostbyname(arg0));
  }
}
Variant i_stream_wrapper_restore(CArrRef params) {
  FUNCTION_INJECTION(stream_wrapper_restore);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_restore", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stream_wrapper_restore(arg0));
  }
}
Variant i_magickgetimagecompression(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagecompression);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompression", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagecompression(arg0));
  }
}
Variant i_hphp_invoke_method(CArrRef params) {
  FUNCTION_INJECTION(hphp_invoke_method);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_invoke_method", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_invoke_method(arg0, arg1, arg2, arg3));
  }
}
Variant i_xbox_schedule_thread_reset(CArrRef params) {
  FUNCTION_INJECTION(xbox_schedule_thread_reset);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_schedule_thread_reset", 0, 1);
  return (f_xbox_schedule_thread_reset(), null);
}
Variant i_date_offset_get(CArrRef params) {
  FUNCTION_INJECTION(date_offset_get);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_offset_get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_offset_get(arg0));
  }
}
Variant i_pixelgetiteratorexception(CArrRef params) {
  FUNCTION_INJECTION(pixelgetiteratorexception);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexception", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetiteratorexception(arg0));
  }
}
Variant i_mysql_field_flags(CArrRef params) {
  FUNCTION_INJECTION(mysql_field_flags);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_flags", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_field_flags(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_field_flags(arg0, arg1));
  }
}
Variant i_linkinfo(CArrRef params) {
  FUNCTION_INJECTION(linkinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("linkinfo", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_linkinfo(arg0));
  }
}
Variant i_strchr(CArrRef params) {
  FUNCTION_INJECTION(strchr);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strchr", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strchr(arg0, arg1));
  }
}
Variant i_magickqueryformats(CArrRef params) {
  FUNCTION_INJECTION(magickqueryformats);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryformats", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryformats(arg0));
  }
}
Variant i_class_parents(CArrRef params) {
  FUNCTION_INJECTION(class_parents);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_parents", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_class_parents(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_class_parents(arg0, arg1));
  }
}
Variant i_date_time_set(CArrRef params) {
  FUNCTION_INJECTION(date_time_set);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_time_set", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_date_time_set(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_time_set(arg0, arg1, arg2, arg3), null);
  }
}
Variant i_iconv_strpos(CArrRef params) {
  FUNCTION_INJECTION(iconv_strpos);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_strpos", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iconv_strpos(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_iconv_strpos(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iconv_strpos(arg0, arg1, arg2, arg3));
  }
}
Variant i_i18n_loc_set_strength(CArrRef params) {
  FUNCTION_INJECTION(i18n_loc_set_strength);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_strength", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_i18n_loc_set_strength(arg0));
  }
}
Variant i_magickgetimagebordercolor(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagebordercolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebordercolor", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagebordercolor(arg0));
  }
}
Variant i_ob_end_clean(CArrRef params) {
  FUNCTION_INJECTION(ob_end_clean);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_clean", 0, 1);
  return (f_ob_end_clean());
}
Variant i_dom_document_savexml(CArrRef params) {
  FUNCTION_INJECTION(dom_document_savexml);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("dom_document_savexml", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dom_document_savexml(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_dom_document_savexml(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_savexml(arg0, arg1, arg2));
  }
}
Variant i_trigger_error(CArrRef params) {
  FUNCTION_INJECTION(trigger_error);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trigger_error", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_trigger_error(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_trigger_error(arg0, arg1));
  }
}
Variant i_pcntl_getpriority(CArrRef params) {
  FUNCTION_INJECTION(pcntl_getpriority);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("pcntl_getpriority", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_pcntl_getpriority());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_pcntl_getpriority(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pcntl_getpriority(arg0, arg1));
  }
}
Variant i_date_default_timezone_get(CArrRef params) {
  FUNCTION_INJECTION(date_default_timezone_get);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("date_default_timezone_get", 0, 1);
  return (f_date_default_timezone_get());
}
Variant i_strcmp(CArrRef params) {
  FUNCTION_INJECTION(strcmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcmp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strcmp(arg0, arg1));
  }
}
Variant i_hphp_recursivedirectoryiterator_haschildren(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursivedirectoryiterator_haschildren);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_haschildren", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursivedirectoryiterator_haschildren(arg0));
  }
}
Variant i_hphp_instanceof(CArrRef params) {
  FUNCTION_INJECTION(hphp_instanceof);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_instanceof", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_instanceof(arg0, arg1));
  }
}
Variant i_import_request_variables(CArrRef params) {
  FUNCTION_INJECTION(import_request_variables);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("import_request_variables", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_import_request_variables(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_import_request_variables(arg0, arg1));
  }
}
Variant i_magickgetpackagename(CArrRef params) {
  FUNCTION_INJECTION(magickgetpackagename);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetpackagename", 0, 1);
  return (f_magickgetpackagename());
}
Variant i_destroypixelwandarray(CArrRef params) {
  FUNCTION_INJECTION(destroypixelwandarray);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwandarray", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_destroypixelwandarray(arg0), null);
  }
}
Variant i_spliti(CArrRef params) {
  FUNCTION_INJECTION(spliti);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("spliti", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_spliti(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_spliti(arg0, arg1, arg2));
  }
}
Variant i_posix_setgid(CArrRef params) {
  FUNCTION_INJECTION(posix_setgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setgid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_setgid(arg0));
  }
}
Variant i_is_double(CArrRef params) {
  FUNCTION_INJECTION(is_double);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_double", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_double(arg0));
  }
}
Variant i_output_reset_rewrite_vars(CArrRef params) {
  FUNCTION_INJECTION(output_reset_rewrite_vars);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("output_reset_rewrite_vars", 0, 1);
  return (f_output_reset_rewrite_vars());
}
Variant i_get_declared_interfaces(CArrRef params) {
  FUNCTION_INJECTION(get_declared_interfaces);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_interfaces", 0, 1);
  return (f_get_declared_interfaces());
}
Variant i_passthru(CArrRef params) {
  FUNCTION_INJECTION(passthru);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("passthru", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_passthru(arg0), null);
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_passthru(arg0, arg1), null);
  }
}
Variant i_magickmontageimage(CArrRef params) {
  FUNCTION_INJECTION(magickmontageimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmontageimage", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmontageimage(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_session_commit(CArrRef params) {
  FUNCTION_INJECTION(session_commit);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_commit", 0, 1);
  return (f_session_commit(), null);
}
Variant i_apc_cache_info(CArrRef params) {
  FUNCTION_INJECTION(apc_cache_info);
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_cache_info", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_apc_cache_info());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (f_apc_cache_info(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_cache_info(arg0, arg1));
  }
}
Variant i_convert_cyr_string(CArrRef params) {
  FUNCTION_INJECTION(convert_cyr_string);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("convert_cyr_string", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_convert_cyr_string(arg0, arg1, arg2));
  }
}
Variant i_sys_get_temp_dir(CArrRef params) {
  FUNCTION_INJECTION(sys_get_temp_dir);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_get_temp_dir", 0, 1);
  return (f_sys_get_temp_dir());
}
Variant i_libxml_get_last_error(CArrRef params) {
  FUNCTION_INJECTION(libxml_get_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_last_error", 0, 1);
  return (f_libxml_get_last_error());
}
Variant i_drawline(CArrRef params) {
  FUNCTION_INJECTION(drawline);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawline", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawline(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant i_drawsetfillcolor(CArrRef params) {
  FUNCTION_INJECTION(drawsetfillcolor);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillcolor", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfillcolor(arg0, arg1), null);
  }
}
Variant i_gzopen(CArrRef params) {
  FUNCTION_INJECTION(gzopen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzopen", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzopen(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzopen(arg0, arg1, arg2));
  }
}
Variant i_getservbyport(CArrRef params) {
  FUNCTION_INJECTION(getservbyport);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyport", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_getservbyport(arg0, arg1));
  }
}
Variant i_hphp_splfileinfo_getfilename(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getfilename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getfilename", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_splfileinfo_getfilename(arg0));
  }
}
Variant i_stripcslashes(CArrRef params) {
  FUNCTION_INJECTION(stripcslashes);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripcslashes", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_stripcslashes(arg0));
  }
}
Variant i_curl_multi_add_handle(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_add_handle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_add_handle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_curl_multi_add_handle(arg0, arg1));
  }
}
Variant i_ldap_free_result(CArrRef params) {
  FUNCTION_INJECTION(ldap_free_result);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_free_result", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_ldap_free_result(arg0));
  }
}
Variant i_array_replace(CArrRef params) {
  FUNCTION_INJECTION(array_replace);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_replace(count, arg0));
    return (f_array_replace(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant i_xmlwriter_end_pi(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_end_pi);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_pi", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_end_pi(arg0));
  }
}
Variant i_imagewbmp(CArrRef params) {
  FUNCTION_INJECTION(imagewbmp);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagewbmp", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagewbmp(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagewbmp(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagewbmp(arg0, arg1, arg2));
  }
}
Variant i_shm_get_var(CArrRef params) {
  FUNCTION_INJECTION(shm_get_var);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_get_var", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_shm_get_var(arg0, arg1));
  }
}
Variant i_magickgetmimetype(CArrRef params) {
  FUNCTION_INJECTION(magickgetmimetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetmimetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetmimetype(arg0));
  }
}
Variant i_mysql_fetch_assoc(CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_assoc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_assoc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_fetch_assoc(arg0));
  }
}
Variant i_socket_set_nonblock(CArrRef params) {
  FUNCTION_INJECTION(socket_set_nonblock);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_nonblock", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_set_nonblock(arg0));
  }
}
Variant i_array_filter(CArrRef params) {
  FUNCTION_INJECTION(array_filter);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_filter", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_filter(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_filter(arg0, arg1));
  }
}
Variant i_mysql_query(CArrRef params) {
  FUNCTION_INJECTION(mysql_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_query", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_query(arg0, arg1));
  }
}
Variant i_crypt(CArrRef params) {
  FUNCTION_INJECTION(crypt);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("crypt", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_crypt(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_crypt(arg0, arg1));
  }
}
Variant i_xmlwriter_start_cdata(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_cdata);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_cdata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xmlwriter_start_cdata(arg0));
  }
}
Variant i_fgetc(CArrRef params) {
  FUNCTION_INJECTION(fgetc);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fgetc", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_fgetc(arg0));
  }
}
Variant i_move_uploaded_file(CArrRef params) {
  FUNCTION_INJECTION(move_uploaded_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("move_uploaded_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_move_uploaded_file(arg0, arg1));
  }
}
Variant i_hphp_splfileobject_flock(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileobject_flock);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_flock", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileobject_flock(arg0, arg1));
  }
}
Variant i_imagecopyresampled(CArrRef params) {
  FUNCTION_INJECTION(imagecopyresampled);
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresampled", count, 10, 10, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg9((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecopyresampled(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));
  }
}
Variant i_imagecreatefrompng(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefrompng);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefrompng", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefrompng(arg0));
  }
}
Variant i_magickgetimage(CArrRef params) {
  FUNCTION_INJECTION(magickgetimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimage(arg0));
  }
}
Variant i_imagesettile(CArrRef params) {
  FUNCTION_INJECTION(imagesettile);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesettile", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesettile(arg0, arg1));
  }
}
Variant i_hphp_recursiveiteratoriterator_valid(CArrRef params) {
  FUNCTION_INJECTION(hphp_recursiveiteratoriterator_valid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_valid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_recursiveiteratoriterator_valid(arg0));
  }
}
Variant i_fgets(CArrRef params) {
  FUNCTION_INJECTION(fgets);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("fgets", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_fgets(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fgets(arg0, arg1));
  }
}
Variant i_tempnam(CArrRef params) {
  FUNCTION_INJECTION(tempnam);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("tempnam", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_tempnam(arg0, arg1));
  }
}
Variant i_bcdiv(CArrRef params) {
  FUNCTION_INJECTION(bcdiv);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcdiv", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_bcdiv(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_bcdiv(arg0, arg1, arg2));
  }
}
Variant i_hphp_splfileinfo_getbasename(CArrRef params) {
  FUNCTION_INJECTION(hphp_splfileinfo_getbasename);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getbasename", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_splfileinfo_getbasename(arg0, arg1));
  }
}
Variant i_rsort(CArrRef params) {
  FUNCTION_INJECTION(rsort);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("rsort", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (f_rsort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_rsort(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rsort(arg0, arg1, arg2));
  }
}
Variant i_drawgettextdecoration(CArrRef params) {
  FUNCTION_INJECTION(drawgettextdecoration);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextdecoration", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextdecoration(arg0));
  }
}
Variant i_strtolower(CArrRef params) {
  FUNCTION_INJECTION(strtolower);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtolower", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strtolower(arg0));
  }
}
Variant i_posix_getgrgid(CArrRef params) {
  FUNCTION_INJECTION(posix_getgrgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrgid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getgrgid(arg0));
  }
}
Variant i_apc_inc(CArrRef params) {
  FUNCTION_INJECTION(apc_inc);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_inc", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_inc(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_inc(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_inc(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_inc(arg0, arg1, arg2, arg3));
  }
}
Variant i_hphp_create_object(CArrRef params) {
  FUNCTION_INJECTION(hphp_create_object);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_create_object", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_create_object(arg0, arg1));
  }
}
Variant i_hexdec(CArrRef params) {
  FUNCTION_INJECTION(hexdec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hexdec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hexdec(arg0));
  }
}
Variant i_imagefttext(CArrRef params) {
  FUNCTION_INJECTION(imagefttext);
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 9) return throw_wrong_arguments("imagefttext", count, 8, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 8) return (f_imagefttext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefttext(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant i_xhprof_sample_disable(CArrRef params) {
  FUNCTION_INJECTION(xhprof_sample_disable);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_disable", 0, 1);
  return (f_xhprof_sample_disable());
}
Variant i_ldap_compare(CArrRef params) {
  FUNCTION_INJECTION(ldap_compare);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("ldap_compare", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_ldap_compare(arg0, arg1, arg2, arg3));
  }
}
Variant i_dns_get_record(CArrRef params) {
  FUNCTION_INJECTION(dns_get_record);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("dns_get_record", count, 1, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dns_get_record(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_dns_get_record(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_dns_get_record(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_dns_get_record(arg0, arg1, arg2, arg3));
  }
}
Variant i_openssl_get_privatekey(CArrRef params) {
  FUNCTION_INJECTION(openssl_get_privatekey);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_get_privatekey", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_get_privatekey(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_get_privatekey(arg0, arg1));
  }
}
Variant i_imagepng(CArrRef params) {
  FUNCTION_INJECTION(imagepng);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagepng", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagepng(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagepng(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_imagepng(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagepng(arg0, arg1, arg2, arg3));
  }
}
Variant i_socket_bind(CArrRef params) {
  FUNCTION_INJECTION(socket_bind);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_bind", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_socket_bind(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_bind(arg0, arg1, arg2));
  }
}
Variant i_getmyuid(CArrRef params) {
  FUNCTION_INJECTION(getmyuid);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyuid", 0, 1);
  return (f_getmyuid());
}
Variant i_pixelgetopacity(CArrRef params) {
  FUNCTION_INJECTION(pixelgetopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacity", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetopacity(arg0));
  }
}
Variant i_drawsetstrokelinecap(CArrRef params) {
  FUNCTION_INJECTION(drawsetstrokelinecap);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinecap", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetstrokelinecap(arg0, arg1), null);
  }
}
Variant i_xmlwriter_write_attribute_ns(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_write_attribute_ns);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("xmlwriter_write_attribute_ns", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_write_attribute_ns(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_array_keys(CArrRef params) {
  FUNCTION_INJECTION(array_keys);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("array_keys", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_array_keys(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_array_keys(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_keys(arg0, arg1, arg2));
  }
}
Variant i_call_user_method_array(CArrRef params) {
  FUNCTION_INJECTION(call_user_method_array);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("call_user_method_array", count, 3, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_call_user_method_array(arg0, arg1, arg2));
  }
}
Variant i_magickmagnifyimage(CArrRef params) {
  FUNCTION_INJECTION(magickmagnifyimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmagnifyimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickmagnifyimage(arg0));
  }
}
Variant i_is_bool(CArrRef params) {
  FUNCTION_INJECTION(is_bool);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_bool", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_bool(arg0));
  }
}
Variant i_magickgetimagegreenprimary(CArrRef params) {
  FUNCTION_INJECTION(magickgetimagegreenprimary);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegreenprimary", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetimagegreenprimary(arg0));
  }
}
Variant i_session_start(CArrRef params) {
  FUNCTION_INJECTION(session_start);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_start", 0, 1);
  return (f_session_start());
}
Variant i_filegroup(CArrRef params) {
  FUNCTION_INJECTION(filegroup);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filegroup", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filegroup(arg0));
  }
}
Variant i_dom_attr_is_id(CArrRef params) {
  FUNCTION_INJECTION(dom_attr_is_id);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_attr_is_id", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_dom_attr_is_id(arg0));
  }
}
Variant i_gzread(CArrRef params) {
  FUNCTION_INJECTION(gzread);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzread", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzread(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzread(arg0, arg1));
  }
}
Variant i_drawpathellipticarcrelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathellipticarcrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcrelative", count, 8, 8, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathellipticarcrelative(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7), null);
  }
}
Variant i_openssl_csr_export_to_file(CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_export_to_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export_to_file", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_csr_export_to_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_export_to_file(arg0, arg1, arg2));
  }
}
Variant i_magicksetimagecolorspace(CArrRef params) {
  FUNCTION_INJECTION(magicksetimagecolorspace);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecolorspace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetimagecolorspace(arg0, arg1));
  }
}
Variant i_nl_langinfo(CArrRef params) {
  FUNCTION_INJECTION(nl_langinfo);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl_langinfo", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_nl_langinfo(arg0));
  }
}
Variant i_hphp_get_stats(CArrRef params) {
  FUNCTION_INJECTION(hphp_get_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_stats", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_hphp_get_stats(arg0));
  }
}
Variant i_strncmp(CArrRef params) {
  FUNCTION_INJECTION(strncmp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncmp", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_strncmp(arg0, arg1, arg2));
  }
}
Variant i_mb_regex_set_options(CArrRef params) {
  FUNCTION_INJECTION(mb_regex_set_options);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_set_options", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mb_regex_set_options());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mb_regex_set_options(arg0));
  }
}
Variant i_pixelsetmagenta(CArrRef params) {
  FUNCTION_INJECTION(pixelsetmagenta);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagenta", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetmagenta(arg0, arg1), null);
  }
}
Variant i_dom_element_remove_attribute(CArrRef params) {
  FUNCTION_INJECTION(dom_element_remove_attribute);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_element_remove_attribute(arg0, arg1));
  }
}
Variant i_magickdeconstructimages(CArrRef params) {
  FUNCTION_INJECTION(magickdeconstructimages);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdeconstructimages", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickdeconstructimages(arg0));
  }
}
Variant i_xbox_task_status(CArrRef params) {
  FUNCTION_INJECTION(xbox_task_status);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_status", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xbox_task_status(arg0));
  }
}
Variant i_openssl_open(CArrRef params) {
  FUNCTION_INJECTION(openssl_open);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_open", count, 4, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_open(arg0, arg1, arg2, arg3));
  }
}
Variant i_apc_bin_load(CArrRef params) {
  FUNCTION_INJECTION(apc_bin_load);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_bin_load", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_apc_bin_load(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_apc_bin_load(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_bin_load(arg0, arg1, arg2));
  }
}
Variant i_current(CArrRef params) {
  FUNCTION_INJECTION(current);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("current", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (f_current(arg0));
  }
}
Variant i_stream_register_wrapper(CArrRef params) {
  FUNCTION_INJECTION(stream_register_wrapper);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_register_wrapper", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_stream_register_wrapper(arg0, arg1));
  }
}
Variant i_hphp_stats(CArrRef params) {
  FUNCTION_INJECTION(hphp_stats);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_stats", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_hphp_stats(arg0, arg1), null);
  }
}
Variant i_opendir(CArrRef params) {
  FUNCTION_INJECTION(opendir);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("opendir", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_opendir(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_opendir(arg0, arg1));
  }
}
Variant i_magickgetexceptionstring(CArrRef params) {
  FUNCTION_INJECTION(magickgetexceptionstring);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptionstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickgetexceptionstring(arg0));
  }
}
Variant i_mcrypt_module_is_block_algorithm_mode(CArrRef params) {
  FUNCTION_INJECTION(mcrypt_module_is_block_algorithm_mode);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm_mode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mcrypt_module_is_block_algorithm_mode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mcrypt_module_is_block_algorithm_mode(arg0, arg1));
  }
}
Variant i_posix_setpgid(CArrRef params) {
  FUNCTION_INJECTION(posix_setpgid);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_setpgid", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_posix_setpgid(arg0, arg1));
  }
}
Variant i_dns_get_mx(CArrRef params) {
  FUNCTION_INJECTION(dns_get_mx);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dns_get_mx", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_dns_get_mx(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_dns_get_mx(arg0, arg1, arg2));
  }
}
Variant i_headers_list(CArrRef params) {
  FUNCTION_INJECTION(headers_list);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("headers_list", 0, 1);
  return (f_headers_list());
}
Variant i_escapeshellarg(CArrRef params) {
  FUNCTION_INJECTION(escapeshellarg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellarg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_escapeshellarg(arg0));
  }
}
Variant i_is_scalar(CArrRef params) {
  FUNCTION_INJECTION(is_scalar);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_scalar", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_scalar(arg0));
  }
}
Variant i_acos(CArrRef params) {
  FUNCTION_INJECTION(acos);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acos", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_acos(arg0));
  }
}
Variant i_drawgettextencoding(CArrRef params) {
  FUNCTION_INJECTION(drawgettextencoding);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextencoding", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_drawgettextencoding(arg0));
  }
}
Variant i_filetype(CArrRef params) {
  FUNCTION_INJECTION(filetype);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filetype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_filetype(arg0));
  }
}
Variant i_magicksetresolution(CArrRef params) {
  FUNCTION_INJECTION(magicksetresolution);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetresolution", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetresolution(arg0, arg1, arg2));
  }
}
Variant i_posix_isatty(CArrRef params) {
  FUNCTION_INJECTION(posix_isatty);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_isatty", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_isatty(arg0));
  }
}
Variant i_dom_document_relaxng_validate_file(CArrRef params) {
  FUNCTION_INJECTION(dom_document_relaxng_validate_file);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_file", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dom_document_relaxng_validate_file(arg0, arg1));
  }
}
Variant i_escapeshellcmd(CArrRef params) {
  FUNCTION_INJECTION(escapeshellcmd);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellcmd", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_escapeshellcmd(arg0));
  }
}
Variant i_apc_store(CArrRef params) {
  FUNCTION_INJECTION(apc_store);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_store", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_apc_store(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_apc_store(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_apc_store(arg0, arg1, arg2, arg3));
  }
}
Variant i_magickresetiterator(CArrRef params) {
  FUNCTION_INJECTION(magickresetiterator);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickresetiterator", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickresetiterator(arg0), null);
  }
}
Variant i_libxml_disable_entity_loader(CArrRef params) {
  FUNCTION_INJECTION(libxml_disable_entity_loader);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_disable_entity_loader", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_libxml_disable_entity_loader());
    CVarRef arg0((ad->getValue(pos)));
    return (f_libxml_disable_entity_loader(arg0));
  }
}
Variant i_apache_lookup_uri(CArrRef params) {
  FUNCTION_INJECTION(apache_lookup_uri);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("apache_lookup_uri", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_apache_lookup_uri(arg0));
  }
}
Variant i_magickmotionblurimage(CArrRef params) {
  FUNCTION_INJECTION(magickmotionblurimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmotionblurimage", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickmotionblurimage(arg0, arg1, arg2, arg3));
  }
}
Variant i_session_cache_expire(CArrRef params) {
  FUNCTION_INJECTION(session_cache_expire);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_expire", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_cache_expire());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_cache_expire(arg0));
  }
}
Variant i_magicksetwandsize(CArrRef params) {
  FUNCTION_INJECTION(magicksetwandsize);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetwandsize", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicksetwandsize(arg0, arg1, arg2));
  }
}
Variant i_number_format(CArrRef params) {
  FUNCTION_INJECTION(number_format);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("number_format", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_number_format(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_number_format(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_number_format(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_number_format(arg0, arg1, arg2, arg3));
  }
}
Variant i_array_reduce(CArrRef params) {
  FUNCTION_INJECTION(array_reduce);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_reduce", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_array_reduce(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_array_reduce(arg0, arg1, arg2));
  }
}
Variant i_xmlwriter_start_dtd_attlist(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_start_dtd_attlist);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_attlist", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_start_dtd_attlist(arg0, arg1));
  }
}
Variant i_constant(CArrRef params) {
  FUNCTION_INJECTION(constant);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("constant", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_constant(arg0));
  }
}
Variant i_strlen(CArrRef params) {
  FUNCTION_INJECTION(strlen);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strlen", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_strlen(arg0));
  }
}
Variant i_srand(CArrRef params) {
  FUNCTION_INJECTION(srand);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("srand", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_srand(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (f_srand(arg0), null);
  }
}
Variant i_mysql_fetch_object(CArrRef params) {
  FUNCTION_INJECTION(mysql_fetch_object);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mysql_fetch_object", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_mysql_fetch_object(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_mysql_fetch_object(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_fetch_object(arg0, arg1, arg2));
  }
}
Variant i_drawpathlinetoverticalrelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathlinetoverticalrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalrelative", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathlinetoverticalrelative(arg0, arg1), null);
  }
}
Variant i_magickminifyimage(CArrRef params) {
  FUNCTION_INJECTION(magickminifyimage);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickminifyimage", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickminifyimage(arg0));
  }
}
Variant i_date_sunset(CArrRef params) {
  FUNCTION_INJECTION(date_sunset);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunset", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_date_sunset(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_date_sunset(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_date_sunset(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_date_sunset(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (f_date_sunset(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_date_sunset(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_symlink(CArrRef params) {
  FUNCTION_INJECTION(symlink);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("symlink", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_symlink(arg0, arg1));
  }
}
Variant i_imagesetpixel(CArrRef params) {
  FUNCTION_INJECTION(imagesetpixel);
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagesetpixel", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagesetpixel(arg0, arg1, arg2, arg3));
  }
}
Variant i_session_module_name(CArrRef params) {
  FUNCTION_INJECTION(session_module_name);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_module_name", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_session_module_name());
    CVarRef arg0((ad->getValue(pos)));
    return (f_session_module_name(arg0));
  }
}
Variant i_split(CArrRef params) {
  FUNCTION_INJECTION(split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("split", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_split(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_split(arg0, arg1, arg2));
  }
}
Variant i_drawsetfontstyle(CArrRef params) {
  FUNCTION_INJECTION(drawsetfontstyle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstyle", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawsetfontstyle(arg0, arg1), null);
  }
}
Variant i_imagecreatefromxbm(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromxbm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxbm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromxbm(arg0));
  }
}
Variant i_mysql_db_query(CArrRef params) {
  FUNCTION_INJECTION(mysql_db_query);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_query", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mysql_db_query(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mysql_db_query(arg0, arg1, arg2));
  }
}
Variant i_imagecolorclosestalpha(CArrRef params) {
  FUNCTION_INJECTION(imagecolorclosestalpha);
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorclosestalpha", count, 5, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagecolorclosestalpha(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_gzuncompress(CArrRef params) {
  FUNCTION_INJECTION(gzuncompress);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzuncompress", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzuncompress(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzuncompress(arg0, arg1));
  }
}
Variant i_is_executable(CArrRef params) {
  FUNCTION_INJECTION(is_executable);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_executable", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_executable(arg0));
  }
}
Variant i_socket_create_listen(CArrRef params) {
  FUNCTION_INJECTION(socket_create_listen);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_create_listen", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_socket_create_listen(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_socket_create_listen(arg0, arg1));
  }
}
Variant i_pixelgetcolorcount(CArrRef params) {
  FUNCTION_INJECTION(pixelgetcolorcount);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorcount", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_pixelgetcolorcount(arg0));
  }
}
Variant i_magickqueryconfigureoptions(CArrRef params) {
  FUNCTION_INJECTION(magickqueryconfigureoptions);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoptions", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_magickqueryconfigureoptions(arg0));
  }
}
Variant i_iptcembed(CArrRef params) {
  FUNCTION_INJECTION(iptcembed);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iptcembed", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_iptcembed(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_iptcembed(arg0, arg1, arg2));
  }
}
Variant i_posix_getgrnam(CArrRef params) {
  FUNCTION_INJECTION(posix_getgrnam);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrnam", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_posix_getgrnam(arg0));
  }
}
Variant i_rtrim(CArrRef params) {
  FUNCTION_INJECTION(rtrim);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rtrim", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_rtrim(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_rtrim(arg0, arg1));
  }
}
Variant i_print_r(CArrRef params) {
  FUNCTION_INJECTION(print_r);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("print_r", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_print_r(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_print_r(arg0, arg1));
  }
}
Variant i_drawpathcurvetoquadraticbeziersmoothrelative(CArrRef params) {
  FUNCTION_INJECTION(drawpathcurvetoquadraticbeziersmoothrelative);
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothrelative", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpathcurvetoquadraticbeziersmoothrelative(arg0, arg1, arg2), null);
  }
}
Variant i_openssl_pkey_export(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_export);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_openssl_pkey_export(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_openssl_pkey_export(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_pkey_export(arg0, arg1, arg2, arg3));
  }
}
Variant i_abs(CArrRef params) {
  FUNCTION_INJECTION(abs);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("abs", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_abs(arg0));
  }
}
Variant i_restore_exception_handler(CArrRef params) {
  FUNCTION_INJECTION(restore_exception_handler);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_exception_handler", 0, 1);
  return (f_restore_exception_handler());
}
Variant i_shell_exec(CArrRef params) {
  FUNCTION_INJECTION(shell_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shell_exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_shell_exec(arg0));
  }
}
Variant i_curl_multi_exec(CArrRef params) {
  FUNCTION_INJECTION(curl_multi_exec);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_exec", count, 2, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (f_curl_multi_exec(arg0, arg1));
  }
}
Variant i_htmlspecialchars(CArrRef params) {
  FUNCTION_INJECTION(htmlspecialchars);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlspecialchars", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_htmlspecialchars(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_htmlspecialchars(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_htmlspecialchars(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_htmlspecialchars(arg0, arg1, arg2, arg3));
  }
}
Variant i_imagexbm(CArrRef params) {
  FUNCTION_INJECTION(imagexbm);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagexbm", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_imagexbm(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_imagexbm(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagexbm(arg0, arg1, arg2));
  }
}
Variant i_magickgetreleasedate(CArrRef params) {
  FUNCTION_INJECTION(magickgetreleasedate);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetreleasedate", 0, 1);
  return (f_magickgetreleasedate());
}
Variant i_xbox_set_thread_timeout(CArrRef params) {
  FUNCTION_INJECTION(xbox_set_thread_timeout);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_set_thread_timeout", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_xbox_set_thread_timeout(arg0), null);
  }
}
Variant i_sem_remove(CArrRef params) {
  FUNCTION_INJECTION(sem_remove);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_remove", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_sem_remove(arg0));
  }
}
Variant i_imageellipse(CArrRef params) {
  FUNCTION_INJECTION(imageellipse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageellipse", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imageellipse(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_getprotobynumber(CArrRef params) {
  FUNCTION_INJECTION(getprotobynumber);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobynumber", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_getprotobynumber(arg0));
  }
}
Variant i_pixelsetopacity(CArrRef params) {
  FUNCTION_INJECTION(pixelsetopacity);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_pixelsetopacity(arg0, arg1), null);
  }
}
Variant i_lchgrp(CArrRef params) {
  FUNCTION_INJECTION(lchgrp);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchgrp", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_lchgrp(arg0, arg1));
  }
}
Variant i_simplexml_load_file(CArrRef params) {
  FUNCTION_INJECTION(simplexml_load_file);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_file", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_simplexml_load_file(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_simplexml_load_file(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (f_simplexml_load_file(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (f_simplexml_load_file(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_simplexml_load_file(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant i_openssl_pkey_get_details(CArrRef params) {
  FUNCTION_INJECTION(openssl_pkey_get_details);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_details", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_openssl_pkey_get_details(arg0));
  }
}
Variant i_imagetypes(CArrRef params) {
  FUNCTION_INJECTION(imagetypes);
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagetypes", 0, 1);
  return (f_imagetypes());
}
Variant i_gzseek(CArrRef params) {
  FUNCTION_INJECTION(gzseek);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzseek", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_gzseek(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzseek(arg0, arg1, arg2));
  }
}
Variant i_magickgetmaxtextadvance(CArrRef params) {
  FUNCTION_INJECTION(magickgetmaxtextadvance);
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetmaxtextadvance", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (f_magickgetmaxtextadvance(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magickgetmaxtextadvance(arg0, arg1, arg2, arg3));
  }
}
Variant i_func_get_arg(CArrRef params) {
  FUNCTION_INJECTION(func_get_arg);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("func_get_arg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_func_get_arg(arg0));
  }
}
Variant i_imagefilledrectangle(CArrRef params) {
  FUNCTION_INJECTION(imagefilledrectangle);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledrectangle", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_imagefilledrectangle(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant i_drawpushpattern(CArrRef params) {
  FUNCTION_INJECTION(drawpushpattern);
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("drawpushpattern", count, 6, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_drawpushpattern(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant i_xmlwriter_set_indent(CArrRef params) {
  FUNCTION_INJECTION(xmlwriter_set_indent);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_xmlwriter_set_indent(arg0, arg1));
  }
}
Variant i_openssl_csr_get_subject(CArrRef params) {
  FUNCTION_INJECTION(openssl_csr_get_subject);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_csr_get_subject", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_openssl_csr_get_subject(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_openssl_csr_get_subject(arg0, arg1));
  }
}
Variant i_is_numeric(CArrRef params) {
  FUNCTION_INJECTION(is_numeric);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_numeric", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_is_numeric(arg0));
  }
}
Variant i_gzdeflate(CArrRef params) {
  FUNCTION_INJECTION(gzdeflate);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzdeflate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_gzdeflate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_gzdeflate(arg0, arg1));
  }
}
Variant i_dns_check_record(CArrRef params) {
  FUNCTION_INJECTION(dns_check_record);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dns_check_record", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_dns_check_record(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_dns_check_record(arg0, arg1));
  }
}
Variant i_magicknegateimage(CArrRef params) {
  FUNCTION_INJECTION(magicknegateimage);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magicknegateimage", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_magicknegateimage(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (f_magicknegateimage(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_magicknegateimage(arg0, arg1, arg2));
  }
}
Variant i_socket_last_error(CArrRef params) {
  FUNCTION_INJECTION(socket_last_error);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_last_error", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_socket_last_error());
    CVarRef arg0((ad->getValue(pos)));
    return (f_socket_last_error(arg0));
  }
}
Variant i_create_function(CArrRef params) {
  FUNCTION_INJECTION(create_function);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("create_function", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_create_function(arg0, arg1));
  }
}
Variant i_str_split(CArrRef params) {
  FUNCTION_INJECTION(str_split);
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("str_split", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (f_str_split(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_str_split(arg0, arg1));
  }
}
Variant i_date_parse(CArrRef params) {
  FUNCTION_INJECTION(date_parse);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_parse", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_date_parse(arg0));
  }
}
Variant i_imagecreatefromxpm(CArrRef params) {
  FUNCTION_INJECTION(imagecreatefromxpm);
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxpm", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (f_imagecreatefromxpm(arg0));
  }
}
Variant i_mysql_thread_id(CArrRef params) {
  FUNCTION_INJECTION(mysql_thread_id);
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_thread_id", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (f_mysql_thread_id());
    CVarRef arg0((ad->getValue(pos)));
    return (f_mysql_thread_id(arg0));
  }
}
Variant i_mb_encode_numericentity(CArrRef params) {
  FUNCTION_INJECTION(mb_encode_numericentity);
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_encode_numericentity", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (f_mb_encode_numericentity(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_mb_encode_numericentity(arg0, arg1, arg2));
  }
}
Variant i_fb_call_user_func_array_safe(CArrRef params) {
  FUNCTION_INJECTION(fb_call_user_func_array_safe);
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_call_user_func_array_safe", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (f_fb_call_user_func_array_safe(arg0, arg1));
  }
}
Variant invoke_builtin(const char *s, CArrRef params, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 4095) {
    case 1:
      HASH_INVOKE(0x4F7230DC25F0E001LL, magicknormalizeimage);
      break;
    case 2:
      HASH_INVOKE(0x76C320EDB9B6E002LL, xmlwriter_flush);
      break;
    case 3:
      HASH_INVOKE(0x7E0EC3E131BCA003LL, token_name);
      break;
    case 5:
      HASH_INVOKE(0x20D579E7E4131005LL, imagecolorclosest);
      HASH_INVOKE(0x18A0F1EE8E249005LL, msg_send);
      break;
    case 10:
      HASH_INVOKE(0x555D7A3FB939300ALL, apache_setenv);
      break;
    case 11:
      HASH_INVOKE(0x4FDCCE1C7754600BLL, ob_iconv_handler);
      break;
    case 13:
      HASH_INVOKE(0x40FA17130FA7100DLL, openssl_seal);
      break;
    case 22:
      HASH_INVOKE(0x5623A698A728F016LL, getlastmod);
      break;
    case 24:
      HASH_INVOKE(0x4C915E3480E94018LL, mb_substr_count);
      break;
    case 26:
      HASH_INVOKE(0x03834225EBBC101ALL, drawsettextundercolor);
      break;
    case 34:
      HASH_INVOKE(0x145D42B2AB55D022LL, drawmatte);
      break;
    case 35:
      HASH_INVOKE(0x35C74650867B7023LL, imagesetpixel);
      break;
    case 40:
      HASH_INVOKE(0x601C5152277AE028LL, readfile);
      break;
    case 44:
      HASH_INVOKE(0x464EB9B1F955202CLL, apc_add);
      break;
    case 45:
      HASH_INVOKE(0x3BE730D90618202DLL, collator_sort_with_sort_keys);
      break;
    case 51:
      HASH_INVOKE(0x48F35DFD653D7033LL, pclose);
      break;
    case 54:
      HASH_INVOKE(0x32F23F206C394036LL, curl_setopt_array);
      break;
    case 55:
      HASH_INVOKE(0x418D937957ECE037LL, tanh);
      break;
    case 59:
      HASH_INVOKE(0x40329F2A6B84D03BLL, dom_node_lookup_prefix);
      break;
    case 62:
      HASH_INVOKE(0x32E6E5D3CCE3703ELL, magickgetimagewidth);
      HASH_INVOKE(0x43461C4D9130103ELL, exit);
      HASH_INVOKE(0x67C1ED9B816E503ELL, md5_file);
      HASH_INVOKE(0x497E31C70409603ELL, timezone_name_from_abbr);
      break;
    case 63:
      HASH_INVOKE(0x24206A195B9C203FLL, ucfirst);
      break;
    case 65:
      HASH_INVOKE(0x65B39B11F5D7C041LL, array_unique);
      break;
    case 67:
      HASH_INVOKE(0x5ACCF9166CD9D043LL, ftruncate);
      break;
    case 68:
      HASH_INVOKE(0x378A73FF98B60044LL, curl_init);
      break;
    case 73:
      HASH_INVOKE(0x047A8BF04DB51049LL, range);
      HASH_INVOKE(0x4282E0231F600049LL, fseek);
      break;
    case 75:
      HASH_INVOKE(0x17CD0E68E778C04BLL, drawsetstrokelinejoin);
      HASH_INVOKE(0x6370CF455EA8604BLL, socket_create);
      break;
    case 76:
      HASH_INVOKE(0x7848970191D5A04CLL, mysql_connect_with_db);
      HASH_INVOKE(0x03047FD5FC67204CLL, exif_read_data);
      break;
    case 83:
      HASH_INVOKE(0x15A9EB33DA6E9053LL, getimagesize);
      HASH_INVOKE(0x07EB5C3A3BEA3053LL, acosh);
      break;
    case 87:
      HASH_INVOKE(0x12B22A2E6B344057LL, ldap_sort);
      break;
    case 90:
      HASH_INVOKE(0x271AB768D202F05ALL, mcrypt_module_is_block_algorithm);
      break;
    case 92:
      HASH_INVOKE(0x2B7532A070BF605CLL, openssl_get_privatekey);
      break;
    case 95:
      HASH_INVOKE(0x4B70746F965E705FLL, preg_last_error);
      break;
    case 98:
      HASH_INVOKE(0x745910AD5C922062LL, magickgetmimetype);
      break;
    case 100:
      HASH_INVOKE(0x5CC8BA5ADFAC0064LL, imagegrabscreen);
      break;
    case 101:
      HASH_INVOKE(0x777FE52584FAE065LL, apc_bin_dump);
      break;
    case 103:
      HASH_INVOKE(0x0CE1918B30DF5067LL, sys_getloadavg);
      HASH_INVOKE(0x4512BD5EA7076067LL, openssl_csr_export_to_file);
      break;
    case 111:
      HASH_INVOKE(0x4C6FD8808A62506FLL, session_set_save_handler);
      break;
    case 112:
      HASH_INVOKE(0x3C466098FF7B5070LL, mb_check_encoding);
      break;
    case 120:
      HASH_INVOKE(0x6B268C26E21C1078LL, arsort);
      HASH_INVOKE(0x01AE1DE8FA116078LL, call_user_func_array_async);
      break;
    case 121:
      HASH_INVOKE(0x08AA4EA901C9B079LL, session_encode);
      break;
    case 122:
      HASH_INVOKE(0x5F9DDC342A83807ALL, date_default_timezone_get);
      break;
    case 131:
      HASH_INVOKE(0x1A90213EE1A56083LL, array_pop);
      break;
    case 132:
      HASH_INVOKE(0x53FD8C9AC3F4D084LL, dangling_server_proxy_new_request);
      break;
    case 135:
      HASH_INVOKE(0x255D919D501C5087LL, dom_characterdata_delete_data);
      break;
    case 137:
      HASH_INVOKE(0x4AD554CBAB9CC089LL, call_user_method_array);
      break;
    case 140:
      HASH_INVOKE(0x4F1D1ED7B087208CLL, exec);
      HASH_INVOKE(0x3A0B58797E8FE08CLL, xml_set_external_entity_ref_handler);
      break;
    case 141:
      HASH_INVOKE(0x200864F8F053C08DLL, magickgetversionstring);
      break;
    case 142:
      HASH_INVOKE(0x3E4AE974AFA9708ELL, pixelsetquantumcolor);
      break;
    case 145:
      HASH_INVOKE(0x3E5CF6378A49C091LL, ldap_get_attributes);
      HASH_INVOKE(0x673B36244DC87091LL, closelog);
      HASH_INVOKE(0x1C32BB63986C8091LL, socket_strerror);
      break;
    case 147:
      HASH_INVOKE(0x3B5E32078E37A093LL, imagedestroy);
      break;
    case 158:
      HASH_INVOKE(0x4AF87BA91163D09ELL, mysql_db_name);
      HASH_INVOKE(0x74F0D6D8F1F2709ELL, drawsetstrokedashoffset);
      break;
    case 159:
      HASH_INVOKE(0x2B130322DEC4B09FLL, pixelgetopacityquantum);
      break;
    case 161:
      HASH_INVOKE(0x0DF945F12533F0A1LL, abs);
      break;
    case 162:
      HASH_INVOKE(0x10DF7941C3F3E0A2LL, socket_bind);
      break;
    case 163:
      HASH_INVOKE(0x54242D2846BC60A3LL, magickunsharpmaskimage);
      break;
    case 167:
      HASH_INVOKE(0x74C787060F7290A7LL, icu_transliterate);
      break;
    case 168:
      HASH_INVOKE(0x6E8C61326DCE40A8LL, var_export);
      break;
    case 171:
      HASH_INVOKE(0x439DF153FC32D0ABLL, printf);
      HASH_INVOKE(0x5B1D9F56698A40ABLL, html_entity_decode);
      break;
    case 172:
      HASH_INVOKE(0x6E27DC1E74C5B0ACLL, drawpathstart);
      break;
    case 173:
      HASH_INVOKE(0x4C9252FB9C3300ADLL, pixelsetalphaquantum);
      break;
    case 174:
      HASH_INVOKE(0x47AB4A08446BD0AELL, bcmod);
      HASH_INVOKE(0x4BBD5D8A6E0110AELL, error_log);
      break;
    case 175:
      HASH_INVOKE(0x3954FFED1E0650AFLL, stream_register_wrapper);
      break;
    case 176:
      HASH_INVOKE(0x5B9F8B3E1D8330B0LL, stream_socket_sendto);
      break;
    case 177:
      HASH_INVOKE(0x191B5F1B190BC0B1LL, dom_xpath_register_ns);
      break;
    case 178:
      HASH_INVOKE(0x48BBFB59FB7F90B2LL, iconv_strlen);
      break;
    case 184:
      HASH_INVOKE(0x05A4C165810A30B8LL, gzread);
      break;
    case 185:
      HASH_INVOKE(0x5C659372B2CD80B9LL, imagecolorstotal);
      break;
    case 187:
      HASH_INVOKE(0x331E7DFBE6E240BBLL, libxml_get_errors);
      break;
    case 188:
      HASH_INVOKE(0x3900350CD9D990BCLL, imagecreatefromjpeg);
      break;
    case 192:
      HASH_INVOKE(0x6EDC1E7A8D5710C0LL, memcache_add_server);
      break;
    case 197:
      HASH_INVOKE(0x7424946F7ED520C5LL, magickgetimagefilename);
      HASH_INVOKE(0x6B477F3B9CDB10C5LL, base64_decode);
      break;
    case 199:
      HASH_INVOKE(0x677F33E78342A0C7LL, function_exists);
      break;
    case 200:
      HASH_INVOKE(0x30AB38D851C440C8LL, magickgetimagebackgroundcolor);
      break;
    case 202:
      HASH_INVOKE(0x2EE0967F6EB5A0CALL, date_format);
      HASH_INVOKE(0x4C67DEE74080E0CALL, magicksetimagecompose);
      break;
    case 206:
      HASH_INVOKE(0x64E390E5F2FDC0CELL, ismagickwand);
      break;
    case 210:
      HASH_INVOKE(0x7D1FAF3322A360D2LL, hphp_splfileobject___construct);
      HASH_INVOKE(0x5365BD7509BE60D2LL, ldap_dn2ufn);
      HASH_INVOKE(0x3E4DAD592CD0A0D2LL, magickdescribeimage);
      break;
    case 213:
      HASH_INVOKE(0x3BF44C6DECD790D5LL, xmlwriter_start_dtd_entity);
      break;
    case 216:
      HASH_INVOKE(0x79F2E516A3B070D8LL, libxml_disable_entity_loader);
      break;
    case 217:
      HASH_INVOKE(0x08F6B727D60670D9LL, magicksetimagedepth);
      break;
    case 218:
      HASH_INVOKE(0x6F242340B2E930DALL, hphp_splfileinfo_setfileclass);
      break;
    case 219:
      HASH_INVOKE(0x3801923AD84670DBLL, apc_inc);
      break;
    case 224:
      HASH_INVOKE(0x2E4612DF112010E0LL, imagecopyresized);
      break;
    case 228:
      HASH_INVOKE(0x2B9425038D4230E4LL, imagecreatefromxpm);
      break;
    case 231:
      HASH_INVOKE(0x79E6FD78989B10E7LL, tmpfile);
      HASH_INVOKE(0x59DE3A26AFF570E7LL, magickshaveimage);
      break;
    case 232:
      HASH_INVOKE(0x476F4B6CC987E0E8LL, magickframeimage);
      HASH_INVOKE(0x17CB328F55FDF0E8LL, drawsetstrokeantialias);
      break;
    case 234:
      HASH_INVOKE(0x53BA3992F8C240EALL, imagegrabwindow);
      break;
    case 243:
      HASH_INVOKE(0x315CCBC8C5C7D0F3LL, xmlwriter_write_raw);
      break;
    case 249:
      HASH_INVOKE(0x480797DB7165A0F9LL, xmlwriter_set_indent);
      break;
    case 259:
      HASH_INVOKE(0x1FFCBCF1927D7103LL, posix_setpgid);
      break;
    case 261:
      HASH_INVOKE(0x71E3372AA1AD0105LL, is_infinite);
      HASH_INVOKE(0x509B763CDAD9D105LL, gethostbyaddr);
      break;
    case 264:
      HASH_INVOKE(0x60B8B61133F59108LL, quoted_printable_decode);
      break;
    case 267:
      HASH_INVOKE(0x7DE1BEE0C35D010BLL, pcntl_signal);
      break;
    case 272:
      HASH_INVOKE(0x16B481D0DEA32110LL, call_user_func_async);
      break;
    case 273:
      HASH_INVOKE(0x3A9A5D4FEE79A111LL, getmxrr);
      break;
    case 274:
      HASH_INVOKE(0x0B1BA48B0CFB1112LL, strval);
      HASH_INVOKE(0x28C44527BD59D112LL, is_link);
      break;
    case 276:
      HASH_INVOKE(0x02A4724E6A881114LL, mb_decode_numericentity);
      break;
    case 281:
      HASH_INVOKE(0x3AB82455A70F5119LL, imagecolortransparent);
      HASH_INVOKE(0x2B31A877824A1119LL, stristr);
      break;
    case 284:
      HASH_INVOKE(0x070A63F6A0B8711CLL, array_walk_recursive);
      break;
    case 285:
      HASH_INVOKE(0x291088666B8BF11DLL, drawsetfontfamily);
      break;
    case 286:
      HASH_INVOKE(0x658444BB4E29E11ELL, openssl_free_key);
      break;
    case 287:
      HASH_INVOKE(0x4C70C24C84F5511FLL, magicksetimagegamma);
      break;
    case 291:
      HASH_INVOKE(0x3669138315204123LL, mcrypt_module_get_algo_key_size);
      break;
    case 292:
      HASH_INVOKE(0x7D4D28D561392124LL, drawsettextalignment);
      break;
    case 293:
      HASH_INVOKE(0x7A8B3EC0235EF125LL, magickprofileimage);
      break;
    case 301:
      HASH_INVOKE(0x7579DBE83CE5812DLL, imagerectangle);
      break;
    case 307:
      HASH_INVOKE(0x6A7E0B15FF689133LL, mb_ereg_search_init);
      break;
    case 311:
      HASH_INVOKE(0x5666016FA3C0F137LL, socket_clear_error);
      break;
    case 312:
      HASH_INVOKE(0x2676902697E37138LL, xmlwriter_start_comment);
      break;
    case 314:
      HASH_INVOKE(0x2A57E5D29D73D13ALL, register_tick_function);
      break;
    case 315:
      HASH_INVOKE(0x1F61AFCDC510413BLL, imagefilter);
      break;
    case 319:
      HASH_INVOKE(0x5BFDE63106CE713FLL, dom_element_get_attribute);
      break;
    case 323:
      HASH_INVOKE(0x296C739F28D6C143LL, drawsetfontsize);
      break;
    case 335:
      HASH_INVOKE(0x61A61E91C477514FLL, chop);
      HASH_INVOKE(0x7863294A8F33D14FLL, file);
      break;
    case 337:
      HASH_INVOKE(0x3044E9F91628E151LL, mb_strlen);
      break;
    case 338:
      HASH_INVOKE(0x5D170BCBBBA02152LL, system);
      HASH_INVOKE(0x26DD46D8C1F47152LL, ldap_bind);
      break;
    case 341:
      HASH_INVOKE(0x2623917110168155LL, fclose);
      HASH_INVOKE(0x4F43FE32079C0155LL, magickgetimagesblob);
      break;
    case 347:
      HASH_INVOKE(0x3711AF36391EA15BLL, mysql_list_tables);
      break;
    case 348:
      HASH_INVOKE(0x6CD7466174B9A15CLL, pixelsetredquantum);
      break;
    case 349:
      HASH_INVOKE(0x517941D034E3015DLL, iterator_to_array);
      break;
    case 353:
      HASH_INVOKE(0x309E780586D6C161LL, socket_set_nonblock);
      break;
    case 355:
      HASH_INVOKE(0x36D6B73D289DD163LL, date_sunset);
      break;
    case 360:
      HASH_INVOKE(0x14E46EA3CBCFB168LL, magickgetsamplingfactors);
      break;
    case 361:
      HASH_INVOKE(0x4983571BFEAE6169LL, magickaffinetransformimage);
      HASH_INVOKE(0x1612E331D1726169LL, drawsetstrokecolor);
      break;
    case 366:
      HASH_INVOKE(0x15B61E061268B16ELL, magickenhanceimage);
      HASH_INVOKE(0x0125F8B9428E416ELL, hphp_create_object);
      break;
    case 370:
      HASH_INVOKE(0x59FE6A862E1CB172LL, get_browser);
      break;
    case 372:
      HASH_INVOKE(0x345E070844E3F174LL, create_function);
      break;
    case 375:
      HASH_INVOKE(0x174DB93CAF0D1177LL, hphp_splfileinfo___tostring);
      break;
    case 377:
      HASH_INVOKE(0x6884FAF0D1EF3179LL, posix_mknod);
      break;
    case 379:
      HASH_INVOKE(0x59594143EFC7617BLL, mcrypt_module_open);
      break;
    case 380:
      HASH_INVOKE(0x3E1343B4A3AD717CLL, magickgettextascent);
      break;
    case 383:
      HASH_INVOKE(0x4EF9496D16F9D17FLL, xmlwriter_start_element_ns);
      break;
    case 385:
      HASH_INVOKE(0x2227E30BAB23B181LL, dom_xpath_query);
      HASH_INVOKE(0x1CBD3B58296C8181LL, xmlwriter_write_dtd);
      break;
    case 386:
      HASH_INVOKE(0x7BB7C27B2C118182LL, get_magic_quotes_gpc);
      HASH_INVOKE(0x130B62A8C77F3182LL, mb_ereg_search_getregs);
      break;
    case 389:
      HASH_INVOKE(0x13E90F8874839185LL, ob_get_status);
      HASH_INVOKE(0x54DB5DC6A069A185LL, hphp_get_class_info);
      break;
    case 390:
      HASH_INVOKE(0x5DB5E45860801186LL, openssl_csr_export);
      break;
    case 391:
      HASH_INVOKE(0x1BC448670BA4E187LL, iconv_strpos);
      break;
    case 393:
      HASH_INVOKE(0x0CC53B2F0D38D189LL, timezone_offset_get);
      break;
    case 402:
      HASH_INVOKE(0x07B5BF934F6EA192LL, imagesettile);
      break;
    case 407:
      HASH_INVOKE(0x15AD9CE061C75197LL, timezone_transitions_get);
      break;
    case 409:
      HASH_INVOKE(0x0CE71BC3B75D8199LL, mb_strimwidth);
      break;
    case 411:
      HASH_INVOKE(0x7FF6C2A693CE119BLL, magickcyclecolormapimage);
      HASH_INVOKE(0x74F20C284227219BLL, similar_text);
      break;
    case 416:
      HASH_INVOKE(0x6FB5104FC97A31A0LL, drawpathcurvetorelative);
      break;
    case 418:
      HASH_INVOKE(0x6DFC0765EBAB81A2LL, mcrypt_decrypt);
      HASH_INVOKE(0x2A9015499A2EB1A2LL, fnmatch);
      HASH_INVOKE(0x615723D21421A1A2LL, sem_remove);
      break;
    case 419:
      HASH_INVOKE(0x735B81C45C2971A3LL, drawgetfillopacity);
      break;
    case 422:
      HASH_INVOKE(0x37B4612178EF91A6LL, memcache_get_version);
      break;
    case 425:
      HASH_INVOKE(0x740DC7FFAD8BB1A9LL, imagecolorat);
      HASH_INVOKE(0x0DDFE3B1F6EEE1A9LL, array_reduce);
      break;
    case 426:
      HASH_INVOKE(0x11A5C66A3D0711AALL, apc_sma_info);
      break;
    case 429:
      HASH_INVOKE(0x5A6EFF8C71A431ADLL, socket_get_status);
      HASH_INVOKE(0x50538F37398AF1ADLL, ldap_get_option);
      break;
    case 431:
      HASH_INVOKE(0x5B1F9C2E9FE111AFLL, fb_utf8ize);
      break;
    case 434:
      HASH_INVOKE(0x4B96F870584541B2LL, hphp_splfileobject_setflags);
      break;
    case 438:
      HASH_INVOKE(0x33BD672B4AC301B6LL, mt_rand);
      break;
    case 445:
      HASH_INVOKE(0x589F7316EDC581BDLL, fb_serialize);
      HASH_INVOKE(0x4B3F35310DEA31BDLL, socket_create_pair);
      break;
    case 447:
      HASH_INVOKE(0x0E88ACEB15A581BFLL, magickgetimageextrema);
      HASH_INVOKE(0x681CD0E7D9DB71BFLL, pow);
      break;
    case 450:
      HASH_INVOKE(0x02103322F88C71C2LL, pixelgetcolorcount);
      break;
    case 452:
      HASH_INVOKE(0x3617DAE43A23D1C4LL, xml_parser_set_option);
      break;
    case 454:
      HASH_INVOKE(0x188D37410B6051C6LL, session_unregister);
      break;
    case 455:
      HASH_INVOKE(0x5AE12CB1FFDC21C7LL, drawellipse);
      break;
    case 456:
      HASH_INVOKE(0x11C0B5DA066891C8LL, preg_match_all);
      break;
    case 458:
      HASH_INVOKE(0x75CA86838D24A1CALL, hash_algos);
      break;
    case 460:
      HASH_INVOKE(0x3DF488365DAAF1CCLL, drawgettextencoding);
      break;
    case 461:
      HASH_INVOKE(0x37340B707E7CD1CDLL, magickgetimagebordercolor);
      break;
    case 462:
      HASH_INVOKE(0x2E7741B5440FB1CELL, magicksetlastiterator);
      break;
    case 464:
      HASH_INVOKE(0x03012F3DDD7AB1D0LL, getservbyport);
      break;
    case 468:
      HASH_INVOKE(0x219F3257BA3371D4LL, decbin);
      break;
    case 470:
      HASH_INVOKE(0x78831282736801D6LL, stream_context_get_default);
      break;
    case 472:
      HASH_INVOKE(0x60E9E392663921D8LL, readlink);
      break;
    case 473:
      HASH_INVOKE(0x7A69D0078F4F31D9LL, ldap_start_tls);
      break;
    case 474:
      HASH_INVOKE(0x0482E069503A91DALL, posix_setgid);
      break;
    case 475:
      HASH_INVOKE(0x3FEBBC0DA79F31DBLL, fb_call_user_func_safe);
      break;
    case 476:
      HASH_INVOKE(0x14FB46333D6D11DCLL, xml_set_default_handler);
      HASH_INVOKE(0x5B3A4A72846B21DCLL, current);
      break;
    case 477:
      HASH_INVOKE(0x04666D6F67C7A1DDLL, mysql_list_processes);
      HASH_INVOKE(0x03A183D73942B1DDLL, apc_filehits);
      break;
    case 478:
      HASH_INVOKE(0x44563CC8FA9B11DELL, memcache_set_server_params);
      break;
    case 479:
      HASH_INVOKE(0x7403251412E931DFLL, syslog);
      break;
    case 480:
      HASH_INVOKE(0x5932D2750A8A91E0LL, magickgetpackagename);
      break;
    case 481:
      HASH_INVOKE(0x2771C632A60371E1LL, ftok);
      HASH_INVOKE(0x0ED729A444C611E1LL, openssl_x509_read);
      break;
    case 482:
      HASH_INVOKE(0x67D4BA8513BF41E2LL, newpixelwand);
      break;
    case 483:
      HASH_INVOKE(0x131D11F79A8801E3LL, mb_http_output);
      HASH_INVOKE(0x406BDC51A3FD81E3LL, pcntl_waitpid);
      break;
    case 484:
      HASH_INVOKE(0x08F7A6C37FC7B1E4LL, shm_get_var);
      break;
    case 488:
      HASH_INVOKE(0x7F843353646391E8LL, rad2deg);
      break;
    case 493:
      HASH_INVOKE(0x1B09A9A533FFA1EDLL, drawgetexceptiontype);
      HASH_INVOKE(0x19932EEC5CAE01EDLL, hphp_splfileinfo_getfileinfo);
      break;
    case 497:
      HASH_INVOKE(0x02BCE5B0FBED61F1LL, strlen);
      break;
    case 498:
      HASH_INVOKE(0x46AFE55982B371F2LL, posix_geteuid);
      break;
    case 499:
      HASH_INVOKE(0x582D10141D5601F3LL, stream_context_set_option);
      HASH_INVOKE(0x11BB3CDC5E4971F3LL, xmlwriter_end_pi);
      break;
    case 501:
      HASH_INVOKE(0x542FBDCF960031F5LL, fprintf);
      HASH_INVOKE(0x02ABC00C046291F5LL, imageellipse);
      break;
    case 502:
      HASH_INVOKE(0x06DAF95935D221F6LL, dom_namednodemap_item);
      break;
    case 506:
      HASH_INVOKE(0x135D5CBF936B11FALL, msg_receive);
      break;
    case 509:
      HASH_INVOKE(0x5304E6B47ED0B1FDLL, srand);
      break;
    case 514:
      HASH_INVOKE(0x16699E33370A8202LL, idn_to_unicode);
      break;
    case 515:
      HASH_INVOKE(0x5B3C354575BB8203LL, mysql_free_result);
      break;
    case 520:
      HASH_INVOKE(0x7B525920E026C208LL, gztell);
      break;
    case 523:
      HASH_INVOKE(0x2F5144AB3647C20BLL, dom_text_is_whitespace_in_element_content);
      break;
    case 524:
      HASH_INVOKE(0x41B15671649A320CLL, curl_multi_getcontent);
      HASH_INVOKE(0x257BEA4D6DC9920CLL, ctype_alnum);
      break;
    case 525:
      HASH_INVOKE(0x5C0DECC8CC67E20DLL, magickwriteimagesfile);
      break;
    case 526:
      HASH_INVOKE(0x533642044A00520ELL, pixelgetmagentaquantum);
      break;
    case 527:
      HASH_INVOKE(0x08DC8BF3ADAE520FLL, getallheaders);
      HASH_INVOKE(0x53631CF3A937320FLL, get_class_methods);
      break;
    case 528:
      HASH_INVOKE(0x15EF510022CAF210LL, xml_parser_create_ns);
      HASH_INVOKE(0x2D41D7F8F4113210LL, sinh);
      break;
    case 529:
      HASH_INVOKE(0x438CD1A0327A8211LL, apc_define_constants);
      break;
    case 532:
      HASH_INVOKE(0x7D85E9FACB92D214LL, magickgetimageblob);
      break;
    case 535:
      HASH_INVOKE(0x4BC4B81CC5F32217LL, dom_node_append_child);
      break;
    case 536:
      HASH_INVOKE(0x56C95225813A5218LL, memory_get_usage);
      HASH_INVOKE(0x4D63F2C9AAB79218LL, fb_renamed_functions);
      break;
    case 538:
      HASH_INVOKE(0x72C0C89D897E721ALL, magicksetimagetype);
      break;
    case 539:
      HASH_INVOKE(0x3A90CC67D58A021BLL, hash_hmac_file);
      break;
    case 545:
      HASH_INVOKE(0x345E2BAE171FA221LL, date_sunrise);
      break;
    case 546:
      HASH_INVOKE(0x39E4E0175FADC222LL, drawskewx);
      break;
    case 547:
      HASH_INVOKE(0x5208E8B08455E223LL, dom_node_has_child_nodes);
      break;
    case 550:
      HASH_INVOKE(0x007B6BD94D767226LL, hphp_splfileobject_fpassthru);
      break;
    case 551:
      HASH_INVOKE(0x5A26F00A81BA5227LL, xmlwriter_start_attribute_ns);
      break;
    case 552:
      HASH_INVOKE(0x44911AEE34D63228LL, time_sleep_until);
      HASH_INVOKE(0x7CD3C6F6495D3228LL, memcache_get_stats);
      break;
    case 556:
      HASH_INVOKE(0x4129FFBF3548E22CLL, mb_strpos);
      break;
    case 558:
      HASH_INVOKE(0x0B7559F53F31D22ELL, fb_stubout_intercept_handler);
      break;
    case 560:
      HASH_INVOKE(0x036A5935D9936230LL, hphp_splfileinfo_openfile);
      break;
    case 561:
      HASH_INVOKE(0x61A192D10C004231LL, magickconvolveimage);
      HASH_INVOKE(0x7C07D66F70E43231LL, mailparse_determine_best_xfer_encoding);
      break;
    case 564:
      HASH_INVOKE(0x23C478B2D95F3234LL, dom_element_has_attribute_ns);
      HASH_INVOKE(0x422C51C95928A234LL, str_replace);
      break;
    case 566:
      HASH_INVOKE(0x5542AABF33A2F236LL, stream_filter_remove);
      break;
    case 568:
      HASH_INVOKE(0x695AC59F79E2A238LL, mb_encode_mimeheader);
      break;
    case 570:
      HASH_INVOKE(0x679ABBE5A08C523ALL, xml_parse_into_struct);
      break;
    case 574:
      HASH_INVOKE(0x5E54CE856B78223ELL, array_flip);
      break;
    case 576:
      HASH_INVOKE(0x0DB9DD4AE24B0240LL, base64_encode);
      break;
    case 579:
      HASH_INVOKE(0x78183A24F2ACB243LL, strtotime);
      break;
    case 584:
      HASH_INVOKE(0x7071BB6F0591E248LL, serialize);
      break;
    case 589:
      HASH_INVOKE(0x5E73B9F3B7C8224DLL, parse_hdf_string);
      break;
    case 591:
      HASH_INVOKE(0x1D8FE8E68F7EA24FLL, pixelsetiteratorrow);
      break;
    case 592:
      HASH_INVOKE(0x30747B708DA1D250LL, pushdrawingwand);
      break;
    case 598:
      HASH_INVOKE(0x0384346A8857D256LL, clonemagickwand);
      break;
    case 600:
      HASH_INVOKE(0x32C51FFF185F4258LL, memcache_set);
      break;
    case 603:
      HASH_INVOKE(0x2F8F40E95EDF925BLL, sizeof);
      break;
    case 605:
      HASH_INVOKE(0x7E6024E53AEEE25DLL, apc_delete);
      break;
    case 608:
      HASH_INVOKE(0x71D2D4757B7E4260LL, apache_request_headers);
      break;
    case 609:
      HASH_INVOKE(0x383800902035F261LL, apache_child_terminate);
      HASH_INVOKE(0x48305E8ABB8BC261LL, hphp_instanceof);
      break;
    case 610:
      HASH_INVOKE(0x63AC0EED6D946262LL, pcntl_fork);
      break;
    case 612:
      HASH_INVOKE(0x261F403C4174D264LL, posix_getsid);
      break;
    case 613:
      HASH_INVOKE(0x561DB8F1DC0BC265LL, magickseparateimagechannel);
      break;
    case 615:
      HASH_INVOKE(0x50C5488E19492267LL, mb_list_encodings_alias_names);
      HASH_INVOKE(0x38B376B9D9091267LL, xmlwriter_write_attribute);
      break;
    case 620:
      HASH_INVOKE(0x188DF1EB5FD1B26CLL, mailparse_msg_parse_file);
      break;
    case 622:
      HASH_INVOKE(0x5672949384A4F26ELL, stream_filter_register);
      break;
    case 626:
      HASH_INVOKE(0x1C65F32FF28BC272LL, pathinfo);
      break;
    case 627:
      HASH_INVOKE(0x61C991F216E85273LL, inet_ntop);
      HASH_INVOKE(0x08CC1E49661DB273LL, dom_element_get_attribute_ns);
      break;
    case 634:
      HASH_INVOKE(0x39E05F957C7DD27ALL, magickgetimagedepth);
      break;
    case 636:
      HASH_INVOKE(0x0F7E33D551E0727CLL, posix_getpid);
      break;
    case 637:
      HASH_INVOKE(0x7DB57C59E607627DLL, mcrypt_generic_deinit);
      break;
    case 638:
      HASH_INVOKE(0x4111669F4862E27ELL, drawpathlinetoverticalrelative);
      break;
    case 639:
      HASH_INVOKE(0x5B94A6962F1EC27FLL, magickechoimagesblob);
      HASH_INVOKE(0x57E8781CF111727FLL, fileowner);
      break;
    case 640:
      HASH_INVOKE(0x2E54EF1891172280LL, hphp_splfileinfo_isexecutable);
      break;
    case 641:
      HASH_INVOKE(0x1765A2E5186DE281LL, socket_write);
      HASH_INVOKE(0x0881440DCF5D3281LL, magickflattenimages);
      break;
    case 643:
      HASH_INVOKE(0x4C83B098C8BDA283LL, posix_setsid);
      break;
    case 645:
      HASH_INVOKE(0x5F7DC3612050A285LL, drawsetfontweight);
      HASH_INVOKE(0x1A895A2307126285LL, openssl_pkcs7_decrypt);
      break;
    case 646:
      HASH_INVOKE(0x3A2E2C40B019E286LL, is_a);
      HASH_INVOKE(0x4F028FA6AAEEC286LL, call_user_method);
      break;
    case 647:
      HASH_INVOKE(0x27698DDEDAD6E287LL, openssl_pkey_new);
      HASH_INVOKE(0x23A1E13930E44287LL, xbox_schedule_thread_reset);
      break;
    case 656:
      HASH_INVOKE(0x04C11602C720A290LL, convert_cyr_string);
      break;
    case 660:
      HASH_INVOKE(0x4D05DD57E4052294LL, xmlwriter_output_memory);
      break;
    case 661:
      HASH_INVOKE(0x69868C648BC12295LL, apc_store);
      break;
    case 665:
      HASH_INVOKE(0x22D380E06E67E299LL, stream_encoding);
      HASH_INVOKE(0x5665CB664C38A299LL, parse_ini_string);
      break;
    case 666:
      HASH_INVOKE(0x68272A37CC9E729ALL, mb_strtolower);
      break;
    case 667:
      HASH_INVOKE(0x4A09634AE6DFF29BLL, fileperms);
      break;
    case 668:
      HASH_INVOKE(0x0F71D3E47044E29CLL, drawpathcurvetosmoothrelative);
      break;
    case 674:
      HASH_INVOKE(0x1FBF8A270331C2A2LL, write_hdf_file);
      break;
    case 675:
      HASH_INVOKE(0x10E7B5A0E29CF2A3LL, bcscale);
      HASH_INVOKE(0x743EA4BF2CC8F2A3LL, mysql_field_type);
      break;
    case 678:
      HASH_INVOKE(0x73EF3A19F76872A6LL, iconv_strrpos);
      break;
    case 680:
      HASH_INVOKE(0x5409127FEDE332A8LL, exif_imagetype);
      break;
    case 685:
      HASH_INVOKE(0x35D259398CDDA2ADLL, pixelgetredquantum);
      HASH_INVOKE(0x00AB6FC4E9EE62ADLL, imagefilledrectangle);
      break;
    case 686:
      HASH_INVOKE(0x36AB9E6AA687F2AELL, xmlwriter_start_dtd_element);
      break;
    case 691:
      HASH_INVOKE(0x44530C37F2B522B3LL, drawgetstrokedasharray);
      HASH_INVOKE(0x59BB7B8078AC22B3LL, tempnam);
      break;
    case 694:
      HASH_INVOKE(0x0C4B98B47B0862B6LL, apd_echo);
      HASH_INVOKE(0x0E9C9B409F94B2B6LL, setcookie);
      break;
    case 696:
      HASH_INVOKE(0x3C6D50F3BB8102B8LL, next);
      break;
    case 698:
      HASH_INVOKE(0x4A3D2113D3DFD2BALL, newpixelwandarray);
      break;
    case 700:
      HASH_INVOKE(0x33E08846F3EB42BCLL, ldap_get_values);
      HASH_INVOKE(0x41F7E2214DDE12BCLL, mcrypt_enc_self_test);
      break;
    case 701:
      HASH_INVOKE(0x327C865E52FD12BDLL, ldap_get_values_len);
      break;
    case 702:
      HASH_INVOKE(0x72D6F9B3661AB2BELL, magickgetimage);
      break;
    case 704:
      HASH_INVOKE(0x5B7C1B74BA3452C0LL, newpixelregioniterator);
      break;
    case 707:
      HASH_INVOKE(0x446D76A95365D2C3LL, pixelgetyellow);
      break;
    case 708:
      HASH_INVOKE(0x6018C9F7DF40C2C4LL, xml_get_current_column_number);
      HASH_INVOKE(0x1C7B8161F3C412C4LL, dom_document_create_document_fragment);
      break;
    case 716:
      HASH_INVOKE(0x407EF03C23BF92CCLL, drawpathellipticarcabsolute);
      HASH_INVOKE(0x44273F8BA3F542CCLL, imagesx);
      break;
    case 718:
      HASH_INVOKE(0x1922D51F3E1522CELL, xmlwriter_end_dtd_attlist);
      break;
    case 719:
      HASH_INVOKE(0x4ACE27EC476632CFLL, apc_bin_dumpfile);
      break;
    case 722:
      HASH_INVOKE(0x4D9A87BD0CF742D2LL, imagepsextendfont);
      break;
    case 725:
      HASH_INVOKE(0x4D04C580CF9212D5LL, posix_getgroups);
      break;
    case 726:
      HASH_INVOKE(0x06E9C984B5F0B2D6LL, furchash_hphp_ext);
      break;
    case 728:
      HASH_INVOKE(0x56C4896BA2FF52D8LL, drawsetstrokeopacity);
      break;
    case 730:
      HASH_INVOKE(0x5C6A85B448C352DALL, posix_uname);
      break;
    case 733:
      HASH_INVOKE(0x5F585DF7CB82E2DDLL, hphp_splfileinfo_iswritable);
      break;
    case 738:
      HASH_INVOKE(0x4AEC19D75BF652E2LL, magickremoveimage);
      break;
    case 739:
      HASH_INVOKE(0x45382D0BA5B262E3LL, mysql_get_proto_info);
      break;
    case 749:
      HASH_INVOKE(0x1B9FC9E27B8AB2EDLL, memcache_flush);
      HASH_INVOKE(0x215E0E2EFA7422EDLL, drawgetstrokeantialias);
      break;
    case 750:
      HASH_INVOKE(0x5D43C0E4868EC2EELL, forward_static_call);
      HASH_INVOKE(0x2884B7B3252B02EELL, imagealphablending);
      break;
    case 752:
      HASH_INVOKE(0x25CA0794823AA2F0LL, openssl_csr_get_public_key);
      break;
    case 754:
      HASH_INVOKE(0x2EE56D216BB832F2LL, time_nanosleep);
      break;
    case 756:
      HASH_INVOKE(0x418EC805C5FD32F4LL, mcrypt_get_key_size);
      break;
    case 761:
      HASH_INVOKE(0x00CFD56391DF82F9LL, mysql_data_seek);
      HASH_INVOKE(0x319EF52B36AAB2F9LL, posix_isatty);
      break;
    case 763:
      HASH_INVOKE(0x4D393D30CE1112FBLL, drawpathmovetoabsolute);
      break;
    case 764:
      HASH_INVOKE(0x66D59E4DBC7382FCLL, drawscale);
      break;
    case 766:
      HASH_INVOKE(0x208B66A8731F72FELL, sem_get);
      HASH_INVOKE(0x755A9950B65472FELL, drawgetgravity);
      break;
    case 770:
      HASH_INVOKE(0x0103FE1E2C307302LL, socket_recvfrom);
      break;
    case 772:
      HASH_INVOKE(0x33A532FDB8EAC304LL, memcache_delete);
      break;
    case 773:
      HASH_INVOKE(0x65D40C6B4842F305LL, clearpixelwand);
      break;
    case 774:
      HASH_INVOKE(0x689D60184DD81306LL, htmlspecialchars_decode);
      break;
    case 777:
      HASH_INVOKE(0x414038596F552309LL, magickgetversionnumber);
      HASH_INVOKE(0x47CB27E8FDB60309LL, array_fill);
      break;
    case 779:
      HASH_INVOKE(0x0C6F751411F5E30BLL, strrev);
      HASH_INVOKE(0x65F586C35A88030BLL, magickresizeimage);
      HASH_INVOKE(0x2D2BC1125ECA930BLL, dom_document_relaxng_validate_file);
      break;
    case 780:
      HASH_INVOKE(0x553940FCE453330CLL, hphp_splfileobject_getmaxlinelen);
      break;
    case 785:
      HASH_INVOKE(0x141EDCAE1D155311LL, xbox_get_thread_time);
      break;
    case 789:
      HASH_INVOKE(0x4F1E663AE18FD315LL, msg_remove_queue);
      break;
    case 798:
      HASH_INVOKE(0x27FF9DB54420531ELL, xml_error_string);
      break;
    case 804:
      HASH_INVOKE(0x5E5E4F998C8E7324LL, pcntl_wifexited);
      break;
    case 808:
      HASH_INVOKE(0x73FEB3BF75FFB328LL, ctype_space);
      break;
    case 811:
      HASH_INVOKE(0x2BDB1EE3869E132BLL, restore_error_handler);
      break;
    case 815:
      HASH_INVOKE(0x7DD6461A6290B32FLL, mysql_real_escape_string);
      break;
    case 816:
      HASH_INVOKE(0x300F758BB0E16330LL, mysql_num_rows);
      HASH_INVOKE(0x1601C1826E90B330LL, strptime);
      break;
    case 817:
      HASH_INVOKE(0x00DAFE46631AE331LL, stream_set_timeout);
      break;
    case 818:
      HASH_INVOKE(0x037055C215998332LL, bcsub);
      break;
    case 824:
      HASH_INVOKE(0x549D51040C250338LL, cleardrawingwand);
      break;
    case 825:
      HASH_INVOKE(0x48D57F17C5132339LL, drawgetclippath);
      break;
    case 826:
      HASH_INVOKE(0x34DDF0DFC546033ALL, xbox_task_start);
      break;
    case 829:
      HASH_INVOKE(0x4E166ECE0EC6A33DLL, openssl_pkey_get_public);
      break;
    case 830:
      HASH_INVOKE(0x758EA7E9AA45C33ELL, xmlwriter_end_document);
      break;
    case 835:
      HASH_INVOKE(0x6794CFB89DEEF343LL, curl_exec);
      break;
    case 836:
      HASH_INVOKE(0x1A9DC76AB74F6344LL, openssl_verify);
      break;
    case 837:
      HASH_INVOKE(0x45FAE3D08E96B345LL, curl_errno);
      break;
    case 838:
      HASH_INVOKE(0x4B30FBA18042E346LL, session_cache_expire);
      break;
    case 842:
      HASH_INVOKE(0x208BB4C3C0BA534ALL, xmlwriter_write_dtd_element);
      break;
    case 843:
      HASH_INVOKE(0x3880550F6AD8034BLL, session_destroy);
      HASH_INVOKE(0x57A9E8878872D34BLL, parse_ini_file);
      break;
    case 844:
      HASH_INVOKE(0x0644E5FB91C8134CLL, array_udiff);
      break;
    case 845:
      HASH_INVOKE(0x5998E61D600D634DLL, drawaffine);
      break;
    case 847:
      HASH_INVOKE(0x4F2D0EFF0D4B534FLL, fb_get_taint);
      HASH_INVOKE(0x5C8B3B9FA833934FLL, ldap_first_attribute);
      break;
    case 849:
      HASH_INVOKE(0x2B422699C3A57351LL, sha1);
      break;
    case 852:
      HASH_INVOKE(0x501F4DF5C8997354LL, hphp_get_property);
      HASH_INVOKE(0x77EB4D2F5BDDB354LL, magickgetimageresolution);
      break;
    case 858:
      HASH_INVOKE(0x4BF5DEBDB76EC35ALL, mcrypt_enc_get_iv_size);
      HASH_INVOKE(0x0E0C79E42812235ALL, imagepng);
      break;
    case 859:
      HASH_INVOKE(0x1AC48909BEEF935BLL, func_get_arg);
      break;
    case 861:
      HASH_INVOKE(0x54C3E9AB6FB8E35DLL, magickswirlimage);
      break;
    case 863:
      HASH_INVOKE(0x280DE04F84FB235FLL, popdrawingwand);
      break;
    case 869:
      HASH_INVOKE(0x68DBF8ABB26A8365LL, hphp_directoryiterator_rewind);
      break;
    case 870:
      HASH_INVOKE(0x4EF3469306E44366LL, floatval);
      break;
    case 871:
      HASH_INVOKE(0x4810A9774785C367LL, posix_getpgrp);
      break;
    case 872:
      HASH_INVOKE(0x5D406167C673D368LL, magickcompareimages);
      break;
    case 873:
      HASH_INVOKE(0x6C715D7DD63DA369LL, is_integer);
      break;
    case 878:
      HASH_INVOKE(0x7CE90898E882F36ELL, pixelsetyellow);
      break;
    case 882:
      HASH_INVOKE(0x7107AE03689F5372LL, hphp_invoke);
      break;
    case 888:
      HASH_INVOKE(0x34BAEFD8AE59D378LL, hphp_set_error_page);
      break;
    case 889:
      HASH_INVOKE(0x5ED8901DB5D14379LL, magickcharcoalimage);
      break;
    case 890:
      HASH_INVOKE(0x69EA8DC005FEC37ALL, hphp_splfileobject_fwrite);
      break;
    case 893:
      HASH_INVOKE(0x7C40E2514FB5437DLL, dom_namednodemap_get_named_item_ns);
      break;
    case 900:
      HASH_INVOKE(0x44C1BC500D175384LL, wandgetexception);
      break;
    case 901:
      HASH_INVOKE(0x7C5CA3E2E3C8F385LL, magickflipimage);
      HASH_INVOKE(0x57554E082E0ED385LL, pcntl_exec);
      HASH_INVOKE(0x0B0B8765A4CDD385LL, hphp_splfileobject_fgets);
      break;
    case 902:
      HASH_INVOKE(0x589E24C7664D5386LL, doubleval);
      break;
    case 904:
      HASH_INVOKE(0x791E946E04F50388LL, magicksetresourcelimit);
      break;
    case 907:
      HASH_INVOKE(0x32354CC291ECF38BLL, fb_intercept);
      HASH_INVOKE(0x73A3F87C0A56238BLL, stat);
      break;
    case 908:
      HASH_INVOKE(0x7F18BA1FBD95B38CLL, hphp_directoryiterator_next);
      break;
    case 909:
      HASH_INVOKE(0x4127DE142CD4A38DLL, xml_get_error_code);
      break;
    case 913:
      HASH_INVOKE(0x25FA64929C619391LL, asin);
      break;
    case 914:
      HASH_INVOKE(0x2052D8D4822EF392LL, is_subclass_of);
      HASH_INVOKE(0x2395B0A85E292392LL, hphp_splfileobject_flock);
      break;
    case 916:
      HASH_INVOKE(0x269A220896FD2394LL, deg2rad);
      HASH_INVOKE(0x36953788781F4394LL, mailparse_msg_extract_part);
      break;
    case 917:
      HASH_INVOKE(0x7B0552A224E27395LL, bcsqrt);
      HASH_INVOKE(0x422599B9E8AC0395LL, stream_bucket_make_writeable);
      break;
    case 918:
      HASH_INVOKE(0x15EC64198D93C396LL, openssl_pkcs12_read);
      break;
    case 919:
      HASH_INVOKE(0x1D2C305EA5C82397LL, idn_to_utf8);
      break;
    case 920:
      HASH_INVOKE(0x215547858BA7E398LL, hphp_recursiveiteratoriterator___construct);
      break;
    case 921:
      HASH_INVOKE(0x66DA89629BA5D399LL, posix_getgrgid);
      break;
    case 922:
      HASH_INVOKE(0x0CC562CBD773639ALL, i18n_loc_get_default);
      HASH_INVOKE(0x4C24BC37D807D39ALL, collator_get_strength);
      break;
    case 923:
      HASH_INVOKE(0x25DF28703309C39BLL, idate);
      HASH_INVOKE(0x5B33B55D4B7E339BLL, fpassthru);
      break;
    case 924:
      HASH_INVOKE(0x0136F8F03932E39CLL, session_unset);
      break;
    case 926:
      HASH_INVOKE(0x27AD0D17AA7FB39ELL, ldap_set_rebind_proc);
      break;
    case 927:
      HASH_INVOKE(0x57E72C21F67D039FLL, user_error);
      HASH_INVOKE(0x0368F1779E3AE39FLL, mysql_field_table);
      HASH_INVOKE(0x4019A6916456339FLL, dom_node_remove_child);
      break;
    case 929:
      HASH_INVOKE(0x5C29B6D7973903A1LL, proc_nice);
      break;
    case 930:
      HASH_INVOKE(0x0207E332D629A3A2LL, mailparse_msg_get_structure);
      HASH_INVOKE(0x0A2A4AA078D433A2LL, hexdec);
      break;
    case 932:
      HASH_INVOKE(0x1676FB393F8493A4LL, constant);
      break;
    case 934:
      HASH_INVOKE(0x40E0D496EE29B3A6LL, call_user_func_array);
      break;
    case 936:
      HASH_INVOKE(0x0121CD6CDCE1C3A8LL, mysql_pconnect_with_db);
      HASH_INVOKE(0x4120B8157ED413A8LL, i18n_loc_set_strength);
      break;
    case 937:
      HASH_INVOKE(0x7F9E810BC93023A9LL, memcache_close);
      break;
    case 938:
      HASH_INVOKE(0x3238A5BD362443AALL, escapeshellcmd);
      break;
    case 946:
      HASH_INVOKE(0x3DB7EBC0B670C3B2LL, magicksetimageredprimary);
      break;
    case 947:
      HASH_INVOKE(0x61720D771D1A23B3LL, posix_getpwnam);
      HASH_INVOKE(0x6077CFE09EE4D3B3LL, session_save_path);
      break;
    case 950:
      HASH_INVOKE(0x6E6C0E9A715073B6LL, dom_xpath_register_php_functions);
      HASH_INVOKE(0x6C07640F7C5BD3B6LL, imagettfbbox);
      break;
    case 955:
      HASH_INVOKE(0x5A3F5AAD1B13A3BBLL, is_executable);
      break;
    case 956:
      HASH_INVOKE(0x0629158C42C893BCLL, compact);
      break;
    case 957:
      HASH_INVOKE(0x60294C2616F6A3BDLL, mcrypt_enc_get_supported_key_sizes);
      break;
    case 958:
      HASH_INVOKE(0x49A34964289453BELL, eregi);
      break;
    case 959:
      HASH_INVOKE(0x0E38CDC93E5893BFLL, magicksetimagemattecolor);
      break;
    case 968:
      HASH_INVOKE(0x4D100C70E86593C8LL, stream_set_write_buffer);
      HASH_INVOKE(0x3101CE70BA49A3C8LL, error_reporting);
      break;
    case 971:
      HASH_INVOKE(0x0173CC6FACAB93CBLL, quotemeta);
      HASH_INVOKE(0x4C3B6BE9112E63CBLL, str_split);
      break;
    case 972:
      HASH_INVOKE(0x50C88817090C63CCLL, pcntl_wait);
      break;
    case 974:
      HASH_INVOKE(0x4F9F68F60FD7A3CELL, drawgetfillrule);
      HASH_INVOKE(0x02BEFBEE8287D3CELL, get_magic_quotes_runtime);
      break;
    case 978:
      HASH_INVOKE(0x67C155632E5373D2LL, mailparse_msg_create);
      break;
    case 979:
      HASH_INVOKE(0x734FD402E190E3D3LL, evhttp_async_get);
      HASH_INVOKE(0x0A8D4FAF266973D3LL, bcpow);
      break;
    case 980:
      HASH_INVOKE(0x0FF21F9BE4CCC3D4LL, call_user_func_rpc);
      break;
    case 983:
      HASH_INVOKE(0x382B5B1EF00153D7LL, imagecreatefrompng);
      break;
    case 996:
      HASH_INVOKE(0x7E7718CC939D63E4LL, setrawcookie);
      break;
    case 1000:
      HASH_INVOKE(0x6BB9D669DDB703E8LL, xml_get_current_byte_index);
      HASH_INVOKE(0x4A3127C309B0C3E8LL, drawsetstrokelinecap);
      break;
    case 1002:
      HASH_INVOKE(0x0D3C8F00B0C633EALL, inet_pton);
      HASH_INVOKE(0x6DA49696220FE3EALL, mailparse_rfc822_parse_addresses);
      break;
    case 1003:
      HASH_INVOKE(0x1DAE0831CECB63EBLL, ob_get_clean);
      break;
    case 1006:
      HASH_INVOKE(0x598472448937E3EELL, magickqueryfontmetrics);
      break;
    case 1009:
      HASH_INVOKE(0x5EFE291585A713F1LL, method_exists);
      break;
    case 1010:
      HASH_INVOKE(0x0FE12E46BC9853F2LL, stream_filter_append);
      HASH_INVOKE(0x41A19AE18BC8B3F2LL, curl_error);
      HASH_INVOKE(0x696241660648B3F2LL, magickwhitethresholdimage);
      break;
    case 1012:
      HASH_INVOKE(0x1938C8715806E3F4LL, spl_classes);
      HASH_INVOKE(0x26D53A77483EF3F4LL, drawbezier);
      break;
    case 1015:
      HASH_INVOKE(0x43F22CB4E3E8F3F7LL, apache_note);
      break;
    case 1016:
      HASH_INVOKE(0x4C024573FCD5B3F8LL, var_dump);
      HASH_INVOKE(0x514EA9C8FF5B33F8LL, posix_getrlimit);
      break;
    case 1018:
      HASH_INVOKE(0x1B217E78CBC713FALL, zend_thread_id);
      break;
    case 1025:
      HASH_INVOKE(0x36B9C440B1881401LL, fmod);
      HASH_INVOKE(0x3DCB1C92B5864401LL, gzrewind);
      break;
    case 1028:
      HASH_INVOKE(0x2B12B0E9109D0404LL, iptcembed);
      break;
    case 1033:
      HASH_INVOKE(0x2E57E06900594409LL, xbox_send_message);
      break;
    case 1034:
      HASH_INVOKE(0x6DC61C51FA1D340ALL, show_source);
      break;
    case 1035:
      HASH_INVOKE(0x6C2CE092B900D40BLL, hphp_splfileinfo___construct);
      break;
    case 1037:
      HASH_INVOKE(0x2939C5BAE0C4A40DLL, nl2br);
      HASH_INVOKE(0x267529454569840DLL, ob_flush);
      HASH_INVOKE(0x152C7161567F940DLL, func_num_args);
      HASH_INVOKE(0x002CCCD877D9640DLL, drawpathclose);
      break;
    case 1043:
      HASH_INVOKE(0x56EC1A6732D07413LL, drawgetfontsize);
      HASH_INVOKE(0x20C24D873DC65413LL, openssl_csr_get_subject);
      break;
    case 1051:
      HASH_INVOKE(0x47279C717370B41BLL, acos);
      break;
    case 1054:
      HASH_INVOKE(0x3E4E7C561D3A541ELL, fgetss);
      break;
    case 1055:
      HASH_INVOKE(0x301963016A91741FLL, hphp_stats);
      break;
    case 1059:
      HASH_INVOKE(0x4C9108B5A5807423LL, drawsetfillcolor);
      break;
    case 1062:
      HASH_INVOKE(0x21EFB0B9D1514426LL, magicksetpassphrase);
      HASH_INVOKE(0x161D8EA3339AB426LL, apc_cas);
      break;
    case 1068:
      HASH_INVOKE(0x12D324CC744BF42CLL, pixelgetcolorasstring);
      break;
    case 1069:
      HASH_INVOKE(0x333D1E2E28B0942DLL, imagejpeg);
      HASH_INVOKE(0x2A5A519E4BFE442DLL, mb_eregi);
      break;
    case 1071:
      HASH_INVOKE(0x316F2725AC15042FLL, stream_resolve_include_path);
      break;
    case 1072:
      HASH_INVOKE(0x6349C9658B2A2430LL, memcache_pconnect);
      break;
    case 1074:
      HASH_INVOKE(0x71C6E38BC56CE432LL, stream_wrapper_register);
      break;
    case 1075:
      HASH_INVOKE(0x6829094421CDB433LL, touch);
      break;
    case 1077:
      HASH_INVOKE(0x75DAFEF5BFEF1435LL, imagesetstyle);
      HASH_INVOKE(0x044386A0E8B25435LL, drawgetclipunits);
      break;
    case 1079:
      HASH_INVOKE(0x1AAF02CF6DEBB437LL, magickdeconstructimages);
      break;
    case 1081:
      HASH_INVOKE(0x34C52EF423EFD439LL, proc_open);
      break;
    case 1082:
      HASH_INVOKE(0x5019A1FBF377C43ALL, imagepsbbox);
      break;
    case 1084:
      HASH_INVOKE(0x59ECE01C7629643CLL, mysql_drop_db);
      break;
    case 1088:
      HASH_INVOKE(0x5247425ED698B440LL, hphp_thread_is_warmup_enabled);
      break;
    case 1089:
      HASH_INVOKE(0x158E2271E381C441LL, hash_file);
      HASH_INVOKE(0x05892E3C5B9EB441LL, closedir);
      break;
    case 1090:
      HASH_INVOKE(0x3F869126D0336442LL, trigger_error);
      break;
    case 1105:
      HASH_INVOKE(0x7539134E1CC61451LL, xmlwriter_start_cdata);
      break;
    case 1106:
      HASH_INVOKE(0x1056EF1C14D2A452LL, socket_connect);
      break;
    case 1116:
      HASH_INVOKE(0x436AB52B2099145CLL, ldap_close);
      break;
    case 1117:
      HASH_INVOKE(0x0246AF48CD31245DLL, count_chars);
      break;
    case 1118:
      HASH_INVOKE(0x0ED191E71A60545ELL, magicksetfirstiterator);
      break;
    case 1125:
      HASH_INVOKE(0x05D72365192CE465LL, fwrite);
      HASH_INVOKE(0x406A1404F48E4465LL, posix_getuid);
      break;
    case 1130:
      HASH_INVOKE(0x32643AE461D3F46ALL, mailparse_stream_encode);
      break;
    case 1132:
      HASH_INVOKE(0x07D959A8C0CF546CLL, stream_wrapper_unregister);
      HASH_INVOKE(0x4F39BD300305746CLL, hphp_splfileobject_key);
      break;
    case 1133:
      HASH_INVOKE(0x738D381800CE946DLL, ldap_parse_result);
      HASH_INVOKE(0x5229C0069FD7D46DLL, vfprintf);
      break;
    case 1136:
      HASH_INVOKE(0x0C626F268F120470LL, __halt_compiler);
      break;
    case 1139:
      HASH_INVOKE(0x0F8F276A48900473LL, drawgetstrokelinecap);
      break;
    case 1141:
      HASH_INVOKE(0x268706C46202C475LL, sem_acquire);
      break;
    case 1143:
      HASH_INVOKE(0x18666906A8001477LL, array_diff_assoc);
      break;
    case 1144:
      HASH_INVOKE(0x080594ABE715B478LL, hphp_splfileobject_current);
      HASH_INVOKE(0x6497CC8295DDB478LL, fb_thrift_unserialize);
      break;
    case 1145:
      HASH_INVOKE(0x4859AF715D5A3479LL, magickmagnifyimage);
      break;
    case 1148:
      HASH_INVOKE(0x1A08C578AD3BC47CLL, apache_response_headers);
      HASH_INVOKE(0x2FA7269AB0E1147CLL, mysql_field_seek);
      break;
    case 1150:
      HASH_INVOKE(0x1D583AA4F7F6547ELL, drawpathlinetorelative);
      HASH_INVOKE(0x0AC36D9F961B247ELL, newpixeliterator);
      break;
    case 1151:
      HASH_INVOKE(0x68AE04B02253B47FLL, mb_parse_str);
      break;
    case 1154:
      HASH_INVOKE(0x4590C853C2027482LL, magickembossimage);
      break;
    case 1157:
      HASH_INVOKE(0x250DD3D58EA37485LL, gmstrftime);
      HASH_INVOKE(0x61499C92F4FBA485LL, hphp_splfileobject_fgetc);
      break;
    case 1161:
      HASH_INVOKE(0x4F7EAF5B37663489LL, magickgetimageredprimary);
      HASH_INVOKE(0x7505924F05854489LL, dom_element_set_attribute_ns);
      break;
    case 1162:
      HASH_INVOKE(0x7E88764A1DE8548ALL, drawgetstrokewidth);
      break;
    case 1163:
      HASH_INVOKE(0x5860ACF621DD948BLL, is_file);
      break;
    case 1165:
      HASH_INVOKE(0x23511F83C2BC548DLL, header);
      HASH_INVOKE(0x275D127C87EF048DLL, mysql_db_query);
      break;
    case 1167:
      HASH_INVOKE(0x43672229728A648FLL, drawpushpattern);
      break;
    case 1171:
      HASH_INVOKE(0x56377FCC2447D493LL, magicksetimagepixels);
      break;
    case 1175:
      HASH_INVOKE(0x353E2A635A47F497LL, evhttp_get);
      HASH_INVOKE(0x5388045C2D13D497LL, mysql_num_fields);
      break;
    case 1181:
      HASH_INVOKE(0x7A59813AC331449DLL, mb_ereg_search_regs);
      break;
    case 1183:
      HASH_INVOKE(0x7FF66005524E649FLL, drawgettextdecoration);
      break;
    case 1188:
      HASH_INVOKE(0x6EC476E42A53A4A4LL, ldap_err2str);
      break;
    case 1189:
      HASH_INVOKE(0x18BE9B1C2DE6D4A5LL, imagexbm);
      break;
    case 1192:
      HASH_INVOKE(0x6F4497457F1584A8LL, dom_element_set_id_attribute_node);
      break;
    case 1193:
      HASH_INVOKE(0x386378F2BA3234A9LL, magickevaluateimage);
      break;
    case 1196:
      HASH_INVOKE(0x245AA2790C87C4ACLL, image_type_to_mime_type);
      HASH_INVOKE(0x6E8FFA56842304ACLL, drawgetfont);
      break;
    case 1197:
      HASH_INVOKE(0x3D98ACFCEBB764ADLL, hphp_set_property);
      break;
    case 1199:
      HASH_INVOKE(0x42463E7E5C3434AFLL, mb_strrichr);
      HASH_INVOKE(0x6AC751181531F4AFLL, simplexml_load_string);
      break;
    case 1200:
      HASH_INVOKE(0x0E11D317044974B0LL, magickgetnumberimages);
      HASH_INVOKE(0x3AF65A9F3653E4B0LL, addslashes);
      break;
    case 1201:
      HASH_INVOKE(0x060619D7A1B5F4B1LL, checkdate);
      break;
    case 1203:
      HASH_INVOKE(0x57034CAD772AF4B3LL, magickgetimagechannelmean);
      break;
    case 1204:
      HASH_INVOKE(0x00621C58E54D44B4LL, hphp_recursiveiteratoriterator_key);
      break;
    case 1206:
      HASH_INVOKE(0x3DE291DCBA5134B6LL, dom_document_create_element);
      HASH_INVOKE(0x12A9166E68DCF4B6LL, pixelgetgreen);
      break;
    case 1207:
      HASH_INVOKE(0x7EEBC81AF9BC54B7LL, xml_parser_free);
      break;
    case 1209:
      HASH_INVOKE(0x5351290CD139A4B9LL, mb_strrpos);
      break;
    case 1210:
      HASH_INVOKE(0x6B49D11E633274BALL, fopen);
      break;
    case 1213:
      HASH_INVOKE(0x35BE8F6E7726C4BDLL, dechex);
      HASH_INVOKE(0x5BA371A93F60F4BDLL, use_soap_error_handler);
      break;
    case 1214:
      HASH_INVOKE(0x57278846B8B0E4BELL, ldap_count_entries);
      break;
    case 1215:
      HASH_INVOKE(0x01681C307C5AE4BFLL, strtoupper);
      break;
    case 1219:
      HASH_INVOKE(0x7AAC29849263C4C3LL, getprotobyname);
      break;
    case 1220:
      HASH_INVOKE(0x67EADCF4E81084C4LL, mb_ereg);
      HASH_INVOKE(0x4A24DB9D6B0334C4LL, hphp_recursivedirectoryiterator_next);
      break;
    case 1221:
      HASH_INVOKE(0x34A38DDF2CD914C5LL, long2ip);
      break;
    case 1222:
      HASH_INVOKE(0x651F7FBBA90604C6LL, magickgetimageindex);
      HASH_INVOKE(0x4F7AA8120E33E4C6LL, collator_get_attribute);
      break;
    case 1224:
      HASH_INVOKE(0x1B8BBFC882FDB4C8LL, magicktintimage);
      break;
    case 1230:
      HASH_INVOKE(0x60783C20BF7724CELL, mailparse_msg_free);
      break;
    case 1231:
      HASH_INVOKE(0x72DECE786967A4CFLL, magickpreviousimage);
      break;
    case 1233:
      HASH_INVOKE(0x29EE24C41FD3D4D1LL, mysql_field_name);
      break;
    case 1238:
      HASH_INVOKE(0x19ECDD5A937DD4D6LL, mailparse_msg_get_part_data);
      break;
    case 1239:
      HASH_INVOKE(0x215403F1E335C4D7LL, magicksolarizeimage);
      break;
    case 1240:
      HASH_INVOKE(0x2532EB687D51E4D8LL, unregister_tick_function);
      HASH_INVOKE(0x14BF763DDDC014D8LL, imagepsencodefont);
      HASH_INVOKE(0x56B908FC91C834D8LL, magickflopimage);
      HASH_INVOKE(0x1301F911ED6D54D8LL, is_nan);
      HASH_INVOKE(0x575C5AE3D2A694D8LL, ob_end_clean);
      break;
    case 1247:
      HASH_INVOKE(0x747A7F585CD694DFLL, zend_version);
      HASH_INVOKE(0x2E5E5A0FC3B5C4DFLL, xml_set_character_data_handler);
      break;
    case 1248:
      HASH_INVOKE(0x340A51AE22A924E0LL, reset);
      break;
    case 1251:
      HASH_INVOKE(0x7D57A0D72D6254E3LL, ob_implicit_flush);
      break;
    case 1262:
      HASH_INVOKE(0x5895ADDD91F354EELL, hphp_thread_set_warmup_enabled);
      break;
    case 1265:
      HASH_INVOKE(0x65BD541EAB38E4F1LL, mysql_close);
      break;
    case 1266:
      HASH_INVOKE(0x41276F8DE35354F2LL, dom_document_get_elements_by_tag_name);
      break;
    case 1268:
      HASH_INVOKE(0x436B36C5EB8DB4F4LL, mcrypt_generic);
      break;
    case 1269:
      HASH_INVOKE(0x528AC8D252D224F5LL, log10);
      HASH_INVOKE(0x112A0ACDD8B9D4F5LL, mb_list_mime_names);
      break;
    case 1271:
      HASH_INVOKE(0x0BD9C5D811CB04F7LL, dom_element_set_id_attribute_ns);
      break;
    case 1272:
      HASH_INVOKE(0x011006D90D79E4F8LL, mysql_errno);
      break;
    case 1277:
      HASH_INVOKE(0x002387F1D23B44FDLL, mcrypt_list_modes);
      HASH_INVOKE(0x2CEAE845E4F404FDLL, dom_document_save);
      break;
    case 1287:
      HASH_INVOKE(0x4FC9FE38A748B507LL, intl_get_error_message);
      HASH_INVOKE(0x197A5D237BD4C507LL, mb_ereg_search_getpos);
      break;
    case 1288:
      HASH_INVOKE(0x63A08D6AD1209508LL, magickgetexception);
      break;
    case 1291:
      HASH_INVOKE(0x71DCF11E3640C50BLL, hphp_directoryiterator_valid);
      break;
    case 1295:
      HASH_INVOKE(0x5A66CCB3D924450FLL, xml_parser_create);
      break;
    case 1297:
      HASH_INVOKE(0x09D5355CA8198511LL, mb_internal_encoding);
      HASH_INVOKE(0x3C0304A55503D511LL, magickgetimageiterations);
      break;
    case 1299:
      HASH_INVOKE(0x772E8BF114FEF513LL, eregi_replace);
      break;
    case 1300:
      HASH_INVOKE(0x100385A0988FD514LL, magickgetfilename);
      break;
    case 1305:
      HASH_INVOKE(0x54EDBB6BAF318519LL, memcache_add);
      break;
    case 1314:
      HASH_INVOKE(0x7DA98E0379D33522LL, chdir);
      break;
    case 1316:
      HASH_INVOKE(0x28E724EDE0BB6524LL, mb_strcut);
      break;
    case 1317:
      HASH_INVOKE(0x230FE1D6EC599525LL, link);
      break;
    case 1318:
      HASH_INVOKE(0x57DDA4C3F7FF8526LL, fputcsv);
      break;
    case 1319:
      HASH_INVOKE(0x6B2B942CAF1A2527LL, array_shift);
      break;
    case 1324:
      HASH_INVOKE(0x1AB55BBA0967952CLL, mb_convert_variables);
      break;
    case 1327:
      HASH_INVOKE(0x6770E2559C9A152FLL, openssl_private_decrypt);
      break;
    case 1329:
      HASH_INVOKE(0x6776C27C6123D531LL, dl);
      break;
    case 1330:
      HASH_INVOKE(0x6193A26936F4D532LL, disk_total_space);
      break;
    case 1331:
      HASH_INVOKE(0x313D2A505076A533LL, dir);
      break;
    case 1333:
      HASH_INVOKE(0x6C87406DDC0AB535LL, mcrypt_ecb);
      break;
    case 1334:
      HASH_INVOKE(0x0E80D04691227536LL, eval);
      HASH_INVOKE(0x746DC7AD953EA536LL, memcache_set_compress_threshold);
      break;
    case 1335:
      HASH_INVOKE(0x0830FF7C379D7537LL, dom_text_split_text);
      HASH_INVOKE(0x557C72DE98679537LL, hash_update_stream);
      HASH_INVOKE(0x175B86BCB3124537LL, magickgetexceptionstring);
      break;
    case 1337:
      HASH_INVOKE(0x3C88F0FAC3EDD539LL, phpversion);
      break;
    case 1340:
      HASH_INVOKE(0x5CA55E62F2A5953CLL, drawgetstrokeopacity);
      break;
    case 1341:
      HASH_INVOKE(0x0F32841DBF7A053DLL, fb_crossall_query);
      break;
    case 1342:
      HASH_INVOKE(0x36A80B48E08B753ELL, implode);
      break;
    case 1346:
      HASH_INVOKE(0x59A44591E67D4542LL, drawrender);
      break;
    case 1347:
      HASH_INVOKE(0x20E2B1D920122543LL, die);
      HASH_INVOKE(0x0962EACAE0F0B543LL, hphp_splfileinfo_getlinktarget);
      break;
    case 1348:
      HASH_INVOKE(0x4D397FE5D0C0B544LL, magickmedianfilterimage);
      break;
    case 1350:
      HASH_INVOKE(0x12A739BE0ED32546LL, ignore_user_abort);
      HASH_INVOKE(0x081F76AC889BC546LL, getrusage);
      break;
    case 1352:
      HASH_INVOKE(0x0AD3BFAB5F780548LL, magickcoalesceimages);
      break;
    case 1355:
      HASH_INVOKE(0x40CE61115E11154BLL, msg_stat_queue);
      break;
    case 1356:
      HASH_INVOKE(0x1D011CB0E810D54CLL, pdo_drivers);
      break;
    case 1357:
      HASH_INVOKE(0x0F0702D91EAFB54DLL, drawgettextantialias);
      HASH_INVOKE(0x1B9E769FFEC3C54DLL, pcntl_wtermsig);
      break;
    case 1359:
      HASH_INVOKE(0x30DE78E7131B954FLL, furchash_hphp_ext_supported);
      HASH_INVOKE(0x063200B5AAFEC54FLL, mysql_thread_id);
      break;
    case 1370:
      HASH_INVOKE(0x268EE73DB2EA555ALL, get_object_vars);
      break;
    case 1372:
      HASH_INVOKE(0x5749AD20CAFCD55CLL, pixelgetbluequantum);
      break;
    case 1379:
      HASH_INVOKE(0x1B1B2D70792D9563LL, mysql_get_client_info);
      break;
    case 1382:
      HASH_INVOKE(0x6E2FDBD28F895566LL, timezone_abbreviations_list);
      HASH_INVOKE(0x3DA2058E5C540566LL, spliti);
      break;
    case 1386:
      HASH_INVOKE(0x74599147803DC56ALL, magickgetstringwidth);
      break;
    case 1387:
      HASH_INVOKE(0x0DE86977367F656BLL, register_shutdown_function);
      break;
    case 1390:
      HASH_INVOKE(0x2A1F1B52160DE56ELL, zend_logo_guid);
      break;
    case 1391:
      HASH_INVOKE(0x016722439BBA756FLL, filetype);
      break;
    case 1392:
      HASH_INVOKE(0x13D0427F3BB3E570LL, get_declared_interfaces);
      HASH_INVOKE(0x21B3935EB3140570LL, mysql_fetch_object);
      break;
    case 1393:
      HASH_INVOKE(0x2AD3361DE8B1D571LL, pcntl_signal_dispatch);
      break;
    case 1396:
      HASH_INVOKE(0x636C871213F37574LL, mcrypt_encrypt);
      break;
    case 1399:
      HASH_INVOKE(0x412521E7ADB21577LL, iconv_mime_decode_headers);
      HASH_INVOKE(0x1E154D823451B577LL, magicksetresolution);
      break;
    case 1401:
      HASH_INVOKE(0x1DC8A386E219C579LL, ldap_add);
      break;
    case 1405:
      HASH_INVOKE(0x78EDB608B02A857DLL, join);
      HASH_INVOKE(0x22E08DEDF360057DLL, pixelsetmagenta);
      break;
    case 1406:
      HASH_INVOKE(0x31529E9BCA1E157ELL, shm_remove);
      HASH_INVOKE(0x132776D93181E57ELL, ldap_set_option);
      break;
    case 1410:
      HASH_INVOKE(0x02688986D5D76582LL, magickspreadimage);
      HASH_INVOKE(0x0B1F0EB755BDB582LL, ispixeliterator);
      break;
    case 1411:
      HASH_INVOKE(0x3B2CD86F5DB72583LL, magickblackthresholdimage);
      break;
    case 1419:
      HASH_INVOKE(0x1EF2C1426AB0A58BLL, dom_node_replace_child);
      HASH_INVOKE(0x3A34B44E4C51C58BLL, xml_set_element_handler);
      break;
    case 1420:
      HASH_INVOKE(0x560C2F71978CE58CLL, shm_put_var);
      break;
    case 1426:
      HASH_INVOKE(0x3E9519FE856C4592LL, curl_multi_init);
      HASH_INVOKE(0x5464E148E8A0C592LL, get_extension_funcs);
      HASH_INVOKE(0x7F65501600346592LL, mcrypt_get_block_size);
      break;
    case 1427:
      HASH_INVOKE(0x0F5984B8A7FD8593LL, hphp_splfileinfo_getperms);
      break;
    case 1431:
      HASH_INVOKE(0x513787A813DB0597LL, date_date_set);
      break;
    case 1433:
      HASH_INVOKE(0x12F502A88E0AA599LL, magickcompositeimage);
      break;
    case 1434:
      HASH_INVOKE(0x77F1EDE7D5EF759ALL, apc_cache_info);
      break;
    case 1435:
      HASH_INVOKE(0x37D003B09D0C759BLL, stream_get_contents);
      break;
    case 1440:
      HASH_INVOKE(0x20502FCACBB9F5A0LL, convert_uuencode);
      break;
    case 1441:
      HASH_INVOKE(0x297690F3A63335A1LL, magickrotateimage);
      break;
    case 1444:
      HASH_INVOKE(0x3C014439AE5D75A4LL, magickgetcharheight);
      break;
    case 1448:
      HASH_INVOKE(0x4FBB1F662399A5A8LL, is_soap_fault);
      break;
    case 1451:
      HASH_INVOKE(0x79E0380A18A345ABLL, apache_get_modules);
      break;
    case 1452:
      HASH_INVOKE(0x763BA2B1C60A55ACLL, pixelgetalphaquantum);
      break;
    case 1453:
      HASH_INVOKE(0x4110AF96B98B25ADLL, gzeof);
      break;
    case 1455:
      HASH_INVOKE(0x1636FBA5043CF5AFLL, ldap_error);
      break;
    case 1459:
      HASH_INVOKE(0x001DBE44BC0B55B3LL, magicksetimagecolormapcolor);
      HASH_INVOKE(0x7AFA32F70E8195B3LL, xbox_set_thread_timeout);
      break;
    case 1461:
      HASH_INVOKE(0x3F9C5B4708FC55B5LL, timezone_name_get);
      HASH_INVOKE(0x5EFE573046B565B5LL, mcrypt_module_close);
      break;
    case 1462:
      HASH_INVOKE(0x1A05907F563235B6LL, collator_set_attribute);
      break;
    case 1466:
      HASH_INVOKE(0x05B8EB2C515885BALL, vprintf);
      break;
    case 1472:
      HASH_INVOKE(0x61465CD8C67905C0LL, openssl_pkey_free);
      break;
    case 1473:
      HASH_INVOKE(0x7731B90FB7C975C1LL, magickremoveimageprofile);
      break;
    case 1478:
      HASH_INVOKE(0x3B3D5CE69B1565C6LL, mcrypt_module_is_block_mode);
      break;
    case 1480:
      HASH_INVOKE(0x1CE8175A87C785C8LL, dom_document_validate);
      break;
    case 1481:
      HASH_INVOKE(0x75B299F5E35A95C9LL, mb_strwidth);
      HASH_INVOKE(0x60F8818C0F38D5C9LL, hphp_directoryiterator___tostring);
      break;
    case 1483:
      HASH_INVOKE(0x6751946191FBE5CBLL, override_function);
      break;
    case 1484:
      HASH_INVOKE(0x2A6F86821A39C5CCLL, expm1);
      break;
    case 1486:
      HASH_INVOKE(0x406AC1DDB92925CELL, parse_hdf_file);
      break;
    case 1487:
      HASH_INVOKE(0x5D9818B3E1C385CFLL, openssl_pkey_export_to_file);
      break;
    case 1489:
      HASH_INVOKE(0x054503DBBF5CA5D1LL, imagecopy);
      break;
    case 1492:
      HASH_INVOKE(0x2FE56B4C457AB5D4LL, ctype_graph);
      break;
    case 1493:
      HASH_INVOKE(0x43901543EA8625D5LL, curl_multi_select);
      break;
    case 1494:
      HASH_INVOKE(0x6D265875A19685D6LL, is_float);
      break;
    case 1495:
      HASH_INVOKE(0x617AD1AD708785D7LL, magickmodulateimage);
      break;
    case 1508:
      HASH_INVOKE(0x3A9643992AC805E4LL, magickdrawimage);
      break;
    case 1509:
      HASH_INVOKE(0x470F990B218315E5LL, fb_unset_taint);
      break;
    case 1510:
      HASH_INVOKE(0x6FE2E44FBC44E5E6LL, magickaddnoiseimage);
      HASH_INVOKE(0x08069ECE0EA3C5E6LL, imagecopymergegray);
      break;
    case 1514:
      HASH_INVOKE(0x0B7ACBAB402015EALL, mb_send_mail);
      break;
    case 1518:
      HASH_INVOKE(0x3076D369F63E65EELL, pixelgetalpha);
      break;
    case 1524:
      HASH_INVOKE(0x1E89F15B7F2805F4LL, openssl_pkcs7_encrypt);
      HASH_INVOKE(0x459330C31956A5F4LL, vsprintf);
      break;
    case 1525:
      HASH_INVOKE(0x0D1BD0E5AF4175F5LL, drawsetfont);
      HASH_INVOKE(0x73A1F34DF95B35F5LL, get_defined_constants);
      break;
    case 1527:
      HASH_INVOKE(0x18E4CC945005E5F7LL, drawpushclippath);
      break;
    case 1528:
      HASH_INVOKE(0x7C48F6EA39B7B5F8LL, magickadaptivethresholdimage);
      break;
    case 1531:
      HASH_INVOKE(0x3535B6615F2B05FBLL, session_cache_limiter);
      HASH_INVOKE(0x0FEC4ED541B7F5FBLL, magickgetimagevirtualpixelmethod);
      break;
    case 1532:
      HASH_INVOKE(0x39156C7CCE2D75FCLL, hash_update);
      break;
    case 1533:
      HASH_INVOKE(0x0C1CB24A3FC065FDLL, bcmul);
      HASH_INVOKE(0x46832743CAF5C5FDLL, dom_element_set_attribute_node);
      break;
    case 1534:
      HASH_INVOKE(0x397D3C6576ED75FELL, set_include_path);
      break;
    case 1535:
      HASH_INVOKE(0x40A557CBB9FC35FFLL, mysql_tablename);
      break;
    case 1536:
      HASH_INVOKE(0x552D7CAD93755600LL, dom_document_create_comment);
      break;
    case 1537:
      HASH_INVOKE(0x0F3403D8676C2601LL, mysql_query);
      break;
    case 1545:
      HASH_INVOKE(0x52D5698F31D12609LL, pcntl_setpriority);
      break;
    case 1555:
      HASH_INVOKE(0x36783304F63C4613LL, sscanf);
      HASH_INVOKE(0x4AC405EA2B8C4613LL, magickresetiterator);
      break;
    case 1557:
      HASH_INVOKE(0x6AD774816F8F7615LL, mb_strrchr);
      break;
    case 1558:
      HASH_INVOKE(0x66C7616225F1C616LL, pixelsetgreen);
      HASH_INVOKE(0x7FA6D13B0D38E616LL, imagegif);
      break;
    case 1561:
      HASH_INVOKE(0x6DD51BF03F003619LL, mailparse_uudecode_all);
      HASH_INVOKE(0x2F29627AF1A97619LL, shm_attach);
      break;
    case 1563:
      HASH_INVOKE(0x40DDE277D934061BLL, gzputs);
      break;
    case 1564:
      HASH_INVOKE(0x70725954DC99F61CLL, mcrypt_create_iv);
      break;
    case 1565:
      HASH_INVOKE(0x69E1368FD737F61DLL, dom_namednodemap_get_named_item);
      HASH_INVOKE(0x7E98B97C1B5D861DLL, magickqueryconfigureoptions);
      break;
    case 1569:
      HASH_INVOKE(0x0F71DDE51AA55621LL, hphp_output_global_state);
      break;
    case 1570:
      HASH_INVOKE(0x134550B9EB596622LL, drawgetfontstyle);
      break;
    case 1576:
      HASH_INVOKE(0x1E77B3BCF062D628LL, magickreadimage);
      break;
    case 1577:
      HASH_INVOKE(0x679B81CE06EE0629LL, bcdiv);
      break;
    case 1578:
      HASH_INVOKE(0x608EA42B08A7462ALL, linkinfo);
      break;
    case 1580:
      HASH_INVOKE(0x5CEA60D9C54A162CLL, pcntl_wifstopped);
      break;
    case 1583:
      HASH_INVOKE(0x652C331CE138362FLL, is_string);
      break;
    case 1585:
      HASH_INVOKE(0x5AD6595ACA656631LL, pixelresetiterator);
      break;
    case 1591:
      HASH_INVOKE(0x60276BC7990F9637LL, mysql_list_dbs);
      HASH_INVOKE(0x75AFA49220C9B637LL, collator_sort);
      break;
    case 1595:
      HASH_INVOKE(0x391C68F2BE85E63BLL, pixelgetiteratorexceptionstring);
      break;
    case 1596:
      HASH_INVOKE(0x62DE03461EF4663CLL, symlink);
      break;
    case 1598:
      HASH_INVOKE(0x60302D15A677963ELL, ldap_free_result);
      break;
    case 1599:
      HASH_INVOKE(0x17242BC6C9C9563FLL, crypt);
      break;
    case 1606:
      HASH_INVOKE(0x4901517CB796F646LL, msg_set_queue);
      HASH_INVOKE(0x234F6A0A486E8646LL, natcasesort);
      break;
    case 1614:
      HASH_INVOKE(0x7E978C38D741664ELL, fgetcsv);
      HASH_INVOKE(0x769E5C6A5369F64ELL, ob_list_handlers);
      break;
    case 1618:
      HASH_INVOKE(0x03066277F647E652LL, hphp_splfileobject_ftell);
      break;
    case 1621:
      HASH_INVOKE(0x629EDDC1E74ED655LL, array_uintersect_assoc);
      break;
    case 1625:
      HASH_INVOKE(0x7A4B37C23D674659LL, collator_get_error_message);
      break;
    case 1628:
      HASH_INVOKE(0x381BBFEABFEC865CLL, libxml_get_last_error);
      break;
    case 1630:
      HASH_INVOKE(0x1491ED033E39465ELL, dom_document_schema_validate_xml);
      HASH_INVOKE(0x205BB9CFF397B65ELL, ldap_mod_replace);
      break;
    case 1631:
      HASH_INVOKE(0x1355AFB40AB1165FLL, drawsetfontstyle);
      break;
    case 1634:
      HASH_INVOKE(0x5629E14D6B9FF662LL, dom_document_get_element_by_id);
      break;
    case 1636:
      HASH_INVOKE(0x5B0759F776EC2664LL, newdrawingwand);
      break;
    case 1637:
      HASH_INVOKE(0x08A6AD20C2C5A665LL, hphp_set_static_property);
      break;
    case 1639:
      HASH_INVOKE(0x557A08AC57724667LL, hphp_splfileinfo_getpathinfo);
      break;
    case 1647:
      HASH_INVOKE(0x7D68CADB8069466FLL, magickaverageimages);
      break;
    case 1651:
      HASH_INVOKE(0x126FC82D358E9673LL, magicksetimagevirtualpixelmethod);
      break;
    case 1655:
      HASH_INVOKE(0x001F23CAC36E3677LL, magickgetimagescene);
      break;
    case 1658:
      HASH_INVOKE(0x583AA7498A40E67ALL, drawgetcliprule);
      break;
    case 1659:
      HASH_INVOKE(0x5BCED33A57D9B67BLL, intval);
      break;
    case 1660:
      HASH_INVOKE(0x43B1BAFFB27F367CLL, session_is_registered);
      break;
    case 1661:
      HASH_INVOKE(0x69616E2817E1967DLL, fileinode);
      HASH_INVOKE(0x111DACCF8628267DLL, array_replace_recursive);
      break;
    case 1666:
      HASH_INVOKE(0x665D2615E377A682LL, pagelet_server_task_start);
      HASH_INVOKE(0x5F6750E1C7E5D682LL, imageinterlace);
      break;
    case 1677:
      HASH_INVOKE(0x07A946E3DD8E968DLL, ldap_connect);
      break;
    case 1679:
      HASH_INVOKE(0x2EFF4F69EB1DF68FLL, apache_get_config);
      break;
    case 1680:
      HASH_INVOKE(0x166D5E2336878690LL, imagepolygon);
      break;
    case 1681:
      HASH_INVOKE(0x57BA0BC1A4870691LL, magickgetquantumdepth);
      break;
    case 1682:
      HASH_INVOKE(0x16BE0DBA42800692LL, magickgetimagesize);
      break;
    case 1684:
      HASH_INVOKE(0x2673FAB2B4DE4694LL, destroypixelwands);
      break;
    case 1685:
      HASH_INVOKE(0x7186EF5EF0581695LL, exp);
      break;
    case 1686:
      HASH_INVOKE(0x0DD7A2DB53093696LL, utf8_decode);
      break;
    case 1690:
      HASH_INVOKE(0x5CC40F6A365FE69ALL, session_register);
      break;
    case 1691:
      HASH_INVOKE(0x24D34E49C21DE69BLL, mb_stristr);
      break;
    case 1694:
      HASH_INVOKE(0x5E9821F06711669ELL, gethostbynamel);
      break;
    case 1702:
      HASH_INVOKE(0x0D841874977646A6LL, krsort);
      break;
    case 1703:
      HASH_INVOKE(0x38BBEE42F136D6A7LL, magickgetimageblueprimary);
      break;
    case 1704:
      HASH_INVOKE(0x45AB8F419BA666A8LL, drawpathlinetohorizontalabsolute);
      break;
    case 1706:
      HASH_INVOKE(0x6E9D4D3A119D76AALL, wandgetexceptiontype);
      HASH_INVOKE(0x48C4DB333172F6AALL, parse_url);
      HASH_INVOKE(0x541926FB6D6FC6AALL, magickgetimagecolors);
      break;
    case 1707:
      HASH_INVOKE(0x72B3F8E02D8B16ABLL, array_unshift);
      break;
    case 1711:
      HASH_INVOKE(0x65497D63C0D716AFLL, getdate);
      break;
    case 1712:
      HASH_INVOKE(0x23AAF570C78AC6B0LL, ip2long);
      break;
    case 1714:
      HASH_INVOKE(0x0D669C546C0EC6B2LL, proc_terminate);
      break;
    case 1717:
      HASH_INVOKE(0x798B4197212456B5LL, bcpowmod);
      HASH_INVOKE(0x623CE67C41A9E6B5LL, ldap_next_attribute);
      HASH_INVOKE(0x7E773A36449576B5LL, imagecharup);
      break;
    case 1719:
      HASH_INVOKE(0x0C44E5EEB9C646B7LL, memcache_connect);
      break;
    case 1721:
      HASH_INVOKE(0x316F054CB76446B9LL, openssl_sign);
      break;
    case 1722:
      HASH_INVOKE(0x4605D48C234606BALL, dom_document_import_node);
      HASH_INVOKE(0x72B901C3605CB6BALL, pixelsetopacity);
      break;
    case 1726:
      HASH_INVOKE(0x081D5EA9920076BELL, drawgetfillalpha);
      break;
    case 1732:
      HASH_INVOKE(0x4842AF70A71BE6C4LL, uksort);
      HASH_INVOKE(0x34184B42D6AA86C4LL, mb_ereg_search_pos);
      HASH_INVOKE(0x3C042C09F662C6C4LL, drawsetstrokepatternurl);
      break;
    case 1733:
      HASH_INVOKE(0x28526EF49FF516C5LL, pixelsetgreenquantum);
      break;
    case 1736:
      HASH_INVOKE(0x29DD2C9F889246C8LL, passthru);
      break;
    case 1737:
      HASH_INVOKE(0x2D8DF100C30D06C9LL, xmlwriter_set_indent_string);
      break;
    case 1738:
      HASH_INVOKE(0x41BCD0A72B1396CALL, xmlwriter_start_dtd_attlist);
      break;
    case 1745:
      HASH_INVOKE(0x2B3D5B9AF915D6D1LL, imagecopymerge);
      break;
    case 1746:
      HASH_INVOKE(0x1FDF80EA9B8A96D2LL, collator_set_strength);
      break;
    case 1748:
      HASH_INVOKE(0x04A0E6E8337E56D4LL, drawcolor);
      break;
    case 1749:
      HASH_INVOKE(0x317FFA522A7D96D5LL, imagefilledpolygon);
      break;
    case 1750:
      HASH_INVOKE(0x158348EB08F406D6LL, strtr);
      break;
    case 1761:
      HASH_INVOKE(0x11DA0A0EB8E0D6E1LL, clock_getres);
      break;
    case 1764:
      HASH_INVOKE(0x40D0E3AF799226E4LL, bin2hex);
      HASH_INVOKE(0x1CF3544CB5C9D6E4LL, xml_set_processing_instruction_handler);
      HASH_INVOKE(0x31FFFC333AA6D6E4LL, drawsetfillrule);
      break;
    case 1767:
      HASH_INVOKE(0x44201A16F3D876E7LL, trim);
      break;
    case 1772:
      HASH_INVOKE(0x0A5EFECAE87EA6ECLL, hphp_splfileobject_eof);
      break;
    case 1773:
      HASH_INVOKE(0x04BD4B43921956EDLL, ldap_search);
      HASH_INVOKE(0x2B661CD43C6006EDLL, hphpd_break);
      break;
    case 1774:
      HASH_INVOKE(0x76382756EA00B6EELL, is_object);
      break;
    case 1775:
      HASH_INVOKE(0x0FA74D85885F86EFLL, output_add_rewrite_var);
      break;
    case 1776:
      HASH_INVOKE(0x014BD9A6823256F0LL, extract);
      break;
    case 1777:
      HASH_INVOKE(0x6B7347DF1AA7E6F1LL, drawpopdefs);
      break;
    case 1778:
      HASH_INVOKE(0x314DA880FE2CE6F2LL, session_start);
      break;
    case 1779:
      HASH_INVOKE(0x6F1968BE449FB6F3LL, stream_socket_pair);
      HASH_INVOKE(0x5768A80BB0B926F3LL, apd_set_session_trace_socket);
      break;
    case 1782:
      HASH_INVOKE(0x534C1A5E626C26F6LL, collator_get_error_code);
      break;
    case 1785:
      HASH_INVOKE(0x20740D956F0236F9LL, image2wbmp);
      break;
    case 1791:
      HASH_INVOKE(0x623C20A027A606FFLL, array_uintersect_uassoc);
      break;
    case 1793:
      HASH_INVOKE(0x1A80392751AA7701LL, magickgetformat);
      break;
    case 1796:
      HASH_INVOKE(0x5EFE15CE970A5704LL, drawpolyline);
      break;
    case 1801:
      HASH_INVOKE(0x7681C631B34CC709LL, hphp_splfileobject_fflush);
      HASH_INVOKE(0x21972B2BC7A14709LL, imageistruecolor);
      break;
    case 1803:
      HASH_INVOKE(0x27AF8F6A5DF0B70BLL, dom_document_xinclude);
      HASH_INVOKE(0x5F7873F2DF5BE70BLL, ctype_cntrl);
      break;
    case 1805:
      HASH_INVOKE(0x7CE752299E80B70DLL, unserialize);
      HASH_INVOKE(0x4F3C0DB2F6C8F70DLL, unlink);
      break;
    case 1807:
      HASH_INVOKE(0x2FB2FA1DD832C70FLL, xmlwriter_write_attribute_ns);
      break;
    case 1812:
      HASH_INVOKE(0x1778ED2AF035F714LL, rsort);
      break;
    case 1813:
      HASH_INVOKE(0x25D578B4772C1715LL, define);
      break;
    case 1816:
      HASH_INVOKE(0x7971A5647C957718LL, date_time_set);
      break;
    case 1819:
      HASH_INVOKE(0x3C16230CBC6D471BLL, imagecreatetruecolor);
      break;
    case 1820:
      HASH_INVOKE(0x50AC61A28C5AC71CLL, imagecolorclosestalpha);
      break;
    case 1824:
      HASH_INVOKE(0x2D213FD80048F720LL, usleep);
      break;
    case 1827:
      HASH_INVOKE(0x78420E0B5D110723LL, imagetruecolortopalette);
      break;
    case 1828:
      HASH_INVOKE(0x4DAA3FBC2BD3A724LL, magickequalizeimage);
      break;
    case 1829:
      HASH_INVOKE(0x31EAD049860CE725LL, posix_kill);
      break;
    case 1830:
      HASH_INVOKE(0x523AB2EA95DAD726LL, get_included_files);
      break;
    case 1831:
      HASH_INVOKE(0x11641BE0F11CD727LL, magickgammaimage);
      break;
    case 1833:
      HASH_INVOKE(0x1D30F1E638D71729LL, readgzfile);
      break;
    case 1834:
      HASH_INVOKE(0x17C0D9B1C10B872ALL, openssl_x509_export);
      HASH_INVOKE(0x1F98B41362CDA72ALL, magickgetimagegreenprimary);
      break;
    case 1837:
      HASH_INVOKE(0x14563723F798172DLL, magickpaintopaqueimage);
      break;
    case 1840:
      HASH_INVOKE(0x0D558F552A784730LL, ob_get_contents);
      break;
    case 1842:
      HASH_INVOKE(0x2B1C192C419B8732LL, drawgetexception);
      break;
    case 1850:
      HASH_INVOKE(0x404236CC5ABD973ALL, xhprof_run_trace);
      break;
    case 1855:
      HASH_INVOKE(0x650E641CC0E3873FLL, connection_aborted);
      break;
    case 1857:
      HASH_INVOKE(0x5062777D2B947741LL, wordwrap);
      break;
    case 1863:
      HASH_INVOKE(0x3CD58419E181A747LL, magickstereoimage);
      HASH_INVOKE(0x13BB9EC5A2D2E747LL, hphp_splfileinfo_isdir);
      break;
    case 1864:
      HASH_INVOKE(0x0D7BBA9608A36748LL, magickcombineimages);
      break;
    case 1865:
      HASH_INVOKE(0x73E4417BA7B49749LL, curl_multi_info_read);
      break;
    case 1866:
      HASH_INVOKE(0x1FF03B7DE19DD74ALL, drawpathmovetorelative);
      break;
    case 1867:
      HASH_INVOKE(0x7DA9307A6149B74BLL, get_meta_tags);
      break;
    case 1873:
      HASH_INVOKE(0x017FF216C00D9751LL, property_exists);
      break;
    case 1875:
      HASH_INVOKE(0x42795829DF700753LL, mysql_get_host_info);
      break;
    case 1876:
      HASH_INVOKE(0x53AEFD595C044754LL, max);
      break;
    case 1879:
      HASH_INVOKE(0x7554E3E8674F2757LL, mb_list_encodings);
      break;
    case 1883:
      HASH_INVOKE(0x05D293F45C15F75BLL, ldap_mod_del);
      break;
    case 1884:
      HASH_INVOKE(0x6D5B592E524AF75CLL, hphp_splfileinfo_getbasename);
      break;
    case 1887:
      HASH_INVOKE(0x3EDB48C5DDD9675FLL, socket_select);
      break;
    case 1888:
      HASH_INVOKE(0x1BD984C11BB16760LL, array_merge);
      HASH_INVOKE(0x7AB5E6EA37196760LL, date_timezone_set);
      break;
    case 1889:
      HASH_INVOKE(0x6AF50085AC2AC761LL, xmlwriter_write_element);
      break;
    case 1891:
      HASH_INVOKE(0x7FCE6DD53FED6763LL, intl_is_failure);
      break;
    case 1893:
      HASH_INVOKE(0x1D803CE961921765LL, md5);
      HASH_INVOKE(0x45631C592AD6D765LL, str_ireplace);
      break;
    case 1894:
      HASH_INVOKE(0x1F4505BE6460D766LL, scandir);
      break;
    case 1895:
      HASH_INVOKE(0x2FC27987B3F88767LL, dom_node_clone_node);
      HASH_INVOKE(0x6C280D5855D20767LL, drawsetfillalpha);
      break;
    case 1896:
      HASH_INVOKE(0x179A72074C778768LL, openssl_x509_export_to_file);
      break;
    case 1901:
      HASH_INVOKE(0x3304663FBC6C976DLL, get_html_translation_table);
      HASH_INVOKE(0x553ADA5A41AE976DLL, mb_ereg_replace);
      break;
    case 1902:
      HASH_INVOKE(0x6DB71D850799D76ELL, hphp_splfileobject_fscanf);
      break;
    case 1904:
      HASH_INVOKE(0x6F6C5B9E3DC64770LL, drawgetstrokemiterlimit);
      break;
    case 1909:
      HASH_INVOKE(0x04D9076808F79775LL, getenv);
      break;
    case 1910:
      HASH_INVOKE(0x616DDB67073A0776LL, ord);
      HASH_INVOKE(0x4102C410C5031776LL, magickcolorizeimage);
      break;
    case 1914:
      HASH_INVOKE(0x1FBF36B5D65E677ALL, fb_call_user_func_safe_return);
      HASH_INVOKE(0x4330CE9C9002477ALL, array_udiff_uassoc);
      break;
    case 1915:
      HASH_INVOKE(0x129E39AC523A977BLL, magickgethomeurl);
      break;
    case 1920:
      HASH_INVOKE(0x29824AAA934CE780LL, array_filter);
      break;
    case 1923:
      HASH_INVOKE(0x53B4DBE58B356783LL, imagesetthickness);
      HASH_INVOKE(0x38704D99FEA9B783LL, mysql_fetch_array);
      break;
    case 1924:
      HASH_INVOKE(0x784FD2E7191A3784LL, drawpathellipticarcrelative);
      break;
    case 1925:
      HASH_INVOKE(0x5BFC6198960A5785LL, in_array);
      break;
    case 1927:
      HASH_INVOKE(0x4991643BD854D787LL, drawgetexceptionstring);
      break;
    case 1928:
      HASH_INVOKE(0x32D8CE5D0FA6D788LL, ldap_rename);
      break;
    case 1930:
      HASH_INVOKE(0x70A1EC006032E78ALL, pixelgetquantumcolor);
      break;
    case 1935:
      HASH_INVOKE(0x7B4E25772D0AC78FLL, simplexml_load_file);
      break;
    case 1938:
      HASH_INVOKE(0x0D4891A5E1A20792LL, get_defined_functions);
      break;
    case 1941:
      HASH_INVOKE(0x34BA3AAA6711C795LL, dom_document_create_entity_reference);
      break;
    case 1942:
      HASH_INVOKE(0x5B42B2AB1B57D796LL, array_replace);
      break;
    case 1945:
      HASH_INVOKE(0x26D226FD28566799LL, date_isodate_set);
      break;
    case 1947:
      HASH_INVOKE(0x1196D899ACCD379BLL, evhttp_recv);
      break;
    case 1949:
      HASH_INVOKE(0x02ECD8C169DF579DLL, feof);
      break;
    case 1951:
      HASH_INVOKE(0x4B092931EFB7979FLL, mysql_create_db);
      break;
    case 1959:
      HASH_INVOKE(0x1F76E954F9A147A7LL, magickcontrastimage);
      break;
    case 1961:
      HASH_INVOKE(0x7C251B7DE8DB87A9LL, mcrypt_list_algorithms);
      HASH_INVOKE(0x7707A7FEA07FB7A9LL, hphp_recursivedirectoryiterator___construct);
      break;
    case 1962:
      HASH_INVOKE(0x45A53A884414A7AALL, pack);
      HASH_INVOKE(0x58D6464A3A9127AALL, apc_bin_loadfile);
      break;
    case 1965:
      HASH_INVOKE(0x7DA08D9D148837ADLL, posix_mkfifo);
      HASH_INVOKE(0x217C52A1EBDF87ADLL, apache_get_version);
      break;
    case 1966:
      HASH_INVOKE(0x00141B0E3E6F77AELL, xml_set_unparsed_entity_decl_handler);
      break;
    case 1967:
      HASH_INVOKE(0x16CB9891EF26D7AFLL, drawgetstrokedashoffset);
      break;
    case 1977:
      HASH_INVOKE(0x1FC9406FD7FCD7B9LL, strrpos);
      HASH_INVOKE(0x1B6467AD87E167B9LL, log1p);
      break;
    case 1983:
      HASH_INVOKE(0x3F46374E6E1B07BFLL, posix_getpwuid);
      break;
    case 1984:
      HASH_INVOKE(0x152D1AB941A647C0LL, hphp_get_extension_info);
      HASH_INVOKE(0x52FDAC1D298D67C0LL, mcrypt_enc_get_algorithms_name);
      break;
    case 1985:
      HASH_INVOKE(0x4E172EA6743697C1LL, ldap_first_entry);
      break;
    case 1988:
      HASH_INVOKE(0x3C696836396BE7C4LL, mb_language);
      break;
    case 1990:
      HASH_INVOKE(0x0C8A7BE6ABC957C6LL, clearpixeliterator);
      HASH_INVOKE(0x3D6D684AF537A7C6LL, ldap_explode_dn);
      break;
    case 1991:
      HASH_INVOKE(0x686C5142FD0337C7LL, lcg_value);
      break;
    case 1993:
      HASH_INVOKE(0x6BF7D7B5FBFF77C9LL, hphp_get_thread_id);
      break;
    case 1994:
      HASH_INVOKE(0x3C781898488687CALL, xml_parse);
      HASH_INVOKE(0x55B68546CFAC87CALL, magicksetimageresolution);
      break;
    case 1998:
      HASH_INVOKE(0x3AE33FEA6830C7CELL, magickshearimage);
      break;
    case 1999:
      HASH_INVOKE(0x2FAB1F75659707CFLL, is_scalar);
      break;
    case 2001:
      HASH_INVOKE(0x35B661C87484D7D1LL, openssl_csr_sign);
      break;
    case 2009:
      HASH_INVOKE(0x2ED6760DAA3A67D9LL, strcasecmp);
      break;
    case 2012:
      HASH_INVOKE(0x1FE65AFCC92967DCLL, rmdir);
      break;
    case 2013:
      HASH_INVOKE(0x2B5AEDF1A5FC47DDLL, strripos);
      break;
    case 2017:
      HASH_INVOKE(0x7AA1691D3D94A7E1LL, dom_xpath_evaluate);
      break;
    case 2018:
      HASH_INVOKE(0x0888289CBD2887E2LL, iconv_substr);
      break;
    case 2020:
      HASH_INVOKE(0x2621680306BC97E4LL, magicksetimagescene);
      break;
    case 2023:
      HASH_INVOKE(0x4215DDB57604F7E7LL, xmlwriter_start_pi);
      break;
    case 2024:
      HASH_INVOKE(0x53B7BF8991FA67E8LL, i18n_loc_get_error_code);
      break;
    case 2025:
      HASH_INVOKE(0x6BB8AC68771287E9LL, strcmp);
      break;
    case 2027:
      HASH_INVOKE(0x54AE7140B95027EBLL, pixelgetgreenquantum);
      HASH_INVOKE(0x1A397501431EC7EBLL, is_numeric);
      break;
    case 2029:
      HASH_INVOKE(0x0DC2C2D372EC97EDLL, hphp_crash_log);
      break;
    case 2031:
      HASH_INVOKE(0x5367B0F3A4D2D7EFLL, ldap_list);
      break;
    case 2032:
      HASH_INVOKE(0x14F700DD189DB7F0LL, drawsetclipunits);
      break;
    case 2035:
      HASH_INVOKE(0x73877357478137F3LL, posix_ctermid);
      HASH_INVOKE(0x4B57E07A323FE7F3LL, drawpathlinetoverticalabsolute);
      HASH_INVOKE(0x7F436B50B7BBD7F3LL, getcwd);
      break;
    case 2041:
      HASH_INVOKE(0x376FB2649384A7F9LL, str_pad);
      break;
    case 2042:
      HASH_INVOKE(0x0FD7C3144B4007FALL, libxml_set_streams_context);
      break;
    case 2045:
      HASH_INVOKE(0x238E501F2536E7FDLL, drawsetclippath);
      break;
    case 2048:
      HASH_INVOKE(0x0E66983DD04B0800LL, get_current_user);
      break;
    case 2049:
      HASH_INVOKE(0x290E54137CF06801LL, dom_nodelist_item);
      break;
    case 2051:
      HASH_INVOKE(0x10F7244AA9CB5803LL, imagepstext);
      break;
    case 2052:
      HASH_INVOKE(0x349A0DF6723B6804LL, pixelsetcolorcount);
      break;
    case 2054:
      HASH_INVOKE(0x4D832DD6A72AB806LL, dom_document_create_attribute);
      break;
    case 2056:
      HASH_INVOKE(0x19279D6DB4F70808LL, hash_hmac);
      HASH_INVOKE(0x083B8F01AE15B808LL, assert);
      break;
    case 2057:
      HASH_INVOKE(0x52DCFB6F41D41809LL, dom_characterdata_append_data);
      HASH_INVOKE(0x221F5A9D5E021809LL, magickwriteimages);
      break;
    case 2058:
      HASH_INVOKE(0x5A0D1AE1D4C6F80ALL, array_slice);
      break;
    case 2060:
      HASH_INVOKE(0x3FF63423EC4B280CLL, posix_getegid);
      break;
    case 2061:
      HASH_INVOKE(0x11EC19E702F2C80DLL, getmyinode);
      HASH_INVOKE(0x727F5A6D8E26B80DLL, extension_loaded);
      break;
    case 2064:
      HASH_INVOKE(0x4297B1072CE76810LL, fb_call_user_func_array_safe);
      break;
    case 2067:
      HASH_INVOKE(0x1A6B577442218813LL, pixelsetmagentaquantum);
      HASH_INVOKE(0x5F7940A713863813LL, floor);
      break;
    case 2068:
      HASH_INVOKE(0x3C0DFA15D3447814LL, rawurldecode);
      break;
    case 2071:
      HASH_INVOKE(0x0D8B1D0A8C381817LL, stream_bucket_new);
      break;
    case 2072:
      HASH_INVOKE(0x0FBDB0B22A59B818LL, mailparse_msg_parse);
      break;
    case 2077:
      HASH_INVOKE(0x4D624A655A9B581DLL, drawpoint);
      break;
    case 2081:
      HASH_INVOKE(0x2D52FB9B52EC2821LL, xml_set_notation_decl_handler);
      HASH_INVOKE(0x107DBCA79C15B821LL, addcslashes);
      break;
    case 2082:
      HASH_INVOKE(0x13C241C02DE72822LL, dom_document_relaxng_validate_xml);
      break;
    case 2084:
      HASH_INVOKE(0x2B78E204F615A824LL, openssl_pkcs12_export_to_file);
      break;
    case 2087:
      HASH_INVOKE(0x33EC567341B9C827LL, magickgetmaxtextadvance);
      break;
    case 2089:
      HASH_INVOKE(0x39EE4CCCA716E829LL, stream_context_get_options);
      HASH_INVOKE(0x57FFCEB7FA2D9829LL, usort);
      break;
    case 2092:
      HASH_INVOKE(0x34F0E032AB05C82CLL, pixelsetblue);
      break;
    case 2093:
      HASH_INVOKE(0x1C4AE57BF4E4A82DLL, apc_dec);
      break;
    case 2094:
      HASH_INVOKE(0x3402C1E7544C382ELL, lstat);
      break;
    case 2095:
      HASH_INVOKE(0x79A05154A7F5482FLL, magickgetimagedelay);
      break;
    case 2096:
      HASH_INVOKE(0x5BBFA7EAEBD25830LL, pixelgetcyanquantum);
      break;
    case 2100:
      HASH_INVOKE(0x605132E71CE7D834LL, array_push);
      break;
    case 2101:
      HASH_INVOKE(0x1C4A162E6635B835LL, imageftbbox);
      HASH_INVOKE(0x43A96BA7F58EB835LL, hphp_splfileobject_valid);
      break;
    case 2104:
      HASH_INVOKE(0x63E554E0F11CE838LL, mysql_unbuffered_query);
      HASH_INVOKE(0x03098F16B0AD5838LL, mcrypt_module_get_supported_key_sizes);
      HASH_INVOKE(0x0890F9052322E838LL, fstat);
      break;
    case 2107:
      HASH_INVOKE(0x63E2EA180786B83BLL, pixelsetblack);
      break;
    case 2108:
      HASH_INVOKE(0x7C8969C75CA1783CLL, get_declared_classes);
      HASH_INVOKE(0x034EDEBD109FD83CLL, filesize);
      break;
    case 2115:
      HASH_INVOKE(0x567A7139AD476843LL, socket_listen);
      break;
    case 2118:
      HASH_INVOKE(0x50088ED5D482C846LL, ldap_mod_add);
      break;
    case 2119:
      HASH_INVOKE(0x4E69A952E3EA4847LL, magicksetfilename);
      break;
    case 2122:
      HASH_INVOKE(0x7D3F626E636C084ALL, ldap_delete);
      break;
    case 2123:
      HASH_INVOKE(0x68B7597C22FA484BLL, openssl_public_encrypt);
      break;
    case 2124:
      HASH_INVOKE(0x26A2BBC465A2B84CLL, strcoll);
      break;
    case 2126:
      HASH_INVOKE(0x488C2F267BF2884ELL, array_intersect);
      break;
    case 2127:
      HASH_INVOKE(0x632D491E42E7E84FLL, session_get_cookie_params);
      break;
    case 2128:
      HASH_INVOKE(0x4DDB82A3632FA850LL, atan);
      break;
    case 2129:
      HASH_INVOKE(0x488BFCC942C73851LL, gzopen);
      break;
    case 2134:
      HASH_INVOKE(0x51FD8C9B5109F856LL, dom_characterdata_replace_data);
      break;
    case 2140:
      HASH_INVOKE(0x5A017A4C6A41E85CLL, curl_multi_add_handle);
      break;
    case 2142:
      HASH_INVOKE(0x3D8327794429585ELL, hphpd_install_user_command);
      HASH_INVOKE(0x6B4DE6865142285ELL, destroypixeliterator);
      break;
    case 2145:
      HASH_INVOKE(0x2AD6B0E3B9F3B861LL, array_search);
      break;
    case 2147:
      HASH_INVOKE(0x21B30164F5D49863LL, is_resource);
      break;
    case 2148:
      HASH_INVOKE(0x168EDA8238EEE864LL, mb_detect_order);
      break;
    case 2151:
      HASH_INVOKE(0x65A68A31B96E7867LL, hash);
      break;
    case 2152:
      HASH_INVOKE(0x785C812E6292E868LL, i18n_loc_set_default);
      break;
    case 2153:
      HASH_INVOKE(0x246EC2B1844DB869LL, pixelgetexception);
      break;
    case 2155:
      HASH_INVOKE(0x0C1BBEDECEF1C86BLL, newmagickwand);
      break;
    case 2156:
      HASH_INVOKE(0x6414504A6658286CLL, stripos);
      break;
    case 2159:
      HASH_INVOKE(0x1476A177CC50686FLL, mb_strstr);
      break;
    case 2160:
      HASH_INVOKE(0x34F50577C14C6870LL, array_diff_uassoc);
      break;
    case 2162:
      HASH_INVOKE(0x3C7B86F57AFA0872LL, hebrev);
      HASH_INVOKE(0x558D62FBEB210872LL, str_rot13);
      break;
    case 2163:
      HASH_INVOKE(0x4C06B4AFC1C08873LL, str_shuffle);
      break;
    case 2167:
      HASH_INVOKE(0x6AA3788C9B737877LL, magickdespeckleimage);
      break;
    case 2168:
      HASH_INVOKE(0x00F8C6758B50B878LL, drawpathcurvetoquadraticbezierabsolute);
      break;
    case 2172:
      HASH_INVOKE(0x11DFC3C9D916387CLL, hphp_splfileobject_ftruncate);
      HASH_INVOKE(0x6451BCB825D1787CLL, chroot);
      break;
    case 2173:
      HASH_INVOKE(0x54F84DC9A334287DLL, gzencode);
      HASH_INVOKE(0x2B36081E0828487DLL, debug_print_backtrace);
      break;
    case 2176:
      HASH_INVOKE(0x7549612A72BA5880LL, hphp_splfileinfo_getrealpath);
      break;
    case 2179:
      HASH_INVOKE(0x3EBD8F559B4EA883LL, hphp_splfileobject_getflags);
      break;
    case 2180:
      HASH_INVOKE(0x766CD15A7F2A0884LL, array_uintersect);
      break;
    case 2184:
      HASH_INVOKE(0x1062CF2DA5443888LL, imagedashedline);
      break;
    case 2191:
      HASH_INVOKE(0x5DDC2A079AB7988FLL, dom_document_schema_validate_file);
      HASH_INVOKE(0x539868C56806688FLL, imagecopyresampled);
      break;
    case 2200:
      HASH_INVOKE(0x4AC522FF7BB60898LL, xmlwriter_write_dtd_entity);
      break;
    case 2205:
      HASH_INVOKE(0x1FC855F0E4F1189DLL, magickminifyimage);
      break;
    case 2208:
      HASH_INVOKE(0x6B1A3BCE67BAC8A0LL, openssl_csr_new);
      break;
    case 2209:
      HASH_INVOKE(0x1756D4437A4098A1LL, date_modify);
      break;
    case 2215:
      HASH_INVOKE(0x57105D4E43B078A7LL, magicksetformat);
      HASH_INVOKE(0x6C6B4B739AE1B8A7LL, curl_close);
      break;
    case 2217:
      HASH_INVOKE(0x346B2DB3BA2378A9LL, imagecolormatch);
      break;
    case 2218:
      HASH_INVOKE(0x44BC069A75EE98AALL, xhprof_disable);
      break;
    case 2219:
      HASH_INVOKE(0x39F11BA6A4D778ABLL, strnatcmp);
      break;
    case 2220:
      HASH_INVOKE(0x5B1F4C6424DDD8ACLL, openlog);
      break;
    case 2224:
      HASH_INVOKE(0x2CEF8DDC092698B0LL, drawgetvectorgraphics);
      break;
    case 2226:
      HASH_INVOKE(0x31830AA5032428B2LL, is_double);
      break;
    case 2230:
      HASH_INVOKE(0x5866C5DF3A1AD8B6LL, dom_element_get_attribute_node);
      break;
    case 2236:
      HASH_INVOKE(0x7AE3AE9B634988BCLL, stream_context_create);
      break;
    case 2244:
      HASH_INVOKE(0x5C28BE7FFE6A68C4LL, xml_set_start_namespace_decl_handler);
      break;
    case 2245:
      HASH_INVOKE(0x146A1A7658CCA8C5LL, asinh);
      break;
    case 2247:
      HASH_INVOKE(0x4623383F8534E8C7LL, array_multisort);
      HASH_INVOKE(0x6D9B9BE3CED388C7LL, apc_load_constants);
      break;
    case 2254:
      HASH_INVOKE(0x3FFAA982E4B1E8CELL, date_offset_get);
      break;
    case 2257:
      HASH_INVOKE(0x1015EB3F52B098D1LL, print);
      break;
    case 2258:
      HASH_INVOKE(0x74EB6C564ABC68D2LL, dom_document_create_text_node);
      break;
    case 2260:
      HASH_INVOKE(0x6DB4EE8696C7E8D4LL, magicksetimageiterations);
      break;
    case 2262:
      HASH_INVOKE(0x2F585B36DDDB68D6LL, mb_convert_case);
      HASH_INVOKE(0x26DC8AB4A9CBE8D6LL, iconv);
      break;
    case 2264:
      HASH_INVOKE(0x3A65182A3E8908D8LL, openssl_open);
      break;
    case 2265:
      HASH_INVOKE(0x18B64D6BFE4208D9LL, stream_get_transports);
      break;
    case 2267:
      HASH_INVOKE(0x4052842EC87038DBLL, magickcropimage);
      break;
    case 2268:
      HASH_INVOKE(0x31F50FDA18B888DCLL, magickgetimagetype);
      break;
    case 2276:
      HASH_INVOKE(0x16A18007E10F48E4LL, socket_getsockname);
      break;
    case 2278:
      HASH_INVOKE(0x69887F054A1E28E6LL, strtok);
      break;
    case 2279:
      HASH_INVOKE(0x608729F27FA428E7LL, error_get_last);
      break;
    case 2280:
      HASH_INVOKE(0x4F7ED8C3156AD8E8LL, magicksetimagedispose);
      break;
    case 2293:
      HASH_INVOKE(0x45DA105C5B48F8F5LL, apd_set_pprof_trace);
      break;
    case 2295:
      HASH_INVOKE(0x17582BEA497D48F7LL, ctype_alpha);
      break;
    case 2298:
      HASH_INVOKE(0x6F0F82818B68A8FALL, array_values);
      break;
    case 2299:
      HASH_INVOKE(0x214532C4A2BC28FBLL, ldap_next_entry);
      break;
    case 2300:
      HASH_INVOKE(0x4C2AFB2EFDB1B8FCLL, stripslashes);
      break;
    case 2302:
      HASH_INVOKE(0x047BF4D3D0ED08FELL, strchr);
      break;
    case 2315:
      HASH_INVOKE(0x67B879A1120C190BLL, headers_sent);
      HASH_INVOKE(0x2987B15E11FE890BLL, clock_settime);
      break;
    case 2321:
      HASH_INVOKE(0x04F822B7817E5911LL, bindec);
      HASH_INVOKE(0x0AFD4F231D6CB911LL, magickaddimage);
      HASH_INVOKE(0x5B9B2C3B32906911LL, drawsetfillpatternurl);
      break;
    case 2323:
      HASH_INVOKE(0x55757E1242390913LL, cos);
      break;
    case 2324:
      HASH_INVOKE(0x6E22C6D840B44914LL, mcrypt_generic_init);
      break;
    case 2326:
      HASH_INVOKE(0x245A2DC3B6B62916LL, apache_lookup_uri);
      break;
    case 2329:
      HASH_INVOKE(0x022B16C0D64D7919LL, file_put_contents);
      break;
    case 2331:
      HASH_INVOKE(0x37A3DF6E0795091BLL, memcache_increment);
      break;
    case 2333:
      HASH_INVOKE(0x069C028EFEF8C91DLL, date);
      break;
    case 2335:
      HASH_INVOKE(0x277D7E2D1F5C191FLL, drawpathcurvetoquadraticbezierrelative);
      HASH_INVOKE(0x4E2C55C92D71F91FLL, magickcolorfloodfillimage);
      break;
    case 2337:
      HASH_INVOKE(0x0F5917FFCDD6C921LL, mb_substr);
      break;
    case 2339:
      HASH_INVOKE(0x044B276686B77923LL, fscanf);
      break;
    case 2346:
      HASH_INVOKE(0x174C510386E6492ALL, hphp_directoryiterator_key);
      break;
    case 2349:
      HASH_INVOKE(0x27363CE6CBFC392DLL, pcntl_wexitstatus);
      HASH_INVOKE(0x2337F8C3EE17192DLL, sprintf);
      break;
    case 2350:
      HASH_INVOKE(0x26E8B741BDDDC92ELL, xmlwriter_start_element);
      break;
    case 2352:
      HASH_INVOKE(0x507CE1912FD74930LL, mail);
      HASH_INVOKE(0x30972530BD557930LL, shell_exec);
      break;
    case 2354:
      HASH_INVOKE(0x72C01E1D90BE5932LL, mcrypt_enc_get_block_size);
      break;
    case 2356:
      HASH_INVOKE(0x4FB95164A5F84934LL, mcrypt_generic_end);
      break;
    case 2357:
      HASH_INVOKE(0x46BD9A56BDE40935LL, mysql_escape_string);
      HASH_INVOKE(0x06486B6912479935LL, zlib_get_coding_type);
      HASH_INVOKE(0x48D3CA6CA0B29935LL, mb_regex_set_options);
      break;
    case 2361:
      HASH_INVOKE(0x5B60C8396C624939LL, mb_substitute_character);
      break;
    case 2366:
      HASH_INVOKE(0x3946D67A0D16D93ELL, hphp_splfileinfo_isreadable);
      HASH_INVOKE(0x0CADFE289C92893ELL, socket_getpeername);
      break;
    case 2371:
      HASH_INVOKE(0x7C565AD57BC84943LL, pixelsetindex);
      break;
    case 2373:
      HASH_INVOKE(0x7CB0596B6CCFA945LL, split);
      break;
    case 2375:
      HASH_INVOKE(0x630288865DE68947LL, php_strip_whitespace);
      break;
    case 2376:
      HASH_INVOKE(0x6A3412DE82715948LL, openssl_x509_checkpurpose);
      break;
    case 2377:
      HASH_INVOKE(0x243BB8B284895949LL, apache_get_rewrite_rules);
      break;
    case 2379:
      HASH_INVOKE(0x37F356F578FA394BLL, substr);
      break;
    case 2381:
      HASH_INVOKE(0x3D3AD12E52FF294DLL, imagecreatefromwbmp);
      break;
    case 2387:
      HASH_INVOKE(0x068438AFD33A9953LL, imagecolorclosesthwb);
      break;
    case 2391:
      HASH_INVOKE(0x253AC5D4E450A957LL, magickgetreleasedate);
      break;
    case 2394:
      HASH_INVOKE(0x103C12985527295ALL, hphp_splfileobject_setcsvcontrol);
      HASH_INVOKE(0x7056E766A274895ALL, virtual);
      break;
    case 2397:
      HASH_INVOKE(0x21DBCE74EB1FC95DLL, xmlwriter_text);
      break;
    case 2401:
      HASH_INVOKE(0x5EA7052A00E88961LL, magickgetcopyright);
      break;
    case 2407:
      HASH_INVOKE(0x1419B3BF428B2967LL, evhttp_async_post);
      break;
    case 2415:
      HASH_INVOKE(0x134EF88685C0396FLL, magickgetexceptiontype);
      break;
    case 2417:
      HASH_INVOKE(0x442A28FB6F6C3971LL, xmlwriter_start_attribute);
      HASH_INVOKE(0x72C73F5DA7D6F971LL, magickgetimagecolormapcolor);
      break;
    case 2418:
      HASH_INVOKE(0x758263CEBF2E8972LL, assert_options);
      break;
    case 2421:
      HASH_INVOKE(0x7E26D48503362975LL, drawpathcurvetoabsolute);
      HASH_INVOKE(0x488141281A75E975LL, imagecreatefromgif);
      break;
    case 2423:
      HASH_INVOKE(0x0C16C797916C2977LL, posix_setegid);
      break;
    case 2430:
      HASH_INVOKE(0x5067A65AD1D0297ELL, pixelgetiteratorexception);
      break;
    case 2432:
      HASH_INVOKE(0x3D3445105C335980LL, filectime);
      break;
    case 2434:
      HASH_INVOKE(0x214EA70BDD8FB982LL, magickmorphimages);
      break;
    case 2435:
      HASH_INVOKE(0x3DA64BF893DBF983LL, strncmp);
      break;
    case 2438:
      HASH_INVOKE(0x6ECE4BDB8842E986LL, posix_strerror);
      break;
    case 2439:
      HASH_INVOKE(0x22B3CF8DD3D1A987LL, pixelsynciterator);
      break;
    case 2440:
      HASH_INVOKE(0x489355BDBE396988LL, drawsettextencoding);
      HASH_INVOKE(0x55BE7AE8DEF3F988LL, magickgetstringheight);
      break;
    case 2443:
      HASH_INVOKE(0x0E863EF8C11A598BLL, is_writable);
      break;
    case 2445:
      HASH_INVOKE(0x69003892F71C798DLL, apache_get_scoreboard);
      HASH_INVOKE(0x651A8CBB8D2A398DLL, mysql_stat);
      break;
    case 2446:
      HASH_INVOKE(0x45CFDEE19995398ELL, hphp_recursiveiteratoriterator_next);
      HASH_INVOKE(0x333D4DFD4927898ELL, magickgetimagewhitepoint);
      break;
    case 2448:
      HASH_INVOKE(0x342D957A86A03990LL, hphp_splfileobject_seek);
      break;
    case 2456:
      HASH_INVOKE(0x501AAD31C8086998LL, posix_getcwd);
      break;
    case 2459:
      HASH_INVOKE(0x564D8D3DA1E8E99BLL, xml_get_current_line_number);
      break;
    case 2462:
      HASH_INVOKE(0x59D2DFF08F4DB99ELL, imagecreate);
      break;
    case 2464:
      HASH_INVOKE(0x047EF9173590C9A0LL, session_decode);
      break;
    case 2466:
      HASH_INVOKE(0x01D2367A02F0A9A2LL, magicksetsize);
      break;
    case 2467:
      HASH_INVOKE(0x43D1339C52E309A3LL, hphp_service_thread_started);
      HASH_INVOKE(0x78261FA60B8D89A3LL, imagepsloadfont);
      break;
    case 2468:
      HASH_INVOKE(0x6F8676B049C919A4LL, array_intersect_uassoc);
      break;
    case 2469:
      HASH_INVOKE(0x76988956F35329A5LL, xmlwriter_end_cdata);
      break;
    case 2473:
      HASH_INVOKE(0x6F9CF95104CAE9A9LL, pixelgetyellowquantum);
      break;
    case 2476:
      HASH_INVOKE(0x522256BAA78159ACLL, popen);
      break;
    case 2477:
      HASH_INVOKE(0x05C5AD90751159ADLL, drawpathcurvetoquadraticbeziersmoothabsolute);
      break;
    case 2479:
      HASH_INVOKE(0x25268012A48A99AFLL, magickclipimage);
      break;
    case 2481:
      HASH_INVOKE(0x7C1CE38F14E529B1LL, date_default_timezone_set);
      break;
    case 2482:
      HASH_INVOKE(0x65D7CBE8681CE9B2LL, gzgetss);
      break;
    case 2486:
      HASH_INVOKE(0x5FC1B94446EA59B6LL, magickremoveimageprofiles);
      break;
    case 2487:
      HASH_INVOKE(0x18F2C246FACAD9B7LL, each);
      break;
    case 2488:
      HASH_INVOKE(0x3741447B159359B8LL, mcrypt_get_cipher_name);
      HASH_INVOKE(0x4EFD7A9C90E559B8LL, posix_ttyname);
      break;
    case 2489:
      HASH_INVOKE(0x145702974C97F9B9LL, ltrim);
      break;
    case 2490:
      HASH_INVOKE(0x13B3172E092D99BALL, is_dir);
      break;
    case 2492:
      HASH_INVOKE(0x7E7BF1BDA6DB49BCLL, hphp_splfileinfo_getgroup);
      break;
    case 2494:
      HASH_INVOKE(0x458B5ABEDAC1C9BELL, disk_free_space);
      break;
    case 2498:
      HASH_INVOKE(0x6A7BDB900E7429C2LL, magickconstituteimage);
      break;
    case 2500:
      HASH_INVOKE(0x47B7D3745D80B9C4LL, socket_get_option);
      break;
    case 2502:
      HASH_INVOKE(0x080F661DB8BFC9C6LL, hphp_splfileinfo_getmtime);
      break;
    case 2503:
      HASH_INVOKE(0x6ECDF24B29D789C7LL, strtolower);
      break;
    case 2506:
      HASH_INVOKE(0x5C5B0CC85133B9CALL, mkdir);
      break;
    case 2507:
      HASH_INVOKE(0x032DFAC5B24679CBLL, header_remove);
      break;
    case 2509:
      HASH_INVOKE(0x4E61FE901C1C29CDLL, array_intersect_key);
      break;
    case 2510:
      HASH_INVOKE(0x7A9FB932873D09CELL, gmmktime);
      break;
    case 2511:
      HASH_INVOKE(0x415B91CAEE0689CFLL, magickgetimageinterlacescheme);
      break;
    case 2514:
      HASH_INVOKE(0x3DCCD1FEAD8759D2LL, array_sum);
      break;
    case 2515:
      HASH_INVOKE(0x1C31A9E1207209D3LL, mb_split);
      HASH_INVOKE(0x10C82F357BB7E9D3LL, curl_version);
      HASH_INVOKE(0x25CA0299103F49D3LL, magickgetsize);
      break;
    case 2517:
      HASH_INVOKE(0x245860A2FE4CB9D5LL, socket_set_blocking);
      break;
    case 2519:
      HASH_INVOKE(0x7628053EFCC0C9D7LL, hphp_clear_unflushed);
      break;
    case 2523:
      HASH_INVOKE(0x48B2E069B89489DBLL, magickappendimages);
      break;
    case 2526:
      HASH_INVOKE(0x5C039967E60089DELL, array_intersect_ukey);
      break;
    case 2527:
      HASH_INVOKE(0x349E2E0F2CD7B9DFLL, magickgetversion);
      break;
    case 2534:
      HASH_INVOKE(0x1B44CF284E9B09E6LL, interface_exists);
      break;
    case 2537:
      HASH_INVOKE(0x4ADFA265F07AB9E9LL, drawgettextalignment);
      HASH_INVOKE(0x6A45EB471332A9E9LL, imagecolorexactalpha);
      HASH_INVOKE(0x330EE2729DB7C9E9LL, drawgetfontstretch);
      break;
    case 2538:
      HASH_INVOKE(0x25DDD924EFE979EALL, hash_update_file);
      break;
    case 2539:
      HASH_INVOKE(0x71B0FF80B88459EBLL, diskfreespace);
      break;
    case 2543:
      HASH_INVOKE(0x7EA6200B688459EFLL, ldap_modify);
      break;
    case 2544:
      HASH_INVOKE(0x1FC307200E8959F0LL, stream_bucket_append);
      break;
    case 2547:
      HASH_INVOKE(0x6535B60A4BC449F3LL, dns_get_record);
      break;
    case 2548:
      HASH_INVOKE(0x51201EE65BC729F4LL, localtime);
      break;
    case 2549:
      HASH_INVOKE(0x2BC61637253BE9F5LL, drawgetfontweight);
      HASH_INVOKE(0x35BABFBC091759F5LL, socket_server);
      break;
    case 2557:
      HASH_INVOKE(0x2394D4E030AB69FDLL, getmypid);
      break;
    case 2564:
      HASH_INVOKE(0x0B88D3F582D16A04LL, memcache_get_extended_stats);
      HASH_INVOKE(0x17B83C425BD09A04LL, atanh);
      break;
    case 2567:
      HASH_INVOKE(0x391E0A4CF1EC9A07LL, stream_socket_recvfrom);
      break;
    case 2568:
      HASH_INVOKE(0x0436CA4DFB315A08LL, soundex);
      break;
    case 2571:
      HASH_INVOKE(0x70075DC878825A0BLL, ctype_lower);
      break;
    case 2573:
      HASH_INVOKE(0x736C133EFF8E5A0DLL, mysql_list_fields);
      HASH_INVOKE(0x50A7146A79877A0DLL, pcntl_alarm);
      break;
    case 2577:
      HASH_INVOKE(0x472CA39715598A11LL, mb_eregi_replace);
      break;
    case 2584:
      HASH_INVOKE(0x66A378C6BBC26A18LL, dom_document_create_cdatasection);
      break;
    case 2588:
      HASH_INVOKE(0x12D49AD562F38A1CLL, date_timezone_get);
      break;
    case 2591:
      HASH_INVOKE(0x35C8BD7DFDADEA1FLL, hphp_directoryiterator_current);
      break;
    case 2592:
      HASH_INVOKE(0x2A420675E6AF0A20LL, basename);
      break;
    case 2593:
      HASH_INVOKE(0x14279BB1A6872A21LL, atan2);
      break;
    case 2594:
      HASH_INVOKE(0x3FC127C442BAEA22LL, session_id);
      break;
    case 2597:
      HASH_INVOKE(0x5EC0A3DD935EEA25LL, magickresampleimage);
      HASH_INVOKE(0x1DB9A1FB97A3AA25LL, magicksetimageoption);
      break;
    case 2601:
      HASH_INVOKE(0x618D2A98986B1A29LL, ldap_unbind);
      break;
    case 2602:
      HASH_INVOKE(0x3CAEA6B8D1C92A2ALL, stream_bucket_prepend);
      break;
    case 2604:
      HASH_INVOKE(0x073ACDF9B3F06A2CLL, memcache_setoptimeout);
      break;
    case 2609:
      HASH_INVOKE(0x1F3E32847C1CCA31LL, mb_ereg_match);
      break;
    case 2612:
      HASH_INVOKE(0x2D948E4099975A34LL, restore_include_path);
      HASH_INVOKE(0x5AB266C6E7075A34LL, mysql_error);
      break;
    case 2616:
      HASH_INVOKE(0x3E65EF9761BE5A38LL, pixelgetiteratorexceptiontype);
      break;
    case 2619:
      HASH_INVOKE(0x545A7BE199EC4A3BLL, pcntl_getpriority);
      HASH_INVOKE(0x785ECCF53D98BA3BLL, curl_multi_exec);
      break;
    case 2620:
      HASH_INVOKE(0x21DF7BAEEFABCA3CLL, umask);
      break;
    case 2622:
      HASH_INVOKE(0x31C3A072D092FA3ELL, socket_create_listen);
      break;
    case 2623:
      HASH_INVOKE(0x4C0E2C6882051A3FLL, magickgetresourcelimit);
      break;
    case 2624:
      HASH_INVOKE(0x4926EE59103B2A40LL, destroydrawingwand);
      HASH_INVOKE(0x682C14726D484A40LL, fileatime);
      break;
    case 2626:
      HASH_INVOKE(0x128914E131AFFA42LL, microtime);
      HASH_INVOKE(0x5FF7C3A6BDDCFA42LL, mb_convert_kana);
      break;
    case 2628:
      HASH_INVOKE(0x7F6A6306BBE8AA44LL, imagelayereffect);
      break;
    case 2629:
      HASH_INVOKE(0x7CDF1FB642529A45LL, dom_characterdata_insert_data);
      break;
    case 2631:
      HASH_INVOKE(0x1B45CFF586F85A47LL, utf8_encode);
      break;
    case 2636:
      HASH_INVOKE(0x4894583F517C6A4CLL, intl_get_error_code);
      HASH_INVOKE(0x7039B1C3356B8A4CLL, hphp_splfileobject_rewind);
      break;
    case 2638:
      HASH_INVOKE(0x1635DCC4882CBA4ELL, dom_node_has_attributes);
      break;
    case 2640:
      HASH_INVOKE(0x506BBFC1B32AEA50LL, memcache_replace);
      break;
    case 2647:
      HASH_INVOKE(0x5088945958DD4A57LL, mktime);
      HASH_INVOKE(0x7E929ED7D9BE6A57LL, ini_get);
      break;
    case 2648:
      HASH_INVOKE(0x6E823A722DE1EA58LL, stream_socket_client);
      break;
    case 2651:
      HASH_INVOKE(0x2B18DFF183C0BA5BLL, mb_get_info);
      break;
    case 2653:
      HASH_INVOKE(0x7E1E9C4C3D4E8A5DLL, stream_select);
      break;
    case 2654:
      HASH_INVOKE(0x2C6826999658AA5ELL, getopt);
      break;
    case 2655:
      HASH_INVOKE(0x7CAE3FE798EC0A5FLL, php_logo_guid);
      break;
    case 2661:
      HASH_INVOKE(0x469199B8FD886A65LL, putenv);
      HASH_INVOKE(0x3590F3AAC94E0A65LL, array_change_key_case);
      break;
    case 2662:
      HASH_INVOKE(0x60C4B9EEDBD5FA66LL, pos);
      break;
    case 2664:
      HASH_INVOKE(0x01DD2057FD9B1A68LL, xmlwriter_write_cdata);
      HASH_INVOKE(0x32AD0455A7689A68LL, magickoilpaintimage);
      break;
    case 2665:
      HASH_INVOKE(0x1DD37E722E11AA69LL, session_regenerate_id);
      HASH_INVOKE(0x10CDCF2BB4057A69LL, debug_zval_dump);
      break;
    case 2667:
      HASH_INVOKE(0x0912965F4440FA6BLL, str_repeat);
      break;
    case 2673:
      HASH_INVOKE(0x5B5DA6AD0AD63A71LL, drawannotation);
      break;
    case 2674:
      HASH_INVOKE(0x71AFF1D58D103A72LL, imagefontheight);
      break;
    case 2677:
      HASH_INVOKE(0x7A957BEC6CA57A75LL, preg_replace_callback);
      break;
    case 2681:
      HASH_INVOKE(0x28AC28C54C4E6A79LL, openssl_error_string);
      break;
    case 2685:
      HASH_INVOKE(0x414C2E31304E9A7DLL, stream_get_filters);
      break;
    case 2689:
      HASH_INVOKE(0x09367774F803EA81LL, hphp_recursiveiteratoriterator_valid);
      break;
    case 2690:
      HASH_INVOKE(0x258205B54DC06A82LL, newpixelwands);
      HASH_INVOKE(0x79786FABC5551A82LL, jpeg2wbmp);
      break;
    case 2691:
      HASH_INVOKE(0x11149278DB0A9A83LL, levenshtein);
      break;
    case 2692:
      HASH_INVOKE(0x08C1A5A05B6A0A84LL, ob_get_length);
      break;
    case 2693:
      HASH_INVOKE(0x755DEFDEDF35DA85LL, ctype_print);
      HASH_INVOKE(0x2180916F8D4F6A85LL, drawcomment);
      break;
    case 2695:
      HASH_INVOKE(0x7C5A22328CAB4A87LL, ereg_replace);
      break;
    case 2696:
      HASH_INVOKE(0x1818A3CFBA357A88LL, magicksetwandsize);
      break;
    case 2699:
      HASH_INVOKE(0x7588BD0546C8BA8BLL, hphp_recursivedirectoryiterator_valid);
      HASH_INVOKE(0x7ACBCD9CF335AA8BLL, xmlwriter_start_document);
      break;
    case 2700:
      HASH_INVOKE(0x6A2EEE463F969A8CLL, getservbyname);
      break;
    case 2706:
      HASH_INVOKE(0x1257DB9F159E9A92LL, magickmontageimage);
      break;
    case 2707:
      HASH_INVOKE(0x4A32653C8E719A93LL, pixelgetcyan);
      break;
    case 2708:
      HASH_INVOKE(0x465E6C67F885AA94LL, drawgetstrokelinejoin);
      HASH_INVOKE(0x7761D019E0B5EA94LL, magickstripimage);
      HASH_INVOKE(0x4B1501C4C22FFA94LL, quoted_printable_encode);
      HASH_INVOKE(0x0AC7CBCE30442A94LL, imagepalettecopy);
      break;
    case 2709:
      HASH_INVOKE(0x34B8A4E5AE0EFA95LL, pixelgetopacity);
      break;
    case 2711:
      HASH_INVOKE(0x0089115038C03A97LL, array_diff_ukey);
      break;
    case 2714:
      HASH_INVOKE(0x19AFF8596E19DA9ALL, xhprof_enable);
      break;
    case 2717:
      HASH_INVOKE(0x1234AB687C515A9DLL, mb_encode_numericentity);
      break;
    case 2719:
      HASH_INVOKE(0x2E5E23ECA0525A9FLL, bcadd);
      break;
    case 2720:
      HASH_INVOKE(0x55FAF12AF1920AA0LL, sha1_file);
      break;
    case 2723:
      HASH_INVOKE(0x2B75B48A53AACAA3LL, imagestring);
      break;
    case 2725:
      HASH_INVOKE(0x2418528164415AA5LL, magickscaleimage);
      break;
    case 2726:
      HASH_INVOKE(0x4BBA1E164DF9CAA6LL, localeconv);
      break;
    case 2727:
      HASH_INVOKE(0x797CEC173CBB7AA7LL, ob_get_flush);
      break;
    case 2729:
      HASH_INVOKE(0x2238FC7870E9CAA9LL, strspn);
      break;
    case 2731:
      HASH_INVOKE(0x1331979EF8EF0AABLL, mb_ereg_search);
      break;
    case 2732:
      HASH_INVOKE(0x18CF3E4A60E4AAACLL, pi);
      break;
    case 2735:
      HASH_INVOKE(0x3ED47399FE1D6AAFLL, dom_document_create_attribute_ns);
      break;
    case 2738:
      HASH_INVOKE(0x569EED88F20BAAB2LL, drawgettextundercolor);
      HASH_INVOKE(0x62519270CC9F1AB2LL, stream_get_meta_data);
      break;
    case 2740:
      HASH_INVOKE(0x1BAFB965204D0AB4LL, openssl_x509_check_private_key);
      break;
    case 2751:
      HASH_INVOKE(0x030DFC3D3C88BABFLL, filegroup);
      break;
    case 2757:
      HASH_INVOKE(0x3754E97715176AC5LL, hphp_get_stats);
      break;
    case 2759:
      HASH_INVOKE(0x5D2F899A270D9AC7LL, xmlwriter_end_dtd_element);
      HASH_INVOKE(0x79215854355CBAC7LL, proc_get_status);
      HASH_INVOKE(0x3886D2664F874AC7LL, openssl_pkcs7_verify);
      break;
    case 2761:
      HASH_INVOKE(0x5CA9671385EF0AC9LL, sem_release);
      break;
    case 2762:
      HASH_INVOKE(0x45B30CD663284ACALL, is_int);
      break;
    case 2763:
      HASH_INVOKE(0x348888DDF223AACBLL, mt_getrandmax);
      break;
    case 2764:
      HASH_INVOKE(0x750D0396676E6ACCLL, imagecolorexact);
      HASH_INVOKE(0x2BD6476D2C467ACCLL, pagelet_server_task_status);
      break;
    case 2765:
      HASH_INVOKE(0x173EDC165B673ACDLL, magicktransformimage);
      break;
    case 2769:
      HASH_INVOKE(0x47E2B4F7B8DE5AD1LL, xmlwriter_write_dtd_attlist);
      HASH_INVOKE(0x314317450857FAD1LL, ctype_punct);
      break;
    case 2773:
      HASH_INVOKE(0x0D5DAF8034B41AD5LL, get_include_path);
      HASH_INVOKE(0x5338F971C6DCEAD5LL, hphp_splfileinfo_islink);
      break;
    case 2774:
      HASH_INVOKE(0x231BCE6071220AD6LL, drawcircle);
      break;
    case 2776:
      HASH_INVOKE(0x52401023E146AAD8LL, xmlwriter_end_dtd);
      break;
    case 2779:
      HASH_INVOKE(0x24771ED112008ADBLL, echo);
      HASH_INVOKE(0x56E867A1F7507ADBLL, dom_document_create_processing_instruction);
      break;
    case 2780:
      HASH_INVOKE(0x547E7EE64761AADCLL, imagecreatefromxbm);
      break;
    case 2781:
      HASH_INVOKE(0x3E319E451A32FADDLL, magicksharpenimage);
      break;
    case 2782:
      HASH_INVOKE(0x31D1C58F7BD89ADELL, hphp_directoryiterator_seek);
      break;
    case 2788:
      HASH_INVOKE(0x47B15A7136E94AE4LL, strnatcasecmp);
      HASH_INVOKE(0x1827F1C22F1CCAE4LL, hebrevc);
      break;
    case 2790:
      HASH_INVOKE(0x0E09D0FEA30B6AE6LL, hphp_get_function_info);
      break;
    case 2795:
      HASH_INVOKE(0x225F05071947BAEBLL, drawpathlinetoabsolute);
      break;
    case 2797:
      HASH_INVOKE(0x46C33B4739C2FAEDLL, shm_remove_var);
      break;
    case 2798:
      HASH_INVOKE(0x160A82E3E2CBBAEELL, is_finite);
      break;
    case 2800:
      HASH_INVOKE(0x6B259D5D9D681AF0LL, register_postsend_function);
      break;
    case 2804:
      HASH_INVOKE(0x2EC0ABF9A979FAF4LL, ob_get_level);
      break;
    case 2806:
      HASH_INVOKE(0x2C7C9772AE983AF6LL, drawsetgravity);
      break;
    case 2808:
      HASH_INVOKE(0x12859AD75BAF3AF8LL, magickreadimageblob);
      HASH_INVOKE(0x757229A894864AF8LL, session_set_cookie_params);
      break;
    case 2813:
      HASH_INVOKE(0x16BA422EB6C51AFDLL, gzwrite);
      break;
    case 2814:
      HASH_INVOKE(0x04E86BA79B6CBAFELL, stream_socket_shutdown);
      break;
    case 2815:
      HASH_INVOKE(0x7833F4C337542AFFLL, openssl_pkey_export);
      break;
    case 2817:
      HASH_INVOKE(0x6F3503C7FB12DB01LL, lchgrp);
      break;
    case 2819:
      HASH_INVOKE(0x673A96C50F00FB03LL, str_word_count);
      HASH_INVOKE(0x32458C11C6E74B03LL, pixelsetblackquantum);
      break;
    case 2826:
      HASH_INVOKE(0x14B366EF64A66B0ALL, get_loaded_extensions);
      HASH_INVOKE(0x14AF32A23B507B0ALL, metaphone);
      break;
    case 2829:
      HASH_INVOKE(0x368DBC0699272B0DLL, magicknegateimage);
      break;
    case 2836:
      HASH_INVOKE(0x76675F14C1138B14LL, gzuncompress);
      break;
    case 2837:
      HASH_INVOKE(0x24D0895FBB7BCB15LL, is_callable);
      HASH_INVOKE(0x773E3809C4954B15LL, hphp_recursivedirectoryiterator_current);
      break;
    case 2839:
      HASH_INVOKE(0x66F9A476DAB47B17LL, pixelsetcolor);
      break;
    case 2840:
      HASH_INVOKE(0x70448A629A74FB18LL, ksort);
      break;
    case 2841:
      HASH_INVOKE(0x0551EACBE8278B19LL, decoct);
      break;
    case 2842:
      HASH_INVOKE(0x399522EE0CF3EB1ALL, drawsetstrokewidth);
      break;
    case 2843:
      HASH_INVOKE(0x1B7CE8114AEACB1BLL, magickannotateimage);
      break;
    case 2844:
      HASH_INVOKE(0x249399CEC35B7B1CLL, png2wbmp);
      break;
    case 2845:
      HASH_INVOKE(0x6791459B883F0B1DLL, apache_reset_timeout);
      break;
    case 2846:
      HASH_INVOKE(0x7160AA24D4251B1ELL, mb_strripos);
      break;
    case 2848:
      HASH_INVOKE(0x1112712715D75B20LL, pixelgetblackquantum);
      break;
    case 2853:
      HASH_INVOKE(0x798F2776FECAEB25LL, get_required_files);
      break;
    case 2854:
      HASH_INVOKE(0x24CE95457EACBB26LL, get_parent_class);
      break;
    case 2857:
      HASH_INVOKE(0x17C38BE3A6EE8B29LL, mysql_field_flags);
      break;
    case 2858:
      HASH_INVOKE(0x1F4984938E1DBB2ALL, sort);
      break;
    case 2860:
      HASH_INVOKE(0x70742211FA3EFB2CLL, imagettftext);
      break;
    case 2865:
      HASH_INVOKE(0x442B1E05FC146B31LL, stream_context_set_param);
      break;
    case 2867:
      HASH_INVOKE(0x00DCD60DD8752B33LL, set_exception_handler);
      HASH_INVOKE(0x4D5D45D1F1EB3B33LL, posix_access);
      break;
    case 2868:
      HASH_INVOKE(0x0B7D52E2540ABB34LL, tan);
      break;
    case 2869:
      HASH_INVOKE(0x78842C1950B38B35LL, drawpathfinish);
      break;
    case 2871:
      HASH_INVOKE(0x053B14F52350FB37LL, socket_shutdown);
      break;
    case 2872:
      HASH_INVOKE(0x68C09D6CB8E79B38LL, class_exists);
      break;
    case 2873:
      HASH_INVOKE(0x02A2C373E54FFB39LL, hash_init);
      break;
    case 2874:
      HASH_INVOKE(0x49A45F75B2B25B3ALL, apd_breakpoint);
      break;
    case 2876:
      HASH_INVOKE(0x35F4A0789F367B3CLL, drawpathlinetohorizontalrelative);
      break;
    case 2878:
      HASH_INVOKE(0x5E2AF775FEB04B3ELL, posix_getppid);
      break;
    case 2879:
      HASH_INVOKE(0x0B07AD87DF1B5B3FLL, urldecode);
      break;
    case 2880:
      HASH_INVOKE(0x24CBCBA5C4407B40LL, evhttp_set_cache);
      break;
    case 2884:
      HASH_INVOKE(0x4E4449EBAADD7B44LL, magickpingimage);
      break;
    case 2885:
      HASH_INVOKE(0x684881C79ED1AB45LL, func_get_args);
      HASH_INVOKE(0x72E3AE55A0B33B45LL, ispixelwand);
      break;
    case 2886:
      HASH_INVOKE(0x00D8FE7A00252B46LL, escapeshellarg);
      break;
    case 2893:
      HASH_INVOKE(0x37DF53E4D9348B4DLL, xbox_post_message);
      break;
    case 2896:
      HASH_INVOKE(0x6237393C71E56B50LL, array_fill_keys);
      break;
    case 2899:
      HASH_INVOKE(0x40F0B69D55F7EB53LL, drawsetstrokealpha);
      break;
    case 2901:
      HASH_INVOKE(0x333FB673518A1B55LL, ldap_get_entries);
      break;
    case 2904:
      HASH_INVOKE(0x6158E2E0A5ACCB58LL, idn_to_ascii);
      break;
    case 2907:
      HASH_INVOKE(0x29203294F6214B5BLL, memcache_debug);
      HASH_INVOKE(0x23FD09A13E0D8B5BLL, xmlwriter_open_memory);
      break;
    case 2909:
      HASH_INVOKE(0x4888951358F53B5DLL, dom_document_get_elements_by_tag_name_ns);
      break;
    case 2913:
      HASH_INVOKE(0x7636825871399B61LL, highlight_file);
      break;
    case 2920:
      HASH_INVOKE(0x674F1DA24EDE7B68LL, xmlwriter_end_attribute);
      break;
    case 2922:
      HASH_INVOKE(0x4BD4E9D9D4A56B6ALL, exif_tagname);
      break;
    case 2923:
      HASH_INVOKE(0x5543A0CACD153B6BLL, substr_replace);
      HASH_INVOKE(0x1D4136B4CEAE4B6BLL, stripcslashes);
      break;
    case 2927:
      HASH_INVOKE(0x2D8D57FC1DC6CB6FLL, import_request_variables);
      break;
    case 2928:
      HASH_INVOKE(0x1A73FD4416FECB70LL, magickwriteimagefile);
      break;
    case 2929:
      HASH_INVOKE(0x5E5C875DB04CFB71LL, drawrectangle);
      break;
    case 2933:
      HASH_INVOKE(0x42F0AED7599C1B75LL, magickechoimageblob);
      break;
    case 2934:
      HASH_INVOKE(0x2A63A0BF9B7E3B76LL, ini_alter);
      break;
    case 2935:
      HASH_INVOKE(0x7F5F29D8E63ABB77LL, mcrypt_module_self_test);
      HASH_INVOKE(0x5025B43B46679B77LL, openssl_x509_free);
      break;
    case 2937:
      HASH_INVOKE(0x31242F51AA828B79LL, drawpoppattern);
      break;
    case 2940:
      HASH_INVOKE(0x3A096F905FBF7B7CLL, magickcommentimage);
      break;
    case 2941:
      HASH_INVOKE(0x28DE19828167FB7DLL, magickmapimage);
      break;
    case 2943:
      HASH_INVOKE(0x308C90AD9478CB7FLL, substr_compare);
      break;
    case 2946:
      HASH_INVOKE(0x5BDE96FD5015AB82LL, base_convert);
      break;
    case 2949:
      HASH_INVOKE(0x41F8FDD700C0CB85LL, socket_last_error);
      break;
    case 2955:
      HASH_INVOKE(0x3B72159A4B04FB8BLL, set_time_limit);
      break;
    case 2957:
      HASH_INVOKE(0x3B831DB1A615FB8DLL, xhprof_sample_enable);
      break;
    case 2958:
      HASH_INVOKE(0x62A4D7A03F7C3B8ELL, ceil);
      break;
    case 2967:
      HASH_INVOKE(0x09837A82A928AB97LL, is_null);
      break;
    case 2969:
      HASH_INVOKE(0x076E66D4089A3B99LL, mb_stripos);
      break;
    case 2970:
      HASH_INVOKE(0x023133732CB51B9ALL, exif_thumbnail);
      break;
    case 2975:
      HASH_INVOKE(0x390A267EC6B51B9FLL, socket_sendto);
      break;
    case 2978:
      HASH_INVOKE(0x4870ADD98EE02BA2LL, pcntl_wifsignaled);
      break;
    case 2979:
      HASH_INVOKE(0x444A3375EFBC2BA3LL, openssl_public_decrypt);
      break;
    case 2980:
      HASH_INVOKE(0x0D95DD13A2D3BBA4LL, drawtranslate);
      break;
    case 2986:
      HASH_INVOKE(0x7C833A303C7CFBAALL, getrandmax);
      break;
    case 2987:
      HASH_INVOKE(0x006481EAF2A70BABLL, ldap_errno);
      break;
    case 2991:
      HASH_INVOKE(0x6A2236CDDFF12BAFLL, magickhaspreviousimage);
      break;
    case 2992:
      HASH_INVOKE(0x1F3E4C6660247BB0LL, imagecolorresolve);
      HASH_INVOKE(0x7D9BF61D6CDE3BB0LL, fb_parallel_query);
      break;
    case 2993:
      HASH_INVOKE(0x04A24B397CF46BB1LL, strrchr);
      break;
    case 2997:
      HASH_INVOKE(0x3F7DCC3A00800BB5LL, imagecolorallocate);
      break;
    case 3004:
      HASH_INVOKE(0x43B74276235F4BBCLL, is_bool);
      break;
    case 3006:
      HASH_INVOKE(0x79617ED8EFD1ABBELL, get_class_vars);
      HASH_INVOKE(0x3F56AF1511AEDBBELL, magicklabelimage);
      HASH_INVOKE(0x5ECB0B145B88EBBELL, imagefilledarc);
      HASH_INVOKE(0x42684202E2E62BBELL, mcrypt_get_iv_size);
      break;
    case 3015:
      HASH_INVOKE(0x10C5CF7B55173BC7LL, settype);
      break;
    case 3017:
      HASH_INVOKE(0x0B4E7B9180C4ABC9LL, xml_set_end_namespace_decl_handler);
      HASH_INVOKE(0x22BA0903D344CBC9LL, array_rand);
      break;
    case 3018:
      HASH_INVOKE(0x0D375A94E75ACBCALL, hphp_throw_fatal_error);
      HASH_INVOKE(0x4122DFAC25BDFBCALL, hphp_splfileinfo_getowner);
      break;
    case 3021:
      HASH_INVOKE(0x22251ECF8CD58BCDLL, array_product);
      HASH_INVOKE(0x53A88C8F973CFBCDLL, apc_clear_cache);
      break;
    case 3022:
      HASH_INVOKE(0x45D6BA980AFFDBCELL, msg_get_queue);
      HASH_INVOKE(0x600AFF0A6378ABCELL, is_writeable);
      break;
    case 3024:
      HASH_INVOKE(0x7046755D8374EBD0LL, ctype_digit);
      HASH_INVOKE(0x6846CA07A5E21BD0LL, hphp_directoryiterator___construct);
      break;
    case 3026:
      HASH_INVOKE(0x6FE3C5FF5E883BD2LL, round);
      break;
    case 3028:
      HASH_INVOKE(0x5B2F2A23D8368BD4LL, magickraiseimage);
      HASH_INVOKE(0x4E4EB301A994DBD4LL, drawpolygon);
      break;
    case 3032:
      HASH_INVOKE(0x21E44C7C7A911BD8LL, phpinfo);
      HASH_INVOKE(0x06D5979AB150EBD8LL, dom_node_lookup_namespace_uri);
      break;
    case 3038:
      HASH_INVOKE(0x58D0D9B66F045BDELL, strpos);
      break;
    case 3040:
      HASH_INVOKE(0x2E10B74DC6067BE0LL, strip_tags);
      break;
    case 3041:
      HASH_INVOKE(0x25FBB61480091BE1LL, mysql_client_encoding);
      break;
    case 3047:
      HASH_INVOKE(0x1BB5D99C1D29CBE7LL, strstr);
      break;
    case 3048:
      HASH_INVOKE(0x4E903B706977ABE8LL, imagepsslantfont);
      break;
    case 3051:
      HASH_INVOKE(0x505B44DDF2383BEBLL, drawgetfillcolor);
      HASH_INVOKE(0x0C1904372E8EDBEBLL, stream_copy_to_stream);
      break;
    case 3052:
      HASH_INVOKE(0x44279BB3E2191BECLL, socket_accept);
      HASH_INVOKE(0x5A22BA9B012A9BECLL, dom_document_save_html);
      break;
    case 3054:
      HASH_INVOKE(0x03F50E435DE20BEELL, magickclippathimage);
      HASH_INVOKE(0x790B7C44A3442BEELL, asort);
      break;
    case 3056:
      HASH_INVOKE(0x187C049E785A1BF0LL, iconv_get_encoding);
      HASH_INVOKE(0x04C0582DB1AD7BF0LL, mt_srand);
      break;
    case 3057:
      HASH_INVOKE(0x0CA96856E5BEFBF1LL, iptcparse);
      break;
    case 3060:
      HASH_INVOKE(0x1444DB037B4D5BF4LL, imagegammacorrect);
      break;
    case 3062:
      HASH_INVOKE(0x08B4BEBAB3312BF6LL, image_type_to_extension);
      break;
    case 3063:
      HASH_INVOKE(0x74ABB4A1E10BBBF7LL, time);
      break;
    case 3065:
      HASH_INVOKE(0x5B7F6E0A642BBBF9LL, sleep);
      break;
    case 3068:
      HASH_INVOKE(0x64F52E1DB5E95BFCLL, curl_multi_remove_handle);
      break;
    case 3074:
      HASH_INVOKE(0x249340DF734D9C02LL, magickgetimageheight);
      break;
    case 3077:
      HASH_INVOKE(0x2EC378A759F9EC05LL, xbox_task_status);
      break;
    case 3080:
      HASH_INVOKE(0x48E1616EE837FC08LL, is_uploaded_file);
      break;
    case 3082:
      HASH_INVOKE(0x1E47C281193ABC0ALL, collator_compare);
      break;
    case 3083:
      HASH_INVOKE(0x0EEE484739520C0BLL, magickthresholdimage);
      HASH_INVOKE(0x0833BCE91C40CC0BLL, magickqueryconfigureoption);
      break;
    case 3090:
      HASH_INVOKE(0x062C0FFA8E29DC12LL, intl_error_name);
      HASH_INVOKE(0x510B683F2E764C12LL, fb_load_local_databases);
      break;
    case 3095:
      HASH_INVOKE(0x3A702EF906B37C17LL, collator_get_locale);
      break;
    case 3099:
      HASH_INVOKE(0x67742A0F218F6C1BLL, posix_initgroups);
      HASH_INVOKE(0x7D615C7E3ADB2C1BLL, xmlwriter_write_comment);
      break;
    case 3100:
      HASH_INVOKE(0x758A62BD65E6FC1CLL, imagegd2);
      break;
    case 3102:
      HASH_INVOKE(0x7039C5EBB1D6BC1ELL, array_walk);
      break;
    case 3103:
      HASH_INVOKE(0x3A5D921797669C1FLL, hphp_log);
      break;
    case 3104:
      HASH_INVOKE(0x7BD43EB167198C20LL, xmlwriter_write_pi);
      break;
    case 3105:
      HASH_INVOKE(0x0179CBA2C5F4DC21LL, magickgetimageformat);
      break;
    case 3111:
      HASH_INVOKE(0x5A02EE8ED39F0C27LL, posix_getgrnam);
      break;
    case 3112:
      HASH_INVOKE(0x79A4E240F18BAC28LL, rand);
      break;
    case 3115:
      HASH_INVOKE(0x09A98E99D51E8C2BLL, hphp_recursivedirectoryiterator_seek);
      break;
    case 3116:
      HASH_INVOKE(0x116C3EC924B9AC2CLL, imagegd);
      break;
    case 3122:
      HASH_INVOKE(0x0B9B362534621C32LL, isdrawingwand);
      break;
    case 3123:
      HASH_INVOKE(0x49965C44E9EE3C33LL, set_file_buffer);
      break;
    case 3125:
      HASH_INVOKE(0x2B9A380A29D0EC35LL, session_write_close);
      break;
    case 3128:
      HASH_INVOKE(0x21564F9315F3FC38LL, drawsettextdecoration);
      break;
    case 3132:
      HASH_INVOKE(0x69488CC69B897C3CLL, hphp_recursiveiteratoriterator_getinneriterator);
      break;
    case 3134:
      HASH_INVOKE(0x15EC581662651C3ELL, date_parse);
      break;
    case 3141:
      HASH_INVOKE(0x6EF89BCAD607CC45LL, strncasecmp);
      break;
    case 3142:
      HASH_INVOKE(0x7D992445F5E37C46LL, magicktextureimage);
      break;
    case 3143:
      HASH_INVOKE(0x44055093E56E4C47LL, mcrypt_enc_get_key_size);
      break;
    case 3145:
      HASH_INVOKE(0x2D3F0F8DB0C20C49LL, dom_node_insert_before);
      HASH_INVOKE(0x357F73CEBD6E2C49LL, write_hdf_string);
      break;
    case 3146:
      HASH_INVOKE(0x3C23768CFB492C4ALL, gzinflate);
      break;
    case 3147:
      HASH_INVOKE(0x120E7B01366DFC4BLL, call_user_func_serialized);
      break;
    case 3150:
      HASH_INVOKE(0x5DAC1C64D8F08C4ELL, openssl_pkey_get_private);
      break;
    case 3152:
      HASH_INVOKE(0x04534F26B8D05C50LL, drawgetstrokecolor);
      break;
    case 3153:
      HASH_INVOKE(0x56EDB60C824E8C51LL, key);
      break;
    case 3154:
      HASH_INVOKE(0x1FC294B806F76C52LL, php_sapi_name);
      break;
    case 3159:
      HASH_INVOKE(0x793259E03C37CC57LL, memcache_decrement);
      HASH_INVOKE(0x313E8EB28A111C57LL, hphp_splfileinfo_setinfoclass);
      break;
    case 3160:
      HASH_INVOKE(0x1B8C3DA27170DC58LL, dirname);
      break;
    case 3161:
      HASH_INVOKE(0x57633BDF8DB3FC59LL, i18n_loc_set_attribute);
      break;
    case 3166:
      HASH_INVOKE(0x47B38F1E4FA29C5ELL, fb_get_code_coverage);
      break;
    case 3169:
      HASH_INVOKE(0x6E54EEDA1D887C61LL, magicksetimageinterlacescheme);
      HASH_INVOKE(0x5176725DA884DC61LL, curl_setopt);
      break;
    case 3171:
      HASH_INVOKE(0x43C0E9827D502C63LL, array_intersect_assoc);
      break;
    case 3172:
      HASH_INVOKE(0x3409D717D9246C64LL, libxml_use_internal_errors);
      break;
    case 3175:
      HASH_INVOKE(0x07DC355325165C67LL, magickwriteimage);
      break;
    case 3176:
      HASH_INVOKE(0x10D6AE9D688D1C68LL, copy);
      break;
    case 3178:
      HASH_INVOKE(0x41BD9EA0BC5E4C6ALL, move_uploaded_file);
      break;
    case 3179:
      HASH_INVOKE(0x7C6B37BF6300AC6BLL, iconv_mime_encode);
      break;
    case 3185:
      HASH_INVOKE(0x1E074215FE5FCC71LL, set_error_handler);
      HASH_INVOKE(0x18D9ED67E8E0FC71LL, dom_attr_is_id);
      break;
    case 3188:
      HASH_INVOKE(0x20F0AAA486F39C74LL, dom_element_get_elements_by_tag_name_ns);
      break;
    case 3189:
      HASH_INVOKE(0x528366F3195ACC75LL, xbox_task_result);
      break;
    case 3190:
      HASH_INVOKE(0x1C35934C6BC52C76LL, libxml_clear_errors);
      break;
    case 3192:
      HASH_INVOKE(0x665F08996BD4AC78LL, magicksetimagegreenprimary);
      break;
    case 3194:
      HASH_INVOKE(0x05D7B804ECDE8C7ALL, checkdnsrr);
      HASH_INVOKE(0x05F3BC04D61CAC7ALL, get_defined_vars);
      break;
    case 3195:
      HASH_INVOKE(0x749E45FBD48BEC7BLL, hphp_recursivedirectoryiterator___tostring);
      HASH_INVOKE(0x71B25229CD080C7BLL, dom_element_set_attribute_node_ns);
      break;
    case 3198:
      HASH_INVOKE(0x5F41821072A06C7ELL, hphp_splfileinfo_getctime);
      break;
    case 3201:
      HASH_INVOKE(0x767806D6F1053C81LL, sin);
      break;
    case 3204:
      HASH_INVOKE(0x5D49AF7004696C84LL, shm_detach);
      break;
    case 3205:
      HASH_INVOKE(0x56DA17241B793C85LL, mysql_set_timeout);
      break;
    case 3209:
      HASH_INVOKE(0x0F9C0C82F40F2C89LL, pixelsetcyanquantum);
      break;
    case 3214:
      HASH_INVOKE(0x467470230015AC8ELL, mcrypt_module_is_block_algorithm_mode);
      break;
    case 3215:
      HASH_INVOKE(0x4173EFD9A8EECC8FLL, magicknewimage);
      break;
    case 3216:
      HASH_INVOKE(0x05556EDFC1BB0C90LL, mysql_info);
      HASH_INVOKE(0x3F0C947E68D02C90LL, ini_get_all);
      break;
    case 3217:
      HASH_INVOKE(0x4E04B71729485C91LL, clonedrawingwand);
      break;
    case 3219:
      HASH_INVOKE(0x0F8242C6327B5C93LL, dns_check_record);
      break;
    case 3222:
      HASH_INVOKE(0x47C5BC101A512C96LL, magickquantizeimage);
      break;
    case 3225:
      HASH_INVOKE(0x2EA6E1D600786C99LL, mb_strtoupper);
      break;
    case 3226:
      HASH_INVOKE(0x374F20BDAF709C9ALL, mb_preferred_mime_name);
      break;
    case 3227:
      HASH_INVOKE(0x36F7F9FD7766DC9BLL, xmlwriter_end_comment);
      break;
    case 3230:
      HASH_INVOKE(0x50296037C7968C9ELL, preg_split);
      break;
    case 3233:
      HASH_INVOKE(0x4590B5971EC9ACA1LL, getmygid);
      break;
    case 3235:
      HASH_INVOKE(0x737253E9FC112CA3LL, socket_close);
      break;
    case 3245:
      HASH_INVOKE(0x1C1216F2B7C16CADLL, ftell);
      break;
    case 3246:
      HASH_INVOKE(0x12580A083B0D7CAELL, iterator_apply);
      HASH_INVOKE(0x3ACD2F1EA5282CAELL, magickmattefloodfillimage);
      break;
    case 3248:
      HASH_INVOKE(0x373B3FADEACB7CB0LL, openssl_private_encrypt);
      break;
    case 3249:
      HASH_INVOKE(0x40D8DC24FA917CB1LL, hphp_splfileobject_fgetss);
      HASH_INVOKE(0x735555B148E58CB1LL, ldap_read);
      break;
    case 3250:
      HASH_INVOKE(0x56023CC5ECC9ECB2LL, dns_get_mx);
      break;
    case 3252:
      HASH_INVOKE(0x41FBEF9F7A024CB4LL, xmlwriter_end_element);
      HASH_INVOKE(0x742AD1AA5A80ECB4LL, output_reset_rewrite_vars);
      break;
    case 3254:
      HASH_INVOKE(0x560637BE51C36CB6LL, ezmlm_hash);
      break;
    case 3255:
      HASH_INVOKE(0x3DFD5CA79919DCB7LL, imageantialias);
      HASH_INVOKE(0x39E03AAC188D3CB7LL, magickgetimagecompressionquality);
      break;
    case 3259:
      HASH_INVOKE(0x41D3B07854936CBBLL, token_get_all);
      HASH_INVOKE(0x15ACD9F32D214CBBLL, mysql_fetch_lengths);
      break;
    case 3260:
      HASH_INVOKE(0x19C1872E55A7ECBCLL, is_long);
      HASH_INVOKE(0x3978BE548631ECBCLL, hash_final);
      HASH_INVOKE(0x733137183026ACBCLL, hphp_splfileobject_next);
      break;
    case 3264:
      HASH_INVOKE(0x3033FE14E114FCC0LL, magicksetimageblueprimary);
      break;
    case 3266:
      HASH_INVOKE(0x42BCEFCF899D0CC2LL, magickgetimagecolorspace);
      HASH_INVOKE(0x34B6388D7730BCC2LL, drawline);
      break;
    case 3267:
      HASH_INVOKE(0x7A147B8B98C76CC3LL, key_exists);
      break;
    case 3278:
      HASH_INVOKE(0x0183A548B759BCCELL, posix_getpgid);
      HASH_INVOKE(0x66273C5932B1FCCELL, clock_gettime);
      break;
    case 3279:
      HASH_INVOKE(0x407B1F3AFEC43CCFLL, pixelgetblue);
      break;
    case 3281:
      HASH_INVOKE(0x576C5DC462663CD1LL, explode);
      break;
    case 3282:
      HASH_INVOKE(0x1FD3FB2AB0F48CD2LL, magickgetimagesignature);
      break;
    case 3283:
      HASH_INVOKE(0x544302E2FAD3FCD3LL, magicknextimage);
      HASH_INVOKE(0x6406BC03A5D84CD3LL, dom_element_remove_attribute);
      break;
    case 3284:
      HASH_INVOKE(0x323FE1D92C9B3CD4LL, gzdecode);
      break;
    case 3285:
      HASH_INVOKE(0x757BC444FDF79CD5LL, posix_get_last_error);
      break;
    case 3286:
      HASH_INVOKE(0x11166D3106DB6CD6LL, wandhasexception);
      break;
    case 3289:
      HASH_INVOKE(0x27BFAF1293A60CD9LL, ldap_get_dn);
      break;
    case 3290:
      HASH_INVOKE(0x674AA2DBDA5E4CDALL, imageloadfont);
      HASH_INVOKE(0x09C6455B4BC6FCDALL, drawsetviewbox);
      break;
    case 3298:
      HASH_INVOKE(0x6B92530A9ABA0CE2LL, session_commit);
      break;
    case 3300:
      HASH_INVOKE(0x7CDDF96AFEA2DCE4LL, chunk_split);
      break;
    case 3306:
      HASH_INVOKE(0x5A8AF4F880DA4CEALL, mailparse_msg_extract_whole_part_file);
      HASH_INVOKE(0x7821BD05E5228CEALL, imagewbmp);
      break;
    case 3310:
      HASH_INVOKE(0x78FFA0E69D6AACEELL, mcrypt_cfb);
      break;
    case 3311:
      HASH_INVOKE(0x6AA89C314C647CEFLL, magickgetimagehistogram);
      break;
    case 3313:
      HASH_INVOKE(0x21C8FC9A94404CF1LL, php_ini_scanned_files);
      break;
    case 3314:
      HASH_INVOKE(0x26C49BBC67475CF2LL, magicksetimagewhitepoint);
      break;
    case 3315:
      HASH_INVOKE(0x5C1F75D51C077CF3LL, pixelgetindex);
      break;
    case 3317:
      HASH_INVOKE(0x26729ECB00B8ECF5LL, end_user_func_async);
      break;
    case 3319:
      HASH_INVOKE(0x1C30C8470100ECF7LL, mcrypt_enc_is_block_mode);
      break;
    case 3321:
      HASH_INVOKE(0x537CF5DE8C43CCF9LL, curl_getinfo);
      break;
    case 3323:
      HASH_INVOKE(0x09B4EE276DCCFCFBLL, mysql_fetch_row);
      break;
    case 3326:
      HASH_INVOKE(0x768F3E6D1CBA5CFELL, socket_recv);
      break;
    case 3327:
      HASH_INVOKE(0x748D3DFF0EB57CFFLL, uniqid);
      HASH_INVOKE(0x48A2F2A7A4620CFFLL, pixelsetyellowquantum);
      break;
    case 3330:
      HASH_INVOKE(0x018F22AEA371ED02LL, filemtime);
      HASH_INVOKE(0x7EB48D1BB5B7AD02LL, dom_element_set_attribute);
      break;
    case 3331:
      HASH_INVOKE(0x48EE7157C4392D03LL, apache_getenv);
      break;
    case 3332:
      HASH_INVOKE(0x1248250E701DAD04LL, magickgaussianblurimage);
      break;
    case 3334:
      HASH_INVOKE(0x2BA9FB0F8B76DD06LL, number_format);
      break;
    case 3335:
      HASH_INVOKE(0x19B643D858DC6D07LL, magickgetimagerenderingintent);
      break;
    case 3337:
      HASH_INVOKE(0x153F7DBFC9047D09LL, pixelsetred);
      break;
    case 3338:
      HASH_INVOKE(0x6E8996DD071CED0ALL, dom_element_remove_attribute_node);
      break;
    case 3340:
      HASH_INVOKE(0x30A8326034801D0CLL, mysql_pconnect);
      break;
    case 3341:
      HASH_INVOKE(0x3ACE8A8BC9ACDD0DLL, iconv_mime_decode);
      break;
    case 3344:
      HASH_INVOKE(0x42BEEC88EE81FD10LL, imagechar);
      HASH_INVOKE(0x08F41A00D5D57D10LL, mb_decode_mimeheader);
      HASH_INVOKE(0x5CEFA5A265104D10LL, count);
      break;
    case 3345:
      HASH_INVOKE(0x2D484921B5400D11LL, magickradialblurimage);
      break;
    case 3346:
      HASH_INVOKE(0x5F165B40AEEE5D12LL, hphp_splfileinfo_getfilename);
      break;
    case 3348:
      HASH_INVOKE(0x63837ECAF6235D14LL, preg_replace);
      break;
    case 3351:
      HASH_INVOKE(0x12BB5E00E714ED17LL, magickgetimagecompose);
      break;
    case 3354:
      HASH_INVOKE(0x75DB75CA9DE56D1ALL, xml_parser_get_option);
      HASH_INVOKE(0x39994614C6315D1ALL, hphp_recursivedirectoryiterator_key);
      break;
    case 3355:
      HASH_INVOKE(0x70C22A7EEF54CD1BLL, ldap_compare);
      break;
    case 3358:
      HASH_INVOKE(0x25DADFF238A15D1ELL, collator_create);
      break;
    case 3359:
      HASH_INVOKE(0x566465036CCBCD1FLL, min);
      break;
    case 3365:
      HASH_INVOKE(0x71DF0C17F47EDD25LL, getprotobynumber);
      break;
    case 3366:
      HASH_INVOKE(0x429D088E9779CD26LL, dom_document_normalize_document);
      break;
    case 3368:
      HASH_INVOKE(0x7C12261259F87D28LL, mcrypt_enc_is_block_algorithm_mode);
      break;
    case 3369:
      HASH_INVOKE(0x632D50B69429ED29LL, socket_set_block);
      break;
    case 3370:
      HASH_INVOKE(0x7A9C06B9CF853D2ALL, substr_count);
      break;
    case 3378:
      HASH_INVOKE(0x4DAC43060BA57D32LL, stream_wrapper_restore);
      break;
    case 3382:
      HASH_INVOKE(0x515841235FADCD36LL, class_implements);
      break;
    case 3383:
      HASH_INVOKE(0x3ACF745D381E9D37LL, rtrim);
      break;
    case 3384:
      HASH_INVOKE(0x0BA3AD85EB597D38LL, pagelet_server_task_result);
      break;
    case 3387:
      HASH_INVOKE(0x0784B2B034560D3BLL, destroypixelwand);
      HASH_INVOKE(0x6C9AE626DAD02D3BLL, mailparse_msg_extract_part_file);
      break;
    case 3392:
      HASH_INVOKE(0x198627C81DABAD40LL, register_cleanup_function);
      break;
    case 3393:
      HASH_INVOKE(0x6B6DA1EE18673D41LL, xmlwriter_end_dtd_entity);
      break;
    case 3394:
      HASH_INVOKE(0x40497FCA4EC4DD42LL, posix_seteuid);
      HASH_INVOKE(0x298BA735FA3ABD42LL, nl_langinfo);
      break;
    case 3397:
      HASH_INVOKE(0x400A44045A999D45LL, rawurlencode);
      break;
    case 3398:
      HASH_INVOKE(0x502CF4EB0A747D46LL, magicksetimagebias);
      HASH_INVOKE(0x455DB7F86BCEDD46LL, pixelsetopacityquantum);
      HASH_INVOKE(0x59AD2C922FF75D46LL, mdecrypt_generic);
      break;
    case 3401:
      HASH_INVOKE(0x113ED435AEFDDD49LL, imagecolorallocatealpha);
      HASH_INVOKE(0x41785512C45FCD49LL, mysql_ping);
      break;
    case 3407:
      HASH_INVOKE(0x0FBCF35ADD209D4FLL, drawarc);
      break;
    case 3408:
      HASH_INVOKE(0x39B11A2A25E40D50LL, mysql_get_server_info);
      HASH_INVOKE(0x337D2252CDA22D50LL, is_real);
      break;
    case 3413:
      HASH_INVOKE(0x36D672EF4FBEFD55LL, json_encode);
      break;
    case 3416:
      HASH_INVOKE(0x146109BDD2F97D58LL, hphp_splfileobject_setmaxlinelen);
      break;
    case 3418:
      HASH_INVOKE(0x4ACCF26A7AE80D5ALL, imagefilltoborder);
      break;
    case 3419:
      HASH_INVOKE(0x41B5E3D2AADE2D5BLL, drawroundrectangle);
      break;
    case 3420:
      HASH_INVOKE(0x1371413B4F6F8D5CLL, pixelgetred);
      break;
    case 3424:
      HASH_INVOKE(0x6FACBD7F02B6FD60LL, uasort);
      HASH_INVOKE(0x567276D68FE12D60LL, preg_quote);
      break;
    case 3425:
      HASH_INVOKE(0x34F150F3D94E6D61LL, gzpassthru);
      HASH_INVOKE(0x357BAB6E700EBD61LL, destroypixelwandarray);
      break;
    case 3430:
      HASH_INVOKE(0x0C393EE8F6540D66LL, bccomp);
      break;
    case 3437:
      HASH_INVOKE(0x21D924BA98BFCD6DLL, file_get_contents);
      HASH_INVOKE(0x7D9E024FD8696D6DLL, get_class);
      HASH_INVOKE(0x4351AFD0FD818D6DLL, magickmotionblurimage);
      break;
    case 3438:
      HASH_INVOKE(0x0B1348D1540E7D6ELL, magicksetimageformat);
      break;
    case 3441:
      HASH_INVOKE(0x74FDC4596C654D71LL, dom_node_is_default_namespace);
      break;
    case 3443:
      HASH_INVOKE(0x7D8DCC72522CBD73LL, mb_detect_encoding);
      break;
    case 3446:
      HASH_INVOKE(0x7467E8107EF08D76LL, unpack);
      break;
    case 3447:
      HASH_INVOKE(0x3ED49C2BBDDFAD77LL, ldap_next_reference);
      HASH_INVOKE(0x7FCAAAB932C57D77LL, iterator_count);
      break;
    case 3448:
      HASH_INVOKE(0x6352349F97557D78LL, stream_socket_get_name);
      break;
    case 3451:
      HASH_INVOKE(0x680A7EB3DA1F5D7BLL, prev);
      break;
    case 3454:
      HASH_INVOKE(0x384E8BC9B5FE2D7ELL, magickfximage);
      break;
    case 3455:
      HASH_INVOKE(0x4E19AFB75A62AD7FLL, imagerotate);
      break;
    case 3457:
      HASH_INVOKE(0x25EA810DAEA74D81LL, ob_clean);
      break;
    case 3458:
      HASH_INVOKE(0x2D15262403ADDD82LL, drawcomposite);
      break;
    case 3459:
      HASH_INVOKE(0x1B0FF5C02F571D83LL, fb_rename_function);
      break;
    case 3463:
      HASH_INVOKE(0x344091B785FE8D87LL, socket_set_timeout);
      break;
    case 3464:
      HASH_INVOKE(0x2AFF8525E93D6D88LL, drawsetfillopacity);
      HASH_INVOKE(0x1F22C82816F9AD88LL, hphp_splfileinfo_getpath);
      break;
    case 3465:
      HASH_INVOKE(0x230E7AD147721D89LL, end);
      break;
    case 3470:
      HASH_INVOKE(0x6A351AEDFC4D0D8ELL, magickgetimagemimetype);
      break;
    case 3471:
      HASH_INVOKE(0x1806DC9468882D8FLL, gzfile);
      break;
    case 3472:
      HASH_INVOKE(0x5E4360FC28D0AD90LL, magicksetinterlacescheme);
      break;
    case 3473:
      HASH_INVOKE(0x5695393CF6428D91LL, dom_element_set_id_attribute);
      HASH_INVOKE(0x48444F8F18E60D91LL, strftime);
      HASH_INVOKE(0x7C2B3FE61FBDFD91LL, openssl_pkey_get_details);
      break;
    case 3480:
      HASH_INVOKE(0x06A796D329C21D98LL, call_user_func);
      break;
    case 3485:
      HASH_INVOKE(0x74BE8836F3B13D9DLL, session_name);
      break;
    case 3486:
      HASH_INVOKE(0x30C1AE2B06990D9ELL, gzseek);
      break;
    case 3488:
      HASH_INVOKE(0x73B43ABDD5C61DA0LL, shuffle);
      HASH_INVOKE(0x5E8606470A09BDA0LL, magickposterizeimage);
      HASH_INVOKE(0x7084C6294240CDA0LL, octdec);
      HASH_INVOKE(0x167A11C41EB71DA0LL, pixelgetexceptiontype);
      break;
    case 3490:
      HASH_INVOKE(0x71583A8FEF5C7DA2LL, sys_get_temp_dir);
      break;
    case 3493:
      HASH_INVOKE(0x46B2F287D2FC7DA5LL, memcache_get);
      break;
    case 3494:
      HASH_INVOKE(0x28DC1AD6DA9E7DA6LL, gethostbyname);
      break;
    case 3496:
      HASH_INVOKE(0x18FEAF2459E5ADA8LL, dom_element_has_attribute);
      HASH_INVOKE(0x572AE270D9E4FDA8LL, socket_set_option);
      HASH_INVOKE(0x474A096265502DA8LL, glob);
      break;
    case 3498:
      HASH_INVOKE(0x6326C14D0FFA7DAALL, fb_thrift_serialize);
      break;
    case 3499:
      HASH_INVOKE(0x188720048AB37DABLL, magickquantizeimages);
      HASH_INVOKE(0x66764CAABFF4CDABLL, array_keys);
      break;
    case 3505:
      HASH_INVOKE(0x67EAC6D7332F3DB1LL, hphp_splfileobject_fgetcsv);
      break;
    case 3506:
      HASH_INVOKE(0x257371BC40186DB2LL, magickblurimage);
      break;
    case 3507:
      HASH_INVOKE(0x628069E483F35DB3LL, hphp_splfileobject_fstat);
      HASH_INVOKE(0x53F2C6F5AE244DB3LL, drawpushdefs);
      break;
    case 3512:
      HASH_INVOKE(0x2B1D442AEA06ADB8LL, strpbrk);
      break;
    case 3514:
      HASH_INVOKE(0x5E0C6E797607DDBALL, mysql_result);
      HASH_INVOKE(0x7964DE73DCA17DBALL, magickhasnextimage);
      break;
    case 3516:
      HASH_INVOKE(0x770DEDCB168B0DBCLL, mb_ereg_search_setpos);
      break;
    case 3517:
      HASH_INVOKE(0x48AA091B1E493DBDLL, setlocale);
      HASH_INVOKE(0x01E6FF7D9746CDBDLL, stream_socket_accept);
      break;
    case 3521:
      HASH_INVOKE(0x683E88F441F9BDC1LL, chgrp);
      break;
    case 3523:
      HASH_INVOKE(0x069EE6F604BA2DC3LL, array_reverse);
      HASH_INVOKE(0x0433140BB339DDC3LL, log);
      break;
    case 3524:
      HASH_INVOKE(0x2A38BA8B4A0F9DC4LL, apc_fetch);
      break;
    case 3526:
      HASH_INVOKE(0x73210FEAA2EACDC6LL, imagecolorsforindex);
      break;
    case 3528:
      HASH_INVOKE(0x66C3E73210067DC8LL, magickgetimageunits);
      break;
    case 3530:
      HASH_INVOKE(0x3BB701F2BDD0ADCALL, magickgetimageprofile);
      break;
    case 3534:
      HASH_INVOKE(0x3E5C990C32470DCELL, array_combine);
      HASH_INVOKE(0x4AD5B65BCE665DCELL, array_key_exists);
      HASH_INVOKE(0x40C3C7DE46D62DCELL, ob_start);
      break;
    case 3536:
      HASH_INVOKE(0x0E1C354339208DD0LL, imagetypes);
      break;
    case 3541:
      HASH_INVOKE(0x7E1801C8E70D1DD5LL, imagefontwidth);
      break;
    case 3543:
      HASH_INVOKE(0x638690DF6D06FDD7LL, imageconvolution);
      HASH_INVOKE(0x1AE08377A1630DD7LL, mysql_insert_id);
      break;
    case 3548:
      HASH_INVOKE(0x5EBE067E3FAECDDCLL, ob_gzhandler);
      HASH_INVOKE(0x2497295AC9F72DDCLL, stream_set_blocking);
      break;
    case 3549:
      HASH_INVOKE(0x3B00B916C3682DDDLL, ctype_upper);
      break;
    case 3560:
      HASH_INVOKE(0x47A4BA8616D02DE8LL, restore_exception_handler);
      break;
    case 3564:
      HASH_INVOKE(0x5B51DD18C3E13DECLL, openssl_x509_parse);
      HASH_INVOKE(0x5ABB7486CE861DECLL, array_merge_recursive);
      break;
    case 3567:
      HASH_INVOKE(0x0BB22147ADADDDEFLL, pfsockopen);
      HASH_INVOKE(0x72293DCE8CC4BDEFLL, htmlspecialchars);
      break;
    case 3571:
      HASH_INVOKE(0x7AE1BE187F18FDF3LL, fgets);
      break;
    case 3572:
      HASH_INVOKE(0x73B30E65808A6DF4LL, ctype_xdigit);
      HASH_INVOKE(0x5046A0D9DFDB5DF4LL, strcspn);
      break;
    case 3575:
      HASH_INVOKE(0x23E563F1EC919DF7LL, hphp_splfileinfo_getpathname);
      break;
    case 3576:
      HASH_INVOKE(0x5E43280BC8DD1DF8LL, magicktrimimage);
      break;
    case 3579:
      HASH_INVOKE(0x47C62D58B0B65DFBLL, thrift_protocol_write_binary);
      break;
    case 3582:
      HASH_INVOKE(0x21F24104004CFDFELL, evhttp_post);
      HASH_INVOKE(0x072690BF719D7DFELL, hphp_recursivedirectoryiterator_rewind);
      break;
    case 3586:
      HASH_INVOKE(0x7829D2171DFBFE02LL, magickgetimagegamma);
      break;
    case 3596:
      HASH_INVOKE(0x3AD6E084483B2E0CLL, array_udiff_assoc);
      break;
    case 3597:
      HASH_INVOKE(0x5EB0A2F93E650E0DLL, array_diff_key);
      HASH_INVOKE(0x756B92411E7FBE0DLL, stream_get_wrappers);
      break;
    case 3598:
      HASH_INVOKE(0x5230E4C9D8D64E0ELL, highlight_string);
      break;
    case 3602:
      HASH_INVOKE(0x05FAA2085D94FE12LL, urlencode);
      HASH_INVOKE(0x76636D0F0C090E12LL, curl_copy_handle);
      break;
    case 3604:
      HASH_INVOKE(0x41E394B12170BE14LL, socket_send);
      HASH_INVOKE(0x3192209D50C1FE14LL, pixelsetalpha);
      break;
    case 3605:
      HASH_INVOKE(0x525F197D74423E15LL, get_resource_type);
      break;
    case 3607:
      HASH_INVOKE(0x0F5759A501FAFE17LL, imagecreatefromgd2part);
      HASH_INVOKE(0x3D13FD5FE3AF6E17LL, imagestringup);
      break;
    case 3609:
      HASH_INVOKE(0x4A694B42B21A9E19LL, destroymagickwand);
      break;
    case 3611:
      HASH_INVOKE(0x7FA0B63054221E1BLL, magickrollimage);
      break;
    case 3616:
      HASH_INVOKE(0x7BDA47B5C47EAE20LL, fread);
      break;
    case 3617:
      HASH_INVOKE(0x5B7F218FA08D8E21LL, imagefilledellipse);
      break;
    case 3621:
      HASH_INVOKE(0x1C6246FA51EBDE25LL, hphp_get_static_property);
      break;
    case 3624:
      HASH_INVOKE(0x3456885FF0679E28LL, lchown);
      break;
    case 3625:
      HASH_INVOKE(0x73FE5C79E14A0E29LL, pixelsetbluequantum);
      break;
    case 3629:
      HASH_INVOKE(0x7817FA38BAAEFE2DLL, fsockopen);
      break;
    case 3630:
      HASH_INVOKE(0x3E62C1A48E9EEE2ELL, hphp_splfileinfo_getsize);
      break;
    case 3634:
      HASH_INVOKE(0x000AAF93F814AE32LL, drawsetvectorgraphics);
      break;
    case 3635:
      HASH_INVOKE(0x38433635F28B4E33LL, is_readable);
      break;
    case 3638:
      HASH_INVOKE(0x2E42ED1E15CCFE36LL, mysql_affected_rows);
      break;
    case 3642:
      HASH_INVOKE(0x6E2CF6ECA0987E3ALL, get_headers);
      HASH_INVOKE(0x13048F0A79F7CE3ALL, magicksetsamplingfactors);
      break;
    case 3648:
      HASH_INVOKE(0x11681FDE841D0E40LL, drawskewy);
      break;
    case 3650:
      HASH_INVOKE(0x160B01F095B20E42LL, mb_output_handler);
      break;
    case 3652:
      HASH_INVOKE(0x71B7756BD1B43E44LL, dom_document_savexml);
      break;
    case 3654:
      HASH_INVOKE(0x7F4C1DF551150E46LL, pixelgetnextiteratorrow);
      break;
    case 3660:
      HASH_INVOKE(0x1EEBDFD62B6BEE4CLL, mcrypt_module_get_algo_block_size);
      break;
    case 3663:
      HASH_INVOKE(0x62C934CD93938E4FLL, magickimplodeimage);
      break;
    case 3664:
      HASH_INVOKE(0x4022005DE7E24E50LL, openssl_pkcs7_sign);
      break;
    case 3668:
      HASH_INVOKE(0x6BF155774D546E54LL, define_syslog_variables);
      HASH_INVOKE(0x7B6BF544EB420E54LL, hphp_recursivedirectoryiterator_haschildren);
      break;
    case 3671:
      HASH_INVOKE(0x21B07F1F212BDE57LL, hphp_get_original_class_name);
      HASH_INVOKE(0x2DEF52641933CE57LL, magickgetimagemattecolor);
      break;
    case 3675:
      HASH_INVOKE(0x299F1A5895461E5BLL, curl_multi_close);
      break;
    case 3676:
      HASH_INVOKE(0x532D0D905CE60E5CLL, posix_times);
      break;
    case 3677:
      HASH_INVOKE(0x38373F6643B14E5DLL, ldap_parse_reference);
      break;
    case 3681:
      HASH_INVOKE(0x593EA675D239CE61LL, ldap_first_reference);
      break;
    case 3682:
      HASH_INVOKE(0x7639C74DBC4F4E62LL, array_splice);
      break;
    case 3683:
      HASH_INVOKE(0x4B6FE37D66784E63LL, imagesy);
      HASH_INVOKE(0x5697E5F6AAF47E63LL, mb_http_input);
      break;
    case 3684:
      HASH_INVOKE(0x4F0DF8BBC4340E64LL, stream_socket_server);
      break;
    case 3685:
      HASH_INVOKE(0x21D5A3208639EE65LL, dom_element_get_attribute_node_ns);
      break;
    case 3686:
      HASH_INVOKE(0x6CB3DEB458A2DE66LL, apc_bin_load);
      break;
    case 3688:
      HASH_INVOKE(0x5B1DFB89BFC1CE68LL, realpath);
      break;
    case 3689:
      HASH_INVOKE(0x24B836D2C79D0E69LL, magickgetimagepixels);
      break;
    case 3690:
      HASH_INVOKE(0x2F9816D9A2B2CE6ALL, mysql_set_charset);
      HASH_INVOKE(0x25C0C5E961AFDE6ALL, xmlwriter_full_end_element);
      break;
    case 3693:
      HASH_INVOKE(0x714001ABB0D76E6DLL, magickgetinterlacescheme);
      break;
    case 3695:
      HASH_INVOKE(0x7E6223D0CF184E6FLL, magickqueryformats);
      break;
    case 3697:
      HASH_INVOKE(0x6AC126DCE941FE71LL, memory_get_peak_usage);
      break;
    case 3699:
      HASH_INVOKE(0x3B28CA1BE1D0DE73LL, xbox_get_thread_timeout);
      break;
    case 3700:
      HASH_INVOKE(0x47D0510206B89E74LL, ini_restore);
      break;
    case 3701:
      HASH_INVOKE(0x4EC7C66593DDEE75LL, sql_regcase);
      break;
    case 3702:
      HASH_INVOKE(0x36E9EC047FC73E76LL, mb_convert_encoding);
      break;
    case 3703:
      HASH_INVOKE(0x12B7B2D835B80E77LL, chmod);
      break;
    case 3706:
      HASH_INVOKE(0x6A3D9F8EDB005E7ALL, flush);
      break;
    case 3708:
      HASH_INVOKE(0x4D9C5B9A944CCE7CLL, convert_uudecode);
      break;
    case 3710:
      HASH_INVOKE(0x51060D186C703E7ELL, headers_list);
      break;
    case 3713:
      HASH_INVOKE(0x0ECFC3676B4FDE81LL, chr);
      HASH_INVOKE(0x3B426B13FA584E81LL, fb_unserialize);
      break;
    case 3714:
      HASH_INVOKE(0x379F7BF525FF1E82LL, magicksetimagecolorspace);
      break;
    case 3715:
      HASH_INVOKE(0x724011CF7C31AE83LL, sqrt);
      break;
    case 3716:
      HASH_INVOKE(0x1765A63835CC4E84LL, drawgetfontfamily);
      break;
    case 3717:
      HASH_INVOKE(0x4710320ED6638E85LL, rename_function);
      break;
    case 3720:
      HASH_INVOKE(0x1569DCC552EE8E88LL, cosh);
      break;
    case 3722:
      HASH_INVOKE(0x15C9E5C16374EE8ALL, gzclose);
      break;
    case 3726:
      HASH_INVOKE(0x29A2FBD427647E8ELL, mysql_connect);
      break;
    case 3728:
      HASH_INVOKE(0x33D6CC3959D3CE90LL, clearmagickwand);
      break;
    case 3731:
      HASH_INVOKE(0x5E968924197F5E93LL, mcrypt_ofb);
      HASH_INVOKE(0x37A9E8F91C33EE93LL, magickborderimage);
      break;
    case 3735:
      HASH_INVOKE(0x6254E9BDC11F3E97LL, imagecreatefromgd2);
      break;
    case 3739:
      HASH_INVOKE(0x2A019CAA1188BE9BLL, preg_grep);
      break;
    case 3742:
      HASH_INVOKE(0x76EBE919625D8E9ELL, openssl_pkcs12_export);
      break;
    case 3743:
      HASH_INVOKE(0x224004A728974E9FLL, spl_object_hash);
      HASH_INVOKE(0x7CFF820207DC6E9FLL, debug_backtrace);
      break;
    case 3744:
      HASH_INVOKE(0x37C5AF6E7E8B5EA0LL, fputs);
      break;
    case 3747:
      HASH_INVOKE(0x6467FFB910B8BEA3LL, magickspliceimage);
      break;
    case 3750:
      HASH_INVOKE(0x1D7B8E395613AEA6LL, dom_element_remove_attribute_ns);
      break;
    case 3752:
      HASH_INVOKE(0x3C6190E9534F3EA8LL, ebcdic2ascii);
      break;
    case 3753:
      HASH_INVOKE(0x308D76DB12424EA9LL, magicksetimageindex);
      break;
    case 3755:
      HASH_INVOKE(0x632D4FC346797EABLL, pixelgetexceptionstring);
      break;
    case 3758:
      HASH_INVOKE(0x5772A0B8C16DAEAELL, posix_setuid);
      break;
    case 3759:
      HASH_INVOKE(0x12D83A92EFB0EEAFLL, xmlwriter_open_uri);
      break;
    case 3761:
      HASH_INVOKE(0x33FE101882726EB1LL, proc_close);
      break;
    case 3763:
      HASH_INVOKE(0x7DB9D839ACE0DEB3LL, natsort);
      HASH_INVOKE(0x7379B5B97EC2EEB3LL, hypot);
      break;
    case 3764:
      HASH_INVOKE(0x1F936B3C5406DEB4LL, fb_set_taint);
      break;
    case 3767:
      HASH_INVOKE(0x58B9EFA0FB35FEB7LL, stream_filter_prepend);
      break;
    case 3769:
      HASH_INVOKE(0x2A483AD7A3D07EB9LL, magickgetwandsize);
      break;
    case 3770:
      HASH_INVOKE(0x1F5B2728DE875EBALL, magicksetimage);
      break;
    case 3773:
      HASH_INVOKE(0x31A30B274AD2DEBDLL, call_user_func_array_rpc);
      break;
    case 3776:
      HASH_INVOKE(0x2475D7045D9DEEC0LL, magicksetimagecompression);
      HASH_INVOKE(0x495316E596537EC0LL, imagefttext);
      break;
    case 3778:
      HASH_INVOKE(0x4CDD0B7BF826FEC2LL, rewinddir);
      break;
    case 3780:
      HASH_INVOKE(0x7052903F1B17AEC4LL, parse_str);
      break;
    case 3781:
      HASH_INVOKE(0x7D69B3537C353EC5LL, hphp_splfileinfo_isfile);
      break;
    case 3783:
      HASH_INVOKE(0x4FC99DC20A955EC7LL, session_module_name);
      break;
    case 3785:
      HASH_INVOKE(0x58C8DCAAE5B7CEC9LL, get_cfg_var);
      break;
    case 3786:
      HASH_INVOKE(0x08E6C1CD3AC64ECALL, hphp_splfileinfo_gettype);
      HASH_INVOKE(0x1AA83A1057BE6ECALL, mysql_field_len);
      break;
    case 3794:
      HASH_INVOKE(0x3CCD09EC3511CED2LL, apd_stop_trace);
      break;
    case 3798:
      HASH_INVOKE(0x134B37520683DED6LL, imagesetbrush);
      break;
    case 3800:
      HASH_INVOKE(0x338D9D95095D1ED8LL, magicksetimagedelay);
      break;
    case 3801:
      HASH_INVOKE(0x7F802A06996BBED9LL, apd_set_browser_trace);
      break;
    case 3802:
      HASH_INVOKE(0x29E2771785CCBEDALL, magickgettextdescent);
      break;
    case 3803:
      HASH_INVOKE(0x16331E18B5CD8EDBLL, timezone_open);
      HASH_INVOKE(0x1340509769275EDBLL, magickgetimagecompression);
      break;
    case 3808:
      HASH_INVOKE(0x7A1C6E429399CEE0LL, iconv_set_encoding);
      break;
    case 3809:
      HASH_INVOKE(0x528BA9796BD0FEE1LL, fb_rpc_intercept_handler);
      break;
    case 3811:
      HASH_INVOKE(0x1F4AACF075E9CEE3LL, memcache_get_server_status);
      HASH_INVOKE(0x28A98134BD97BEE3LL, mb_regex_encoding);
      HASH_INVOKE(0x0E1368A3BDFE6EE3LL, hphp_recursiveiteratoriterator_rewind);
      break;
    case 3812:
      HASH_INVOKE(0x5B6FF42ACB2FBEE4LL, getmyuid);
      break;
    case 3813:
      HASH_INVOKE(0x367CFD20B4446EE5LL, is_array);
      break;
    case 3816:
      HASH_INVOKE(0x6CB6650E66CE4EE8LL, magicksetimagebordercolor);
      HASH_INVOKE(0x32B3951DFD2B9EE8LL, hphp_directoryiterator_isdot);
      break;
    case 3819:
      HASH_INVOKE(0x72882DBF2D49CEEBLL, set_magic_quotes_runtime);
      break;
    case 3824:
      HASH_INVOKE(0x7DFF9707F1CD9EF0LL, dangling_server_proxy_old_request);
      break;
    case 3832:
      HASH_INVOKE(0x33FD10AC81146EF8LL, thrift_protocol_read_binary);
      break;
    case 3833:
      HASH_INVOKE(0x200FC256EB093EF9LL, gettimeofday);
      break;
    case 3835:
      HASH_INVOKE(0x6D450F078F02BEFBLL, apd_continue);
      break;
    case 3837:
      HASH_INVOKE(0x0CF27A6BC84CEEFDLL, openssl_get_publickey);
      HASH_INVOKE(0x283E167EB3F04EFDLL, posix_getgid);
      break;
    case 3840:
      HASH_INVOKE(0x09637D7CA2E33F00LL, fgetc);
      break;
    case 3841:
      HASH_INVOKE(0x66137942508EBF01LL, date_create);
      HASH_INVOKE(0x7B6A0D7510184F01LL, mysql_fetch_assoc);
      break;
    case 3842:
      HASH_INVOKE(0x78A02A603FA6FF02LL, magickreducenoiseimage);
      break;
    case 3845:
      HASH_INVOKE(0x6842585E79988F05LL, magickmosaicimages);
      break;
    case 3846:
      HASH_INVOKE(0x1D3B08AA0AF50F06LL, gettype);
      HASH_INVOKE(0x6692475BA65A2F06LL, imagearc);
      break;
    case 3851:
      HASH_INVOKE(0x7756593AAC1F6F0BLL, imagecreatefromstring);
      break;
    case 3855:
      HASH_INVOKE(0x61E7A36CA7FF5F0FLL, drawsetcliprule);
      HASH_INVOKE(0x4BD54A631F665F0FLL, drawpathcurvetosmoothabsolute);
      break;
    case 3856:
      HASH_INVOKE(0x700A75BF904DAF10LL, magickgetcharwidth);
      break;
    case 3858:
      HASH_INVOKE(0x042492DDA48C4F12LL, gzdeflate);
      break;
    case 3859:
      HASH_INVOKE(0x3B197C0731233F13LL, dom_characterdata_substring_data);
      break;
    case 3860:
      HASH_INVOKE(0x04525BA2AE51EF14LL, date_sun_info);
      break;
    case 3861:
      HASH_INVOKE(0x12F09EAED9078F15LL, mysql_fetch_field);
      break;
    case 3862:
      HASH_INVOKE(0x23B7D9E4EC992F16LL, stream_get_line);
      HASH_INVOKE(0x38664EFE3E0A0F16LL, json_decode);
      HASH_INVOKE(0x0287B907DDA3EF16LL, hphpd_get_user_commands);
      break;
    case 3867:
      HASH_INVOKE(0x27A4633381195F1BLL, chown);
      break;
    case 3871:
      HASH_INVOKE(0x7C0C145EFE0EBF1FLL, defined);
      break;
    case 3872:
      HASH_INVOKE(0x2C4206A0BD904F20LL, hphp_splfileobject_fseek);
      break;
    case 3873:
      HASH_INVOKE(0x4282496A4BF42F21LL, php_uname);
      HASH_INVOKE(0x77EC28645855AF21LL, magicksetcompressionquality);
      HASH_INVOKE(0x1FF5B9A4FC78BF21LL, drawsettextantialias);
      break;
    case 3876:
      HASH_INVOKE(0x05BD68F1D09CEF24LL, array_count_values);
      HASH_INVOKE(0x5FA07E8B63BEAF24LL, mcrypt_enc_get_modes_name);
      break;
    case 3879:
      HASH_INVOKE(0x4BAA5B688E6F6F27LL, gd_info);
      break;
    case 3884:
      HASH_INVOKE(0x035EFF9E1757DF2CLL, http_build_query);
      break;
    case 3890:
      HASH_INVOKE(0x78257F34467BDF32LL, drawsetstrokedasharray);
      HASH_INVOKE(0x2B66EACB77AE9F32LL, print_r);
      break;
    case 3897:
      HASH_INVOKE(0x0D4446B2DBC8EF39LL, hphp_splfileinfo_getinode);
      HASH_INVOKE(0x3E9146C06AAEFF39LL, magicksetimagecompressionquality);
      HASH_INVOKE(0x496CF4113CEA8F39LL, magicksetimagefilename);
      break;
    case 3899:
      HASH_INVOKE(0x7EE74F798791CF3BLL, magickedgeimage);
      break;
    case 3900:
      HASH_INVOKE(0x41136A5F28E84F3CLL, forward_static_call_array);
      break;
    case 3903:
      HASH_INVOKE(0x1A9EFDD653DB8F3FLL, pcntl_wstopsig);
      break;
    case 3906:
      HASH_INVOKE(0x3B46305DA1154F42LL, drawpopclippath);
      break;
    case 3909:
      HASH_INVOKE(0x4E36A077234B8F45LL, pixelgetblack);
      HASH_INVOKE(0x79265AADD9A8AF45LL, mcrypt_cbc);
      HASH_INVOKE(0x5D3A31AB0E326F45LL, crc32);
      break;
    case 3910:
      HASH_INVOKE(0x079EA27F72594F46LL, gzgets);
      break;
    case 3920:
      HASH_INVOKE(0x7978A278AEAFAF50LL, pixelgetmagenta);
      break;
    case 3925:
      HASH_INVOKE(0x49D986274B1C5F55LL, collator_asort);
      break;
    case 3926:
      HASH_INVOKE(0x621590803EC88F56LL, imageline);
      break;
    case 3928:
      HASH_INVOKE(0x0551AAE8F1A6FF58LL, magicklevelimage);
      break;
    case 3929:
      HASH_INVOKE(0x38246B6BDE246F59LL, magickgetimagedispose);
      break;
    case 3931:
      HASH_INVOKE(0x24F698A8A4B5AF5BLL, imagecolordeallocate);
      HASH_INVOKE(0x76418F884500DF5BLL, stream_socket_enable_crypto);
      break;
    case 3933:
      HASH_INVOKE(0x07FF92CF46DDFF5DLL, imagepsfreefont);
      break;
    case 3935:
      HASH_INVOKE(0x703D339DD44E8F5FLL, dom_element_get_elements_by_tag_name);
      break;
    case 3936:
      HASH_INVOKE(0x4F1D2858AD31AF60LL, imagecreatefromgd);
      break;
    case 3939:
      HASH_INVOKE(0x1FFD204252F60F63LL, magicksetimageprofile);
      break;
    case 3940:
      HASH_INVOKE(0x41EF51E62AD3DF64LL, pagelet_server_is_enabled);
      HASH_INVOKE(0x280051555A21DF64LL, rename);
      break;
    case 3942:
      HASH_INVOKE(0x6FFF1304EA444F66LL, drawsetstrokemiterlimit);
      break;
    case 3943:
      HASH_INVOKE(0x319407AC92912F67LL, ereg);
      break;
    case 3946:
      HASH_INVOKE(0x1670096FDE27AF6ALL, rewind);
      break;
    case 3947:
      HASH_INVOKE(0x56EF59D6CB0A5F6BLL, dom_document_save_html_file);
      break;
    case 3948:
      HASH_INVOKE(0x23D5E9E53D11BF6CLL, gmdate);
      break;
    case 3950:
      HASH_INVOKE(0x3A56371CDDEA0F6ELL, gzgetc);
      break;
    case 3951:
      HASH_INVOKE(0x42C4EC9D9F782F6FLL, htmlentities);
      break;
    case 3952:
      HASH_INVOKE(0x68C257B62A36EF70LL, magicksetimagebackgroundcolor);
      HASH_INVOKE(0x71557D108E5C0F70LL, xml_set_object);
      break;
    case 3954:
      HASH_INVOKE(0x4B22EF06BAA83F72LL, version_compare);
      break;
    case 3956:
      HASH_INVOKE(0x18BC9BF6D1E3CF74LL, magickpreviewimages);
      break;
    case 3961:
      HASH_INVOKE(0x4BE9D91DD8624F79LL, money_format);
      break;
    case 3962:
      HASH_INVOKE(0x7B0E6DB649084F7ALL, clearstatcache);
      break;
    case 3966:
      HASH_INVOKE(0x7064BEBF508F3F7ELL, socket_read);
      break;
    case 3968:
      HASH_INVOKE(0x63F18DE0DB807F80LL, magickqueryfonts);
      break;
    case 3972:
      HASH_INVOKE(0x14402B01D00E9F84LL, magicksteganoimage);
      break;
    case 3973:
      HASH_INVOKE(0x7EF68B9A55222F85LL, wandgetexceptionstring);
      break;
    case 3974:
      HASH_INVOKE(0x44CE4DB1CE7E9F86LL, flock);
      break;
    case 3977:
      HASH_INVOKE(0x13F52A829BAC0F89LL, timezone_identifiers_list);
      break;
    case 3979:
      HASH_INVOKE(0x2755DD4112AA5F8BLL, magicksampleimage);
      HASH_INVOKE(0x3703D22147C24F8BLL, pixelsetcyan);
      break;
    case 3982:
      HASH_INVOKE(0x7A8F1104B0CCDF8ELL, phpcredits);
      break;
    case 3983:
      HASH_INVOKE(0x4A6C46DC7FE29F8FLL, hphp_recursivedirectoryiterator_getchildren);
      break;
    case 3985:
      HASH_INVOKE(0x78463112BE739F91LL, connection_timeout);
      break;
    case 3986:
      HASH_INVOKE(0x288D61E7DE28AF92LL, ucwords);
      break;
    case 3988:
      HASH_INVOKE(0x76B9D87BC7F02F94LL, preg_match);
      break;
    case 3989:
      HASH_INVOKE(0x40D620CBA0D41F95LL, opendir);
      break;
    case 3991:
      HASH_INVOKE(0x35117886C885DF97LL, hphp_recursivedirectoryiterator_getsubpathname);
      HASH_INVOKE(0x6F9651265C096F97LL, magickreadimages);
      break;
    case 3992:
      HASH_INVOKE(0x0293F60B46511F98LL, drawsetfontstretch);
      HASH_INVOKE(0x66F1F0DB16C82F98LL, imagesavealpha);
      break;
    case 3994:
      HASH_INVOKE(0x2B7CAC006AF27F9ALL, fflush);
      break;
    case 3995:
      HASH_INVOKE(0x44244ECFB9F76F9BLL, dom_document_create_element_ns);
      break;
    case 3997:
      HASH_INVOKE(0x0AD6DE8829773F9DLL, apc_compile_file);
      break;
    case 4004:
      HASH_INVOKE(0x0E7E9AA21AE99FA4LL, hphp_recursiveiteratoriterator_current);
      break;
    case 4006:
      HASH_INVOKE(0x0DEEA8C3E3A47FA6LL, read_exif_data);
      break;
    case 4014:
      HASH_INVOKE(0x64D269A505D51FAELL, array_map);
      break;
    case 4015:
      HASH_INVOKE(0x03979AACDBB24FAFLL, mailparse_msg_get_part);
      break;
    case 4016:
      HASH_INVOKE(0x4A0B5F4676578FB0LL, imagecolorresolvealpha);
      break;
    case 4017:
      HASH_INVOKE(0x0F78ECF42C30DFB1LL, array_chunk);
      break;
    case 4020:
      HASH_INVOKE(0x3900FDF1C97BEFB4LL, drawrotate);
      break;
    case 4022:
      HASH_INVOKE(0x56C0CCB57BB6EFB6LL, magicksetimageunits);
      HASH_INVOKE(0x2B451EF5D52C4FB6LL, array_diff);
      break;
    case 4023:
      HASH_INVOKE(0x6465CD999F4C5FB7LL, hphp_invoke_method);
      break;
    case 4024:
      HASH_INVOKE(0x6DB2DB341ECF3FB8LL, file_exists);
      break;
    case 4026:
      HASH_INVOKE(0x0664323CB1CC2FBALL, imagecolorset);
      break;
    case 4031:
      HASH_INVOKE(0x70B38AB9EAE16FBFLL, ini_set);
      break;
    case 4033:
      HASH_INVOKE(0x3FF9AAFF85DDDFC1LL, class_parents);
      break;
    case 4034:
      HASH_INVOKE(0x6CA22E62D4762FC2LL, magickpainttransparentimage);
      HASH_INVOKE(0x460470C490FAFFC2LL, dom_node_normalize);
      break;
    case 4037:
      HASH_INVOKE(0x38498DD4C28D0FC5LL, hphp_splfileinfo_getatime);
      break;
    case 4043:
      HASH_INVOKE(0x38237A4515F42FCBLL, array_pad);
      break;
    case 4045:
      HASH_INVOKE(0x474566F3A2BE0FCDLL, mcrypt_enc_is_block_algorithm);
      break;
    case 4046:
      HASH_INVOKE(0x042193C97C65FFCELL, magickwaveimage);
      break;
    case 4047:
      HASH_INVOKE(0x3A3CFC1F001A6FCFLL, magickreadimagefile);
      break;
    case 4048:
      HASH_INVOKE(0x21104CCA2942AFD0LL, fb_const_fetch);
      HASH_INVOKE(0x2EAA47FA6C3FEFD0LL, drawgetstrokealpha);
      HASH_INVOKE(0x53DB5D0490C51FD0LL, xhprof_sample_disable);
      break;
    case 4052:
      HASH_INVOKE(0x4970B72A182E4FD4LL, readdir);
      break;
    case 4053:
      HASH_INVOKE(0x751283FE764CAFD5LL, mysql_select_db);
      break;
    case 4054:
      HASH_INVOKE(0x7FC00035D14B9FD6LL, apc_delete_file);
      break;
    case 4056:
      HASH_INVOKE(0x4234F2B59531FFD8LL, posix_getlogin);
      break;
    case 4061:
      HASH_INVOKE(0x4EDEDA4278CD3FDDLL, magickchopimage);
      break;
    case 4062:
      HASH_INVOKE(0x7F5FC3CAF8CE9FDELL, gzcompress);
      HASH_INVOKE(0x72925D2DF7E61FDELL, drawpathcurvetoquadraticbeziersmoothrelative);
      break;
    case 4071:
      HASH_INVOKE(0x217067889854CFE7LL, xmlwriter_start_dtd);
      break;
    case 4072:
      HASH_INVOKE(0x4D7AEC41CFD73FE8LL, hphp_recursivedirectoryiterator_getsubpath);
      break;
    case 4075:
      HASH_INVOKE(0x67D1EE05DFE71FEBLL, hphp_splfileobject_getcvscontrol);
      break;
    case 4079:
      HASH_INVOKE(0x00EEEE9C6CEA5FEFLL, xmlwriter_write_element_ns);
      break;
    case 4080:
      HASH_INVOKE(0x1189B7C4F4874FF0LL, php_check_syntax);
      break;
    case 4085:
      HASH_INVOKE(0x191ECE88E06E6FF5LL, dom_node_is_supported);
      break;
    case 4086:
      HASH_INVOKE(0x25FCE64E12505FF6LL, magicksetimagerenderingintent);
      break;
    case 4087:
      HASH_INVOKE(0x7883232CD1A7CFF7LL, dom_node_is_same_node);
      break;
    case 4090:
      HASH_INVOKE(0x13EE24AF67113FFALL, ob_end_flush);
      break;
    case 4091:
      HASH_INVOKE(0x68E499A4D75BDFFBLL, ascii2ebcdic);
      HASH_INVOKE(0x63BE4CEF1FC47FFBLL, imagefill);
      break;
    case 4094:
      HASH_INVOKE(0x32F8747E480CCFFELL, connection_status);
      break;
    default:
      break;
  }
  return invoke_failed(s, params, hash, fatal);
}
Variant ei_utf8_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_encode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_utf8_encode(a0));
}
Variant ei_hphp_splfileobject___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("hphp_splfileobject___construct", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject___construct(a0, a1, a2, a3, a4));
}
Variant ei_dom_document_create_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_comment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_comment(a0, a1));
}
Variant ei_func_get_args(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_get_args", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_func_get_args());
}
Variant ei_php_uname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("php_uname", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_php_uname());
  else return (x_php_uname(a0));
}
Variant ei_posix_uname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_uname", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_uname());
}
Variant ei_curl_multi_remove_handle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_remove_handle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_remove_handle(a0, a1));
}
Variant ei_memcache_get_server_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get_server_status", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_get_server_status(a0, a1));
  else return (x_memcache_get_server_status(a0, a1, a2));
}
Variant ei_mysql_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_result", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_result(a0, a1));
  else return (x_mysql_result(a0, a1, a2));
}
Variant ei_hphp_splfileobject_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_current(a0));
}
Variant ei_hphp_splfileinfo_getgroup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getgroup", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getgroup(a0));
}
Variant ei_register_shutdown_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_shutdown_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_shutdown_function(count, a0), null);
  return (x_register_shutdown_function(count, a0,vargs), null);
}
Variant ei_pixelsetmagentaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagentaquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetmagentaquantum(a0, a1), null);
}
Variant ei_newmagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newmagickwand", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newmagickwand());
}
Variant ei_natsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natsort", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_natsort(ref(a0)));
}
Variant ei_socket_accept(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_accept", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_accept(a0));
}
Variant ei_vprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vprintf", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_vprintf(a0, a1));
}
Variant ei_collator_set_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_set_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_set_attribute(a0, a1, a2));
}
Variant ei_ucwords(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucwords", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ucwords(a0));
}
Variant ei_header(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("header", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_header(a0), null);
  else if (count == 2) return (x_header(a0, a1), null);
  else return (x_header(a0, a1, a2), null);
}
Variant ei_dom_element_has_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_has_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_has_attribute_ns(a0, a1, a2));
}
Variant ei_date_default_timezone_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_default_timezone_set", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_default_timezone_set(a0));
}
Variant ei_is_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_object", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_object(a0));
}
Variant ei_magicksetimagebias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebias", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagebias(a0, a1));
}
Variant ei_exif_imagetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_imagetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_exif_imagetype(a0));
}
Variant ei_imagegrabscreen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagegrabscreen", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagegrabscreen());
}
Variant ei_bcmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("bcmod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bcmod(a0, a1));
}
Variant ei_chr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chr", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chr(a0));
}
Variant ei_drawsetfontstretch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstretch", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontstretch(a0, a1), null);
}
Variant ei_posix_setsid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_setsid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setsid());
}
Variant ei_hphp_splfileinfo_setfileclass(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setfileclass", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_setfileclass(a0, a1), null);
}
Variant ei_posix_getpwnam(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwnam", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpwnam(a0));
}
Variant ei_mcrypt_enc_get_supported_key_sizes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_supported_key_sizes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_supported_key_sizes(a0));
}
Variant ei_phpinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpinfo", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_phpinfo());
  else return (x_phpinfo(a0));
}
Variant ei_evhttp_async_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_async_get", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_evhttp_async_get(a0));
  else if (count == 2) return (x_evhttp_async_get(a0, a1));
  else return (x_evhttp_async_get(a0, a1, a2));
}
Variant ei_ldap_parse_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("ldap_parse_result", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a5 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_parse_result(a0, a1, ref(a2)));
  else if (count == 4) return (x_ldap_parse_result(a0, a1, ref(a2), ref(a3)));
  else if (count == 5) return (x_ldap_parse_result(a0, a1, ref(a2), ref(a3), ref(a4)));
  else return (x_ldap_parse_result(a0, a1, ref(a2), ref(a3), ref(a4), ref(a5)));
}
Variant ei_drawgettextantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextantialias", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextantialias(a0));
}
Variant ei_array_fill_keys(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_fill_keys", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_fill_keys(a0, a1));
}
Variant ei_openssl_seal(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_seal", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_seal(a0, ref(a1), ref(a2), a3));
}
Variant ei_socket_clear_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_clear_error", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_socket_clear_error(), null);
  else return (x_socket_clear_error(a0), null);
}
Variant ei_die(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("die", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_die());
  else return (x_die(a0));
}
Variant ei_diskfreespace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("diskfreespace", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_diskfreespace(a0));
}
Variant ei_xml_set_start_namespace_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_start_namespace_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_start_namespace_decl_handler(a0, a1));
}
Variant ei_decbin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decbin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_decbin(a0));
}
Variant ei_sizeof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sizeof", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sizeof(a0));
  else return (x_sizeof(a0, a1));
}
Variant ei_mb_convert_case(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_case", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_convert_case(a0, a1));
  else return (x_mb_convert_case(a0, a1, a2));
}
Variant ei_fb_set_taint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_set_taint", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_set_taint(ref(a0), a1), null);
}
Variant ei_dir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dir(a0));
}
Variant ei_array_combine(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_combine", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_combine(a0, a1));
}
Variant ei_strpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strpos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strpos(a0, a1));
  else return (x_strpos(a0, a1, a2));
}
Variant ei_array_reverse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_reverse", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_reverse(a0));
  else return (x_array_reverse(a0, a1));
}
Variant ei_strrev(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strrev", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strrev(a0));
}
Variant ei_msg_set_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("msg_set_queue", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_msg_set_queue(a0, a1));
}
Variant ei_cos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_cos(a0));
}
Variant ei_hphp_recursivedirectoryiterator_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_valid(a0));
}
Variant ei_bcmul(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcmul", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcmul(a0, a1));
  else return (x_bcmul(a0, a1, a2));
}
Variant ei_openlog(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openlog", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openlog(a0, a1, a2));
}
Variant ei_get_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_include_path", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_include_path());
}
Variant ei_socket_select(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("socket_select", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_socket_select(ref(a0), ref(a1), ref(a2), a3));
  else return (x_socket_select(ref(a0), ref(a1), ref(a2), a3, a4));
}
Variant ei_magickraiseimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickraiseimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickraiseimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_gzputs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzputs", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzputs(a0, a1));
  else return (x_gzputs(a0, a1, a2));
}
Variant ei_strpbrk(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strpbrk", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strpbrk(a0, a1));
}
Variant ei_shm_remove_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_remove_var", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_remove_var(a0, a1));
}
Variant ei_posix_setuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setuid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setuid(a0));
}
Variant ei_pixelgetyellow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellow", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetyellow(a0));
}
Variant ei_convert_uudecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uudecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_convert_uudecode(a0));
}
Variant ei_htmlspecialchars_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("htmlspecialchars_decode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_htmlspecialchars_decode(a0));
  else return (x_htmlspecialchars_decode(a0, a1));
}
Variant ei_xmlwriter_end_document(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_document", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_document(a0));
}
Variant ei_magickgetimagehistogram(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagehistogram", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagehistogram(a0));
}
Variant ei_preg_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("preg_last_error", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_preg_last_error());
}
Variant ei_end(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("end", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_end(ref(a0)));
}
Variant ei_stream_get_line(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_line", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_get_line(a0));
  else if (count == 2) return (x_stream_get_line(a0, a1));
  else return (x_stream_get_line(a0, a1, a2));
}
Variant ei_deg2rad(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("deg2rad", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_deg2rad(a0));
}
Variant ei_magickrollimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrollimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickrollimage(a0, a1, a2));
}
Variant ei_ldap_sort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_sort", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_sort(a0, a1, a2));
}
Variant ei_imagetruecolortopalette(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagetruecolortopalette", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagetruecolortopalette(a0, a1, a2));
}
Variant ei_defined(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("defined", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_defined(a0));
}
Variant ei_magickgetimageunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageunits", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageunits(a0));
}
Variant ei_magicksetimageblueprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageblueprimary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageblueprimary(a0, a1, a2));
}
Variant ei_session_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_name", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_name());
  else return (x_session_name(a0));
}
Variant ei_get_class_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_vars", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_class_vars(a0));
}
Variant ei_syslog(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("syslog", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_syslog(a0, a1));
}
Variant ei_array_unique(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_unique", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_unique(a0));
}
Variant ei_bcpow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcpow", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcpow(a0, a1));
  else return (x_bcpow(a0, a1, a2));
}
Variant ei_pixelgetopacityquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacityquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetopacityquantum(a0));
}
Variant ei_php_check_syntax(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("php_check_syntax", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_php_check_syntax(a0));
  else return (x_php_check_syntax(a0, ref(a1)));
}
Variant ei_mysql_connect_with_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 8) return throw_toomany_arguments("mysql_connect_with_db", 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_connect_with_db());
  else if (count == 1) return (x_mysql_connect_with_db(a0));
  else if (count == 2) return (x_mysql_connect_with_db(a0, a1));
  else if (count == 3) return (x_mysql_connect_with_db(a0, a1, a2));
  else if (count == 4) return (x_mysql_connect_with_db(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_connect_with_db(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_mysql_connect_with_db(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_mysql_connect_with_db(a0, a1, a2, a3, a4, a5, a6));
  else return (x_mysql_connect_with_db(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_drawgetstrokemiterlimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokemiterlimit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokemiterlimit(a0));
}
Variant ei_hphp_splfileobject_fpassthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fpassthru", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fpassthru(a0));
}
Variant ei_intl_error_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_error_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_error_name(a0));
}
Variant ei_pixelsetquantumcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("pixelsetquantumcolor", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_pixelsetquantumcolor(a0, a1, a2, a3), null);
  else return (x_pixelsetquantumcolor(a0, a1, a2, a3, a4), null);
}
Variant ei_gztell(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gztell", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gztell(a0));
}
Variant ei_strval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strval(a0));
}
Variant ei_evhttp_recv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("evhttp_recv", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_evhttp_recv(a0));
}
Variant ei_dom_node_replace_child(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_replace_child", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_replace_child(a0, a1, a2));
}
Variant ei_strspn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strspn", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strspn(a0, a1));
  else if (count == 3) return (x_strspn(a0, a1, a2));
  else return (x_strspn(a0, a1, a2, a3));
}
Variant ei_ini_restore(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_restore", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_restore(a0), null);
}
Variant ei_ldap_dn2ufn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_dn2ufn", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_dn2ufn(a0));
}
Variant ei_ceil(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ceil", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ceil(a0));
}
Variant ei_xmlwriter_end_dtd_attlist(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_attlist", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd_attlist(a0));
}
Variant ei_phpversion(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpversion", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_phpversion());
  else return (x_phpversion(a0));
}
Variant ei_stream_filter_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_filter_remove", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_filter_remove(a0));
}
Variant ei_mcrypt_generic(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_generic", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic(a0, a1));
}
Variant ei_is_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_file(a0));
}
Variant ei_xml_set_end_namespace_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_end_namespace_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_end_namespace_decl_handler(a0, a1));
}
Variant ei_openssl_x509_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export_to_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_x509_export_to_file(a0, a1));
  else return (x_openssl_x509_export_to_file(a0, a1, a2));
}
Variant ei_imagesetstyle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetstyle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetstyle(a0, a1));
}
Variant ei_drawcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawcolor", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcolor(a0, a1, a2, a3), null);
}
Variant ei_get_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_headers", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_get_headers(a0));
  else return (x_get_headers(a0, a1));
}
Variant ei_mysql_drop_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_drop_db", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_drop_db(a0));
  else return (x_mysql_drop_db(a0, a1));
}
Variant ei_spl_object_hash(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("spl_object_hash", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_spl_object_hash(a0));
}
Variant ei_magickresampleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresampleimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickresampleimage(a0, a1, a2, a3, a4));
}
Variant ei_i18n_loc_get_default(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_default", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_get_default());
}
Variant ei_strtok(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtok", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strtok(a0));
  else return (x_strtok(a0, a1));
}
Variant ei_array_key_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("array_key_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_key_exists(a0, a1));
}
Variant ei_exp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exp", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_exp(a0));
}
Variant ei_strstr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strstr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strstr(a0, a1));
}
Variant ei_realpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("realpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_realpath(a0));
}
Variant ei_memcache_setoptimeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("memcache_setoptimeout", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_setoptimeout(a0, a1));
}
Variant ei_stream_filter_append(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_append", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_filter_append(a0, a1));
  else if (count == 3) return (x_stream_filter_append(a0, a1, a2));
  else return (x_stream_filter_append(a0, a1, a2, a3));
}
Variant ei_dom_characterdata_insert_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_insert_data", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_insert_data(a0, a1, a2));
}
Variant ei_hphp_get_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_get_property", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_property(a0, a1, a2));
}
Variant ei_dom_characterdata_replace_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_characterdata_replace_data", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_replace_data(a0, a1, a2, a3));
}
Variant ei_magickgetcharheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharheight", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetcharheight(a0, a1, a2));
  else return (x_magickgetcharheight(a0, a1, a2, a3));
}
Variant ei_imagerotate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("imagerotate", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_imagerotate(a0, a1, a2));
  else return (x_imagerotate(a0, a1, a2, a3));
}
Variant ei_magickcompositeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcompositeimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcompositeimage(a0, a1, a2, a3, a4));
}
Variant ei_openssl_sign(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_sign", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_sign(a0, ref(a1), a2));
  else return (x_openssl_sign(a0, ref(a1), a2, a3));
}
Variant ei_version_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("version_compare", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_version_compare(a0, a1));
  else return (x_version_compare(a0, a1, a2));
}
Variant ei_timezone_name_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_name_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_name_get(a0));
}
Variant ei_posix_getpgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpgid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpgid(a0));
}
Variant ei_dom_node_has_attributes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_attributes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_has_attributes(a0));
}
Variant ei_dom_text_is_whitespace_in_element_content(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_text_is_whitespace_in_element_content", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_text_is_whitespace_in_element_content(a0));
}
Variant ei_imagestring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestring", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagestring(a0, a1, a2, a3, a4, a5));
}
Variant ei_mcrypt_list_modes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_modes", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mcrypt_list_modes());
  else return (x_mcrypt_list_modes(a0));
}
Variant ei_session_unregister(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_unregister", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_unregister(a0));
}
Variant ei_mcrypt_list_algorithms(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mcrypt_list_algorithms", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mcrypt_list_algorithms());
  else return (x_mcrypt_list_algorithms(a0));
}
Variant ei_mcrypt_get_cipher_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_get_cipher_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_get_cipher_name(a0));
}
Variant ei_idn_to_unicode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_unicode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idn_to_unicode(a0));
  else return (x_idn_to_unicode(a0, ref(a1)));
}
Variant ei_lchown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchown", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lchown(a0, a1));
}
Variant ei_drawcomposite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawcomposite", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcomposite(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_dechex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dechex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dechex(a0));
}
Variant ei_imagecolortransparent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagecolortransparent", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagecolortransparent(a0));
  else return (x_imagecolortransparent(a0, a1));
}
Variant ei_socket_get_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_get_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_get_option(a0, a1, a2));
}
Variant ei_stream_filter_register(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_filter_register", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_filter_register(a0, a1));
}
Variant ei_apache_response_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_response_headers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_response_headers());
}
Variant ei_array_merge(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_merge(count, a0));
  return (x_array_merge(count, a0,vargs));
}
Variant ei_md5(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_md5(a0));
  else return (x_md5(a0, a1));
}
Variant ei_session_write_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_write_close", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_write_close(), null);
}
Variant ei_dom_namednodemap_item(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_item", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_namednodemap_item(a0, a1));
}
Variant ei_bcsub(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcsub", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcsub(a0, a1));
  else return (x_bcsub(a0, a1, a2));
}
Variant ei_xmlwriter_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_flush", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xmlwriter_flush(a0));
  else return (x_xmlwriter_flush(a0, a1));
}
Variant ei_sha1_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sha1_file(a0));
  else return (x_sha1_file(a0, a1));
}
Variant ei_posix_ctermid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_ctermid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_ctermid());
}
Variant ei_date(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("date", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_date(a0));
  else return (x_date(a0, a1));
}
Variant ei_evhttp_post(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_post", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_evhttp_post(a0, a1));
  else if (count == 3) return (x_evhttp_post(a0, a1, a2));
  else return (x_evhttp_post(a0, a1, a2, a3));
}
Variant ei_ldap_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("ldap_connect", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ldap_connect());
  else if (count == 1) return (x_ldap_connect(a0));
  else return (x_ldap_connect(a0, a1));
}
Variant ei_shuffle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shuffle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shuffle(ref(a0)));
}
Variant ei_mcrypt_module_get_algo_block_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_block_size", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_get_algo_block_size(a0));
  else return (x_mcrypt_module_get_algo_block_size(a0, a1));
}
Variant ei_hphp_splfileobject_ftruncate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_ftruncate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_ftruncate(a0, a1));
}
Variant ei_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_key(ref(a0)));
}
Variant ei_xmlwriter_start_dtd_entity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_start_dtd_entity", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_dtd_entity(a0, a1, a2));
}
Variant ei_readfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("readfile", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_readfile(a0));
  else if (count == 2) return (x_readfile(a0, a1));
  else return (x_readfile(a0, a1, a2));
}
Variant ei_atan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_atan(a0));
}
Variant ei_magickmodulateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmodulateimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmodulateimage(a0, a1, a2, a3));
}
Variant ei_mysql_set_charset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_set_charset", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_set_charset(a0));
  else return (x_mysql_set_charset(a0, a1));
}
Variant ei_fb_unset_taint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_unset_taint", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_unset_taint(ref(a0), a1), null);
}
Variant ei_dom_document_xinclude(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_document_xinclude", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_document_xinclude(a0));
  else return (x_dom_document_xinclude(a0, a1));
}
Variant ei_drawgetfontweight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontweight", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontweight(a0));
}
Variant ei_magickgetimageheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageheight", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageheight(a0));
}
Variant ei_posix_getpgrp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpgrp", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpgrp());
}
Variant ei_i18n_loc_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("i18n_loc_get_error_code", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_get_error_code());
}
Variant ei_hash_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash_file(a0, a1));
  else return (x_hash_file(a0, a1, a2));
}
Variant ei_is_callable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("is_callable", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_is_callable(a0));
  else if (count == 2) return (x_is_callable(a0, a1));
  else return (x_is_callable(a0, a1, ref(a2)));
}
Variant ei_asin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_asin(a0));
}
Variant ei_openssl_public_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_encrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_public_encrypt(a0, ref(a1), a2));
  else return (x_openssl_public_encrypt(a0, ref(a1), a2, a3));
}
Variant ei_curl_multi_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("curl_multi_init", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_init());
}
Variant ei_posix_getpwuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getpwuid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpwuid(a0));
}
Variant ei_json_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("json_encode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_json_encode(a0));
  else return (x_json_encode(a0, a1));
}
Variant ei_show_source(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("show_source", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_show_source(a0));
  else return (x_show_source(a0, a1));
}
Variant ei_mcrypt_module_self_test(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_self_test", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_self_test(a0));
  else return (x_mcrypt_module_self_test(a0, a1));
}
Variant ei_sscanf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("sscanf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 2) return (x_sscanf(count, a0, a1));
  return (x_sscanf(count, a0, a1,vargs));
}
Variant ei_chop(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("chop", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_chop(a0));
  else return (x_chop(a0, a1));
}
Variant ei_mb_convert_variables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("mb_convert_variables", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_mb_convert_variables(count, a0, a1, ref(a2)));
  return (x_mb_convert_variables(count, a0, a1, ref(a2),vargs));
}
Variant ei_hphp_recursivedirectoryiterator_getsubpathname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpathname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_getsubpathname(a0));
}
Variant ei_socket_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_close(a0), null);
}
Variant ei_max(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("max", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_max(count, a0));
  return (x_max(count, a0,vargs));
}
Variant ei_magickadaptivethresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickadaptivethresholdimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickadaptivethresholdimage(a0, a1, a2, a3));
}
Variant ei_each(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("each", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_each(ref(a0)));
}
Variant ei_magickremoveimageprofiles(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimageprofiles", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickremoveimageprofiles(a0));
}
Variant ei_drawgettextalignment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextalignment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextalignment(a0));
}
Variant ei_xbox_send_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xbox_send_message", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_xbox_send_message(a0, ref(a1), a2));
  else return (x_xbox_send_message(a0, ref(a1), a2, a3));
}
Variant ei_thrift_protocol_write_binary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("thrift_protocol_write_binary", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_thrift_protocol_write_binary(a0, a1, a2, a3, a4, a5), null);
}
Variant ei_wandgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandgetexceptiontype(a0));
}
Variant ei_drawpathellipticarcabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcabsolute", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathellipticarcabsolute(a0, a1, a2, a3, a4, a5, a6, a7), null);
}
Variant ei_pixelsetgreen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreen", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetgreen(a0, a1), null);
}
Variant ei_magickgetimagecolorspace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolorspace", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecolorspace(a0));
}
Variant ei_pixelsetalphaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalphaquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetalphaquantum(a0, a1), null);
}
Variant ei_stream_bucket_append(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_append", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_append(a0, a1), null);
}
Variant ei_msg_stat_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_stat_queue", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_msg_stat_queue(a0));
}
Variant ei_system(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("system", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_system(a0));
  else return (x_system(a0, ref(a1)));
}
Variant ei_mb_parse_str(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_parse_str", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_parse_str(a0));
  else return (x_mb_parse_str(a0, ref(a1)));
}
Variant ei_dom_characterdata_append_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_characterdata_append_data", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_append_data(a0, a1));
}
Variant ei_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("log", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_log(a0));
  else return (x_log(a0, a1));
}
Variant ei_memcache_decrement(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_decrement", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_decrement(a0, a1));
  else return (x_memcache_decrement(a0, a1, a2));
}
Variant ei_drawskewx(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewx", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawskewx(a0, a1), null);
}
Variant ei_min(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("min", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_min(count, a0));
  return (x_min(count, a0,vargs));
}
Variant ei_curl_multi_getcontent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_getcontent", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_getcontent(a0));
}
Variant ei_drawskewy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawskewy", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawskewy(a0, a1), null);
}
Variant ei_is_uploaded_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_uploaded_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_uploaded_file(a0));
}
Variant ei_magicksetresourcelimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetresourcelimit", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetresourcelimit(a0, a1));
}
Variant ei_date_timezone_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_timezone_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_timezone_get(a0));
}
Variant ei_hphp_splfileobject_fwrite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fwrite", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fwrite(a0, a1, a2));
}
Variant ei_apache_get_rewrite_rules(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_rewrite_rules", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_rewrite_rules());
}
Variant ei_is_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_string(a0));
}
Variant ei_pcntl_wtermsig(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wtermsig", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wtermsig(a0));
}
Variant ei_stream_context_get_default(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("stream_context_get_default", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_stream_context_get_default());
  else return (x_stream_context_get_default(a0));
}
Variant ei_drawpathlinetorelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetorelative", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetorelative(a0, a1, a2), null);
}
Variant ei_urlencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urlencode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_urlencode(a0));
}
Variant ei_mb_preferred_mime_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_preferred_mime_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_preferred_mime_name(a0));
}
Variant ei_pixelgetgreenquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreenquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetgreenquantum(a0));
}
Variant ei_magicksetfilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetfilename", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magicksetfilename(a0));
  else return (x_magicksetfilename(a0, a1));
}
Variant ei_magickappendimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickappendimages", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickappendimages(a0));
  else return (x_magickappendimages(a0, a1));
}
Variant ei_pcntl_wifstopped(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifstopped", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wifstopped(a0));
}
Variant ei_mb_ereg_search(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_ereg_search());
  else if (count == 1) return (x_mb_ereg_search(a0));
  else return (x_mb_ereg_search(a0, a1));
}
Variant ei_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rewind(a0));
}
Variant ei_chunk_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("chunk_split", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_chunk_split(a0));
  else if (count == 2) return (x_chunk_split(a0, a1));
  else return (x_chunk_split(a0, a1, a2));
}
Variant ei_mb_list_encodings_alias_names(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_encodings_alias_names", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_list_encodings_alias_names());
  else return (x_mb_list_encodings_alias_names(a0));
}
Variant ei_i18n_loc_set_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("i18n_loc_set_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_set_attribute(a0, a1));
}
Variant ei_pixelsynciterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelsynciterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsynciterator(a0));
}
Variant ei_openssl_error_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("openssl_error_string", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_error_string());
}
Variant ei_ismagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ismagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ismagickwand(a0));
}
Variant ei_dom_element_has_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_has_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_has_attribute(a0, a1));
}
Variant ei_strrchr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strrchr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strrchr(a0, a1));
}
Variant ei_xmlwriter_start_dtd_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_element", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_dtd_element(a0, a1));
}
Variant ei_str_ireplace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_ireplace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_str_ireplace(a0, a1, a2));
  else return (x_str_ireplace(a0, a1, a2, ref(a3)));
}
Variant ei_magickpainttransparentimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("magickpainttransparentimage", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickpainttransparentimage(a0, a1));
  else if (count == 3) return (x_magickpainttransparentimage(a0, a1, a2));
  else return (x_magickpainttransparentimage(a0, a1, a2, a3));
}
Variant ei_drawsettextundercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextundercolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextundercolor(a0, a1), null);
}
Variant ei_memcache_get_version(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_get_version", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_get_version(a0));
}
Variant ei_hphp_splfileobject_getflags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getflags", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_getflags(a0));
}
Variant ei_hphp_recursivedirectoryiterator_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_rewind(a0), null);
}
Variant ei_magickgetstringwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringwidth", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetstringwidth(a0, a1, a2));
  else return (x_magickgetstringwidth(a0, a1, a2, a3));
}
Variant ei_echo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("echo", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_echo(count, a0), null);
  return (x_echo(count, a0,vargs), null);
}
Variant ei_ldap_parse_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_parse_reference", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_parse_reference(a0, a1, ref(a2)));
}
Variant ei_ctype_xdigit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_xdigit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_xdigit(a0));
}
Variant ei_gmstrftime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmstrftime", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gmstrftime(a0));
  else return (x_gmstrftime(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_next(a0), null);
}
Variant ei_stream_socket_get_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_get_name", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_socket_get_name(a0, a1));
}
Variant ei_socket_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_set_option", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_option(a0, a1, a2, a3));
}
Variant ei_array_multisort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_multisort", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_array_multisort(count, ref(a0)));
  return (x_array_multisort(count, ref(a0),vargs));
}
Variant ei_imagepsbbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("imagepsbbox", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_imagepsbbox(a0, a1, a2));
  else if (count == 4) return (x_imagepsbbox(a0, a1, a2, a3));
  else if (count == 5) return (x_imagepsbbox(a0, a1, a2, a3, a4));
  else return (x_imagepsbbox(a0, a1, a2, a3, a4, a5));
}
Variant ei_drawpathlinetoverticalabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalabsolute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetoverticalabsolute(a0, a1), null);
}
Variant ei_mailparse_msg_get_structure(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_structure", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_get_structure(a0));
}
Variant ei_mb_ereg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_ereg(a0, a1));
  else return (x_mb_ereg(a0, a1, ref(a2)));
}
Variant ei_decoct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("decoct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_decoct(a0));
}
Variant ei_xml_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xml_parse", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xml_parse(a0, a1));
  else return (x_xml_parse(a0, a1, a2));
}
Variant ei_xml_get_current_line_number(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_line_number", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_current_line_number(a0));
}
Variant ei_drawaffine(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawaffine", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawaffine(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_session_destroy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_destroy", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_destroy());
}
Variant ei_magicksetimagewhitepoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagewhitepoint", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagewhitepoint(a0, a1, a2));
}
Variant ei_dom_document_get_elements_by_tag_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_elements_by_tag_name", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_get_elements_by_tag_name(a0, a1));
}
Variant ei_gzclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzclose(a0));
}
Variant ei_imagecolorat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagecolorat", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorat(a0, a1, a2));
}
Variant ei_magickgetimageextrema(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimageextrema", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickgetimageextrema(a0));
  else return (x_magickgetimageextrema(a0, a1));
}
Variant ei_dom_node_insert_before(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_node_insert_before", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_node_insert_before(a0, a1));
  else return (x_dom_node_insert_before(a0, a1, a2));
}
Variant ei_ord(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ord", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ord(a0));
}
Variant ei_mktime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mktime", 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mktime());
  else if (count == 1) return (x_mktime(a0));
  else if (count == 2) return (x_mktime(a0, a1));
  else if (count == 3) return (x_mktime(a0, a1, a2));
  else if (count == 4) return (x_mktime(a0, a1, a2, a3));
  else if (count == 5) return (x_mktime(a0, a1, a2, a3, a4));
  else return (x_mktime(a0, a1, a2, a3, a4, a5));
}
Variant ei_sem_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("sem_get", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sem_get(a0));
  else if (count == 2) return (x_sem_get(a0, a1));
  else if (count == 3) return (x_sem_get(a0, a1, a2));
  else return (x_sem_get(a0, a1, a2, a3));
}
Variant ei_drawsetstrokelinejoin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinejoin", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokelinejoin(a0, a1), null);
}
Variant ei_array_intersect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_intersect(count, a0, a1));
  return (x_array_intersect(count, a0, a1,vargs));
}
Variant ei_mailparse_msg_extract_whole_part_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_whole_part_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mailparse_msg_extract_whole_part_file(a0, a1));
  else return (x_mailparse_msg_extract_whole_part_file(a0, a1, a2));
}
Variant ei_mb_strrichr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrichr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strrichr(a0, a1));
  else if (count == 3) return (x_mb_strrichr(a0, a1, a2));
  else return (x_mb_strrichr(a0, a1, a2, a3));
}
Variant ei_socket_sendto(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_sendto", count, 5, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_socket_sendto(a0, a1, a2, a3, a4));
  else return (x_socket_sendto(a0, a1, a2, a3, a4, a5));
}
Variant ei_memcache_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("memcache_flush", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_flush(a0));
  else return (x_memcache_flush(a0, a1));
}
Variant ei_mb_output_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mb_output_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_output_handler(a0, a1));
}
Variant ei_fclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fclose(a0));
}
Variant ei_drawpathcurvetoquadraticbeziersmoothabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothabsolute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbeziersmoothabsolute(a0, a1, a2), null);
}
Variant ei_function_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("function_exists", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_function_exists(a0));
}
Variant ei_ctype_alpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_alpha(a0));
}
Variant ei_pos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pos(ref(a0)));
}
Variant ei_pagelet_server_is_enabled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pagelet_server_is_enabled", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pagelet_server_is_enabled());
}
Variant ei_xbox_get_thread_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_timeout", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_get_thread_timeout());
}
Variant ei_imagecolorexactalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorexactalpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorexactalpha(a0, a1, a2, a3, a4));
}
Variant ei_pow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pow", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pow(a0, a1));
}
Variant ei_pixelgetredquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetredquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetredquantum(a0));
}
Variant ei_imagecolorsforindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolorsforindex", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorsforindex(a0, a1));
}
Variant ei_libxml_set_streams_context(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("libxml_set_streams_context", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_set_streams_context(a0), null);
}
Variant ei_dom_node_clone_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_node_clone_node", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_node_clone_node(a0));
  else return (x_dom_node_clone_node(a0, a1));
}
Variant ei_image_type_to_mime_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("image_type_to_mime_type", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_image_type_to_mime_type(a0));
}
Variant ei_socket_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("socket_create", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_create(a0, a1, a2));
}
Variant ei_xmlwriter_write_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_pi", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_pi(a0, a1, a2));
}
Variant ei_posix_getppid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getppid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getppid());
}
Variant ei_mb_stripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stripos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_stripos(a0, a1));
  else if (count == 3) return (x_mb_stripos(a0, a1, a2));
  else return (x_mb_stripos(a0, a1, a2, a3));
}
Variant ei_magickpingimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpingimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickpingimage(a0, a1));
}
Variant ei_bcpowmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("bcpowmod", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_bcpowmod(a0, a1, a2));
  else return (x_bcpowmod(a0, a1, a2, a3));
}
Variant ei_timezone_offset_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("timezone_offset_get", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_offset_get(a0, a1));
}
Variant ei_dom_document_create_text_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_text_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_text_node(a0, a1));
}
Variant ei_getrandmax(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getrandmax", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getrandmax());
}
Variant ei_hphp_splfileobject_fseek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_splfileobject_fseek", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fseek(a0, a1, a2));
}
Variant ei_ctype_alnum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_alnum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_alnum(a0));
}
Variant ei_tan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tan(a0));
}
Variant ei_set_exception_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_exception_handler", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_exception_handler(a0));
}
Variant ei_imagegrabwindow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegrabwindow", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegrabwindow(a0));
  else return (x_imagegrabwindow(a0, a1));
}
Variant ei_memcache_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_add", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_memcache_add(a0, a1, a2));
  else if (count == 4) return (x_memcache_add(a0, a1, a2, a3));
  else return (x_memcache_add(a0, a1, a2, a3, a4));
}
Variant ei_magickstereoimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickstereoimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickstereoimage(a0, a1));
}
Variant ei_magickgetimagescene(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagescene", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagescene(a0));
}
Variant ei_hphp_splfileinfo_isfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isfile", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isfile(a0));
}
Variant ei_openssl_csr_sign(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_csr_sign", count, 4, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_csr_sign(a0, a1, a2, a3));
  else if (count == 5) return (x_openssl_csr_sign(a0, a1, a2, a3, a4));
  else return (x_openssl_csr_sign(a0, a1, a2, a3, a4, a5));
}
Variant ei_openssl_pkcs12_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_pkcs12_export(a0, ref(a1), a2, a3));
  else return (x_openssl_pkcs12_export(a0, ref(a1), a2, a3, a4));
}
Variant ei_magickgetquantumdepth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetquantumdepth", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetquantumdepth());
}
Variant ei_socket_listen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_listen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_listen(a0));
  else return (x_socket_listen(a0, a1));
}
Variant ei_parse_str(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_str", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_str(a0), null);
  else return (x_parse_str(a0, ref(a1)), null);
}
Variant ei_sin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sin(a0));
}
Variant ei_dom_node_append_child(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_append_child", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_append_child(a0, a1));
}
Variant ei_cosh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cosh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_cosh(a0));
}
Variant ei_copy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("copy", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_copy(a0, a1));
  else return (x_copy(a0, a1, a2));
}
Variant ei_imagechar(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagechar", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagechar(a0, a1, a2, a3, a4, a5));
}
Variant ei_magicksetimagebackgroundcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebackgroundcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagebackgroundcolor(a0, a1));
}
Variant ei_ldap_mod_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_add", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_mod_add(a0, a1, a2));
}
Variant ei_fb_thrift_serialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_thrift_serialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_thrift_serialize(a0));
}
Variant ei_posix_ttyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_ttyname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_ttyname(a0));
}
Variant ei_filectime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filectime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filectime(a0));
}
Variant ei_newpixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("newpixelwand", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_newpixelwand());
  else return (x_newpixelwand(a0));
}
Variant ei_pcntl_wait(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pcntl_wait", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pcntl_wait(ref(a0)));
  else return (x_pcntl_wait(ref(a0), a1));
}
Variant ei_hypot(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hypot", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hypot(a0, a1));
}
Variant ei_parse_url(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("parse_url", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_url(a0));
  else return (x_parse_url(a0, a1));
}
Variant ei_magickreadimageblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimageblob", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimageblob(a0, a1));
}
Variant ei_eregi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("eregi", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_eregi(a0, a1));
  else return (x_eregi(a0, a1, ref(a2)));
}
Variant ei_pixelsetcolorcount(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolorcount", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcolorcount(a0, a1), null);
}
Variant ei_drawpathcurvetoquadraticbezierrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierrelative", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbezierrelative(a0, a1, a2, a3, a4), null);
}
Variant ei_posix_getgroups(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgroups", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgroups());
}
Variant ei_fileinode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileinode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileinode(a0));
}
Variant ei_magickgetnumberimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetnumberimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetnumberimages(a0));
}
Variant ei_magickgetimagesblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagesblob(a0));
}
Variant ei_magickcontrastimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcontrastimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcontrastimage(a0, a1));
}
Variant ei_pcntl_setpriority(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_setpriority", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pcntl_setpriority(a0));
  else if (count == 2) return (x_pcntl_setpriority(a0, a1));
  else return (x_pcntl_setpriority(a0, a1, a2));
}
Variant ei_drawgetfontstretch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstretch", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontstretch(a0));
}
Variant ei_bcscale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bcscale", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bcscale(a0));
}
Variant ei_imageconvolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imageconvolution", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageconvolution(a0, a1, a2, a3));
}
Variant ei_utf8_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("utf8_decode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_utf8_decode(a0));
}
Variant ei_ldap_unbind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_unbind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_unbind(a0));
}
Variant ei_newpixelregioniterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("newpixelregioniterator", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixelregioniterator(a0, a1, a2, a3, a4));
}
Variant ei_array_intersect_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_intersect_assoc(count, a0, a1));
  return (x_array_intersect_assoc(count, a0, a1,vargs));
}
Variant ei_ob_get_level(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_level", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_level());
}
Variant ei_hebrev(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrev", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hebrev(a0));
  else return (x_hebrev(a0, a1));
}
Variant ei_socket_set_block(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_block", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_block(a0));
}
Variant ei_mcrypt_module_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_module_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_module_close(a0));
}
Variant ei_mb_strwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strwidth", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strwidth(a0));
  else return (x_mb_strwidth(a0, a1));
}
Variant ei_clonemagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonemagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clonemagickwand(a0));
}
Variant ei_pixelgetred(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetred", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetred(a0));
}
Variant ei_dom_document_create_processing_instruction(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_processing_instruction", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_create_processing_instruction(a0, a1));
  else return (x_dom_document_create_processing_instruction(a0, a1, a2));
}
Variant ei_ip2long(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ip2long", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ip2long(a0));
}
Variant ei_mb_stristr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_stristr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_stristr(a0, a1));
  else if (count == 3) return (x_mb_stristr(a0, a1, a2));
  else return (x_mb_stristr(a0, a1, a2, a3));
}
Variant ei_array_diff_ukey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_ukey", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_diff_ukey(count, a0, a1, a2));
  return (x_array_diff_ukey(count, a0, a1, a2,vargs));
}
Variant ei_isdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("isdrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_isdrawingwand(a0));
}
Variant ei_magicksetimagemattecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagemattecolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagemattecolor(a0, a1));
}
Variant ei_closedir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("closedir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_closedir(a0), null);
}
Variant ei_fb_call_user_func_safe_return(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fb_call_user_func_safe_return", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_fb_call_user_func_safe_return(count, a0, a1));
  return (x_fb_call_user_func_safe_return(count, a0, a1,vargs));
}
Variant ei_magickwriteimagesfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagesfile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwriteimagesfile(a0, a1));
}
Variant ei_magickdescribeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdescribeimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdescribeimage(a0));
}
Variant ei_imageftbbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("imageftbbox", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_imageftbbox(a0, a1, a2, a3));
  else return (x_imageftbbox(a0, a1, a2, a3, a4));
}
Variant ei_magicksetlastiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetlastiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetlastiterator(a0), null);
}
Variant ei_hphp_output_global_state(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphp_output_global_state", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_hphp_output_global_state());
  else return (x_hphp_output_global_state(a0));
}
Variant ei_imagefontheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontheight", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefontheight(a0));
}
Variant ei_putenv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("putenv", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_putenv(a0));
}
Variant ei_magickedgeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickedgeimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickedgeimage(a0, a1));
}
Variant ei_xml_error_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_error_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_error_string(a0));
}
Variant ei_array_rand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_rand", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_rand(a0));
  else return (x_array_rand(a0, a1));
}
Variant ei_ldap_mod_del(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_del", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_mod_del(a0, a1, a2));
}
Variant ei_range(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("range", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_range(a0, a1));
  else return (x_range(a0, a1, a2));
}
Variant ei_levenshtein(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("levenshtein", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_levenshtein(a0, a1));
  else if (count == 3) return (x_levenshtein(a0, a1, a2));
  else if (count == 4) return (x_levenshtein(a0, a1, a2, a3));
  else return (x_levenshtein(a0, a1, a2, a3, a4));
}
Variant ei_curl_multi_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_multi_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_close(a0));
}
Variant ei_drawgetfillalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillalpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillalpha(a0));
}
Variant ei_hash_hmac(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_hash_hmac(a0, a1, a2));
  else return (x_hash_hmac(a0, a1, a2, a3));
}
Variant ei_get_html_translation_table(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_html_translation_table", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_html_translation_table());
  else if (count == 1) return (x_get_html_translation_table(a0));
  else return (x_get_html_translation_table(a0, a1));
}
Variant ei_user_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("user_error", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_user_error(a0));
  else return (x_user_error(a0, a1));
}
Variant ei_feof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("feof", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_feof(a0));
}
Variant ei_filemtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filemtime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filemtime(a0));
}
Variant ei_microtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("microtime", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_microtime());
  else return (x_microtime(a0));
}
Variant ei_zend_version(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_version", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zend_version());
}
Variant ei_openssl_x509_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_x509_free(a0), null);
}
Variant ei_fb_call_user_func_safe(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("fb_call_user_func_safe", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_fb_call_user_func_safe(count, a0));
  return (x_fb_call_user_func_safe(count, a0,vargs));
}
Variant ei_var_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("var_export", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_var_export(a0));
  else return (x_var_export(a0, a1));
}
Variant ei_mb_strcut(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strcut", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strcut(a0, a1));
  else if (count == 3) return (x_mb_strcut(a0, a1, a2));
  else return (x_mb_strcut(a0, a1, a2, a3));
}
Variant ei_xmlwriter_end_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_comment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_comment(a0));
}
Variant ei_xmlwriter_end_dtd_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_element", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd_element(a0));
}
Variant ei_dom_text_split_text(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_text_split_text", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_text_split_text(a0, a1));
}
Variant ei_openssl_pkey_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export_to_file", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_pkey_export_to_file(a0, a1));
  else if (count == 3) return (x_openssl_pkey_export_to_file(a0, a1, a2));
  else return (x_openssl_pkey_export_to_file(a0, a1, a2, a3));
}
Variant ei_hphp_get_original_class_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_original_class_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_original_class_name(a0));
}
Variant ei_imagecolorclosesthwb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosesthwb", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorclosesthwb(a0, a1, a2, a3));
}
Variant ei_ldap_get_attributes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_attributes", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_attributes(a0, a1));
}
Variant ei_date_modify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_modify", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_modify(a0, a1), null);
}
Variant ei_hphp_splfileinfo_setinfoclass(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_setinfoclass", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_setinfoclass(a0, a1), null);
}
Variant ei_umask(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("umask", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_umask());
  else return (x_umask(a0));
}
Variant ei_xml_get_current_column_number(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_column_number", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_current_column_number(a0));
}
Variant ei_pixelsetblue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblue", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetblue(a0, a1), null);
}
Variant ei_mb_http_output(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_output", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_http_output());
  else return (x_mb_http_output(a0));
}
Variant ei_flock(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("flock", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_flock(a0, a1));
  else return (x_flock(a0, a1, ref(a2)));
}
Variant ei_hphp_splfileobject_ftell(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_ftell", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_ftell(a0));
}
Variant ei_pcntl_wifexited(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifexited", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wifexited(a0));
}
Variant ei_magicksetformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetformat", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetformat(a0, a1));
}
Variant ei_array_map(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_map", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_map(count, a0, a1));
  return (x_array_map(count, a0, a1,vargs));
}
Variant ei_magicksharpenimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicksharpenimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magicksharpenimage(a0, a1, a2));
  else return (x_magicksharpenimage(a0, a1, a2, a3));
}
Variant ei_is_infinite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_infinite", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_infinite(a0));
}
Variant ei_date_timezone_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_timezone_set", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_timezone_set(a0, a1), null);
}
Variant ei_mb_ereg_search_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_ereg_search_init", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_ereg_search_init(a0));
  else if (count == 2) return (x_mb_ereg_search_init(a0, a1));
  else return (x_mb_ereg_search_init(a0, a1, a2));
}
Variant ei_drawcircle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawcircle", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcircle(a0, a1, a2, a3, a4), null);
}
Variant ei_is_readable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_readable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_readable(a0));
}
Variant ei_image_type_to_extension(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("image_type_to_extension", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_image_type_to_extension(a0));
  else return (x_image_type_to_extension(a0, a1));
}
Variant ei_printf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("printf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_printf(count, a0));
  return (x_printf(count, a0,vargs));
}
Variant ei_magicksetimagecompression(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompression", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecompression(a0, a1));
}
Variant ei_mcrypt_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_decrypt", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_decrypt(a0, a1, a2, a3));
  else return (x_mcrypt_decrypt(a0, a1, a2, a3, a4));
}
Variant ei_hphp_directoryiterator_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_next(a0), null);
}
Variant ei_natcasesort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("natcasesort", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_natcasesort(ref(a0)));
}
Variant ei_intl_get_error_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_message", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_get_error_message());
}
Variant ei_memcache_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_get", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_get(a0, a1));
  else return (x_memcache_get(a0, a1, ref(a2)));
}
Variant ei_array_chunk(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_chunk", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_chunk(a0, a1));
  else return (x_array_chunk(a0, a1, a2));
}
Variant ei_collator_asort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_asort", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_collator_asort(a0, ref(a1)));
  else return (x_collator_asort(a0, ref(a1), a2));
}
Variant ei_imagefilledpolygon(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefilledpolygon", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledpolygon(a0, a1, a2, a3));
}
Variant ei_drawpoppattern(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpoppattern", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpoppattern(a0), null);
}
Variant ei_magickgetimagewidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewidth", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagewidth(a0));
}
Variant ei_drawgetfontfamily(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontfamily", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontfamily(a0));
}
Variant ei_dl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dl", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dl(a0));
}
Variant ei_touch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("touch", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_touch(a0));
  else if (count == 2) return (x_touch(a0, a1));
  else return (x_touch(a0, a1, a2));
}
Variant ei_hphp_recursivedirectoryiterator___tostring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator___tostring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator___tostring(a0));
}
Variant ei_magicksetimagebordercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagebordercolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagebordercolor(a0, a1));
}
Variant ei_hphp_directoryiterator_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_rewind(a0), null);
}
Variant ei_magickspliceimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickspliceimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickspliceimage(a0, a1, a2, a3, a4));
}
Variant ei_define(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("define", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_define(a0, a1));
  else return (x_define(a0, a1, a2));
}
Variant ei_headers_sent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("headers_sent", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_headers_sent());
  else if (count == 1) return (x_headers_sent(ref(a0)));
  else return (x_headers_sent(ref(a0), ref(a1)));
}
Variant ei_stream_context_get_options(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_context_get_options", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_context_get_options(a0));
}
Variant ei_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("file", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_file(a0));
  else if (count == 2) return (x_file(a0, a1));
  else return (x_file(a0, a1, a2));
}
Variant ei_memcache_get_extended_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_extended_stats", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_get_extended_stats(a0));
  else if (count == 2) return (x_memcache_get_extended_stats(a0, a1));
  else if (count == 3) return (x_memcache_get_extended_stats(a0, a1, a2));
  else return (x_memcache_get_extended_stats(a0, a1, a2, a3));
}
Variant ei_hphp_crash_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_crash_log", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_crash_log(a0, a1), null);
}
Variant ei_imagecolorresolvealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorresolvealpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorresolvealpha(a0, a1, a2, a3, a4));
}
Variant ei_strtr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strtr", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strtr(a0, a1));
  else return (x_strtr(a0, a1, a2));
}
Variant ei_posix_strerror(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_strerror", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_strerror(a0));
}
Variant ei_libxml_use_internal_errors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_use_internal_errors", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_libxml_use_internal_errors());
  else return (x_libxml_use_internal_errors(a0));
}
Variant ei_end_user_func_async(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("end_user_func_async", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_end_user_func_async(a0));
  else if (count == 2) return (x_end_user_func_async(a0, a1));
  else return (x_end_user_func_async(a0, a1, a2));
}
Variant ei_openssl_get_publickey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_get_publickey", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_get_publickey(a0));
}
Variant ei_dom_node_lookup_prefix(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_prefix", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_lookup_prefix(a0, a1));
}
Variant ei_time_nanosleep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("time_nanosleep", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_time_nanosleep(a0, a1));
}
Variant ei_magicksetimageunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageunits", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageunits(a0, a1));
}
Variant ei_floor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_floor(a0));
}
Variant ei_array_pad(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_pad", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_pad(a0, a1, a2));
}
Variant ei_sem_release(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_release", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sem_release(a0));
}
Variant ei_hphp_splfileinfo_getctime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getctime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getctime(a0));
}
Variant ei_highlight_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_string", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_highlight_string(a0));
  else return (x_highlight_string(a0, a1));
}
Variant ei_hphp_invoke(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_invoke", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_invoke(a0, a1));
}
Variant ei_imageloadfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageloadfont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageloadfont(a0));
}
Variant ei_xmlwriter_start_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_element", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_element(a0, a1));
}
Variant ei_localeconv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("localeconv", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_localeconv());
}
Variant ei_exif_thumbnail(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_thumbnail", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_exif_thumbnail(a0));
  else if (count == 2) return (x_exif_thumbnail(a0, ref(a1)));
  else if (count == 3) return (x_exif_thumbnail(a0, ref(a1), ref(a2)));
  else return (x_exif_thumbnail(a0, ref(a1), ref(a2), ref(a3)));
}
Variant ei_collator_get_error_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_message", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_error_message(a0));
}
Variant ei_mysql_get_proto_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_proto_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_get_proto_info());
  else return (x_mysql_get_proto_info(a0));
}
Variant ei_imagefontwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagefontwidth", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefontwidth(a0));
}
Variant ei_substr_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("substr_compare", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_substr_compare(a0, a1, a2));
  else if (count == 4) return (x_substr_compare(a0, a1, a2, a3));
  else return (x_substr_compare(a0, a1, a2, a3, a4));
}
Variant ei_xbox_post_message(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xbox_post_message", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xbox_post_message(a0));
  else return (x_xbox_post_message(a0, a1));
}
Variant ei_fb_rename_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_rename_function", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_rename_function(a0, a1));
}
Variant ei_array_walk_recursive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk_recursive", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_walk_recursive(ref(a0), a1));
  else return (x_array_walk_recursive(ref(a0), a1, a2));
}
Variant ei_mysql_list_processes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_processes", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_list_processes());
  else return (x_mysql_list_processes(a0));
}
Variant ei_imagedashedline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagedashedline", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagedashedline(a0, a1, a2, a3, a4, a5));
}
Variant ei_magickgetimagedelay(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedelay", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagedelay(a0));
}
Variant ei_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pi", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pi());
}
Variant ei_mb_substr_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_substr_count", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_substr_count(a0, a1));
  else return (x_mb_substr_count(a0, a1, a2));
}
Variant ei_hphp_splfileinfo_getinode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getinode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getinode(a0));
}
Variant ei_magickgettextdescent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextdescent", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgettextdescent(a0, a1, a2));
  else return (x_magickgettextdescent(a0, a1, a2, a3));
}
Variant ei_drawsetstrokealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokealpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokealpha(a0, a1), null);
}
Variant ei_apc_delete_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_delete_file(a0));
  else return (x_apc_delete_file(a0, a1));
}
Variant ei_strrpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strrpos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strrpos(a0, a1));
  else return (x_strrpos(a0, a1, a2));
}
Variant ei_array_diff_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_diff_assoc(count, a0, a1));
  return (x_array_diff_assoc(count, a0, a1,vargs));
}
Variant ei_magickclippathimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickclippathimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickclippathimage(a0, a1, a2));
}
Variant ei_xmlwriter_write_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("xmlwriter_write_element", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xmlwriter_write_element(a0, a1));
  else return (x_xmlwriter_write_element(a0, a1, a2));
}
Variant ei_dom_document_schema_validate_xml(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_xml", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_schema_validate_xml(a0, a1));
}
Variant ei_ascii2ebcdic(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ascii2ebcdic", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ascii2ebcdic(a0));
}
Variant ei_ereg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("ereg", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_ereg(a0, a1));
  else return (x_ereg(a0, a1, ref(a2)));
}
Variant ei_curl_multi_info_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_info_read", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_curl_multi_info_read(a0));
  else return (x_curl_multi_info_read(a0, ref(a1)));
}
Variant ei_magickthresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickthresholdimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickthresholdimage(a0, a1));
  else return (x_magickthresholdimage(a0, a1, a2));
}
Variant ei_msg_remove_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("msg_remove_queue", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_msg_remove_queue(a0));
}
Variant ei_mb_strlen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strlen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strlen(a0));
  else return (x_mb_strlen(a0, a1));
}
Variant ei_drawgetclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclippath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetclippath(a0));
}
Variant ei_imagecopy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagecopy", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopy(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_pixelsetcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcolor(a0, a1), null);
}
Variant ei_time_sleep_until(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("time_sleep_until", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_time_sleep_until(a0));
}
Variant ei_session_unset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_unset", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_unset());
}
Variant ei_mb_ereg_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_ereg_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_ereg_replace(a0, a1, a2));
  else return (x_mb_ereg_replace(a0, a1, a2, a3));
}
Variant ei_openssl_csr_get_public_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_csr_get_public_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_csr_get_public_key(a0));
}
Variant ei_magickfximage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickfximage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickfximage(a0, a1));
  else return (x_magickfximage(a0, a1, a2));
}
Variant ei_tmpfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("tmpfile", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tmpfile());
}
Variant ei_hash(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash(a0, a1));
  else return (x_hash(a0, a1, a2));
}
Variant ei_uasort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uasort", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_uasort(ref(a0), a1));
}
Variant ei_pixelgetalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetalpha(a0));
}
Variant ei_drawsettextencoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextencoding", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextencoding(a0, a1), null);
}
Variant ei_apache_request_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_request_headers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_request_headers());
}
Variant ei_is_subclass_of(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_subclass_of", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_subclass_of(a0, a1));
}
Variant ei_pixelgetmagentaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagentaquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetmagentaquantum(a0));
}
Variant ei_hphp_get_static_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_get_static_property", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_static_property(a0, a1));
}
Variant ei_array_pop(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_pop", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_pop(ref(a0)));
}
Variant ei_magickgetimagecolors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecolors", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecolors(a0));
}
Variant ei_session_regenerate_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_regenerate_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_regenerate_id());
  else return (x_session_regenerate_id(a0));
}
Variant ei_class_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_exists", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_class_exists(a0));
  else return (x_class_exists(a0, a1));
}
Variant ei_getallheaders(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getallheaders", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getallheaders());
}
Variant ei_get_extension_funcs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_extension_funcs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_extension_funcs(a0));
}
Variant ei_imagecolordeallocate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolordeallocate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolordeallocate(a0, a1));
}
Variant ei_closelog(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("closelog", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_closelog());
}
Variant ei_drawpathlinetoabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathlinetoabsolute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetoabsolute(a0, a1, a2), null);
}
Variant ei_mcrypt_enc_get_iv_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_iv_size", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_iv_size(a0));
}
Variant ei_json_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("json_decode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_json_decode(a0));
  else if (count == 2) return (x_json_decode(a0, a1));
  else return (x_json_decode(a0, a1, a2));
}
Variant ei_preg_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_preg_replace(a0, a1, a2));
  else if (count == 4) return (x_preg_replace(a0, a1, a2, a3));
  else return (x_preg_replace(a0, a1, a2, a3, ref(a4)));
}
Variant ei_hphp_splfileinfo_getmtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getmtime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getmtime(a0));
}
Variant ei_fmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fmod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fmod(a0, a1));
}
Variant ei_curl_errno(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_errno", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_errno(a0));
}
Variant ei_pagelet_server_task_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pagelet_server_task_start", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pagelet_server_task_start(a0));
  else if (count == 2) return (x_pagelet_server_task_start(a0, a1));
  else return (x_pagelet_server_task_start(a0, a1, a2));
}
Variant ei_hash_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("hash_init", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hash_init(a0));
  else if (count == 2) return (x_hash_init(a0, a1));
  else return (x_hash_init(a0, a1, a2));
}
Variant ei_mb_strripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strripos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strripos(a0, a1));
  else if (count == 3) return (x_mb_strripos(a0, a1, a2));
  else return (x_mb_strripos(a0, a1, a2, a3));
}
Variant ei_mysql_fetch_row(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_row", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_fetch_row(a0));
}
Variant ei_hphp_splfileobject_setcsvcontrol(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_setcsvcontrol", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_setcsvcontrol(a0, a1, a2, a3), null);
}
Variant ei_ob_get_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_flush());
}
Variant ei_curl_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_error", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_error(a0));
}
Variant ei_set_magic_quotes_runtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_magic_quotes_runtime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_magic_quotes_runtime(a0));
}
Variant ei_magickcharcoalimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcharcoalimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcharcoalimage(a0, a1, a2));
}
Variant ei_scandir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("scandir", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_scandir(a0));
  else if (count == 2) return (x_scandir(a0, a1));
  else return (x_scandir(a0, a1, a2));
}
Variant ei_magickmosaicimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmosaicimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmosaicimages(a0));
}
Variant ei_timezone_transitions_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_transitions_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_transitions_get(a0));
}
Variant ei_drawsetfontweight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontweight", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontweight(a0, a1), null);
}
Variant ei_popdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("popdrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_popdrawingwand(a0), null);
}
Variant ei_collator_sort_with_sort_keys(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_sort_with_sort_keys", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_sort_with_sort_keys(a0, ref(a1)));
}
Variant ei_socket_shutdown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_shutdown", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_shutdown(a0));
  else return (x_socket_shutdown(a0, a1));
}
Variant ei_mcrypt_create_iv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_create_iv", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_create_iv(a0));
  else return (x_mcrypt_create_iv(a0, a1));
}
Variant ei_eval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("eval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_eval(a0));
}
Variant ei_bindec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bindec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bindec(a0));
}
Variant ei_fileperms(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileperms", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileperms(a0));
}
Variant ei_hphp_splfileobject_fstat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fstat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fstat(a0));
}
Variant ei_unserialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unserialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_unserialize(a0));
}
Variant ei_urldecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("urldecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_urldecode(a0));
}
Variant ei_magickannotateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickannotateimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickannotateimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_mailparse_msg_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mailparse_msg_create", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_create());
}
Variant ei_session_set_cookie_params(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("session_set_cookie_params", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_session_set_cookie_params(a0), null);
  else if (count == 2) return (x_session_set_cookie_params(a0, a1), null);
  else if (count == 3) return (x_session_set_cookie_params(a0, a1, a2), null);
  else if (count == 4) return (x_session_set_cookie_params(a0, a1, a2, a3), null);
  else return (x_session_set_cookie_params(a0, a1, a2, a3, a4), null);
}
Variant ei_apache_get_modules(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_modules", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_modules());
}
Variant ei_drawellipse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawellipse", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawellipse(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_xmlwriter_write_element_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("xmlwriter_write_element_ns", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_xmlwriter_write_element_ns(a0, a1, a2, a3));
  else return (x_xmlwriter_write_element_ns(a0, a1, a2, a3, a4));
}
Variant ei_magicksetcompressionquality(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetcompressionquality", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetcompressionquality(a0, a1));
}
Variant ei_magickaddnoiseimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddnoiseimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaddnoiseimage(a0, a1));
}
Variant ei_magickgetimagewhitepoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagewhitepoint", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagewhitepoint(a0));
}
Variant ei_magickseparateimagechannel(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickseparateimagechannel", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickseparateimagechannel(a0, a1));
}
Variant ei_array_push(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_push", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_push(count, ref(a0), a1));
  return (x_array_push(count, ref(a0), a1,vargs));
}
Variant ei_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_flush(), null);
}
Variant ei_connection_aborted(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_aborted", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_connection_aborted());
}
Variant ei_uksort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("uksort", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_uksort(ref(a0), a1));
}
Variant ei_mysql_set_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mysql_set_timeout", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_set_timeout());
  else if (count == 1) return (x_mysql_set_timeout(a0));
  else return (x_mysql_set_timeout(a0, a1));
}
Variant ei_hash_update_stream(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_stream", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash_update_stream(a0, a1));
  else return (x_hash_update_stream(a0, a1, a2));
}
Variant ei_ob_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 3) return throw_toomany_arguments("ob_start", 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ob_start());
  else if (count == 1) return (x_ob_start(a0));
  else if (count == 2) return (x_ob_start(a0, a1));
  else return (x_ob_start(a0, a1, a2));
}
Variant ei_mysql_get_host_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_host_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_get_host_info());
  else return (x_mysql_get_host_info(a0));
}
Variant ei_mb_language(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_language", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_language());
  else return (x_mb_language(a0));
}
Variant ei_pixelgetnextiteratorrow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetnextiteratorrow", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetnextiteratorrow(a0));
}
Variant ei_ldap_next_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_reference", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_next_reference(a0, a1));
}
Variant ei_socket_get_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_get_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_get_status(a0));
}
Variant ei_checkdnsrr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("checkdnsrr", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_checkdnsrr(a0));
  else return (x_checkdnsrr(a0, a1));
}
Variant ei_openssl_verify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_verify", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_verify(a0, a1, a2));
  else return (x_openssl_verify(a0, a1, a2, a3));
}
Variant ei_curl_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_exec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_exec(a0));
}
Variant ei_magickgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetexceptiontype(a0));
}
Variant ei_array_sum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_sum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_sum(a0));
}
Variant ei_unregister_tick_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("unregister_tick_function", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_unregister_tick_function(a0), null);
}
Variant ei_newpixelwandarray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwandarray", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixelwandarray(a0));
}
Variant ei_magickgetversion(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversion", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetversion());
}
Variant ei_imagelayereffect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagelayereffect", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagelayereffect(a0, a1));
}
Variant ei_apache_reset_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_reset_timeout", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_reset_timeout());
}
Variant ei_glob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("glob", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_glob(a0));
  else return (x_glob(a0, a1));
}
Variant ei_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("exec", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_exec(a0));
  else if (count == 2) return (x_exec(a0, ref(a1)));
  else return (x_exec(a0, ref(a1), ref(a2)));
}
Variant ei_apd_continue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_continue", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_continue());
}
Variant ei_magickgetimagedepth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magickgetimagedepth", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickgetimagedepth(a0));
  else return (x_magickgetimagedepth(a0, a1));
}
Variant ei_pclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pclose(a0));
}
Variant ei_get_parent_class(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_parent_class", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_parent_class());
  else return (x_get_parent_class(a0));
}
Variant ei_mb_strpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strpos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strpos(a0, a1));
  else if (count == 3) return (x_mb_strpos(a0, a1, a2));
  else return (x_mb_strpos(a0, a1, a2, a3));
}
Variant ei_xmlwriter_write_dtd_attlist(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_attlist", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_dtd_attlist(a0, a1, a2));
}
Variant ei_xml_set_element_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_set_element_handler", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_element_handler(a0, a1, a2));
}
Variant ei_drawgetstrokeopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeopacity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokeopacity(a0));
}
Variant ei_ldap_get_entries(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_entries", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_entries(a0, a1));
}
Variant ei_ob_iconv_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_iconv_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_iconv_handler(a0, a1));
}
Variant ei_hphp_throw_fatal_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_throw_fatal_error", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_throw_fatal_error(a0), null);
}
Variant ei_pathinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("pathinfo", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pathinfo(a0));
  else return (x_pathinfo(a0, a1));
}
Variant ei_magickaffinetransformimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaffinetransformimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaffinetransformimage(a0, a1));
}
Variant ei_fb_stubout_intercept_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_stubout_intercept_handler", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_stubout_intercept_handler(a0, a1, a2, a3, ref(a4)));
}
Variant ei_ob_get_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_get_status", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ob_get_status());
  else return (x_ob_get_status(a0));
}
Variant ei_collator_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_create", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_create(a0));
}
Variant ei_exit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("exit", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_exit());
  else return (x_exit(a0));
}
Variant ei_memcache_debug(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_debug", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_debug(a0));
}
Variant ei_apc_sma_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_sma_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_sma_info());
  else return (x_apc_sma_info(a0));
}
Variant ei_ldap_bind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("ldap_bind", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_ldap_bind(a0));
  else if (count == 2) return (x_ldap_bind(a0, a1));
  else return (x_ldap_bind(a0, a1, a2));
}
Variant ei_pixelsetbluequantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetbluequantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetbluequantum(a0, a1), null);
}
Variant ei_magickreadimagefile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimagefile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimagefile(a0, a1));
}
Variant ei_session_is_registered(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_is_registered", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_is_registered(a0));
}
Variant ei_ebcdic2ascii(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ebcdic2ascii", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ebcdic2ascii(a0));
}
Variant ei_mysql_real_escape_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_real_escape_string", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_real_escape_string(a0));
  else return (x_mysql_real_escape_string(a0, a1));
}
Variant ei_magickframeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickframeimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickframeimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_pixelgetblue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblue", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetblue(a0));
}
Variant ei_imagefill(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagefill", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefill(a0, a1, a2, a3));
}
Variant ei_hphp_set_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_set_property", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_set_property(a0, a1, a2, a3), null);
}
Variant ei_readgzfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("readgzfile", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_readgzfile(a0));
  else return (x_readgzfile(a0, a1));
}
Variant ei_memcache_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_set", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_memcache_set(a0, a1, a2));
  else if (count == 4) return (x_memcache_set(a0, a1, a2, a3));
  else return (x_memcache_set(a0, a1, a2, a3, a4));
}
Variant ei_magicksampleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksampleimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksampleimage(a0, a1, a2));
}
Variant ei_mysql_escape_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_escape_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_escape_string(a0));
}
Variant ei_idn_to_utf8(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_utf8", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idn_to_utf8(a0));
  else return (x_idn_to_utf8(a0, ref(a1)));
}
Variant ei_sql_regcase(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sql_regcase", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sql_regcase(a0));
}
Variant ei_in_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("in_array", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_in_array(a0, a1));
  else return (x_in_array(a0, a1, a2));
}
Variant ei_drawpathcurvetoquadraticbezierabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetoquadraticbezierabsolute", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbezierabsolute(a0, a1, a2, a3, a4), null);
}
Variant ei_apache_getenv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apache_getenv", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apache_getenv(a0));
  else return (x_apache_getenv(a0, a1));
}
Variant ei_socket_set_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_set_timeout", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_set_timeout(a0, a1));
  else return (x_socket_set_timeout(a0, a1, a2));
}
Variant ei_bin2hex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("bin2hex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_bin2hex(a0));
}
Variant ei_error_get_last(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("error_get_last", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_error_get_last());
}
Variant ei_is_link(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_link", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_link(a0));
}
Variant ei_set_file_buffer(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("set_file_buffer", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_file_buffer(a0, a1));
}
Variant ei_magicksetimageredprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageredprimary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageredprimary(a0, a1, a2));
}
Variant ei_i18n_loc_set_default(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_default", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_set_default(a0));
}
Variant ei_ftok(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftok", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ftok(a0, a1));
}
Variant ei_mysql_list_fields(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_list_fields", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_list_fields(a0, a1));
  else return (x_mysql_list_fields(a0, a1, a2));
}
Variant ei_stream_wrapper_register(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_wrapper_register", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_wrapper_register(a0, a1));
}
Variant ei_pixelsetredquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetredquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetredquantum(a0, a1), null);
}
Variant ei_xhprof_disable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_disable", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_disable());
}
Variant ei_magickgammaimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickgammaimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickgammaimage(a0, a1));
  else return (x_magickgammaimage(a0, a1, a2));
}
Variant ei_pixelsetcyan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyan", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcyan(a0, a1), null);
}
Variant ei_mb_decode_mimeheader(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_decode_mimeheader", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_decode_mimeheader(a0));
}
Variant ei_key_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("key_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_key_exists(a0, a1));
}
Variant ei_htmlentities(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlentities", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_htmlentities(a0));
  else if (count == 2) return (x_htmlentities(a0, a1));
  else if (count == 3) return (x_htmlentities(a0, a1, a2));
  else return (x_htmlentities(a0, a1, a2, a3));
}
Variant ei_rad2deg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rad2deg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rad2deg(a0));
}
Variant ei_xmlwriter_start_dtd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("xmlwriter_start_dtd", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xmlwriter_start_dtd(a0, a1));
  else if (count == 3) return (x_xmlwriter_start_dtd(a0, a1, a2));
  else return (x_xmlwriter_start_dtd(a0, a1, a2, a3));
}
Variant ei_drawpathstart(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathstart", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathstart(a0), null);
}
Variant ei_proc_nice(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_nice", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_proc_nice(a0));
}
Variant ei_hphp_thread_is_warmup_enabled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_is_warmup_enabled", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_thread_is_warmup_enabled());
}
Variant ei_mysql_pconnect_with_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_pconnect_with_db", 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_pconnect_with_db());
  else if (count == 1) return (x_mysql_pconnect_with_db(a0));
  else if (count == 2) return (x_mysql_pconnect_with_db(a0, a1));
  else if (count == 3) return (x_mysql_pconnect_with_db(a0, a1, a2));
  else if (count == 4) return (x_mysql_pconnect_with_db(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_pconnect_with_db(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_mysql_pconnect_with_db(a0, a1, a2, a3, a4, a5));
  else return (x_mysql_pconnect_with_db(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_imagepsslantfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsslantfont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsslantfont(a0, a1));
}
Variant ei_magickgetimagemattecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemattecolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagemattecolor(a0));
}
Variant ei_mb_strstr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strstr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strstr(a0, a1));
  else if (count == 3) return (x_mb_strstr(a0, a1, a2));
  else return (x_mb_strstr(a0, a1, a2, a3));
}
Variant ei_pixelgetblack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblack", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetblack(a0));
}
Variant ei_mysql_field_table(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_table", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_table(a0));
  else return (x_mysql_field_table(a0, a1));
}
Variant ei_magicksetimagescene(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagescene", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagescene(a0, a1));
}
Variant ei_magickgetimagerenderingintent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagerenderingintent", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagerenderingintent(a0));
}
Variant ei_setlocale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("setlocale", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_setlocale(count, a0, a1));
  return (x_setlocale(count, a0, a1,vargs));
}
Variant ei_drawpushclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpushclippath", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpushclippath(a0, a1), null);
}
Variant ei_drawpopclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopclippath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpopclippath(a0), null);
}
Variant ei_nl2br(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl2br", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_nl2br(a0));
}
Variant ei_hphp_splfileinfo_getperms(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getperms", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getperms(a0));
}
Variant ei_drawsetfillopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillopacity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillopacity(a0, a1), null);
}
Variant ei_mb_substitute_character(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_substitute_character", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_substitute_character());
  else return (x_mb_substitute_character(a0));
}
Variant ei_setrawcookie(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setrawcookie", count, 1, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_setrawcookie(a0));
  else if (count == 2) return (x_setrawcookie(a0, a1));
  else if (count == 3) return (x_setrawcookie(a0, a1, a2));
  else if (count == 4) return (x_setrawcookie(a0, a1, a2, a3));
  else if (count == 5) return (x_setrawcookie(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_setrawcookie(a0, a1, a2, a3, a4, a5));
  else return (x_setrawcookie(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_evhttp_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("evhttp_get", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_evhttp_get(a0));
  else if (count == 2) return (x_evhttp_get(a0, a1));
  else return (x_evhttp_get(a0, a1, a2));
}
Variant ei_getimagesize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getimagesize", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_getimagesize(a0));
  else return (x_getimagesize(a0, ref(a1)));
}
Variant ei_ldap_modify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_modify", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_modify(a0, a1, a2));
}
Variant ei_ldap_search(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_search", count, 3, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_search(a0, a1, a2));
  else if (count == 4) return (x_ldap_search(a0, a1, a2, a3));
  else if (count == 5) return (x_ldap_search(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_ldap_search(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_ldap_search(a0, a1, a2, a3, a4, a5, a6));
  else return (x_ldap_search(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_strcasecmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcasecmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strcasecmp(a0, a1));
}
Variant ei_magickgetimagesignature(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesignature", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagesignature(a0));
}
Variant ei_get_class_methods(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_class_methods", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_class_methods(a0));
}
Variant ei_fopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fopen", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fopen(a0, a1));
  else if (count == 3) return (x_fopen(a0, a1, a2));
  else return (x_fopen(a0, a1, a2, a3));
}
Variant ei_fb_const_fetch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_const_fetch", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_const_fetch(a0));
}
Variant ei_mcrypt_generic_end(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_end", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic_end(a0));
}
Variant ei_openssl_pkey_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkey_free(a0), null);
}
Variant ei_readlink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readlink", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_readlink(a0));
}
Variant ei_header_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("header_remove", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_header_remove(), null);
  else return (x_header_remove(a0), null);
}
Variant ei_magickechoimagesblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimagesblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickechoimagesblob(a0));
}
Variant ei_mailparse_msg_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_parse", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_parse(a0, a1));
}
Variant ei_xmlwriter_text(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_text", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_text(a0, a1));
}
Variant ei_pixelsetindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetindex", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetindex(a0, a1), null);
}
Variant ei_php_sapi_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_sapi_name", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_sapi_name());
}
Variant ei_mcrypt_enc_get_key_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_key_size", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_key_size(a0));
}
Variant ei_mysql_num_fields(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_fields", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_num_fields(a0));
}
Variant ei_dom_xpath_register_php_functions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dom_xpath_register_php_functions", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_xpath_register_php_functions(a0));
  else return (x_dom_xpath_register_php_functions(a0, a1));
}
Variant ei_magicksteganoimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksteganoimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksteganoimage(a0, a1, a2));
}
Variant ei_magicksetfirstiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicksetfirstiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetfirstiterator(a0), null);
}
Variant ei_pixelgetcolorasstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorasstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcolorasstring(a0));
}
Variant ei_magickremoveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickremoveimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickremoveimage(a0));
}
Variant ei_file_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("file_exists", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_file_exists(a0));
}
Variant ei_call_user_func_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_array(a0, a1));
}
Variant ei_restore_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_include_path", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_restore_include_path(), null);
}
Variant ei_memcache_set_compress_threshold(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_set_compress_threshold", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_set_compress_threshold(a0, a1));
  else return (x_memcache_set_compress_threshold(a0, a1, a2));
}
Variant ei_dom_element_set_id_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_id_attribute_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_id_attribute_ns(a0, a1, a2, a3));
}
Variant ei_drawgettextundercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextundercolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextundercolor(a0));
}
Variant ei_array_shift(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_shift", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_shift(ref(a0)));
}
Variant ei_magicksetimageformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageformat", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageformat(a0, a1));
}
Variant ei_xmlwriter_open_memory(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xmlwriter_open_memory", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_open_memory());
}
Variant ei_drawsetstrokemiterlimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokemiterlimit", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokemiterlimit(a0, a1), null);
}
Variant ei_mb_convert_kana(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_convert_kana", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_convert_kana(a0));
  else if (count == 2) return (x_mb_convert_kana(a0, a1));
  else return (x_mb_convert_kana(a0, a1, a2));
}
Variant ei_token_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_token_name(a0));
}
Variant ei_preg_quote(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("preg_quote", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_preg_quote(a0));
  else return (x_preg_quote(a0, a1));
}
Variant ei_hphp_service_thread_started(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_service_thread_started", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_service_thread_started(), null);
}
Variant ei_magickconvolveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickconvolveimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickconvolveimage(a0, a1));
  else return (x_magickconvolveimage(a0, a1, a2));
}
Variant ei_curl_getinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_getinfo", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_curl_getinfo(a0));
  else return (x_curl_getinfo(a0, a1));
}
Variant ei_pfsockopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("pfsockopen", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pfsockopen(a0));
  else if (count == 2) return (x_pfsockopen(a0, a1));
  else if (count == 3) return (x_pfsockopen(a0, a1, ref(a2)));
  else if (count == 4) return (x_pfsockopen(a0, a1, ref(a2), ref(a3)));
  else return (x_pfsockopen(a0, a1, ref(a2), ref(a3), a4));
}
Variant ei_dom_element_get_elements_by_tag_name_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_elements_by_tag_name_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_elements_by_tag_name_ns(a0, a1, a2));
}
Variant ei_ucfirst(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ucfirst", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ucfirst(a0));
}
Variant ei_hphp_splfileinfo_isreadable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isreadable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isreadable(a0));
}
Variant ei_chroot(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chroot", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chroot(a0));
}
Variant ei_chdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("chdir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chdir(a0));
}
Variant ei_socket_write(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_write", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_write(a0, a1));
  else return (x_socket_write(a0, a1, a2));
}
Variant ei_forward_static_call_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("forward_static_call_array", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_forward_static_call_array(a0, a1));
}
Variant ei_stream_bucket_new(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_new", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_new(a0, a1));
}
Variant ei_magickflipimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflipimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickflipimage(a0));
}
Variant ei_timezone_identifiers_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_identifiers_list", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_identifiers_list());
}
Variant ei_array_diff_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff_key", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_diff_key(count, a0, a1));
  return (x_array_diff_key(count, a0, a1,vargs));
}
Variant ei_session_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_encode", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_encode());
}
Variant ei_fread(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fread", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fread(a0, a1));
}
Variant ei_override_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("override_function", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_override_function(a0, a1, a2));
}
Variant ei_is_long(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_long", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_long(a0));
}
Variant ei_pixelsetred(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetred", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetred(a0, a1), null);
}
Variant ei_mailparse_uudecode_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_uudecode_all", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_uudecode_all(a0));
}
Variant ei_drawsetvectorgraphics(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetvectorgraphics", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetvectorgraphics(a0, a1));
}
Variant ei_ctype_upper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_upper", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_upper(a0));
}
Variant ei_get_declared_classes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_classes", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_declared_classes());
}
Variant ei_drawgetstrokelinejoin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinejoin", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokelinejoin(a0));
}
Variant ei_popen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("popen", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_popen(a0, a1));
}
Variant ei_ldap_next_entry(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_entry", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_next_entry(a0, a1));
}
Variant ei_mailparse_msg_parse_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_parse_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_parse_file(a0));
}
Variant ei_get_loaded_extensions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_loaded_extensions", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_loaded_extensions());
  else return (x_get_loaded_extensions(a0));
}
Variant ei_magickdrawimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickdrawimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdrawimage(a0, a1));
}
Variant ei_mcrypt_cbc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cbc", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_cbc(a0, a1, a2, a3));
  else return (x_mcrypt_cbc(a0, a1, a2, a3, a4));
}
Variant ei_session_set_save_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("session_set_save_handler", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_set_save_handler(a0, a1, a2, a3, a4, a5));
}
Variant ei_dom_element_get_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute(a0, a1));
}
Variant ei_imagecreatetruecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreatetruecolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatetruecolor(a0, a1));
}
Variant ei_intl_is_failure(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("intl_is_failure", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_is_failure(a0));
}
Variant ei_inet_ntop(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_ntop", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_inet_ntop(a0));
}
Variant ei_magickreadimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimage(a0, a1));
}
Variant ei_dom_node_is_default_namespace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_default_namespace", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_is_default_namespace(a0, a1));
}
Variant ei_curl_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_init", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_curl_init());
  else return (x_curl_init(a0));
}
Variant ei_mcrypt_cfb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_cfb", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_cfb(a0, a1, a2, a3));
  else return (x_mcrypt_cfb(a0, a1, a2, a3, a4));
}
Variant ei_dom_document_create_document_fragment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_create_document_fragment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_document_fragment(a0));
}
Variant ei_set_time_limit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_time_limit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_time_limit(a0), null);
}
Variant ei_libxml_get_errors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_errors", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_get_errors());
}
Variant ei_get_magic_quotes_gpc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_gpc", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_magic_quotes_gpc());
}
Variant ei_proc_get_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_get_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_proc_get_status(a0));
}
Variant ei_log10(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log10", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_log10(a0));
}
Variant ei_hphp_directoryiterator_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_seek(a0, a1), null);
}
Variant ei_ldap_get_values(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_values(a0, a1, a2));
}
Variant ei_is_soap_fault(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_soap_fault", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_soap_fault(a0));
}
Variant ei_magickgetimagechannelmean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagechannelmean", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagechannelmean(a0, a1));
}
Variant ei_disk_total_space(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_total_space", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_disk_total_space(a0));
}
Variant ei_imagegd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegd", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegd(a0));
  else return (x_imagegd(a0, a1));
}
Variant ei_socket_set_blocking(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("socket_set_blocking", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_blocking(a0, a1));
}
Variant ei_dom_element_get_elements_by_tag_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_elements_by_tag_name", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_elements_by_tag_name(a0, a1));
}
Variant ei_posix_mknod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("posix_mknod", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_posix_mknod(a0, a1));
  else if (count == 3) return (x_posix_mknod(a0, a1, a2));
  else return (x_posix_mknod(a0, a1, a2, a3));
}
Variant ei_apc_define_constants(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_define_constants", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_apc_define_constants(a0, a1));
  else if (count == 3) return (x_apc_define_constants(a0, a1, a2));
  else return (x_apc_define_constants(a0, a1, a2, a3));
}
Variant ei_posix_kill(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_kill", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_kill(a0, a1));
}
Variant ei_drawgetstrokealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokealpha", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokealpha(a0));
}
Variant ei_mcrypt_get_block_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_get_block_size", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_get_block_size(a0));
  else return (x_mcrypt_get_block_size(a0, a1));
}
Variant ei_magickmorphimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmorphimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmorphimages(a0, a1));
}
Variant ei_getlastmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getlastmod", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getlastmod());
}
Variant ei_magickquantizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickquantizeimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_imagesavealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesavealpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesavealpha(a0, a1));
}
Variant ei_drawsetfontfamily(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontfamily", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontfamily(a0, a1));
}
Variant ei_drawsettextantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsettextantialias", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_drawsettextantialias(a0), null);
  else return (x_drawsettextantialias(a0, a1), null);
}
Variant ei_pixelsetgreenquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetgreenquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetgreenquantum(a0, a1), null);
}
Variant ei_bcsqrt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("bcsqrt", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_bcsqrt(a0));
  else return (x_bcsqrt(a0, a1));
}
Variant ei_pcntl_signal(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_signal", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_pcntl_signal(a0, a1));
  else return (x_pcntl_signal(a0, a1, a2));
}
Variant ei_mcrypt_ecb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ecb", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_ecb(a0, a1, a2, a3));
  else return (x_mcrypt_ecb(a0, a1, a2, a3, a4));
}
Variant ei_pixelsetcyanquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetcyanquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetcyanquantum(a0, a1), null);
}
Variant ei_array_walk(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_walk", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_walk(ref(a0), a1));
  else return (x_array_walk(ref(a0), a1, a2));
}
Variant ei_getmxrr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("getmxrr", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_getmxrr(a0, ref(a1)));
  else return (x_getmxrr(a0, ref(a1), ref(a2)));
}
Variant ei_magickqueryfonts(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryfonts", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryfonts(a0));
}
Variant ei_floatval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("floatval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_floatval(a0));
}
Variant ei_dom_element_get_attribute_node_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_node_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute_node_ns(a0, a1, a2));
}
Variant ei_xml_set_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_object", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_object(a0, ref(a1)));
}
Variant ei_ctype_print(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_print", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_print(a0));
}
Variant ei_gzwrite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzwrite", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzwrite(a0, a1));
  else return (x_gzwrite(a0, a1, a2));
}
Variant ei_hphp_splfileinfo___tostring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo___tostring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo___tostring(a0));
}
Variant ei_magickaddimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickaddimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaddimage(a0, a1));
}
Variant ei_clearstatcache(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("clearstatcache", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearstatcache(), null);
}
Variant ei_chgrp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chgrp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chgrp(a0, a1));
}
Variant ei_virtual(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("virtual", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_virtual(a0));
}
Variant ei_reset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("reset", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_reset(ref(a0)));
}
Variant ei_set_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("set_include_path", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_set_include_path(a0));
}
Variant ei_hphp_recursivedirectoryiterator_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_next(a0), null);
}
Variant ei_openssl_x509_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_x509_export", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_x509_export(a0, ref(a1)));
  else return (x_openssl_x509_export(a0, ref(a1), a2));
}
Variant ei_magickcolorizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickcolorizeimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcolorizeimage(a0, a1, a2));
}
Variant ei_imagettftext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagettftext", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagettftext(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_mb_strrchr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrchr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strrchr(a0, a1));
  else if (count == 3) return (x_mb_strrchr(a0, a1, a2));
  else return (x_mb_strrchr(a0, a1, a2, a3));
}
Variant ei_magickgetimageprofile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimageprofile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageprofile(a0, a1));
}
Variant ei_file_put_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("file_put_contents", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_file_put_contents(a0, a1));
  else if (count == 3) return (x_file_put_contents(a0, a1, a2));
  else return (x_file_put_contents(a0, a1, a2, a3));
}
Variant ei_iconv_mime_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_mime_encode", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_mime_encode(a0, a1));
  else return (x_iconv_mime_encode(a0, a1, a2));
}
Variant ei_log1p(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("log1p", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_log1p(a0));
}
Variant ei_fwrite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fwrite", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fwrite(a0, a1));
  else return (x_fwrite(a0, a1, a2));
}
Variant ei_atan2(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("atan2", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_atan2(a0, a1));
}
Variant ei_is_a(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("is_a", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_a(a0, a1));
}
Variant ei_idate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idate(a0));
  else return (x_idate(a0, a1));
}
Variant ei_posix_initgroups(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_initgroups", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_initgroups(a0, a1));
}
Variant ei_arsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("arsort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_arsort(ref(a0)));
  else if (count == 2) return (x_arsort(ref(a0), a1));
  else return (x_arsort(ref(a0), a1, a2));
}
Variant ei_dom_characterdata_substring_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_substring_data", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_substring_data(a0, a1, a2));
}
Variant ei_gethostbyaddr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyaddr", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gethostbyaddr(a0));
}
Variant ei_apc_delete(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apc_delete", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_delete(a0));
  else return (x_apc_delete(a0, a1));
}
Variant ei_magicklevelimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("magicklevelimage", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_magicklevelimage(a0, a1, a2, a3));
  else return (x_magicklevelimage(a0, a1, a2, a3, a4));
}
Variant ei_openssl_x509_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_x509_parse", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_x509_parse(a0));
  else return (x_openssl_x509_parse(a0, a1));
}
Variant ei_dom_nodelist_item(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_nodelist_item", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_nodelist_item(a0, a1));
}
Variant ei_magickcommentimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcommentimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcommentimage(a0, a1));
}
Variant ei_hphp_splfileinfo_islink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_islink", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_islink(a0));
}
Variant ei_magicksetimagedelay(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedelay", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagedelay(a0, a1));
}
Variant ei_magickposterizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickposterizeimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickposterizeimage(a0, a1, a2));
}
Variant ei_dom_namednodemap_get_named_item(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_namednodemap_get_named_item", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_namednodemap_get_named_item(a0, a1));
}
Variant ei_dom_element_get_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_get_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute_ns(a0, a1, a2));
}
Variant ei_stream_socket_accept(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_socket_accept", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_socket_accept(a0));
  else if (count == 2) return (x_stream_socket_accept(a0, a1));
  else return (x_stream_socket_accept(a0, a1, ref(a2)));
}
Variant ei_magickqueryconfigureoption(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoption", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryconfigureoption(a0));
}
Variant ei_magickevaluateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickevaluateimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickevaluateimage(a0, a1, a2));
  else return (x_magickevaluateimage(a0, a1, a2, a3));
}
Variant ei_imagesx(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesx", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesx(a0));
}
Variant ei_imagesy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagesy", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesy(a0));
}
Variant ei_mysql_get_client_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mysql_get_client_info", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_get_client_info());
}
Variant ei_fb_crossall_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("fb_crossall_query", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fb_crossall_query(a0));
  else if (count == 2) return (x_fb_crossall_query(a0, a1));
  else if (count == 3) return (x_fb_crossall_query(a0, a1, a2));
  else if (count == 4) return (x_fb_crossall_query(a0, a1, a2, a3));
  else if (count == 5) return (x_fb_crossall_query(a0, a1, a2, a3, a4));
  else return (x_fb_crossall_query(a0, a1, a2, a3, a4, a5));
}
Variant ei_fseek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fseek", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fseek(a0, a1));
  else return (x_fseek(a0, a1, a2));
}
Variant ei_call_user_func_array_async(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("call_user_func_array_async", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_array_async(a0, a1));
}
Variant ei_apc_compile_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_compile_file", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_compile_file(a0));
  else if (count == 2) return (x_apc_compile_file(a0, a1));
  else return (x_apc_compile_file(a0, a1, a2));
}
Variant ei_memcache_set_server_params(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 7) return throw_wrong_arguments("memcache_set_server_params", count, 2, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_set_server_params(a0, a1));
  else if (count == 3) return (x_memcache_set_server_params(a0, a1, a2));
  else if (count == 4) return (x_memcache_set_server_params(a0, a1, a2, a3));
  else if (count == 5) return (x_memcache_set_server_params(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_memcache_set_server_params(a0, a1, a2, a3, a4, a5));
  else return (x_memcache_set_server_params(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_magicksetpassphrase(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetpassphrase", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetpassphrase(a0, a1));
}
Variant ei_mysql_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_info());
  else return (x_mysql_info(a0));
}
Variant ei_is_writable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_writable(a0));
}
Variant ei_magickrotateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickrotateimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickrotateimage(a0, a1, a2));
}
Variant ei_fgetcsv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("fgetcsv", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fgetcsv(a0));
  else if (count == 2) return (x_fgetcsv(a0, a1));
  else if (count == 3) return (x_fgetcsv(a0, a1, a2));
  else return (x_fgetcsv(a0, a1, a2, a3));
}
Variant ei_magickcolorfloodfillimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickcolorfloodfillimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcolorfloodfillimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_atanh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("atanh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_atanh(a0));
}
Variant ei_imagecopyresized(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresized", count, 10, 10, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopyresized(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
Variant ei_fpassthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fpassthru", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fpassthru(a0));
}
Variant ei_magickblackthresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickblackthresholdimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickblackthresholdimage(a0, a1));
}
Variant ei_mcrypt_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_encrypt", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_encrypt(a0, a1, a2, a3));
  else return (x_mcrypt_encrypt(a0, a1, a2, a3, a4));
}
Variant ei_magicksetimagegreenprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagegreenprimary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagegreenprimary(a0, a1, a2));
}
Variant ei_xmlwriter_start_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_attribute_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_attribute_ns(a0, a1, a2, a3));
}
Variant ei_magickgetimageinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageinterlacescheme", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageinterlacescheme(a0));
}
Variant ei_apache_child_terminate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_child_terminate", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_child_terminate());
}
Variant ei_array_merge_recursive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_merge_recursive", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_merge_recursive(count, a0));
  return (x_array_merge_recursive(count, a0,vargs));
}
Variant ei_array_uintersect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_uintersect(count, a0, a1, a2));
  return (x_array_uintersect(count, a0, a1, a2,vargs));
}
Variant ei_xml_set_unparsed_entity_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_unparsed_entity_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_unparsed_entity_decl_handler(a0, a1));
}
Variant ei_ob_get_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_contents", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_contents());
}
Variant ei_pixelgetcyan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcyan(a0));
}
Variant ei_stream_select(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("stream_select", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_stream_select(ref(a0), ref(a1), ref(a2), a3));
  else return (x_stream_select(ref(a0), ref(a1), ref(a2), a3, a4));
}
Variant ei_get_resource_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_resource_type", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_resource_type(a0));
}
Variant ei_dangling_server_proxy_old_request(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("dangling_server_proxy_old_request", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dangling_server_proxy_old_request());
}
Variant ei_magickgetimagefilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagefilename", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagefilename(a0));
}
Variant ei_exif_tagname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("exif_tagname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_exif_tagname(a0));
}
Variant ei_dom_document_create_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_create_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_attribute_ns(a0, a1, a2));
}
Variant ei_drawsetfillalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillalpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillalpha(a0, a1), null);
}
Variant ei_mb_convert_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_convert_encoding", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_convert_encoding(a0, a1));
  else return (x_mb_convert_encoding(a0, a1, a2));
}
Variant ei_wandgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandgetexceptionstring(a0));
}
Variant ei_proc_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("proc_open", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_proc_open(a0, a1, ref(a2)));
  else if (count == 4) return (x_proc_open(a0, a1, ref(a2), a3));
  else if (count == 5) return (x_proc_open(a0, a1, ref(a2), a3, a4));
  else return (x_proc_open(a0, a1, ref(a2), a3, a4, a5));
}
Variant ei_hphp_splfileobject_fgetss(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_fgetss", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgetss(a0, a1));
}
Variant ei_clearpixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearpixeliterator(a0), null);
}
Variant ei_socket_server(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("socket_server", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_server(a0));
  else if (count == 2) return (x_socket_server(a0, a1));
  else if (count == 3) return (x_socket_server(a0, a1, ref(a2)));
  else return (x_socket_server(a0, a1, ref(a2), ref(a3)));
}
Variant ei_magickremoveimageprofile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickremoveimageprofile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickremoveimageprofile(a0, a1));
}
Variant ei_xmlwriter_write_dtd_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_dtd_element", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_dtd_element(a0, a1, a2));
}
Variant ei_drawpushdefs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpushdefs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpushdefs(a0), null);
}
Variant ei_image2wbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("image2wbmp", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_image2wbmp(a0));
  else if (count == 2) return (x_image2wbmp(a0, a1));
  else return (x_image2wbmp(a0, a1, a2));
}
Variant ei_join(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("join", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_join(a0));
  else return (x_join(a0, a1));
}
Variant ei_magicksetimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimage(a0, a1));
}
Variant ei_openssl_free_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_free_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_free_key(a0), null);
}
Variant ei_preg_grep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("preg_grep", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_preg_grep(a0, a1));
  else return (x_preg_grep(a0, a1, a2));
}
Variant ei_is_float(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_float", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_float(a0));
}
Variant ei_stream_socket_pair(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("stream_socket_pair", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_socket_pair(a0, a1, a2));
}
Variant ei_get_required_files(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_required_files", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_required_files());
}
Variant ei_mysql_fetch_field(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_field", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_fetch_field(a0));
  else return (x_mysql_fetch_field(a0, a1));
}
Variant ei_chmod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chmod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chmod(a0, a1));
}
Variant ei_magickgettextascent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgettextascent", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgettextascent(a0, a1, a2));
  else return (x_magickgettextascent(a0, a1, a2, a3));
}
Variant ei_mb_regex_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_regex_encoding());
  else return (x_mb_regex_encoding(a0));
}
Variant ei_mail(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mail", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mail(a0, a1, a2));
  else if (count == 4) return (x_mail(a0, a1, a2, a3));
  else return (x_mail(a0, a1, a2, a3, a4));
}
Variant ei_mcrypt_enc_self_test(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_self_test", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_self_test(a0));
}
Variant ei_ignore_user_abort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ignore_user_abort", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ignore_user_abort());
  else return (x_ignore_user_abort(a0));
}
Variant ei_imagesetthickness(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetthickness", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetthickness(a0, a1));
}
Variant ei_str_pad(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("str_pad", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_str_pad(a0, a1));
  else if (count == 3) return (x_str_pad(a0, a1, a2));
  else return (x_str_pad(a0, a1, a2, a3));
}
Variant ei_openssl_pkcs7_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_pkcs7_decrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_pkcs7_decrypt(a0, a1, a2));
  else return (x_openssl_pkcs7_decrypt(a0, a1, a2, a3));
}
Variant ei_pagelet_server_task_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("pagelet_server_task_result", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pagelet_server_task_result(a0, ref(a1), ref(a2)));
}
Variant ei_asinh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("asinh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_asinh(a0));
}
Variant ei_mailparse_msg_extract_part(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mailparse_msg_extract_part(a0, a1));
  else return (x_mailparse_msg_extract_part(a0, a1, a2));
}
Variant ei_magickgetimagecompose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecompose(a0));
}
Variant ei_hphp_splfileinfo_getpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getpath(a0));
}
Variant ei_magickcropimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickcropimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcropimage(a0, a1, a2, a3, a4));
}
Variant ei_ob_gzhandler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ob_gzhandler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_gzhandler(a0, a1));
}
Variant ei_dom_document_normalize_document(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_normalize_document", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_normalize_document(a0));
}
Variant ei_drawcomment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawcomment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawcomment(a0, a1), null);
}
Variant ei_call_user_method(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("call_user_method", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_call_user_method(count, a0, ref(a1)));
  return (x_call_user_method(count, a0, ref(a1),vargs));
}
Variant ei_parse_hdf_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_file", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_parse_hdf_file(a0));
}
Variant ei_mb_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_split", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_split(a0, a1));
  else return (x_mb_split(a0, a1, a2));
}
Variant ei_imagepolygon(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagepolygon", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepolygon(a0, a1, a2, a3));
}
Variant ei_mysql_field_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_name", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_name(a0));
  else return (x_mysql_field_name(a0, a1));
}
Variant ei_fputs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fputs", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fputs(a0, a1));
  else return (x_fputs(a0, a1, a2));
}
Variant ei_imagecolorallocatealpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorallocatealpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorallocatealpha(a0, a1, a2, a3, a4));
}
Variant ei_substr_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("substr_count", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_substr_count(a0, a1));
  else if (count == 3) return (x_substr_count(a0, a1, a2));
  else return (x_substr_count(a0, a1, a2, a3));
}
Variant ei_ldap_first_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_reference", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_first_reference(a0, a1));
}
Variant ei_clock_settime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_settime", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clock_settime(a0, a1, a2));
}
Variant ei_dom_namednodemap_get_named_item_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_namednodemap_get_named_item_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_namednodemap_get_named_item_ns(a0, a1, a2));
}
Variant ei_ftruncate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ftruncate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ftruncate(a0, a1));
}
Variant ei_curl_version(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("curl_version", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_curl_version());
  else return (x_curl_version(a0));
}
Variant ei_pixelgetbluequantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetbluequantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetbluequantum(a0));
}
Variant ei_print(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("print", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_print(a0));
}
Variant ei_mysql_unbuffered_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_unbuffered_query", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_unbuffered_query(a0));
  else return (x_mysql_unbuffered_query(a0, a1));
}
Variant ei_dom_characterdata_delete_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_characterdata_delete_data", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_characterdata_delete_data(a0, a1, a2));
}
Variant ei_hphp_recursiveiteratoriterator___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_recursiveiteratoriterator___construct", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator___construct(a0, a1, a2, a3));
}
Variant ei_hash_final(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hash_final", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hash_final(a0));
  else return (x_hash_final(a0, a1));
}
Variant ei_imagecolorresolve(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorresolve", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorresolve(a0, a1, a2, a3));
}
Variant ei_dom_document_import_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_import_node", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_import_node(a0, a1));
  else return (x_dom_document_import_node(a0, a1, a2));
}
Variant ei_date_date_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("date_date_set", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_date_set(a0, a1, a2, a3), null);
}
Variant ei_pixelsetyellow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellow", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetyellow(a0, a1), null);
}
Variant ei_furchash_hphp_ext_supported(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("furchash_hphp_ext_supported", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_furchash_hphp_ext_supported());
}
Variant ei_inet_pton(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("inet_pton", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_inet_pton(a0));
}
Variant ei_mcrypt_get_key_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_key_size", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_get_key_size(a0, a1));
}
Variant ei_drawsettextalignment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextalignment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextalignment(a0, a1), null);
}
Variant ei_magickgetimageredprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageredprimary", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageredprimary(a0));
}
Variant ei_addslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("addslashes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_addslashes(a0));
}
Variant ei_ldap_count_entries(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_count_entries", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_count_entries(a0, a1));
}
Variant ei_ereg_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ereg_replace", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ereg_replace(a0, a1, a2));
}
Variant ei_hphp_recursivedirectoryiterator_getchildren(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getchildren", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_getchildren(a0));
}
Variant ei_call_user_func_async(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func_async", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_call_user_func_async(count, a0));
  return (x_call_user_func_async(count, a0,vargs));
}
Variant ei_drawrender(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawrender", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawrender(a0));
}
Variant ei_fb_rpc_intercept_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("fb_rpc_intercept_handler", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_rpc_intercept_handler(a0, a1, a2, a3, ref(a4)));
}
Variant ei_fb_intercept(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_intercept", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fb_intercept(a0, a1));
  else return (x_fb_intercept(a0, a1, a2));
}
Variant ei_magickgetversionnumber(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionnumber", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetversionnumber());
}
Variant ei_array_splice(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_splice", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_splice(ref(a0), a1));
  else if (count == 3) return (x_array_splice(ref(a0), a1, a2));
  else return (x_array_splice(ref(a0), a1, a2, a3));
}
Variant ei_ftell(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ftell", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ftell(a0));
}
Variant ei_magicksetimagedepth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magicksetimagedepth", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magicksetimagedepth(a0, a1));
  else return (x_magicksetimagedepth(a0, a1, a2));
}
Variant ei_apc_load_constants(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_load_constants", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_load_constants(a0));
  else if (count == 2) return (x_apc_load_constants(a0, a1));
  else return (x_apc_load_constants(a0, a1, a2));
}
Variant ei___halt_compiler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("__halt_compiler", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x___halt_compiler(), null);
}
Variant ei_magicklabelimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicklabelimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicklabelimage(a0, a1));
}
Variant ei_hphp_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_log", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_log(a0, a1));
}
Variant ei_stream_get_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("stream_get_contents", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_get_contents(a0));
  else if (count == 2) return (x_stream_get_contents(a0, a1));
  else return (x_stream_get_contents(a0, a1, a2));
}
Variant ei_imagecreatefromjpeg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromjpeg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromjpeg(a0));
}
Variant ei_chown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("chown", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_chown(a0, a1));
}
Variant ei_hash_hmac_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("hash_hmac_file", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_hash_hmac_file(a0, a1, a2));
  else return (x_hash_hmac_file(a0, a1, a2, a3));
}
Variant ei_magickechoimageblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickechoimageblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickechoimageblob(a0));
}
Variant ei_link(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("link", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_link(a0, a1));
}
Variant ei_fb_utf8ize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_utf8ize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_utf8ize(ref(a0)));
}
Variant ei_drawsetfillpatternurl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillpatternurl", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillpatternurl(a0, a1));
}
Variant ei_iconv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("iconv", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iconv(a0, a1, a2));
}
Variant ei_highlight_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("highlight_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_highlight_file(a0));
  else return (x_highlight_file(a0, a1));
}
Variant ei_iconv_mime_decode_headers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode_headers", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iconv_mime_decode_headers(a0));
  else if (count == 2) return (x_iconv_mime_decode_headers(a0, a1));
  else return (x_iconv_mime_decode_headers(a0, a1, a2));
}
Variant ei_ini_get_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ini_get_all", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ini_get_all());
  else return (x_ini_get_all(a0));
}
Variant ei_collator_get_strength(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_strength", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_strength(a0));
}
Variant ei_ldap_get_values_len(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_values_len", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_values_len(a0, a1, a2));
}
Variant ei_hphp_splfileinfo_getrealpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getrealpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getrealpath(a0));
}
Variant ei_openssl_pkcs7_verify(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("openssl_pkcs7_verify", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_pkcs7_verify(a0, a1));
  else if (count == 3) return (x_openssl_pkcs7_verify(a0, a1, a2));
  else if (count == 4) return (x_openssl_pkcs7_verify(a0, a1, a2, a3));
  else if (count == 5) return (x_openssl_pkcs7_verify(a0, a1, a2, a3, a4));
  else return (x_openssl_pkcs7_verify(a0, a1, a2, a3, a4, a5));
}
Variant ei_hphp_directoryiterator_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_current(a0));
}
Variant ei_hphp_splfileobject_fgetcsv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fgetcsv", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgetcsv(a0, a1, a2, a3));
}
Variant ei_furchash_hphp_ext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("furchash_hphp_ext", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_furchash_hphp_ext(a0, a1, a2));
}
Variant ei_stream_socket_recvfrom(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_recvfrom", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_socket_recvfrom(a0, a1));
  else if (count == 3) return (x_stream_socket_recvfrom(a0, a1, a2));
  else return (x_stream_socket_recvfrom(a0, a1, a2, a3));
}
Variant ei_drawgetcliprule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetcliprule", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetcliprule(a0));
}
Variant ei_apc_filehits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apc_filehits", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apc_filehits());
}
Variant ei_pixelgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetexceptionstring(a0));
}
Variant ei_mcrypt_ofb(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("mcrypt_ofb", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_mcrypt_ofb(a0, a1, a2, a3));
  else return (x_mcrypt_ofb(a0, a1, a2, a3, a4));
}
Variant ei_imageantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imageantialias", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageantialias(a0, a1));
}
Variant ei_hphp_splfileinfo_openfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileinfo_openfile", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_openfile(a0, a1, a2, a3));
}
Variant ei_dom_document_validate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_validate", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_validate(a0));
}
Variant ei_idn_to_ascii(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("idn_to_ascii", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_idn_to_ascii(a0));
  else return (x_idn_to_ascii(a0, ref(a1)));
}
Variant ei_error_log(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("error_log", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_error_log(a0));
  else if (count == 2) return (x_error_log(a0, a1));
  else if (count == 3) return (x_error_log(a0, a1, a2));
  else return (x_error_log(a0, a1, a2, a3));
}
Variant ei_hash_update(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hash_update", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hash_update(a0, a1));
}
Variant ei_ob_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_flush(), null);
}
Variant ei_md5_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("md5_file", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_md5_file(a0));
  else return (x_md5_file(a0, a1));
}
Variant ei_drawgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetexception(a0));
}
Variant ei_file_get_contents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("file_get_contents", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_file_get_contents(a0));
  else if (count == 2) return (x_file_get_contents(a0, a1));
  else if (count == 3) return (x_file_get_contents(a0, a1, a2));
  else if (count == 4) return (x_file_get_contents(a0, a1, a2, a3));
  else return (x_file_get_contents(a0, a1, a2, a3, a4));
}
Variant ei_uniqid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("uniqid", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_uniqid());
  else if (count == 1) return (x_uniqid(a0));
  else return (x_uniqid(a0, a1));
}
Variant ei_strncasecmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncasecmp", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strncasecmp(a0, a1, a2));
}
Variant ei_magicksetimagepixels(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("magicksetimagepixels", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagepixels(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_drawgetfillopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillopacity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillopacity(a0));
}
Variant ei_xml_parser_create_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("xml_parser_create_ns", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_xml_parser_create_ns());
  else if (count == 1) return (x_xml_parser_create_ns(a0));
  else return (x_xml_parser_create_ns(a0, a1));
}
Variant ei_ldap_delete(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_delete", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_delete(a0, a1));
}
Variant ei_fnmatch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fnmatch", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fnmatch(a0, a1));
  else return (x_fnmatch(a0, a1, a2));
}
Variant ei_hphp_splfileobject_eof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_eof", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_eof(a0));
}
Variant ei_metaphone(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("metaphone", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_metaphone(a0));
  else return (x_metaphone(a0, a1));
}
Variant ei_mysql_errno(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_errno", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_errno());
  else return (x_mysql_errno(a0));
}
Variant ei_stream_wrapper_unregister(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_unregister", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_wrapper_unregister(a0));
}
Variant ei_magickcyclecolormapimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcyclecolormapimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcyclecolormapimage(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_current(a0));
}
Variant ei_restore_error_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_error_handler", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_restore_error_handler());
}
Variant ei_hphp_recursivedirectoryiterator___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_recursivedirectoryiterator___construct", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator___construct(a0, a1, a2));
}
Variant ei_magicksetimagevirtualpixelmethod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagevirtualpixelmethod", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagevirtualpixelmethod(a0, a1));
}
Variant ei_socket_getpeername(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getpeername", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_getpeername(a0, ref(a1)));
  else return (x_socket_getpeername(a0, ref(a1), ref(a2)));
}
Variant ei_memcache_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("memcache_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_memcache_close(a0));
}
Variant ei_mysql_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_error", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_error());
  else return (x_mysql_error(a0));
}
Variant ei_drawtranslate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawtranslate", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawtranslate(a0, a1, a2), null);
}
Variant ei_mysql_list_dbs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_list_dbs", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_list_dbs());
  else return (x_mysql_list_dbs(a0));
}
Variant ei_imagefilter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) return throw_wrong_arguments("imagefilter", count, 2, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_imagefilter(a0, a1));
  else if (count == 3) return (x_imagefilter(a0, a1, a2));
  else if (count == 4) return (x_imagefilter(a0, a1, a2, a3));
  else if (count == 5) return (x_imagefilter(a0, a1, a2, a3, a4));
  else return (x_imagefilter(a0, a1, a2, a3, a4, a5));
}
Variant ei_base64_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("base64_encode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_base64_encode(a0));
}
Variant ei_dom_xpath_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_query", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_xpath_query(a0, a1));
  else return (x_dom_xpath_query(a0, a1, a2));
}
Variant ei_hphpd_install_user_command(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphpd_install_user_command", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphpd_install_user_command(a0, a1));
}
Variant ei_dom_element_set_id_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute_node", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_id_attribute_node(a0, a1, a2));
}
Variant ei_is_null(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_null", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_null(a0));
}
Variant ei_octdec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("octdec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_octdec(a0));
}
Variant ei_drawsetclippath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclippath", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetclippath(a0, a1));
}
Variant ei_magickconstituteimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickconstituteimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickconstituteimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_pcntl_wexitstatus(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wexitstatus", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wexitstatus(a0));
}
Variant ei_iterator_apply(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iterator_apply", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iterator_apply(a0, a1));
  else return (x_iterator_apply(a0, a1, a2));
}
Variant ei_apache_setenv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("apache_setenv", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_apache_setenv(a0, a1));
  else return (x_apache_setenv(a0, a1, a2));
}
Variant ei_dom_node_is_same_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_is_same_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_is_same_node(a0, a1));
}
Variant ei_clonedrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clonedrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clonedrawingwand(a0));
}
Variant ei_ob_get_clean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_clean", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_clean());
}
Variant ei_expm1(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("expm1", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_expm1(a0));
}
Variant ei_ldap_first_entry(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_entry", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_first_entry(a0, a1));
}
Variant ei_curl_multi_select(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("curl_multi_select", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_curl_multi_select(a0));
  else return (x_curl_multi_select(a0, a1));
}
Variant ei_magickswirlimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickswirlimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickswirlimage(a0, a1));
}
Variant ei_mb_ereg_search_regs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_regs", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_ereg_search_regs());
  else if (count == 1) return (x_mb_ereg_search_regs(a0));
  else return (x_mb_ereg_search_regs(a0, a1));
}
Variant ei_ldap_errno(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_errno", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_errno(a0));
}
Variant ei_mysql_get_server_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_get_server_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_get_server_info());
  else return (x_mysql_get_server_info(a0));
}
Variant ei_mailparse_rfc822_parse_addresses(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_rfc822_parse_addresses", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_rfc822_parse_addresses(a0));
}
Variant ei_magickgetimagemimetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagemimetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagemimetype(a0));
}
Variant ei_soundex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("soundex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_soundex(a0));
}
Variant ei_magickgetimageformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageformat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageformat(a0));
}
Variant ei_mcrypt_module_get_supported_key_sizes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_supported_key_sizes", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_get_supported_key_sizes(a0));
  else return (x_mcrypt_module_get_supported_key_sizes(a0, a1));
}
Variant ei_preg_replace_callback(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_replace_callback", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_preg_replace_callback(a0, a1, a2));
  else if (count == 4) return (x_preg_replace_callback(a0, a1, a2, a3));
  else return (x_preg_replace_callback(a0, a1, a2, a3, ref(a4)));
}
Variant ei_dom_document_create_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_create_element", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_create_element(a0, a1));
  else return (x_dom_document_create_element(a0, a1, a2));
}
Variant ei_ldap_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_error", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_error(a0));
}
Variant ei_xmlwriter_full_end_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_full_end_element", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_full_end_element(a0));
}
Variant ei_ctype_graph(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_graph", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_graph(a0));
}
Variant ei_session_register(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("session_register", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_session_register(count, a0));
  return (x_session_register(count, a0,vargs));
}
Variant ei_asort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("asort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_asort(ref(a0)));
  else if (count == 2) return (x_asort(ref(a0), a1));
  else return (x_asort(ref(a0), a1, a2));
}
Variant ei_apd_echo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("apd_echo", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_echo(a0));
}
Variant ei_rewinddir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rewinddir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rewinddir(a0), null);
}
Variant ei_ob_implicit_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("ob_implicit_flush", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_ob_implicit_flush(), null);
  else return (x_ob_implicit_flush(a0), null);
}
Variant ei_pcntl_signal_dispatch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_signal_dispatch", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_signal_dispatch());
}
Variant ei_session_get_cookie_params(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_get_cookie_params", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_get_cookie_params());
}
Variant ei_pixelgetiteratorexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetiteratorexceptionstring(a0));
}
Variant ei_stream_socket_client(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("stream_socket_client", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_socket_client(a0));
  else if (count == 2) return (x_stream_socket_client(a0, ref(a1)));
  else if (count == 3) return (x_stream_socket_client(a0, ref(a1), ref(a2)));
  else if (count == 4) return (x_stream_socket_client(a0, ref(a1), ref(a2), a3));
  else if (count == 5) return (x_stream_socket_client(a0, ref(a1), ref(a2), a3, a4));
  else return (x_stream_socket_client(a0, ref(a1), ref(a2), a3, a4, a5));
}
Variant ei_drawsetstrokedasharray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokedasharray", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_drawsetstrokedasharray(a0), null);
  else return (x_drawsetstrokedasharray(a0, a1), null);
}
Variant ei_mysql_free_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_free_result", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_free_result(a0));
}
Variant ei_is_real(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_real", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_real(a0));
}
Variant ei_mcrypt_enc_is_block_algorithm_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm_mode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_is_block_algorithm_mode(a0));
}
Variant ei_array_slice(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("array_slice", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_slice(a0, a1));
  else if (count == 3) return (x_array_slice(a0, a1, a2));
  else return (x_array_slice(a0, a1, a2, a3));
}
Variant ei_count_chars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count_chars", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_count_chars(a0));
  else return (x_count_chars(a0, a1));
}
Variant ei_hphp_splfileobject_getmaxlinelen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getmaxlinelen", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_getmaxlinelen(a0));
}
Variant ei_array_uintersect_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_uintersect_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 4) return (x_array_uintersect_uassoc(count, a0, a1, a2, a3));
  return (x_array_uintersect_uassoc(count, a0, a1, a2, a3,vargs));
}
Variant ei_drawsetstrokewidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokewidth", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokewidth(a0, a1), null);
}
Variant ei_posix_mkfifo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_mkfifo", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_mkfifo(a0, a1));
}
Variant ei_array_count_values(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_count_values", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_count_values(a0));
}
Variant ei_memcache_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_connect", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_connect(a0));
  else if (count == 2) return (x_memcache_connect(a0, a1));
  else if (count == 3) return (x_memcache_connect(a0, a1, a2));
  else return (x_memcache_connect(a0, a1, a2, a3));
}
Variant ei_pixelgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetexception(a0));
}
Variant ei_mkdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("mkdir", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mkdir(a0));
  else if (count == 2) return (x_mkdir(a0, a1));
  else if (count == 3) return (x_mkdir(a0, a1, a2));
  else return (x_mkdir(a0, a1, a2, a3));
}
Variant ei_magicksetsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsize", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetsize(a0, a1, a2));
}
Variant ei_debug_zval_dump(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("debug_zval_dump", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_debug_zval_dump(a0), null);
}
Variant ei_iconv_substr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_substr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_substr(a0, a1));
  else if (count == 3) return (x_iconv_substr(a0, a1, a2));
  else return (x_iconv_substr(a0, a1, a2, a3));
}
Variant ei_xml_set_external_entity_ref_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_external_entity_ref_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_external_entity_ref_handler(a0, a1));
}
Variant ei_mb_decode_numericentity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_decode_numericentity", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_decode_numericentity(a0, a1));
  else return (x_mb_decode_numericentity(a0, a1, a2));
}
Variant ei_ldap_next_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_next_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_next_attribute(a0, a1));
}
Variant ei_hphp_splfileobject_fflush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fflush", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fflush(a0));
}
Variant ei_imagejpeg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagejpeg", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagejpeg(a0));
  else if (count == 2) return (x_imagejpeg(a0, a1));
  else return (x_imagejpeg(a0, a1, a2));
}
Variant ei_imagesetbrush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesetbrush", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetbrush(a0, a1));
}
Variant ei_mb_strtoupper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtoupper", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strtoupper(a0));
  else return (x_mb_strtoupper(a0, a1));
}
Variant ei_usleep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("usleep", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_usleep(a0), null);
}
Variant ei_mb_strrpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_strrpos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_strrpos(a0, a1));
  else if (count == 3) return (x_mb_strrpos(a0, a1, a2));
  else return (x_mb_strrpos(a0, a1, a2, a3));
}
Variant ei_collator_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("collator_compare", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_compare(a0, a1, a2));
}
Variant ei_extract(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("extract", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_extract(a0));
  else if (count == 2) return (x_extract(a0, a1));
  else return (x_extract(a0, a1, a2));
}
Variant ei_session_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("session_decode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_decode(a0));
}
Variant ei_get_browser(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("get_browser", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_browser());
  else if (count == 1) return (x_get_browser(a0));
  else return (x_get_browser(a0, a1));
}
Variant ei_html_entity_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("html_entity_decode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_html_entity_decode(a0));
  else if (count == 2) return (x_html_entity_decode(a0, a1));
  else return (x_html_entity_decode(a0, a1, a2));
}
Variant ei_spl_classes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("spl_classes", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_spl_classes());
}
Variant ei_preg_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("preg_split", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_preg_split(a0, a1));
  else if (count == 3) return (x_preg_split(a0, a1, a2));
  else return (x_preg_split(a0, a1, a2, a3));
}
Variant ei_magickpreviewimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickpreviewimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickpreviewimages(a0, a1));
}
Variant ei_zend_logo_guid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_logo_guid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zend_logo_guid());
}
Variant ei_magickgetimagesize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagesize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagesize(a0));
}
Variant ei_apd_set_browser_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_set_browser_trace", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_set_browser_trace(), null);
}
Variant ei_xhprof_sample_enable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_enable", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_sample_enable(), null);
}
Variant ei_hphp_splfileobject_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_key(a0));
}
Variant ei_mb_http_input(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_http_input", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_http_input());
  else return (x_mb_http_input(a0));
}
Variant ei_gzinflate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzinflate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzinflate(a0));
  else return (x_gzinflate(a0, a1));
}
Variant ei_openssl_pkcs7_sign(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 7) return throw_wrong_arguments("openssl_pkcs7_sign", count, 5, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_openssl_pkcs7_sign(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_openssl_pkcs7_sign(a0, a1, a2, a3, a4, a5));
  else return (x_openssl_pkcs7_sign(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_assert(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("assert", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_assert(a0));
}
Variant ei_stream_get_wrappers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_wrappers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_wrappers());
}
Variant ei_gzfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzfile", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzfile(a0));
  else return (x_gzfile(a0, a1));
}
Variant ei_session_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_id());
  else return (x_session_id(a0));
}
Variant ei_stream_socket_sendto(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_sendto", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_socket_sendto(a0, a1));
  else if (count == 3) return (x_stream_socket_sendto(a0, a1, a2));
  else return (x_stream_socket_sendto(a0, a1, a2, a3));
}
Variant ei_gzpassthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzpassthru", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzpassthru(a0));
}
Variant ei_stream_bucket_make_writeable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_bucket_make_writeable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_make_writeable(a0));
}
Variant ei_posix_setegid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setegid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setegid(a0));
}
Variant ei_drawgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetexceptionstring(a0));
}
Variant ei_hash_algos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hash_algos", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hash_algos());
}
Variant ei_drawsetstrokeantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("drawsetstrokeantialias", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_drawsetstrokeantialias(a0), null);
  else return (x_drawsetstrokeantialias(a0, a1), null);
}
Variant ei_destroypixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixelwand(a0), null);
}
Variant ei_fstat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fstat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fstat(a0));
}
Variant ei_magicksetimageresolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageresolution", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageresolution(a0, a1, a2));
}
Variant ei_mysql_db_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_name", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_db_name(a0, a1));
  else return (x_mysql_db_name(a0, a1, a2));
}
Variant ei_is_finite(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_finite", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_finite(a0));
}
Variant ei_pixelgetyellowquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetyellowquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetyellowquantum(a0));
}
Variant ei_ksort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ksort", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_ksort(ref(a0)));
  else return (x_ksort(ref(a0), a1));
}
Variant ei_thrift_protocol_read_binary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("thrift_protocol_read_binary", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_thrift_protocol_read_binary(a0, a1, a2));
}
Variant ei_get_included_files(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_included_files", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_included_files());
}
Variant ei_strip_tags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strip_tags", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strip_tags(a0));
  else return (x_strip_tags(a0, a1));
}
Variant ei_mb_ereg_search_getpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getpos", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_ereg_search_getpos());
}
Variant ei_pixelgetcyanquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcyanquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcyanquantum(a0));
}
Variant ei_magickgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetexception(a0));
}
Variant ei_ctype_punct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_punct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_punct(a0));
}
Variant ei_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_next(ref(a0)));
}
Variant ei_shm_detach(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_detach", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_detach(a0));
}
Variant ei_shm_attach(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("shm_attach", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_shm_attach(a0));
  else if (count == 2) return (x_shm_attach(a0, a1));
  else return (x_shm_attach(a0, a1, a2));
}
Variant ei_magickflattenimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflattenimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickflattenimages(a0));
}
Variant ei_dom_document_save_html_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_save_html_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_save_html_file(a0, a1));
}
Variant ei_similar_text(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("similar_text", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_similar_text(a0, a1));
  else return (x_similar_text(a0, a1, ref(a2)));
}
Variant ei_hphp_get_thread_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_get_thread_id", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_thread_id());
}
Variant ei_imagecreatefromgd2part(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecreatefromgd2part", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgd2part(a0, a1, a2, a3, a4));
}
Variant ei_dom_element_set_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute(a0, a1, a2));
}
Variant ei_iterator_to_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iterator_to_array", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iterator_to_array(a0));
  else return (x_iterator_to_array(a0, a1));
}
Variant ei_iconv_get_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("iconv_get_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_iconv_get_encoding());
  else return (x_iconv_get_encoding(a0));
}
Variant ei_getmyinode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyinode", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmyinode());
}
Variant ei_gzgetc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzgetc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzgetc(a0));
}
Variant ei_hphp_set_static_property(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("hphp_set_static_property", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_set_static_property(a0, a1, a2), null);
}
Variant ei_unlink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("unlink", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_unlink(a0));
  else return (x_unlink(a0, a1));
}
Variant ei_mcrypt_module_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("mcrypt_module_open", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_module_open(a0, a1, a2, a3));
}
Variant ei_token_get_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("token_get_all", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_token_get_all(a0));
}
Variant ei_base_convert(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("base_convert", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_base_convert(a0, a1, a2));
}
Variant ei_gethostbynamel(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbynamel", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gethostbynamel(a0));
}
Variant ei_var_dump(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("var_dump", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_var_dump(count, a0), null);
  return (x_var_dump(count, a0,vargs), null);
}
Variant ei_xmlwriter_start_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_attribute(a0, a1));
}
Variant ei_pack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("pack", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_pack(count, a0));
  return (x_pack(count, a0,vargs));
}
Variant ei_gzgets(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzgets", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzgets(a0));
  else return (x_gzgets(a0, a1));
}
Variant ei_apache_get_version(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_version", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_version());
}
Variant ei_array_intersect_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_intersect_uassoc(count, a0, a1, a2));
  return (x_array_intersect_uassoc(count, a0, a1, a2,vargs));
}
Variant ei_basename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("basename", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_basename(a0));
  else return (x_basename(a0, a1));
}
Variant ei_krsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("krsort", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_krsort(ref(a0)));
  else return (x_krsort(ref(a0), a1));
}
Variant ei_clock_gettime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_gettime", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clock_gettime(a0, ref(a1), ref(a2)));
}
Variant ei_pushdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pushdrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pushdrawingwand(a0), null);
}
Variant ei_imageline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageline", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageline(a0, a1, a2, a3, a4, a5));
}
Variant ei_socket_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_read", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_read(a0, a1));
  else return (x_socket_read(a0, a1, a2));
}
Variant ei_xmlwriter_write_dtd_entity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 7) return throw_wrong_arguments("xmlwriter_write_dtd_entity", count, 3, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_xmlwriter_write_dtd_entity(a0, a1, a2));
  else if (count == 4) return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3));
  else if (count == 5) return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4, a5));
  else return (x_xmlwriter_write_dtd_entity(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_mysql_tablename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_tablename", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_tablename(a0, a1));
}
Variant ei_collator_sort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("collator_sort", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_collator_sort(a0, ref(a1)));
  else return (x_collator_sort(a0, ref(a1), a2));
}
Variant ei_magickwriteimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwriteimage(a0, a1));
}
Variant ei_mcrypt_module_get_algo_key_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_get_algo_key_size", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_get_algo_key_size(a0));
  else return (x_mcrypt_module_get_algo_key_size(a0, a1));
}
Variant ei_hash_update_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("hash_update_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_hash_update_file(a0, a1));
  else return (x_hash_update_file(a0, a1, a2));
}
Variant ei_magickembossimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickembossimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickembossimage(a0, a1, a2));
}
Variant ei_forward_static_call(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("forward_static_call", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_forward_static_call(count, a0));
  return (x_forward_static_call(count, a0,vargs));
}
Variant ei_gzencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzencode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzencode(a0));
  else if (count == 2) return (x_gzencode(a0, a1));
  else return (x_gzencode(a0, a1, a2));
}
Variant ei_checkdate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("checkdate", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_checkdate(a0, a1, a2));
}
Variant ei_magickimplodeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickimplodeimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickimplodeimage(a0, a1));
}
Variant ei_magickgetimageindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageindex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageindex(a0));
}
Variant ei_ctype_lower(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_lower", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_lower(a0));
}
Variant ei_imagepsloadfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsloadfont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsloadfont(a0));
}
Variant ei_iconv_mime_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("iconv_mime_decode", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iconv_mime_decode(a0));
  else if (count == 2) return (x_iconv_mime_decode(a0, a1));
  else return (x_iconv_mime_decode(a0, a1, a2));
}
Variant ei_hphp_recursiveiteratoriterator_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_key(a0));
}
Variant ei_mcrypt_module_is_block_algorithm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_is_block_algorithm(a0));
  else return (x_mcrypt_module_is_block_algorithm(a0, a1));
}
Variant ei_wandgetexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandgetexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandgetexception(a0));
}
Variant ei_fsockopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("fsockopen", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fsockopen(a0));
  else if (count == 2) return (x_fsockopen(a0, a1));
  else if (count == 3) return (x_fsockopen(a0, a1, ref(a2)));
  else if (count == 4) return (x_fsockopen(a0, a1, ref(a2), ref(a3)));
  else return (x_fsockopen(a0, a1, ref(a2), ref(a3), a4));
}
Variant ei_usort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("usort", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_usort(ref(a0), a1));
}
Variant ei_pixelsetiteratorrow(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetiteratorrow", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetiteratorrow(a0, a1));
}
Variant ei_call_user_func_serialized(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("call_user_func_serialized", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_serialized(a0));
}
Variant ei_hphp_splfileinfo_iswritable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_iswritable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_iswritable(a0));
}
Variant ei_dom_document_create_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_attribute(a0, a1));
}
Variant ei_ldap_get_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_get_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_option(a0, a1, ref(a2)));
}
Variant ei_socket_recv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_recv", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_recv(a0, ref(a1), a2, a3));
}
Variant ei_sys_getloadavg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_getloadavg", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sys_getloadavg());
}
Variant ei_evhttp_async_post(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("evhttp_async_post", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_evhttp_async_post(a0, a1));
  else if (count == 3) return (x_evhttp_async_post(a0, a1, a2));
  else return (x_evhttp_async_post(a0, a1, a2, a3));
}
Variant ei_hphp_recursivedirectoryiterator_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_recursivedirectoryiterator_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_seek(a0, a1), null);
}
Variant ei_array_values(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_values", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_values(a0));
}
Variant ei_ctype_digit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_digit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_digit(a0));
}
Variant ei_ob_get_length(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_get_length", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_get_length());
}
Variant ei_magicksolarizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksolarizeimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksolarizeimage(a0, a1));
}
Variant ei_ob_list_handlers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_list_handlers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_list_handlers());
}
Variant ei_array_uintersect_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_uintersect_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_uintersect_assoc(count, a0, a1, a2));
  return (x_array_uintersect_assoc(count, a0, a1, a2,vargs));
}
Variant ei_openssl_x509_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_x509_read", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_x509_read(a0));
}
Variant ei_magickgetimagecolormapcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickgetimagecolormapcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecolormapcolor(a0, a1));
}
Variant ei_hphp_splfileobject_getcvscontrol(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_getcvscontrol", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_getcvscontrol(a0));
}
Variant ei_settype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("settype", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_settype(ref(a0), a1));
}
Variant ei_posix_access(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("posix_access", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_posix_access(a0));
  else return (x_posix_access(a0, a1));
}
Variant ei_explode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("explode", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_explode(a0, a1));
  else return (x_explode(a0, a1, a2));
}
Variant ei_fb_load_local_databases(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_load_local_databases", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_load_local_databases(a0), null);
}
Variant ei_imagecreatefromgd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgd(a0));
}
Variant ei_proc_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("proc_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_proc_close(a0));
}
Variant ei_magickgaussianblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgaussianblurimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgaussianblurimage(a0, a1, a2));
  else return (x_magickgaussianblurimage(a0, a1, a2, a3));
}
Variant ei_apd_set_session_trace_socket(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("apd_set_session_trace_socket", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_set_session_trace_socket(a0, a1, a2, a3));
}
Variant ei_openssl_pkcs12_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 5) return throw_wrong_arguments("openssl_pkcs12_export_to_file", count, 4, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_pkcs12_export_to_file(a0, a1, a2, a3));
  else return (x_openssl_pkcs12_export_to_file(a0, a1, a2, a3, a4));
}
Variant ei_mailparse_msg_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_free(a0));
}
Variant ei_openssl_private_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_decrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_private_decrypt(a0, ref(a1), a2));
  else return (x_openssl_private_decrypt(a0, ref(a1), a2, a3));
}
Variant ei_dom_document_save(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_document_save", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_document_save(a0, a1));
  else return (x_dom_document_save(a0, a1, a2));
}
Variant ei_hphp_get_extension_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_extension_info", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_extension_info(a0));
}
Variant ei_output_add_rewrite_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("output_add_rewrite_var", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_output_add_rewrite_var(a0, a1));
}
Variant ei_xmlwriter_write_cdata(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_cdata", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_cdata(a0, a1));
}
Variant ei_mb_list_mime_names(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_list_mime_names", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_list_mime_names());
  else return (x_mb_list_mime_names(a0));
}
Variant ei_ispixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixelwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ispixelwand(a0));
}
Variant ei_xmlwriter_end_dtd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd(a0));
}
Variant ei_curl_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_close(a0));
}
Variant ei_array_udiff(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_udiff(count, a0, a1, a2));
  return (x_array_udiff(count, a0, a1, a2,vargs));
}
Variant ei_session_cache_limiter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_limiter", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_cache_limiter());
  else return (x_session_cache_limiter(a0));
}
Variant ei_stream_context_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("stream_context_create", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_stream_context_create());
  else if (count == 1) return (x_stream_context_create(a0));
  else return (x_stream_context_create(a0, a1));
}
Variant ei_drawgetstrokedashoffset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedashoffset", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokedashoffset(a0));
}
Variant ei_openssl_pkey_get_public(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_public", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkey_get_public(a0));
}
Variant ei_interface_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("interface_exists", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_interface_exists(a0));
  else return (x_interface_exists(a0, a1));
}
Variant ei_hphp_directoryiterator___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_directoryiterator___construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator___construct(a0, a1));
}
Variant ei_drawpathmovetorelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetorelative", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathmovetorelative(a0, a1, a2), null);
}
Variant ei_apache_get_config(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_config", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_config());
}
Variant ei_curl_copy_handle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("curl_copy_handle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_copy_handle(a0));
}
Variant ei_drawgetvectorgraphics(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetvectorgraphics", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetvectorgraphics(a0));
}
Variant ei_drawpathfinish(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathfinish", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathfinish(a0), null);
}
Variant ei_png2wbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("png2wbmp", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_png2wbmp(a0, a1, a2, a3, a4));
}
Variant ei_drawmatte(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawmatte", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawmatte(a0, a1, a2, a3), null);
}
Variant ei_imagecolormatch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecolormatch", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolormatch(a0, a1));
}
Variant ei_drawrectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawrectangle", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawrectangle(a0, a1, a2, a3, a4), null);
}
Variant ei_fb_parallel_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("fb_parallel_query", count, 1, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fb_parallel_query(a0));
  else if (count == 2) return (x_fb_parallel_query(a0, a1));
  else if (count == 3) return (x_fb_parallel_query(a0, a1, a2));
  else if (count == 4) return (x_fb_parallel_query(a0, a1, a2, a3));
  else if (count == 5) return (x_fb_parallel_query(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_fb_parallel_query(a0, a1, a2, a3, a4, a5));
  else return (x_fb_parallel_query(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_dom_document_create_entity_reference(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_entity_reference", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_entity_reference(a0, a1));
}
Variant ei_mcrypt_enc_get_block_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_block_size", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_block_size(a0));
}
Variant ei_stream_context_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_context_set_option", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_context_set_option(a0, a1));
  else if (count == 3) return (x_stream_context_set_option(a0, a1, a2));
  else return (x_stream_context_set_option(a0, a1, a2, a3));
}
Variant ei_drawpathcurvetorelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetorelative", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetorelative(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_phpcredits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("phpcredits", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_phpcredits());
  else return (x_phpcredits(a0));
}
Variant ei_drawgetfillrule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillrule", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillrule(a0));
}
Variant ei_parse_hdf_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("parse_hdf_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_parse_hdf_string(a0));
}
Variant ei_xmlwriter_end_cdata(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_cdata", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_cdata(a0));
}
Variant ei_magickgetversionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetversionstring", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetversionstring());
}
Variant ei_pcntl_fork(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pcntl_fork", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_fork());
}
Variant ei_dom_node_normalize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_normalize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_normalize(a0));
}
Variant ei_doubleval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("doubleval", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_doubleval(a0));
}
Variant ei_assert_options(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("assert_options", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_assert_options(a0));
  else return (x_assert_options(a0, a1));
}
Variant ei_magickhasnextimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhasnextimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickhasnextimage(a0));
}
Variant ei_rmdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rmdir", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_rmdir(a0));
  else return (x_rmdir(a0, a1));
}
Variant ei_drawgetstrokelinecap(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokelinecap", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokelinecap(a0));
}
Variant ei_hphp_clear_unflushed(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_clear_unflushed", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_clear_unflushed(), null);
}
Variant ei_magickscaleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickscaleimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickscaleimage(a0, a1, a2));
}
Variant ei_pixelgetblackquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetblackquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetblackquantum(a0));
}
Variant ei_magicknewimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magicknewimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magicknewimage(a0, a1, a2));
  else return (x_magicknewimage(a0, a1, a2, a3));
}
Variant ei_destroypixelwands(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwands", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixelwands(a0), null);
}
Variant ei_shm_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shm_remove", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_remove(a0));
}
Variant ei_hphp_splfileobject_setflags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setflags", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_setflags(a0, a1), null);
}
Variant ei_date_sun_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("date_sun_info", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_sun_info(a0, a1, a2));
}
Variant ei_hphp_directoryiterator_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_valid(a0));
}
Variant ei_magickresizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickresizeimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickresizeimage(a0, a1, a2, a3, a4));
}
Variant ei_parse_ini_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_file", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_ini_file(a0));
  else if (count == 2) return (x_parse_ini_file(a0, a1));
  else return (x_parse_ini_file(a0, a1, a2));
}
Variant ei_stream_get_meta_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_get_meta_data", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_meta_data(a0));
}
Variant ei_imagepsencodefont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsencodefont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsencodefont(a0, a1));
}
Variant ei_ldap_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_set_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_set_option(a0, a1, a2));
}
Variant ei_magickgetsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetsize(a0));
}
Variant ei_memory_get_peak_usage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_peak_usage", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_memory_get_peak_usage());
  else return (x_memory_get_peak_usage(a0));
}
Variant ei_pcntl_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("pcntl_exec", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_pcntl_exec(a0), null);
  else if (count == 2) return (x_pcntl_exec(a0, a1), null);
  else return (x_pcntl_exec(a0, a1, a2), null);
}
Variant ei_xmlwriter_set_indent_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent_string", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_set_indent_string(a0, a1));
}
Variant ei_php_strip_whitespace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("php_strip_whitespace", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_strip_whitespace(a0));
}
Variant ei_strcoll(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcoll", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strcoll(a0, a1));
}
Variant ei_write_hdf_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("write_hdf_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_write_hdf_file(a0, a1));
}
Variant ei_socket_send(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_send", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_send(a0, a1, a2, a3));
}
Variant ei_zlib_get_coding_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zlib_get_coding_type", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zlib_get_coding_type());
}
Variant ei_hphp_splfileobject_fscanf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_splfileobject_fscanf", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fscanf(a0, a1, a2, a3));
}
Variant ei_mb_ereg_search_getregs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_ereg_search_getregs", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_ereg_search_getregs());
}
Variant ei_mb_eregi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_eregi", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_eregi(a0, a1));
  else return (x_mb_eregi(a0, a1, ref(a2)));
}
Variant ei_pixelgetgreen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetgreen", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetgreen(a0));
}
Variant ei_mysql_client_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_client_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_client_encoding());
  else return (x_mysql_client_encoding(a0));
}
Variant ei_zend_thread_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("zend_thread_id", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_zend_thread_id());
}
Variant ei_ldap_mod_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_mod_replace", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_mod_replace(a0, a1, a2));
}
Variant ei_collator_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("collator_get_error_code", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_error_code(a0));
}
Variant ei_stream_filter_prepend(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_filter_prepend", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_filter_prepend(a0, a1));
  else if (count == 3) return (x_stream_filter_prepend(a0, a1, a2));
  else return (x_stream_filter_prepend(a0, a1, a2, a3));
}
Variant ei_substr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("substr", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_substr(a0, a1));
  else return (x_substr(a0, a1, a2));
}
Variant ei_magickcombineimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickcombineimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcombineimages(a0, a1));
}
Variant ei_pixelgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetexceptiontype(a0));
}
Variant ei_unpack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("unpack", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_unpack(a0, a1));
}
Variant ei_hphp_splfileinfo_isdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isdir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isdir(a0));
}
Variant ei_magickgetimagepixels(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("magickgetimagepixels", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagepixels(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_array_product(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_product", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_product(a0));
}
Variant ei_substr_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("substr_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_substr_replace(a0, a1, a2));
  else return (x_substr_replace(a0, a1, a2, a3));
}
Variant ei_xbox_get_thread_time(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_get_thread_time", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_get_thread_time());
}
Variant ei_xmlwriter_write_dtd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("xmlwriter_write_dtd", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_xmlwriter_write_dtd(a0, a1));
  else if (count == 3) return (x_xmlwriter_write_dtd(a0, a1, a2));
  else if (count == 4) return (x_xmlwriter_write_dtd(a0, a1, a2, a3));
  else return (x_xmlwriter_write_dtd(a0, a1, a2, a3, a4));
}
Variant ei_mysql_select_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_select_db", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_select_db(a0));
  else return (x_mysql_select_db(a0, a1));
}
Variant ei_fb_get_taint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_get_taint", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_get_taint(a0));
}
Variant ei_use_soap_error_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("use_soap_error_handler", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_use_soap_error_handler());
  else return (x_use_soap_error_handler(a0));
}
Variant ei_debug_backtrace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("debug_backtrace", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_debug_backtrace());
  else return (x_debug_backtrace(a0));
}
Variant ei_drawpathcurvetosmoothrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothrelative", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetosmoothrelative(a0, a1, a2, a3, a4), null);
}
Variant ei_mailparse_determine_best_xfer_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_determine_best_xfer_encoding", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_determine_best_xfer_encoding(a0));
}
Variant ei_imagettfbbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagettfbbox", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagettfbbox(a0, a1, a2, a3));
}
Variant ei_mb_internal_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_internal_encoding", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_internal_encoding());
  else return (x_mb_internal_encoding(a0));
}
Variant ei_msg_get_queue(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("msg_get_queue", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_msg_get_queue(a0));
  else return (x_msg_get_queue(a0, a1));
}
Variant ei_posix_getegid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getegid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getegid());
}
Variant ei_magickmedianfilterimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickmedianfilterimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmedianfilterimage(a0, a1));
}
Variant ei_xbox_task_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xbox_task_result", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_task_result(a0, a1, ref(a2)));
}
Variant ei_mcrypt_generic_deinit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_generic_deinit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic_deinit(a0));
}
Variant ei_method_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("method_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_method_exists(a0, a1));
}
Variant ei_money_format(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("money_format", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_money_format(a0, a1));
}
Variant ei_clearmagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearmagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearmagickwand(a0), null);
}
Variant ei_dom_element_remove_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_remove_attribute_node(a0, a1));
}
Variant ei_array_udiff_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_udiff_assoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_udiff_assoc(count, a0, a1, a2));
  return (x_array_udiff_assoc(count, a0, a1, a2,vargs));
}
Variant ei_xml_parser_free(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_parser_free", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_parser_free(a0));
}
Variant ei_is_resource(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_resource", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_resource(a0));
}
Variant ei_hphp_splfileinfo_getsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getsize(a0));
}
Variant ei_posix_seteuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_seteuid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_seteuid(a0));
}
Variant ei_magicksetinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetinterlacescheme", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetinterlacescheme(a0, a1));
}
Variant ei_str_shuffle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_shuffle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_str_shuffle(a0));
}
Variant ei_mcrypt_enc_is_block_algorithm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_algorithm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_is_block_algorithm(a0));
}
Variant ei_call_user_func_array_rpc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("call_user_func_array_rpc", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_func_array_rpc(a0, a1, a2, a3, a4, a5));
}
Variant ei_fb_serialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_serialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_serialize(a0));
}
Variant ei_magickgetcopyright(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetcopyright", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetcopyright());
}
Variant ei_magickstripimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickstripimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickstripimage(a0));
}
Variant ei_base64_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("base64_decode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_base64_decode(a0));
  else return (x_base64_decode(a0, a1));
}
Variant ei_rand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("rand", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_rand());
  else if (count == 1) return (x_rand(a0));
  else return (x_rand(a0, a1));
}
Variant ei_crc32(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("crc32", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_crc32(a0));
}
Variant ei_stream_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_encoding", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_encoding(a0));
  else return (x_stream_encoding(a0, a1));
}
Variant ei_drawgetstrokedasharray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokedasharray", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokedasharray(a0));
}
Variant ei_magickgetimagedispose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagedispose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagedispose(a0));
}
Variant ei_drawpopdefs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpopdefs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpopdefs(a0), null);
}
Variant ei_xml_parser_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("xml_parser_create", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_xml_parser_create());
  else return (x_xml_parser_create(a0));
}
Variant ei_session_save_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_save_path", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_save_path());
  else return (x_session_save_path(a0));
}
Variant ei_pcntl_wifsignaled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wifsignaled", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wifsignaled(a0));
}
Variant ei_openssl_pkcs7_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4 || count > 6) return throw_wrong_arguments("openssl_pkcs7_encrypt", count, 4, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 4) return (x_openssl_pkcs7_encrypt(a0, a1, a2, a3));
  else if (count == 5) return (x_openssl_pkcs7_encrypt(a0, a1, a2, a3, a4));
  else return (x_openssl_pkcs7_encrypt(a0, a1, a2, a3, a4, a5));
}
Variant ei_read_exif_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("read_exif_data", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_read_exif_data(a0));
  else if (count == 2) return (x_read_exif_data(a0, a1));
  else if (count == 3) return (x_read_exif_data(a0, a1, a2));
  else return (x_read_exif_data(a0, a1, a2, a3));
}
Variant ei_drawsetstrokeopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokeopacity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokeopacity(a0, a1), null);
}
Variant ei_drawroundrectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawroundrectangle", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawroundrectangle(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_hphp_directoryiterator_isdot(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_isdot", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_isdot(a0));
}
Variant ei_drawgetstrokewidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokewidth", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokewidth(a0));
}
Variant ei_date_create(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("date_create", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_date_create());
  else if (count == 1) return (x_date_create(a0));
  else return (x_date_create(a0, a1));
}
Variant ei_strcspn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("strcspn", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strcspn(a0, a1));
  else if (count == 3) return (x_strcspn(a0, a1, a2));
  else return (x_strcspn(a0, a1, a2, a3));
}
Variant ei_drawgetclipunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetclipunits", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetclipunits(a0));
}
Variant ei_sem_acquire(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_acquire", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sem_acquire(a0));
}
Variant ei_socket_strerror(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_strerror", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_strerror(a0));
}
Variant ei_magickgetstringheight(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetstringheight", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetstringheight(a0, a1, a2));
  else return (x_magickgetstringheight(a0, a1, a2, a3));
}
Variant ei_dom_document_relaxng_validate_xml(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_xml", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_relaxng_validate_xml(a0, a1));
}
Variant ei_rawurlencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurlencode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rawurlencode(a0));
}
Variant ei_strtotime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strtotime", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strtotime(a0));
  else return (x_strtotime(a0, a1));
}
Variant ei_dom_element_set_id_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_set_id_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_id_attribute(a0, a1, a2));
}
Variant ei_hphp_recursivedirectoryiterator_getsubpath(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_getsubpath", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_getsubpath(a0));
}
Variant ei_apc_clear_cache(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("apc_clear_cache", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_clear_cache());
  else return (x_apc_clear_cache(a0));
}
Variant ei_dirname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dirname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dirname(a0));
}
Variant ei_strnatcasecmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcasecmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strnatcasecmp(a0, a1));
}
Variant ei_magicksetsamplingfactors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetsamplingfactors", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetsamplingfactors(a0, a1, a2));
}
Variant ei_openssl_pkey_get_private(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_pkey_get_private", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_pkey_get_private(a0));
  else return (x_openssl_pkey_get_private(a0, a1));
}
Variant ei_magickaverageimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickaverageimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickaverageimages(a0));
}
Variant ei_iconv_strrpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iconv_strrpos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_strrpos(a0, a1));
  else return (x_iconv_strrpos(a0, a1, a2));
}
Variant ei_collator_get_locale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("collator_get_locale", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_collator_get_locale(a0));
  else return (x_collator_get_locale(a0, a1));
}
Variant ei_drawsetviewbox(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawsetviewbox", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetviewbox(a0, a1, a2, a3, a4), null);
}
Variant ei_magicksetimagecompressionquality(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompressionquality", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecompressionquality(a0, a1));
}
Variant ei_mysql_ping(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_ping", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_ping());
  else return (x_mysql_ping(a0));
}
Variant ei_xml_get_current_byte_index(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_current_byte_index", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_current_byte_index(a0));
}
Variant ei_magicktransformimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktransformimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktransformimage(a0, a1, a2));
}
Variant ei_drawgetstrokeantialias(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokeantialias", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokeantialias(a0));
}
Variant ei_ini_alter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_alter", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_alter(a0, a1));
}
Variant ei_get_class(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_class", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_class());
  else return (x_get_class(a0));
}
Variant ei_magicksetimageprofile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimageprofile", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageprofile(a0, a1, a2));
}
Variant ei_mysql_field_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_seek", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_seek(a0));
  else return (x_mysql_field_seek(a0, a1));
}
Variant ei_drawgetfontsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontsize(a0));
}
Variant ei_mysql_num_rows(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_num_rows", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_num_rows(a0));
}
Variant ei_hphp_recursiveiteratoriterator_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_rewind(a0), null);
}
Variant ei_magickgetimageresolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageresolution", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageresolution(a0));
}
Variant ei_array_diff(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_diff", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_diff(count, a0, a1));
  return (x_array_diff(count, a0, a1,vargs));
}
Variant ei_xmlwriter_open_uri(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_open_uri", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_open_uri(a0));
}
Variant ei_magickgetimagetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagetype(a0));
}
Variant ei_simplexml_load_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_string", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_simplexml_load_string(a0));
  else if (count == 2) return (x_simplexml_load_string(a0, a1));
  else if (count == 3) return (x_simplexml_load_string(a0, a1, a2));
  else if (count == 4) return (x_simplexml_load_string(a0, a1, a2, a3));
  else return (x_simplexml_load_string(a0, a1, a2, a3, a4));
}
Variant ei_magickunsharpmaskimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("magickunsharpmaskimage", count, 5, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_magickunsharpmaskimage(a0, a1, a2, a3, a4));
  else return (x_magickunsharpmaskimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_quoted_printable_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_encode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_quoted_printable_encode(a0));
}
Variant ei_gettype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gettype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gettype(a0));
}
Variant ei_magickgetimagebackgroundcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebackgroundcolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagebackgroundcolor(a0));
}
Variant ei_hphp_splfileobject_setmaxlinelen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_setmaxlinelen", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_setmaxlinelen(a0, a1), null);
}
Variant ei_array_intersect_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_intersect_key", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_intersect_key(count, a0, a1));
  return (x_array_intersect_key(count, a0, a1,vargs));
}
Variant ei_array_change_key_case(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_change_key_case", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_change_key_case(a0));
  else return (x_array_change_key_case(a0, a1));
}
Variant ei_ldap_first_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_first_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_first_attribute(a0, a1));
}
Variant ei_gettimeofday(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("gettimeofday", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_gettimeofday());
  else return (x_gettimeofday(a0));
}
Variant ei_xmlwriter_end_element(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_element", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_element(a0));
}
Variant ei_drawpoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpoint", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpoint(a0, a1, a2), null);
}
Variant ei_strnatcmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strnatcmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strnatcmp(a0, a1));
}
Variant ei_property_exists(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("property_exists", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_property_exists(a0, a1));
}
Variant ei_mysql_affected_rows(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_affected_rows", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_affected_rows());
  else return (x_mysql_affected_rows(a0));
}
Variant ei_magickdespeckleimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdespeckleimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdespeckleimage(a0));
}
Variant ei_imagecopymergegray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymergegray", count, 9, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopymergegray(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_ctype_cntrl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_cntrl", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_cntrl(a0));
}
Variant ei_hphp_splfileobject_next(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_next", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_next(a0), null);
}
Variant ei_is_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_array", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_array(a0));
}
Variant ei_rename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("rename", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_rename(a0, a1));
  else return (x_rename(a0, a1, a2));
}
Variant ei_date_format(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("date_format", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_format(a0, a1));
}
Variant ei_hphp_splfileobject_fgetc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgetc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgetc(a0));
}
Variant ei_magickshaveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickshaveimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickshaveimage(a0, a1, a2));
}
Variant ei_dom_element_set_attribute_node_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node_ns", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute_node_ns(a0, a1));
}
Variant ei_xmlwriter_output_memory(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xmlwriter_output_memory", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xmlwriter_output_memory(a0));
  else return (x_xmlwriter_output_memory(a0, a1));
}
Variant ei_ob_end_flush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_flush", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_end_flush());
}
Variant ei_magickwhitethresholdimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwhitethresholdimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwhitethresholdimage(a0, a1));
}
Variant ei_drawpolyline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolyline", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpolyline(a0, a1), null);
}
Variant ei_hphp_splfileobject_fgets(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_fgets", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_fgets(a0));
}
Variant ei_hphp_get_function_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_function_info", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_function_info(a0));
}
Variant ei_prev(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("prev", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_prev(ref(a0)));
}
Variant ei_imagegammacorrect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("imagegammacorrect", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagegammacorrect(a0, a1, a2));
}
Variant ei_str_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("str_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_str_replace(a0, a1, a2));
  else return (x_str_replace(a0, a1, a2, ref(a3)));
}
Variant ei_dom_node_lookup_namespace_uri(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_lookup_namespace_uri", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_lookup_namespace_uri(a0, a1));
}
Variant ei_fb_unserialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_unserialize", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fb_unserialize(a0, ref(a1)));
  else return (x_fb_unserialize(a0, ref(a1), ref(a2)));
}
Variant ei_clock_getres(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("clock_getres", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clock_getres(a0, ref(a1), ref(a2)));
}
Variant ei_magicktrimimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktrimimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktrimimage(a0, a1));
}
Variant ei_hphp_splfileinfo_getpathinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getpathinfo", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getpathinfo(a0, a1));
}
Variant ei_magickgetimagegamma(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegamma", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagegamma(a0));
}
Variant ei_newdrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("newdrawingwand", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newdrawingwand());
}
Variant ei_gzrewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzrewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzrewind(a0));
}
Variant ei_ldap_explode_dn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_explode_dn", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_explode_dn(a0, a1));
}
Variant ei_posix_times(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_times", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_times());
}
Variant ei_drawgetfillcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfillcolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfillcolor(a0));
}
Variant ei_dom_document_save_html(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_document_save_html", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_save_html(a0));
}
Variant ei_mb_strtolower(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mb_strtolower", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_strtolower(a0));
  else return (x_mb_strtolower(a0, a1));
}
Variant ei_localtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("localtime", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_localtime());
  else if (count == 1) return (x_localtime(a0));
  else return (x_localtime(a0, a1));
}
Variant ei_fb_thrift_unserialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("fb_thrift_unserialize", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fb_thrift_unserialize(a0, ref(a1)));
  else return (x_fb_thrift_unserialize(a0, ref(a1), ref(a2)));
}
Variant ei_sha1(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("sha1", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sha1(a0));
  else return (x_sha1(a0, a1));
}
Variant ei_collator_set_strength(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_set_strength", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_set_strength(a0, a1));
}
Variant ei_implode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("implode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_implode(a0));
  else return (x_implode(a0, a1));
}
Variant ei_date_isodate_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_isodate_set", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_date_isodate_set(a0, a1, a2), null);
  else return (x_date_isodate_set(a0, a1, a2, a3), null);
}
Variant ei_magickpaintopaqueimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickpaintopaqueimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickpaintopaqueimage(a0, a1, a2));
  else return (x_magickpaintopaqueimage(a0, a1, a2, a3));
}
Variant ei_mb_strimwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_strimwidth", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_strimwidth(a0, a1, a2));
  else if (count == 4) return (x_mb_strimwidth(a0, a1, a2, a3));
  else return (x_mb_strimwidth(a0, a1, a2, a3, a4));
}
Variant ei_drawsetfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfont(a0, a1));
}
Variant ei_xml_set_default_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_default_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_default_handler(a0, a1));
}
Variant ei_magickchopimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("magickchopimage", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickchopimage(a0, a1, a2, a3, a4));
}
Variant ei_wordwrap(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("wordwrap", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_wordwrap(a0));
  else if (count == 2) return (x_wordwrap(a0, a1));
  else if (count == 3) return (x_wordwrap(a0, a1, a2));
  else return (x_wordwrap(a0, a1, a2, a3));
}
Variant ei_gzgetss(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("gzgetss", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzgetss(a0));
  else if (count == 2) return (x_gzgetss(a0, a1));
  else return (x_gzgetss(a0, a1, a2));
}
Variant ei_magickgetimagevirtualpixelmethod(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagevirtualpixelmethod", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagevirtualpixelmethod(a0));
}
Variant ei_imagedestroy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagedestroy", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagedestroy(a0));
}
Variant ei_timezone_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("timezone_open", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_open(a0));
}
Variant ei_ob_clean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_clean", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_clean(), null);
}
Variant ei_mb_ereg_search_pos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_ereg_search_pos", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_ereg_search_pos());
  else if (count == 1) return (x_mb_ereg_search_pos(a0));
  else return (x_mb_ereg_search_pos(a0, a1));
}
Variant ei_bccomp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bccomp", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bccomp(a0, a1));
  else return (x_bccomp(a0, a1, a2));
}
Variant ei_gzdecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzdecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzdecode(a0));
}
Variant ei_magicksetimagecompose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecompose", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecompose(a0, a1));
}
Variant ei_apc_bin_dump(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_bin_dump", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_bin_dump());
  else if (count == 1) return (x_apc_bin_dump(a0));
  else return (x_apc_bin_dump(a0, a1));
}
Variant ei_ini_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ini_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_get(a0));
}
Variant ei_mb_ereg_search_setpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mb_ereg_search_setpos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_ereg_search_setpos(a0));
}
Variant ei_stream_copy_to_stream(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_copy_to_stream", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_copy_to_stream(a0, a1));
  else if (count == 3) return (x_stream_copy_to_stream(a0, a1, a2));
  else return (x_stream_copy_to_stream(a0, a1, a2, a3));
}
Variant ei_xml_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xml_get_error_code", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_get_error_code(a0));
}
Variant ei_pcntl_alarm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_alarm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_alarm(a0));
}
Variant ei_drawpolygon(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpolygon", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpolygon(a0, a1), null);
}
Variant ei_mysql_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 7) return throw_toomany_arguments("mysql_connect", 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_connect());
  else if (count == 1) return (x_mysql_connect(a0));
  else if (count == 2) return (x_mysql_connect(a0, a1));
  else if (count == 3) return (x_mysql_connect(a0, a1, a2));
  else if (count == 4) return (x_mysql_connect(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_connect(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_mysql_connect(a0, a1, a2, a3, a4, a5));
  else return (x_mysql_connect(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_xmlwriter_write_raw(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_raw", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_raw(a0, a1));
}
Variant ei_fgetss(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("fgetss", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fgetss(a0));
  else if (count == 2) return (x_fgetss(a0, a1));
  else return (x_fgetss(a0, a1, a2));
}
Variant ei_drawarc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawarc", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawarc(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_set_error_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("set_error_handler", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_set_error_handler(a0));
  else return (x_set_error_handler(a0, a1));
}
Variant ei_str_word_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("str_word_count", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_str_word_count(a0));
  else if (count == 2) return (x_str_word_count(a0, a1));
  else return (x_str_word_count(a0, a1, a2));
}
Variant ei_drawsetcliprule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetcliprule", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetcliprule(a0, a1), null);
}
Variant ei_openssl_pkcs12_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("openssl_pkcs12_read", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkcs12_read(a0, ref(a1), a2));
}
Variant ei_ldap_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_list", count, 3, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_list(a0, a1, a2));
  else if (count == 4) return (x_ldap_list(a0, a1, a2, a3));
  else if (count == 5) return (x_ldap_list(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_ldap_list(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_ldap_list(a0, a1, a2, a3, a4, a5, a6));
  else return (x_ldap_list(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_func_num_args(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("func_num_args", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_func_num_args());
}
Variant ei_drawsettextdecoration(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsettextdecoration", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsettextdecoration(a0, a1), null);
}
Variant ei_str_rot13(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("str_rot13", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_str_rot13(a0));
}
Variant ei_openssl_pkey_new(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("openssl_pkey_new", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_openssl_pkey_new());
  else return (x_openssl_pkey_new(a0));
}
Variant ei_magicksetimageindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageindex", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageindex(a0, a1));
}
Variant ei_ldap_rename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("ldap_rename", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_rename(a0, a1, a2, a3, a4));
}
Variant ei_ldap_start_tls(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_start_tls", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_start_tls(a0));
}
Variant ei_tanh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("tanh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tanh(a0));
}
Variant ei_drawscale(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawscale", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawscale(a0, a1, a2), null);
}
Variant ei_drawrotate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawrotate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawrotate(a0, a1), null);
}
Variant ei_getservbyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyname", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getservbyname(a0, a1));
}
Variant ei_compact(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("compact", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_compact(count, a0));
  return (x_compact(count, a0,vargs));
}
Variant ei_hphp_splfileobject_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_valid(a0));
}
Variant ei_imagecolorclosest(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorclosest", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorclosest(a0, a1, a2, a3));
}
Variant ei_magickwriteimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magickwriteimages", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magickwriteimages(a0));
  else if (count == 2) return (x_magickwriteimages(a0, a1));
  else return (x_magickwriteimages(a0, a1, a2));
}
Variant ei_pixelsetalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetalpha", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetalpha(a0, a1), null);
}
Variant ei_magicksetimageiterations(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageiterations", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageiterations(a0, a1));
}
Variant ei_drawpathmovetoabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathmovetoabsolute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathmovetoabsolute(a0, a1, a2), null);
}
Variant ei_quotemeta(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quotemeta", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_quotemeta(a0));
}
Variant ei_parse_ini_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("parse_ini_string", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_parse_ini_string(a0));
  else if (count == 2) return (x_parse_ini_string(a0, a1));
  else return (x_parse_ini_string(a0, a1, a2));
}
Variant ei_imagefilltoborder(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagefilltoborder", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilltoborder(a0, a1, a2, a3, a4));
}
Variant ei_xml_set_notation_decl_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_notation_decl_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_notation_decl_handler(a0, a1));
}
Variant ei_is_writeable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_writeable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_writeable(a0));
}
Variant ei_magickgetwandsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetwandsize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetwandsize(a0));
}
Variant ei_hphp_directoryiterator___tostring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator___tostring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator___tostring(a0));
}
Variant ei_memcache_add_server(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 10) return throw_wrong_arguments("memcache_add_server", count, 2, 10, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_add_server(a0, a1));
  else if (count == 3) return (x_memcache_add_server(a0, a1, a2));
  else if (count == 4) return (x_memcache_add_server(a0, a1, a2, a3));
  else if (count == 5) return (x_memcache_add_server(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6));
  else if (count == 8) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6, a7));
  else if (count == 9) return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6, a7, a8));
  else return (x_memcache_add_server(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
Variant ei_dom_node_remove_child(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_node_remove_child", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_remove_child(a0, a1));
}
Variant ei_imageinterlace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imageinterlace", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imageinterlace(a0));
  else return (x_imageinterlace(a0, a1));
}
Variant ei_preg_match_all(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("preg_match_all", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_preg_match_all(a0, a1, ref(a2)));
  else if (count == 4) return (x_preg_match_all(a0, a1, ref(a2), a3));
  else return (x_preg_match_all(a0, a1, ref(a2), a3, a4));
}
Variant ei_proc_terminate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("proc_terminate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_proc_terminate(a0));
  else return (x_proc_terminate(a0, a1));
}
Variant ei_apc_bin_loadfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_bin_loadfile", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_bin_loadfile(a0));
  else if (count == 2) return (x_apc_bin_loadfile(a0, a1));
  else if (count == 3) return (x_apc_bin_loadfile(a0, a1, a2));
  else return (x_apc_bin_loadfile(a0, a1, a2, a3));
}
Variant ei_posix_getcwd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getcwd", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getcwd());
}
Variant ei_drawpathcurvetoabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 7) return throw_wrong_arguments("drawpathcurvetoabsolute", count, 7, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoabsolute(a0, a1, a2, a3, a4, a5, a6), null);
}
Variant ei_hphp_set_error_page(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_set_error_page", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_set_error_page(a0), null);
}
Variant ei_preg_match(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) return throw_wrong_arguments("preg_match", count, 2, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_preg_match(a0, a1));
  else if (count == 3) return (x_preg_match(a0, a1, ref(a2)));
  else if (count == 4) return (x_preg_match(a0, a1, ref(a2), a3));
  else return (x_preg_match(a0, a1, ref(a2), a3, a4));
}
Variant ei_timezone_abbreviations_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("timezone_abbreviations_list", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_timezone_abbreviations_list());
}
Variant ei_magickradialblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickradialblurimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickradialblurimage(a0, a1));
}
Variant ei_posix_geteuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_geteuid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_geteuid());
}
Variant ei_mysql_fetch_lengths(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_lengths", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_fetch_lengths(a0));
}
Variant ei_magickwriteimagefile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickwriteimagefile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwriteimagefile(a0, a1));
}
Variant ei_serialize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("serialize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_serialize(a0));
}
Variant ei_exif_read_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("exif_read_data", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_exif_read_data(a0));
  else if (count == 2) return (x_exif_read_data(a0, a1));
  else if (count == 3) return (x_exif_read_data(a0, a1, a2));
  else return (x_exif_read_data(a0, a1, a2, a3));
}
Variant ei_pixelgetiteratorexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetiteratorexceptiontype(a0));
}
Variant ei_destroydrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroydrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroydrawingwand(a0), null);
}
Variant ei_lstat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("lstat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lstat(a0));
}
Variant ei_apache_note(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("apache_note", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apache_note(a0));
  else return (x_apache_note(a0, a1));
}
Variant ei_drawgetexceptiontype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetexceptiontype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetexceptiontype(a0));
}
Variant ei_drawbezier(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawbezier", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawbezier(a0, a1), null);
}
Variant ei_xmlwriter_start_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_comment", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_comment(a0));
}
Variant ei_ldap_set_rebind_proc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_set_rebind_proc", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_set_rebind_proc(a0, a1));
}
Variant ei_drawsetstrokecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokecolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokecolor(a0, a1), null);
}
Variant ei_drawpathlinetohorizontalrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalrelative", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetohorizontalrelative(a0, a1), null);
}
Variant ei_gmmktime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("gmmktime", 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_gmmktime());
  else if (count == 1) return (x_gmmktime(a0));
  else if (count == 2) return (x_gmmktime(a0, a1));
  else if (count == 3) return (x_gmmktime(a0, a1, a2));
  else if (count == 4) return (x_gmmktime(a0, a1, a2, a3));
  else if (count == 5) return (x_gmmktime(a0, a1, a2, a3, a4));
  else return (x_gmmktime(a0, a1, a2, a3, a4, a5));
}
Variant ei_gmdate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gmdate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gmdate(a0));
  else return (x_gmdate(a0, a1));
}
Variant ei_posix_getgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getgid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgid());
}
Variant ei_sinh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sinh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sinh(a0));
}
Variant ei_apc_fetch(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_fetch", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_fetch(a0));
  else if (count == 2) return (x_apc_fetch(a0, ref(a1)));
  else return (x_apc_fetch(a0, ref(a1), a2));
}
Variant ei_fileowner(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileowner", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileowner(a0));
}
Variant ei_imagecopymerge(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagecopymerge", count, 9, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopymerge(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_magickclipimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickclipimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickclipimage(a0));
}
Variant ei_intl_get_error_code(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("intl_get_error_code", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_intl_get_error_code());
}
Variant ei_imagestringup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagestringup", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagestringup(a0, a1, a2, a3, a4, a5));
}
Variant ei_mt_getrandmax(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mt_getrandmax", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mt_getrandmax());
}
Variant ei_magickgetresourcelimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetresourcelimit", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetresourcelimit(a0));
}
Variant ei_hphp_splfileinfo_getlinktarget(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getlinktarget", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getlinktarget(a0));
}
Variant ei_imagecolorexact(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorexact", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorexact(a0, a1, a2, a3));
}
Variant ei_hphp_recursivedirectoryiterator_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_current(a0));
}
Variant ei_setcookie(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 7) return throw_wrong_arguments("setcookie", count, 1, 7, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_setcookie(a0));
  else if (count == 2) return (x_setcookie(a0, a1));
  else if (count == 3) return (x_setcookie(a0, a1, a2));
  else if (count == 4) return (x_setcookie(a0, a1, a2, a3));
  else if (count == 5) return (x_setcookie(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_setcookie(a0, a1, a2, a3, a4, a5));
  else return (x_setcookie(a0, a1, a2, a3, a4, a5, a6));
}
Variant ei_fileatime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fileatime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fileatime(a0));
}
Variant ei_apd_stop_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_stop_trace", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_stop_trace(), null);
}
Variant ei_hphpd_break(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("hphpd_break", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_hphpd_break(), null);
  else return (x_hphpd_break(a0), null);
}
Variant ei_addcslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("addcslashes", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_addcslashes(a0, a1));
}
Variant ei_magicksetimageoption(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magicksetimageoption", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageoption(a0, a1, a2, a3));
}
Variant ei_xmlwriter_write_comment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_write_comment", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_comment(a0, a1));
}
Variant ei_drawgetfontstyle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfontstyle", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfontstyle(a0));
}
Variant ei_dom_element_set_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("dom_element_set_attribute_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute_ns(a0, a1, a2, a3));
}
Variant ei_dom_xpath_evaluate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dom_xpath_evaluate", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dom_xpath_evaluate(a0, a1));
  else return (x_dom_xpath_evaluate(a0, a1, a2));
}
Variant ei_strtoupper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtoupper", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strtoupper(a0));
}
Variant ei_xml_set_processing_instruction_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_processing_instruction_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_processing_instruction_handler(a0, a1));
}
Variant ei_apd_breakpoint(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apd_breakpoint", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apd_breakpoint());
}
Variant ei_memcache_delete(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_delete", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_delete(a0, a1));
  else return (x_memcache_delete(a0, a1, a2));
}
Variant ei_magickgetimageblueprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblueprimary", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageblueprimary(a0));
}
Variant ei_magickspreadimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickspreadimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickspreadimage(a0, a1));
}
Variant ei_array_fill(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("array_fill", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_fill(a0, a1, a2));
}
Variant ei_dom_element_set_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_set_attribute_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_set_attribute_node(a0, a1));
}
Variant ei_memcache_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("memcache_replace", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_memcache_replace(a0, a1, a2));
  else if (count == 4) return (x_memcache_replace(a0, a1, a2, a3));
  else return (x_memcache_replace(a0, a1, a2, a3, a4));
}
Variant ei_stream_set_write_buffer(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_write_buffer", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_set_write_buffer(a0, a1));
}
Variant ei_mb_list_encodings(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("mb_list_encodings", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mb_list_encodings());
}
Variant ei_sleep(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sleep", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sleep(a0));
}
Variant ei_cleardrawingwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("cleardrawingwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_cleardrawingwand(a0), null);
}
Variant ei_imagecolorset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorset", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorset(a0, a1, a2, a3, a4));
}
Variant ei_openssl_x509_checkpurpose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_x509_checkpurpose", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_x509_checkpurpose(a0, a1));
  else if (count == 3) return (x_openssl_x509_checkpurpose(a0, a1, a2));
  else return (x_openssl_x509_checkpurpose(a0, a1, a2, a3));
}
Variant ei_drawpathcurvetosmoothabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawpathcurvetosmoothabsolute", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetosmoothabsolute(a0, a1, a2, a3, a4), null);
}
Variant ei_array_intersect_ukey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_intersect_ukey", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_intersect_ukey(count, a0, a1, a2));
  return (x_array_intersect_ukey(count, a0, a1, a2,vargs));
}
Variant ei_timezone_name_from_abbr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("timezone_name_from_abbr", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_timezone_name_from_abbr(a0));
  else if (count == 2) return (x_timezone_name_from_abbr(a0, a1));
  else return (x_timezone_name_from_abbr(a0, a1, a2));
}
Variant ei_imagefilledellipse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledellipse", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledellipse(a0, a1, a2, a3, a4, a5));
}
Variant ei_pcntl_wstopsig(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pcntl_wstopsig", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pcntl_wstopsig(a0));
}
Variant ei_get_defined_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_vars", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_defined_vars());
}
Variant ei_memory_get_usage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("memory_get_usage", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_memory_get_usage());
  else return (x_memory_get_usage(a0));
}
Variant ei_intval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("intval", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_intval(a0));
  else return (x_intval(a0, a1));
}
Variant ei_pagelet_server_task_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pagelet_server_task_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pagelet_server_task_status(a0));
}
Variant ei_dom_document_get_elements_by_tag_name_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_document_get_elements_by_tag_name_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_get_elements_by_tag_name_ns(a0, a1, a2));
}
Variant ei_iconv_set_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("iconv_set_encoding", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iconv_set_encoding(a0, a1));
}
Variant ei_magickmattefloodfillimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmattefloodfillimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmattefloodfillimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_mailparse_msg_get_part(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mailparse_msg_get_part", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_get_part(a0, a1));
}
Variant ei_mb_check_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mb_check_encoding", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_check_encoding());
  else if (count == 1) return (x_mb_check_encoding(a0));
  else return (x_mb_check_encoding(a0, a1));
}
Variant ei_ldap_get_dn(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ldap_get_dn", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_get_dn(a0, a1));
}
Variant ei_newpixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixeliterator(a0));
}
Variant ei_magicksetimagefilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("magicksetimagefilename", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magicksetimagefilename(a0));
  else return (x_magicksetimagefilename(a0, a1));
}
Variant ei_call_user_func(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("call_user_func", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 1) return (x_call_user_func(count, a0));
  return (x_call_user_func(count, a0,vargs));
}
Variant ei_mysql_list_tables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_list_tables", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_list_tables(a0));
  else return (x_mysql_list_tables(a0, a1));
}
Variant ei_magickgetinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetinterlacescheme", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetinterlacescheme(a0));
}
Variant ei_ltrim(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("ltrim", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_ltrim(a0));
  else return (x_ltrim(a0, a1));
}
Variant ei_magicktextureimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicktextureimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktextureimage(a0, a1));
}
Variant ei_mb_ereg_match(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_ereg_match", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_ereg_match(a0, a1));
  else return (x_mb_ereg_match(a0, a1, a2));
}
Variant ei_mt_srand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mt_srand", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mt_srand(), null);
  else return (x_mt_srand(a0), null);
}
Variant ei_imagecolorallocate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagecolorallocate", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorallocate(a0, a1, a2, a3));
}
Variant ei_define_syslog_variables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("define_syslog_variables", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_define_syslog_variables(), null);
}
Variant ei_fb_get_code_coverage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("fb_get_code_coverage", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_get_code_coverage());
}
Variant ei_mcrypt_enc_get_modes_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_modes_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_modes_name(a0));
}
Variant ei_array_flip(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("array_flip", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_array_flip(a0));
}
Variant ei_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("count", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_count(a0));
  else return (x_count(a0, a1));
}
Variant ei_lcg_value(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("lcg_value", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lcg_value());
}
Variant ei_php_logo_guid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_logo_guid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_logo_guid());
}
Variant ei_time(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("time", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_time());
}
Variant ei_magickcoalesceimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickcoalesceimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickcoalesceimages(a0));
}
Variant ei_pixelgetquantumcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetquantumcolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetquantumcolor(a0));
}
Variant ei_openssl_private_encrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_private_encrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_private_encrypt(a0, ref(a1), a2));
  else return (x_openssl_private_encrypt(a0, ref(a1), a2, a3));
}
Variant ei_xhprof_enable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("xhprof_enable", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xhprof_enable(a0), null);
  else return (x_xhprof_enable(a0, a1), null);
}
Variant ei_hphp_splfileinfo_gettype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_gettype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_gettype(a0));
}
Variant ei_xhprof_run_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xhprof_run_trace", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_run_trace(a0, a1));
}
Variant ei_xmlwriter_start_document(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("xmlwriter_start_document", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_xmlwriter_start_document(a0));
  else if (count == 2) return (x_xmlwriter_start_document(a0, a1));
  else if (count == 3) return (x_xmlwriter_start_document(a0, a1, a2));
  else return (x_xmlwriter_start_document(a0, a1, a2, a3));
}
Variant ei_libxml_clear_errors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_clear_errors", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_clear_errors(), null);
}
Variant ei_magicknormalizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknormalizeimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicknormalizeimage(a0));
}
Variant ei_magickgetformat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetformat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetformat(a0));
}
Variant ei_hphp_get_class_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_class_info", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_class_info(a0));
}
Variant ei_dom_element_remove_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_element_remove_attribute_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_remove_attribute_ns(a0, a1, a2));
}
Variant ei_mailparse_msg_get_part_data(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mailparse_msg_get_part_data", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_msg_get_part_data(a0));
}
Variant ei_openssl_csr_new(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_csr_new", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_csr_new(a0, ref(a1)));
  else if (count == 3) return (x_openssl_csr_new(a0, ref(a1), a2));
  else return (x_openssl_csr_new(a0, ref(a1), a2, a3));
}
Variant ei_xbox_task_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_start", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_task_start(a0));
}
Variant ei_newpixelwands(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("newpixelwands", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_newpixelwands(a0));
}
Variant ei_mb_get_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_get_info", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_get_info());
  else return (x_mb_get_info(a0));
}
Variant ei_posix_getrlimit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getrlimit", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getrlimit());
}
Variant ei_getcwd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getcwd", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getcwd());
}
Variant ei_fputcsv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("fputcsv", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_fputcsv(a0, a1));
  else if (count == 3) return (x_fputcsv(a0, a1, a2));
  else return (x_fputcsv(a0, a1, a2, a3));
}
Variant ei_stream_bucket_prepend(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_bucket_prepend", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_bucket_prepend(a0, a1), null);
}
Variant ei_apache_get_scoreboard(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("apache_get_scoreboard", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_get_scoreboard());
}
Variant ei_sprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("sprintf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_sprintf(count, a0));
  return (x_sprintf(count, a0,vargs));
}
Variant ei_ldap_err2str(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_err2str", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_err2str(a0));
}
Variant ei_memcache_get_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_get_stats", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_get_stats(a0));
  else if (count == 2) return (x_memcache_get_stats(a0, a1));
  else if (count == 3) return (x_memcache_get_stats(a0, a1, a2));
  else return (x_memcache_get_stats(a0, a1, a2, a3));
}
Variant ei_xmlwriter_end_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_attribute", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_attribute(a0));
}
Variant ei_imagecharup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagecharup", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecharup(a0, a1, a2, a3, a4, a5));
}
Variant ei_fflush(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fflush", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fflush(a0));
}
Variant ei_magickwaveimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickwaveimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickwaveimage(a0, a1, a2));
}
Variant ei_imagepsfreefont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagepsfreefont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsfreefont(a0));
}
Variant ei_dom_node_is_supported(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_node_is_supported", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_is_supported(a0, a1, a2));
}
Variant ei_magickgetsamplingfactors(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetsamplingfactors", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetsamplingfactors(a0));
}
Variant ei_mt_rand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("mt_rand", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mt_rand());
  else if (count == 1) return (x_mt_rand(a0));
  else return (x_mt_rand(a0, a1));
}
Variant ei_hphp_splfileinfo_getpathname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getpathname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getpathname(a0));
}
Variant ei_magickflopimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickflopimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickflopimage(a0));
}
Variant ei_register_cleanup_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_cleanup_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_cleanup_function(count, a0), null);
  return (x_register_cleanup_function(count, a0,vargs), null);
}
Variant ei_getenv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getenv", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getenv(a0));
}
Variant ei_is_dir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_dir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_dir(a0));
}
Variant ei_get_defined_functions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_defined_functions", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_defined_functions());
}
Variant ei_stream_set_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stream_set_timeout", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_set_timeout(a0, a1));
  else return (x_stream_set_timeout(a0, a1, a2));
}
Variant ei_magickenhanceimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickenhanceimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickenhanceimage(a0));
}
Variant ei_memcache_increment(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("memcache_increment", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_memcache_increment(a0, a1));
  else return (x_memcache_increment(a0, a1, a2));
}
Variant ei_pixelsetblack(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblack", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetblack(a0, a1), null);
}
Variant ei_magickgetcharwidth(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetcharwidth", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetcharwidth(a0, a1, a2));
  else return (x_magickgetcharwidth(a0, a1, a2, a3));
}
Variant ei_magickshearimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickshearimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickshearimage(a0, a1, a2, a3));
}
Variant ei_stream_socket_enable_crypto(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("stream_socket_enable_crypto", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stream_socket_enable_crypto(a0, a1));
  else if (count == 3) return (x_stream_socket_enable_crypto(a0, a1, a2));
  else return (x_stream_socket_enable_crypto(a0, a1, a2, a3));
}
Variant ei_stream_socket_server(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("stream_socket_server", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_socket_server(a0));
  else if (count == 2) return (x_stream_socket_server(a0, ref(a1)));
  else if (count == 3) return (x_stream_socket_server(a0, ref(a1), ref(a2)));
  else if (count == 4) return (x_stream_socket_server(a0, ref(a1), ref(a2), a3));
  else return (x_stream_socket_server(a0, ref(a1), ref(a2), a3, a4));
}
Variant ei_apd_set_pprof_trace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apd_set_pprof_trace", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apd_set_pprof_trace());
  else if (count == 1) return (x_apd_set_pprof_trace(a0));
  else return (x_apd_set_pprof_trace(a0, a1));
}
Variant ei_ini_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("ini_set", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ini_set(a0, a1));
}
Variant ei_sort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("sort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_sort(ref(a0)));
  else if (count == 2) return (x_sort(ref(a0), a1));
  else return (x_sort(ref(a0), a1, a2));
}
Variant ei_drawgetfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetfont", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetfont(a0));
}
Variant ei_readdir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("readdir", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_readdir(a0));
}
Variant ei_mysql_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_close", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_close());
  else return (x_mysql_close(a0));
}
Variant ei_magicksetimagerenderingintent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagerenderingintent", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagerenderingintent(a0, a1));
}
Variant ei_magickreducenoiseimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreducenoiseimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreducenoiseimage(a0, a1));
}
Variant ei_magickblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickblurimage", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickblurimage(a0, a1, a2));
  else return (x_magickblurimage(a0, a1, a2, a3));
}
Variant ei_hphpd_get_user_commands(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphpd_get_user_commands", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphpd_get_user_commands());
}
Variant ei_magicktintimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicktintimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicktintimage(a0, a1, a2));
}
Variant ei_rawurldecode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("rawurldecode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rawurldecode(a0));
}
Variant ei_strftime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("strftime", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_strftime(a0));
  else return (x_strftime(a0, a1));
}
Variant ei_xmlwriter_start_element_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("xmlwriter_start_element_ns", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_element_ns(a0, a1, a2, a3));
}
Variant ei_imagecolorstotal(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecolorstotal", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorstotal(a0));
}
Variant ei_hphp_splfileinfo_getowner(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getowner", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getowner(a0));
}
Variant ei_write_hdf_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("write_hdf_string", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_write_hdf_string(a0));
}
Variant ei_dom_node_has_child_nodes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_node_has_child_nodes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_node_has_child_nodes(a0));
}
Variant ei_apc_bin_dumpfile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("apc_bin_dumpfile", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_apc_bin_dumpfile(a0, a1, a2));
  else if (count == 4) return (x_apc_bin_dumpfile(a0, a1, a2, a3));
  else return (x_apc_bin_dumpfile(a0, a1, a2, a3, a4));
}
Variant ei_xml_parse_into_struct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("xml_parse_into_struct", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_xml_parse_into_struct(a0, a1, ref(a2)));
  else return (x_xml_parse_into_struct(a0, a1, ref(a2), ref(a3)));
}
Variant ei_icu_transliterate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("icu_transliterate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_icu_transliterate(a0, a1));
}
Variant ei_mb_eregi_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("mb_eregi_replace", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_eregi_replace(a0, a1, a2));
  else return (x_mb_eregi_replace(a0, a1, a2, a3));
}
Variant ei_hphp_splfileinfo_getatime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getatime", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getatime(a0));
}
Variant ei_array_unshift(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("array_unshift", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_array_unshift(count, ref(a0), a1));
  return (x_array_unshift(count, ref(a0), a1,vargs));
}
Variant ei_stat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stat", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stat(a0));
}
Variant ei_posix_getpid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getpid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getpid());
}
Variant ei_hphp_directoryiterator_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_directoryiterator_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_directoryiterator_key(a0));
}
Variant ei_get_current_user(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_current_user", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_current_user());
}
Variant ei_filesize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filesize", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filesize(a0));
}
Variant ei_round(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("round", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_round(a0));
  else return (x_round(a0, a1));
}
Variant ei_pdo_drivers(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("pdo_drivers", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pdo_drivers());
}
Variant ei_sqrt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sqrt", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sqrt(a0));
}
Variant ei_ldap_close(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_close", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_close(a0));
}
Variant ei_memcache_pconnect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("memcache_pconnect", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_memcache_pconnect(a0));
  else if (count == 2) return (x_memcache_pconnect(a0, a1));
  else if (count == 3) return (x_memcache_pconnect(a0, a1, a2));
  else return (x_memcache_pconnect(a0, a1, a2, a3));
}
Variant ei_mcrypt_enc_get_algorithms_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_get_algorithms_name", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_get_algorithms_name(a0));
}
Variant ei_hphp_splfileobject_rewind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileobject_rewind", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_rewind(a0), null);
}
Variant ei_fprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fprintf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 2) return (x_fprintf(count, a0, a1));
  return (x_fprintf(count, a0, a1,vargs));
}
Variant ei_extension_loaded(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("extension_loaded", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_extension_loaded(a0));
}
Variant ei_mb_detect_order(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_detect_order", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_detect_order());
  else return (x_mb_detect_order(a0));
}
Variant ei_magickmapimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magickmapimage", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmapimage(a0, a1, a2));
}
Variant ei_get_magic_quotes_runtime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_magic_quotes_runtime", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_magic_quotes_runtime());
}
Variant ei_pixelsetopacityquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacityquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetopacityquantum(a0, a1), null);
}
Variant ei_ctype_space(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ctype_space", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ctype_space(a0));
}
Variant ei_destroymagickwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroymagickwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroymagickwand(a0), null);
}
Variant ei_mcrypt_generic_init(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mcrypt_generic_init", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_generic_init(a0, a1, a2));
}
Variant ei_quoted_printable_decode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("quoted_printable_decode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_quoted_printable_decode(a0));
}
Variant ei_hphp_splfileinfo_getfileinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getfileinfo", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getfileinfo(a0, a1));
}
Variant ei_get_cfg_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_cfg_var", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_cfg_var(a0));
}
Variant ei_imagerectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagerectangle", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagerectangle(a0, a1, a2, a3, a4, a5));
}
Variant ei_call_user_func_rpc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5) return throw_missing_arguments("call_user_func_rpc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 5) return (x_call_user_func_rpc(count, a0, a1, a2, a3, a4));
  return (x_call_user_func_rpc(count, a0, a1, a2, a3, a4,vargs));
}
Variant ei_pixelgetalphaquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetalphaquantum", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetalphaquantum(a0));
}
Variant ei_fb_renamed_functions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fb_renamed_functions", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_renamed_functions(a0), null);
}
Variant ei_imagepsextendfont(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepsextendfont", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepsextendfont(a0, a1));
}
Variant ei_magickgetimageblob(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageblob", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageblob(a0));
}
Variant ei_stream_get_filters(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_filters", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_filters());
}
Variant ei_magickqueryfontmetrics(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickqueryfontmetrics", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickqueryfontmetrics(a0, a1, a2));
  else return (x_magickqueryfontmetrics(a0, a1, a2, a3));
}
Variant ei_ispixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ispixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ispixeliterator(a0));
}
Variant ei_imagefilledarc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 9) return throw_wrong_arguments("imagefilledarc", count, 9, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledarc(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_getdate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getdate", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_getdate());
  else return (x_getdate(a0));
}
Variant ei_xmlwriter_write_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xmlwriter_write_attribute", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_attribute(a0, a1, a2));
}
Variant ei_imagearc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("imagearc", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagearc(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_magickreadimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickreadimages", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickreadimages(a0, a1));
}
Variant ei_drawgetgravity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetgravity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetgravity(a0));
}
Variant ei_connection_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_status", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_connection_status());
}
Variant ei_imagecreatefromgd2(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgd2", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgd2(a0));
}
Variant ei_stream_socket_shutdown(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_socket_shutdown", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_socket_shutdown(a0, a1));
}
Variant ei_pixelresetiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelresetiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelresetiterator(a0), null);
}
Variant ei_msg_send(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 6) return throw_wrong_arguments("msg_send", count, 3, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_msg_send(a0, a1, a2));
  else if (count == 4) return (x_msg_send(a0, a1, a2, a3));
  else if (count == 5) return (x_msg_send(a0, a1, a2, a3, a4));
  else return (x_msg_send(a0, a1, a2, a3, a4, ref(a5)));
}
Variant ei_getmygid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmygid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmygid());
}
Variant ei_dom_document_get_element_by_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_get_element_by_id", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_get_element_by_id(a0, a1));
}
Variant ei_array_udiff_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 4) return throw_missing_arguments("array_udiff_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 4) return (x_array_udiff_uassoc(count, a0, a1, a2, a3));
  return (x_array_udiff_uassoc(count, a0, a1, a2, a3,vargs));
}
Variant ei_strptime(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strptime", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strptime(a0, a1));
}
Variant ei_array_diff_uassoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3) return throw_missing_arguments("array_diff_uassoc", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 3) return (x_array_diff_uassoc(count, a0, a1, a2));
  return (x_array_diff_uassoc(count, a0, a1, a2,vargs));
}
Variant ei_xml_set_character_data_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_set_character_data_handler", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_set_character_data_handler(a0, a1));
}
Variant ei_pcntl_waitpid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("pcntl_waitpid", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_pcntl_waitpid(a0, ref(a1)));
  else return (x_pcntl_waitpid(a0, ref(a1), a2));
}
Variant ei_array_replace_recursive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace_recursive", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_replace_recursive(count, a0));
  return (x_array_replace_recursive(count, a0,vargs));
}
Variant ei_gd_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("gd_info", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gd_info());
}
Variant ei_stream_get_transports(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("stream_get_transports", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_get_transports());
}
Variant ei_drawsetstrokepatternurl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokepatternurl", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokepatternurl(a0, a1));
}
Variant ei_ldap_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("ldap_add", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_add(a0, a1, a2));
}
Variant ei_acosh(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acosh", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_acosh(a0));
}
Variant ei_drawsetfillrule(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillrule", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillrule(a0, a1), null);
}
Variant ei_posix_getlogin(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getlogin", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getlogin());
}
Variant ei_posix_getsid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getsid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getsid(a0));
}
Variant ei_imagegd2(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagegd2", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegd2(a0));
  else if (count == 2) return (x_imagegd2(a0, a1));
  else if (count == 3) return (x_imagegd2(a0, a1, a2));
  else return (x_imagegd2(a0, a1, a2, a3));
}
Variant ei_imagecreate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagecreate", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreate(a0, a1));
}
Variant ei_socket_create_pair(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("socket_create_pair", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_create_pair(a0, a1, a2, ref(a3)));
}
Variant ei_openssl_x509_check_private_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("openssl_x509_check_private_key", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_x509_check_private_key(a0, a1));
}
Variant ei_collator_get_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("collator_get_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_collator_get_attribute(a0, a1));
}
Variant ei_shm_put_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("shm_put_var", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_put_var(a0, a1, a2));
}
Variant ei_debug_print_backtrace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("debug_print_backtrace", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_debug_print_backtrace(), null);
}
Variant ei_hphp_splfileobject_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_seek(a0, a1), null);
}
Variant ei_stream_set_blocking(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_set_blocking", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_set_blocking(a0, a1));
}
Variant ei_ezmlm_hash(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ezmlm_hash", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ezmlm_hash(a0));
}
Variant ei_xml_parser_get_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xml_parser_get_option", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_parser_get_option(a0, a1));
}
Variant ei_array_search(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_search", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_search(a0, a1));
  else return (x_array_search(a0, a1, a2));
}
Variant ei_is_int(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_int", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_int(a0));
}
Variant ei_dangling_server_proxy_new_request(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dangling_server_proxy_new_request", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dangling_server_proxy_new_request(a0));
}
Variant ei_xmlwriter_end_dtd_entity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_dtd_entity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_dtd_entity(a0));
}
Variant ei_trim(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trim", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_trim(a0));
  else return (x_trim(a0, a1));
}
Variant ei_drawpathclose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawpathclose", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathclose(a0), null);
}
Variant ei_magickprofileimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("magickprofileimage", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_magickprofileimage(a0, a1));
  else return (x_magickprofileimage(a0, a1, a2));
}
Variant ei_connection_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("connection_timeout", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_connection_timeout());
}
Variant ei_mysql_data_seek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mysql_data_seek", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_data_seek(a0, a1));
}
Variant ei_pixelgetindex(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetindex", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetindex(a0));
}
Variant ei_class_implements(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_implements", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_class_implements(a0));
  else return (x_class_implements(a0, a1));
}
Variant ei_hebrevc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("hebrevc", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_hebrevc(a0));
  else return (x_hebrevc(a0, a1));
}
Variant ei_get_meta_tags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("get_meta_tags", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_get_meta_tags(a0));
  else return (x_get_meta_tags(a0, a1));
}
Variant ei_magicknextimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magicknextimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicknextimage(a0));
}
Variant ei_hphp_recursivedirectoryiterator_key(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_key", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_key(a0));
}
Variant ei_mysql_create_db(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_create_db", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_create_db(a0));
  else return (x_mysql_create_db(a0, a1));
}
Variant ei_mysql_stat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_stat", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_stat());
  else return (x_mysql_stat(a0));
}
Variant ei_get_object_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("get_object_vars", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_object_vars(a0));
}
Variant ei_msg_receive(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 8) return throw_wrong_arguments("msg_receive", count, 5, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4)));
  else if (count == 6) return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4), a5));
  else if (count == 7) return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4), a5, a6));
  else return (x_msg_receive(a0, a1, ref(a2), a3, ref(a4), a5, a6, ref(a7)));
}
Variant ei_is_integer(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_integer", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_integer(a0));
}
Variant ei_posix_getuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_getuid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getuid());
}
Variant ei_imagecreatefromgif(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromgif", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromgif(a0));
}
Variant ei_mb_send_mail(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 5) return throw_wrong_arguments("mb_send_mail", count, 3, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_mb_send_mail(a0, a1, a2));
  else if (count == 4) return (x_mb_send_mail(a0, a1, a2, a3));
  else return (x_mb_send_mail(a0, a1, a2, a3, a4));
}
Variant ei_hphp_splfileinfo___construct(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo___construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo___construct(a0, a1));
}
Variant ei_register_postsend_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_postsend_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_postsend_function(count, a0), null);
  return (x_register_postsend_function(count, a0,vargs), null);
}
Variant ei_getrusage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("getrusage", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_getrusage());
  else return (x_getrusage(a0));
}
Variant ei_long2ip(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("long2ip", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_long2ip(a0));
}
Variant ei_evhttp_set_cache(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("evhttp_set_cache", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_evhttp_set_cache(a0, a1), null);
  else return (x_evhttp_set_cache(a0, a1, a2), null);
}
Variant ei_magickoilpaintimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magickoilpaintimage", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickoilpaintimage(a0, a1));
}
Variant ei_strripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("strripos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_strripos(a0, a1));
  else return (x_strripos(a0, a1, a2));
}
Variant ei_magicksetimagecolormapcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetimagecolormapcolor", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecolormapcolor(a0, a1, a2));
}
Variant ei_magickgetfilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetfilename", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetfilename(a0));
}
Variant ei_magicksetimagegamma(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagegamma", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagegamma(a0, a1));
}
Variant ei_mysql_pconnect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 6) return throw_toomany_arguments("mysql_pconnect", 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_pconnect());
  else if (count == 1) return (x_mysql_pconnect(a0));
  else if (count == 2) return (x_mysql_pconnect(a0, a1));
  else if (count == 3) return (x_mysql_pconnect(a0, a1, a2));
  else if (count == 4) return (x_mysql_pconnect(a0, a1, a2, a3));
  else if (count == 5) return (x_mysql_pconnect(a0, a1, a2, a3, a4));
  else return (x_mysql_pconnect(a0, a1, a2, a3, a4, a5));
}
Variant ei_stripos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("stripos", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_stripos(a0, a1));
  else return (x_stripos(a0, a1, a2));
}
Variant ei_http_build_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("http_build_query", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_http_build_query(a0));
  else if (count == 2) return (x_http_build_query(a0, a1));
  else return (x_http_build_query(a0, a1, a2));
}
Variant ei_apc_add(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_add", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_apc_add(a0, a1));
  else if (count == 3) return (x_apc_add(a0, a1, a2));
  else return (x_apc_add(a0, a1, a2, a3));
}
Variant ei_iconv_strlen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("iconv_strlen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_iconv_strlen(a0));
  else return (x_iconv_strlen(a0, a1));
}
Variant ei_vsprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("vsprintf", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_vsprintf(a0, a1));
}
Variant ei_imageistruecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imageistruecolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageistruecolor(a0));
}
Variant ei_mailparse_msg_extract_part_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mailparse_msg_extract_part_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mailparse_msg_extract_part_file(a0, a1));
  else return (x_mailparse_msg_extract_part_file(a0, a1, a2));
}
Variant ei_dom_xpath_register_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("dom_xpath_register_ns", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_xpath_register_ns(a0, a1, a2));
}
Variant ei_is_nan(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_nan", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_nan(a0));
}
Variant ei_imagegif(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("imagegif", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagegif(a0));
  else return (x_imagegif(a0, a1));
}
Variant ei_eregi_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("eregi_replace", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_eregi_replace(a0, a1, a2));
}
Variant ei_magickgetimageiterations(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimageiterations", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimageiterations(a0));
}
Variant ei_register_tick_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("register_tick_function", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_register_tick_function(count, a0));
  return (x_register_tick_function(count, a0,vargs));
}
Variant ei_pixelsetblackquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetblackquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetblackquantum(a0, a1), null);
}
Variant ei_jpeg2wbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("jpeg2wbmp", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_jpeg2wbmp(a0, a1, a2, a3, a4));
}
Variant ei_mcrypt_get_iv_size(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mcrypt_get_iv_size", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_get_iv_size(a0, a1));
}
Variant ei_mysql_fetch_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_fetch_array", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_fetch_array(a0));
  else return (x_mysql_fetch_array(a0, a1));
}
Variant ei_magickpreviousimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickpreviousimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickpreviousimage(a0));
}
Variant ei_magickborderimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickborderimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickborderimage(a0, a1, a2, a3));
}
Variant ei_mcrypt_module_is_block_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_mode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_is_block_mode(a0));
  else return (x_mcrypt_module_is_block_mode(a0, a1));
}
Variant ei_mb_substr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("mb_substr", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_substr(a0, a1));
  else if (count == 3) return (x_mb_substr(a0, a1, a2));
  else return (x_mb_substr(a0, a1, a2, a3));
}
Variant ei_get_defined_constants(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("get_defined_constants", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_get_defined_constants());
  else return (x_get_defined_constants(a0));
}
Variant ei_mcrypt_enc_is_block_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mcrypt_enc_is_block_mode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mcrypt_enc_is_block_mode(a0));
}
Variant ei_mailparse_stream_encode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("mailparse_stream_encode", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mailparse_stream_encode(a0, a1, a2));
}
Variant ei_drawsetstrokedashoffset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokedashoffset", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokedashoffset(a0, a1), null);
}
Variant ei_php_ini_scanned_files(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("php_ini_scanned_files", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_php_ini_scanned_files());
}
Variant ei_disk_free_space(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("disk_free_space", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_disk_free_space(a0));
}
Variant ei_pixelsetyellowquantum(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetyellowquantum", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetyellowquantum(a0, a1), null);
}
Variant ei_dom_document_create_element_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("dom_document_create_element_ns", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_dom_document_create_element_ns(a0, a1, a2));
  else return (x_dom_document_create_element_ns(a0, a1, a2, a3));
}
Variant ei_openssl_public_decrypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("openssl_public_decrypt", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_openssl_public_decrypt(a0, ref(a1), a2));
  else return (x_openssl_public_decrypt(a0, ref(a1), a2, a3));
}
Variant ei_convert_uuencode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("convert_uuencode", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_convert_uuencode(a0));
}
Variant ei_magickequalizeimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickequalizeimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickequalizeimage(a0));
}
Variant ei_mysql_field_len(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_len", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_len(a0));
  else return (x_mysql_field_len(a0, a1));
}
Variant ei_drawsetclipunits(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetclipunits", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetclipunits(a0, a1), null);
}
Variant ei_mdecrypt_generic(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("mdecrypt_generic", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mdecrypt_generic(a0, a1));
}
Variant ei_getprotobyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobyname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getprotobyname(a0));
}
Variant ei_xmlwriter_start_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_pi", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_pi(a0, a1));
}
Variant ei_mysql_field_type(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_type", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_type(a0));
  else return (x_mysql_field_type(a0, a1));
}
Variant ei_apc_cas(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("apc_cas", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_apc_cas(a0, a1, a2));
  else return (x_apc_cas(a0, a1, a2, a3));
}
Variant ei_getopt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("getopt", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_getopt(a0));
  else return (x_getopt(a0, a1));
}
Variant ei_clearpixelwand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("clearpixelwand", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_clearpixelwand(a0), null);
}
Variant ei_drawsetgravity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetgravity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetgravity(a0, a1), null);
}
Variant ei_magickgetimagecompressionquality(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompressionquality", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecompressionquality(a0));
}
Variant ei_magickquantizeimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickquantizeimages", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickquantizeimages(a0, a1, a2, a3, a4, a5));
}
Variant ei_mysql_insert_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_insert_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_insert_id());
  else return (x_mysql_insert_id(a0));
}
Variant ei_hphp_thread_set_warmup_enabled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("hphp_thread_set_warmup_enabled", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_thread_set_warmup_enabled(), null);
}
Variant ei_stream_context_set_param(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_context_set_param", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_context_set_param(a0, a1));
}
Variant ei_drawpathlinetohorizontalabsolute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetohorizontalabsolute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetohorizontalabsolute(a0, a1), null);
}
Variant ei_openssl_csr_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_csr_export(a0, ref(a1)));
  else return (x_openssl_csr_export(a0, ref(a1), a2));
}
Variant ei_socket_connect(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_connect", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_connect(a0, a1));
  else return (x_socket_connect(a0, a1, a2));
}
Variant ei_stripslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripslashes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stripslashes(a0));
}
Variant ei_magickhaspreviousimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickhaspreviousimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickhaspreviousimage(a0));
}
Variant ei_drawgetstrokecolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgetstrokecolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgetstrokecolor(a0));
}
Variant ei_imagecreatefromwbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromwbmp", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromwbmp(a0));
}
Variant ei_str_repeat(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("str_repeat", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_str_repeat(a0, a1));
}
Variant ei_stream_resolve_include_path(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("stream_resolve_include_path", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_stream_resolve_include_path(a0));
  else return (x_stream_resolve_include_path(a0, a1));
}
Variant ei_ldap_read(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 8) return throw_wrong_arguments("ldap_read", count, 3, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_ldap_read(a0, a1, a2));
  else if (count == 4) return (x_ldap_read(a0, a1, a2, a3));
  else if (count == 5) return (x_ldap_read(a0, a1, a2, a3, a4));
  else if (count == 6) return (x_ldap_read(a0, a1, a2, a3, a4, a5));
  else if (count == 7) return (x_ldap_read(a0, a1, a2, a3, a4, a5, a6));
  else return (x_ldap_read(a0, a1, a2, a3, a4, a5, a6, a7));
}
Variant ei_apc_dec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_dec", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_dec(a0));
  else if (count == 2) return (x_apc_dec(a0, a1));
  else if (count == 3) return (x_apc_dec(a0, a1, ref(a2)));
  else return (x_apc_dec(a0, a1, ref(a2), a3));
}
Variant ei_posix_get_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("posix_get_last_error", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_get_last_error());
}
Variant ei_iptcparse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iptcparse", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iptcparse(a0));
}
Variant ei_iterator_count(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("iterator_count", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_iterator_count(a0));
}
Variant ei_curl_setopt_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_setopt_array", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_setopt_array(a0, a1));
}
Variant ei_socket_recvfrom(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 5 || count > 6) return throw_wrong_arguments("socket_recvfrom", count, 5, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a5 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 5) return (x_socket_recvfrom(a0, ref(a1), a2, a3, ref(a4)));
  else return (x_socket_recvfrom(a0, ref(a1), a2, a3, ref(a4), ref(a5)));
}
Variant ei_imagepstext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  Variant a10;
  Variant a11;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 12) return throw_wrong_arguments("imagepstext", count, 8, 12, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a10 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a11 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 8) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7));
  else if (count == 9) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8));
  else if (count == 10) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
  else if (count == 11) return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
  else return (x_imagepstext(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
}
Variant ei_mb_encode_mimeheader(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("mb_encode_mimeheader", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_encode_mimeheader(a0));
  else if (count == 2) return (x_mb_encode_mimeheader(a0, a1));
  else if (count == 3) return (x_mb_encode_mimeheader(a0, a1, a2));
  else if (count == 4) return (x_mb_encode_mimeheader(a0, a1, a2, a3));
  else return (x_mb_encode_mimeheader(a0, a1, a2, a3, a4));
}
Variant ei_socket_getsockname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_getsockname", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_getsockname(a0, ref(a1)));
  else return (x_socket_getsockname(a0, ref(a1), ref(a2)));
}
Variant ei_imagecreatefromstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromstring(a0));
}
Variant ei_vfprintf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("vfprintf", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_vfprintf(a0, a1, a2));
}
Variant ei_magickcompareimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickcompareimages", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickcompareimages(a0, a1, a2));
  else return (x_magickcompareimages(a0, a1, a2, a3));
}
Variant ei_fscanf(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2) return throw_missing_arguments("fscanf", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append(ref((*it)->refval(env, false)));
  }
  if (count <= 2) return (x_fscanf(count, a0, a1));
  return (x_fscanf(count, a0, a1,vargs));
}
Variant ei_stristr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stristr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stristr(a0, a1));
}
Variant ei_xml_parser_set_option(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("xml_parser_set_option", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xml_parser_set_option(a0, a1, a2));
}
Variant ei_dom_document_schema_validate_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_schema_validate_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_schema_validate_file(a0, a1));
}
Variant ei_magicksetimageinterlacescheme(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimageinterlacescheme", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimageinterlacescheme(a0, a1));
}
Variant ei_dom_element_get_attribute_node(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_get_attribute_node", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_get_attribute_node(a0, a1));
}
Variant ei_dom_document_create_cdatasection(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_create_cdatasection", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_create_cdatasection(a0, a1));
}
Variant ei_destroypixeliterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixeliterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixeliterator(a0), null);
}
Variant ei_magicksetimagetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagetype", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagetype(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_getinneriterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_getinneriterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_getinneriterator(a0));
}
Variant ei_date_sunrise(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunrise", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_date_sunrise(a0));
  else if (count == 2) return (x_date_sunrise(a0, a1));
  else if (count == 3) return (x_date_sunrise(a0, a1, a2));
  else if (count == 4) return (x_date_sunrise(a0, a1, a2, a3));
  else if (count == 5) return (x_date_sunrise(a0, a1, a2, a3, a4));
  else return (x_date_sunrise(a0, a1, a2, a3, a4, a5));
}
Variant ei_magickgethomeurl(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgethomeurl", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgethomeurl());
}
Variant ei_mb_detect_encoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mb_detect_encoding", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mb_detect_encoding(a0));
  else if (count == 2) return (x_mb_detect_encoding(a0, a1));
  else return (x_mb_detect_encoding(a0, a1, a2));
}
Variant ei_wandhasexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("wandhasexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_wandhasexception(a0));
}
Variant ei_error_reporting(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("error_reporting", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_error_reporting());
  else return (x_error_reporting(a0));
}
Variant ei_imagepalettecopy(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagepalettecopy", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagepalettecopy(a0, a1), null);
}
Variant ei_hphp_splfileinfo_isexecutable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_isexecutable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_isexecutable(a0));
}
Variant ei_rename_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("rename_function", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_rename_function(a0, a1));
}
Variant ei_gzcompress(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzcompress", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzcompress(a0));
  else return (x_gzcompress(a0, a1));
}
Variant ei_gzeof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gzeof", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gzeof(a0));
}
Variant ei_bcadd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcadd", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcadd(a0, a1));
  else return (x_bcadd(a0, a1, a2));
}
Variant ei_curl_setopt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("curl_setopt", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_setopt(a0, a1, a2));
}
Variant ei_imagealphablending(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagealphablending", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagealphablending(a0, a1));
}
Variant ei_pixelgetmagenta(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetmagenta", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetmagenta(a0));
}
Variant ei_drawannotation(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("drawannotation", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawannotation(a0, a1, a2, a3), null);
}
Variant ei_getmypid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmypid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmypid());
}
Variant ei_magicksetimagedispose(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagedispose", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagedispose(a0, a1));
}
Variant ei_drawsetfontsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontsize", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontsize(a0, a1), null);
}
Variant ei_gethostbyname(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("gethostbyname", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_gethostbyname(a0));
}
Variant ei_stream_wrapper_restore(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stream_wrapper_restore", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_wrapper_restore(a0));
}
Variant ei_magickgetimagecompression(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagecompression", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagecompression(a0));
}
Variant ei_hphp_invoke_method(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("hphp_invoke_method", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_invoke_method(a0, a1, a2, a3));
}
Variant ei_xbox_schedule_thread_reset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xbox_schedule_thread_reset", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_schedule_thread_reset(), null);
}
Variant ei_date_offset_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_offset_get", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_offset_get(a0));
}
Variant ei_pixelgetiteratorexception(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetiteratorexception", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetiteratorexception(a0));
}
Variant ei_mysql_field_flags(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_field_flags", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_field_flags(a0));
  else return (x_mysql_field_flags(a0, a1));
}
Variant ei_linkinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("linkinfo", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_linkinfo(a0));
}
Variant ei_strchr(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strchr", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strchr(a0, a1));
}
Variant ei_magickqueryformats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryformats", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryformats(a0));
}
Variant ei_class_parents(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("class_parents", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_class_parents(a0));
  else return (x_class_parents(a0, a1));
}
Variant ei_date_time_set(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("date_time_set", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_date_time_set(a0, a1, a2), null);
  else return (x_date_time_set(a0, a1, a2, a3), null);
}
Variant ei_iconv_strpos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("iconv_strpos", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iconv_strpos(a0, a1));
  else if (count == 3) return (x_iconv_strpos(a0, a1, a2));
  else return (x_iconv_strpos(a0, a1, a2, a3));
}
Variant ei_i18n_loc_set_strength(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("i18n_loc_set_strength", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_i18n_loc_set_strength(a0));
}
Variant ei_magickgetimagebordercolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagebordercolor", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagebordercolor(a0));
}
Variant ei_ob_end_clean(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("ob_end_clean", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ob_end_clean());
}
Variant ei_dom_document_savexml(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("dom_document_savexml", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dom_document_savexml(a0));
  else if (count == 2) return (x_dom_document_savexml(a0, a1));
  else return (x_dom_document_savexml(a0, a1, a2));
}
Variant ei_trigger_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("trigger_error", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_trigger_error(a0));
  else return (x_trigger_error(a0, a1));
}
Variant ei_pcntl_getpriority(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("pcntl_getpriority", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_pcntl_getpriority());
  else if (count == 1) return (x_pcntl_getpriority(a0));
  else return (x_pcntl_getpriority(a0, a1));
}
Variant ei_date_default_timezone_get(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("date_default_timezone_get", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_default_timezone_get());
}
Variant ei_strcmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("strcmp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strcmp(a0, a1));
}
Variant ei_hphp_recursivedirectoryiterator_haschildren(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursivedirectoryiterator_haschildren", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursivedirectoryiterator_haschildren(a0));
}
Variant ei_hphp_instanceof(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_instanceof", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_instanceof(a0, a1));
}
Variant ei_import_request_variables(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("import_request_variables", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_import_request_variables(a0));
  else return (x_import_request_variables(a0, a1));
}
Variant ei_magickgetpackagename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetpackagename", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetpackagename());
}
Variant ei_destroypixelwandarray(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("destroypixelwandarray", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_destroypixelwandarray(a0), null);
}
Variant ei_spliti(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("spliti", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_spliti(a0, a1));
  else return (x_spliti(a0, a1, a2));
}
Variant ei_posix_setgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_setgid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setgid(a0));
}
Variant ei_is_double(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_double", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_double(a0));
}
Variant ei_output_reset_rewrite_vars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("output_reset_rewrite_vars", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_output_reset_rewrite_vars());
}
Variant ei_get_declared_interfaces(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("get_declared_interfaces", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_get_declared_interfaces());
}
Variant ei_passthru(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("passthru", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_passthru(a0), null);
  else return (x_passthru(a0, ref(a1)), null);
}
Variant ei_magickmontageimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("magickmontageimage", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmontageimage(a0, a1, a2, a3, a4, a5));
}
Variant ei_session_commit(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_commit", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_commit(), null);
}
Variant ei_apc_cache_info(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) return throw_toomany_arguments("apc_cache_info", 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_apc_cache_info());
  else if (count == 1) return (x_apc_cache_info(a0));
  else return (x_apc_cache_info(a0, a1));
}
Variant ei_convert_cyr_string(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("convert_cyr_string", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_convert_cyr_string(a0, a1, a2));
}
Variant ei_sys_get_temp_dir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("sys_get_temp_dir", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sys_get_temp_dir());
}
Variant ei_libxml_get_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("libxml_get_last_error", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_libxml_get_last_error());
}
Variant ei_drawline(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("drawline", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawline(a0, a1, a2, a3, a4), null);
}
Variant ei_drawsetfillcolor(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfillcolor", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfillcolor(a0, a1), null);
}
Variant ei_gzopen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzopen", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzopen(a0, a1));
  else return (x_gzopen(a0, a1, a2));
}
Variant ei_getservbyport(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("getservbyport", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getservbyport(a0, a1));
}
Variant ei_hphp_splfileinfo_getfilename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_splfileinfo_getfilename", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getfilename(a0));
}
Variant ei_stripcslashes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("stripcslashes", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stripcslashes(a0));
}
Variant ei_curl_multi_add_handle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_add_handle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_add_handle(a0, a1));
}
Variant ei_ldap_free_result(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("ldap_free_result", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_free_result(a0));
}
Variant ei_array_replace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1) return throw_missing_arguments("array_replace", count+1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  Array vargs;
  for (; it != params.end(); ++it) {
    vargs.append((*it)->eval(env));
  }
  if (count <= 1) return (x_array_replace(count, a0));
  return (x_array_replace(count, a0,vargs));
}
Variant ei_xmlwriter_end_pi(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_end_pi", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_end_pi(a0));
}
Variant ei_imagewbmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagewbmp", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagewbmp(a0));
  else if (count == 2) return (x_imagewbmp(a0, a1));
  else return (x_imagewbmp(a0, a1, a2));
}
Variant ei_shm_get_var(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("shm_get_var", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shm_get_var(a0, a1));
}
Variant ei_magickgetmimetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetmimetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetmimetype(a0));
}
Variant ei_mysql_fetch_assoc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("mysql_fetch_assoc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_mysql_fetch_assoc(a0));
}
Variant ei_socket_set_nonblock(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("socket_set_nonblock", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_socket_set_nonblock(a0));
}
Variant ei_array_filter(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("array_filter", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_filter(a0));
  else return (x_array_filter(a0, a1));
}
Variant ei_mysql_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mysql_query", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_query(a0));
  else return (x_mysql_query(a0, a1));
}
Variant ei_crypt(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("crypt", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_crypt(a0));
  else return (x_crypt(a0, a1));
}
Variant ei_xmlwriter_start_cdata(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xmlwriter_start_cdata", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_cdata(a0));
}
Variant ei_fgetc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("fgetc", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fgetc(a0));
}
Variant ei_move_uploaded_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("move_uploaded_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_move_uploaded_file(a0, a1));
}
Variant ei_hphp_splfileobject_flock(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileobject_flock", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileobject_flock(a0, ref(a1)));
}
Variant ei_imagecopyresampled(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  Variant a9;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 10) return throw_wrong_arguments("imagecopyresampled", count, 10, 10, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a9 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecopyresampled(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
}
Variant ei_imagecreatefrompng(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefrompng", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefrompng(a0));
}
Variant ei_magickgetimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimage(a0));
}
Variant ei_imagesettile(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("imagesettile", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesettile(a0, a1));
}
Variant ei_hphp_recursiveiteratoriterator_valid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_recursiveiteratoriterator_valid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_recursiveiteratoriterator_valid(a0));
}
Variant ei_fgets(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("fgets", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_fgets(a0));
  else return (x_fgets(a0, a1));
}
Variant ei_tempnam(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("tempnam", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_tempnam(a0, a1));
}
Variant ei_bcdiv(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("bcdiv", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_bcdiv(a0, a1));
  else return (x_bcdiv(a0, a1, a2));
}
Variant ei_hphp_splfileinfo_getbasename(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_splfileinfo_getbasename", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_splfileinfo_getbasename(a0, a1));
}
Variant ei_rsort(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("rsort", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_rsort(ref(a0)));
  else if (count == 2) return (x_rsort(ref(a0), a1));
  else return (x_rsort(ref(a0), a1, a2));
}
Variant ei_drawgettextdecoration(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextdecoration", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextdecoration(a0));
}
Variant ei_strtolower(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strtolower", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strtolower(a0));
}
Variant ei_posix_getgrgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrgid", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgrgid(a0));
}
Variant ei_apc_inc(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("apc_inc", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_inc(a0));
  else if (count == 2) return (x_apc_inc(a0, a1));
  else if (count == 3) return (x_apc_inc(a0, a1, ref(a2)));
  else return (x_apc_inc(a0, a1, ref(a2), a3));
}
Variant ei_hphp_create_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_create_object", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_create_object(a0, a1));
}
Variant ei_hexdec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hexdec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hexdec(a0));
}
Variant ei_imagefttext(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  Variant a8;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 8 || count > 9) return throw_wrong_arguments("imagefttext", count, 8, 9, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a8 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 8) return (x_imagefttext(a0, a1, a2, a3, a4, a5, a6, a7));
  else return (x_imagefttext(a0, a1, a2, a3, a4, a5, a6, a7, a8));
}
Variant ei_xhprof_sample_disable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("xhprof_sample_disable", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xhprof_sample_disable());
}
Variant ei_ldap_compare(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("ldap_compare", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_ldap_compare(a0, a1, a2, a3));
}
Variant ei_dns_get_record(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("dns_get_record", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a3 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dns_get_record(a0));
  else if (count == 2) return (x_dns_get_record(a0, a1));
  else if (count == 3) return (x_dns_get_record(a0, a1, ref(a2)));
  else return (x_dns_get_record(a0, a1, ref(a2), ref(a3)));
}
Variant ei_openssl_get_privatekey(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_get_privatekey", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_get_privatekey(a0));
  else return (x_openssl_get_privatekey(a0, a1));
}
Variant ei_imagepng(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("imagepng", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagepng(a0));
  else if (count == 2) return (x_imagepng(a0, a1));
  else if (count == 3) return (x_imagepng(a0, a1, a2));
  else return (x_imagepng(a0, a1, a2, a3));
}
Variant ei_socket_bind(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("socket_bind", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_socket_bind(a0, a1));
  else return (x_socket_bind(a0, a1, a2));
}
Variant ei_getmyuid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("getmyuid", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getmyuid());
}
Variant ei_pixelgetopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetopacity", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetopacity(a0));
}
Variant ei_drawsetstrokelinecap(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetstrokelinecap", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetstrokelinecap(a0, a1), null);
}
Variant ei_xmlwriter_write_attribute_ns(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("xmlwriter_write_attribute_ns", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_write_attribute_ns(a0, a1, a2, a3, a4));
}
Variant ei_array_keys(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("array_keys", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_array_keys(a0));
  else if (count == 2) return (x_array_keys(a0, a1));
  else return (x_array_keys(a0, a1, a2));
}
Variant ei_call_user_method_array(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("call_user_method_array", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_call_user_method_array(a0, ref(a1), a2));
}
Variant ei_magickmagnifyimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickmagnifyimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmagnifyimage(a0));
}
Variant ei_is_bool(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_bool", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_bool(a0));
}
Variant ei_magickgetimagegreenprimary(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetimagegreenprimary", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetimagegreenprimary(a0));
}
Variant ei_session_start(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("session_start", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_session_start());
}
Variant ei_filegroup(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filegroup", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filegroup(a0));
}
Variant ei_dom_attr_is_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("dom_attr_is_id", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_attr_is_id(a0));
}
Variant ei_gzread(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzread", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzread(a0));
  else return (x_gzread(a0, a1));
}
Variant ei_drawpathellipticarcrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  Variant a6;
  Variant a7;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 8) return throw_wrong_arguments("drawpathellipticarcrelative", count, 8, 8, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a6 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a7 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathellipticarcrelative(a0, a1, a2, a3, a4, a5, a6, a7), null);
}
Variant ei_openssl_csr_export_to_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("openssl_csr_export_to_file", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_csr_export_to_file(a0, a1));
  else return (x_openssl_csr_export_to_file(a0, a1, a2));
}
Variant ei_magicksetimagecolorspace(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("magicksetimagecolorspace", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetimagecolorspace(a0, a1));
}
Variant ei_nl_langinfo(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("nl_langinfo", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_nl_langinfo(a0));
}
Variant ei_hphp_get_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("hphp_get_stats", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_get_stats(a0));
}
Variant ei_strncmp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("strncmp", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strncmp(a0, a1, a2));
}
Variant ei_mb_regex_set_options(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mb_regex_set_options", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mb_regex_set_options());
  else return (x_mb_regex_set_options(a0));
}
Variant ei_pixelsetmagenta(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetmagenta", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetmagenta(a0, a1), null);
}
Variant ei_dom_element_remove_attribute(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_element_remove_attribute", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_element_remove_attribute(a0, a1));
}
Variant ei_magickdeconstructimages(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickdeconstructimages", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickdeconstructimages(a0));
}
Variant ei_xbox_task_status(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_task_status", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_task_status(a0));
}
Variant ei_openssl_open(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("openssl_open", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_open(a0, ref(a1), a2, a3));
}
Variant ei_apc_bin_load(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("apc_bin_load", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_apc_bin_load(a0));
  else if (count == 2) return (x_apc_bin_load(a0, a1));
  else return (x_apc_bin_load(a0, a1, a2));
}
Variant ei_current(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("current", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_current(ref(a0)));
}
Variant ei_stream_register_wrapper(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("stream_register_wrapper", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_stream_register_wrapper(a0, a1));
}
Variant ei_hphp_stats(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("hphp_stats", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_hphp_stats(a0, a1), null);
}
Variant ei_opendir(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("opendir", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_opendir(a0));
  else return (x_opendir(a0, a1));
}
Variant ei_magickgetexceptionstring(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickgetexceptionstring", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetexceptionstring(a0));
}
Variant ei_mcrypt_module_is_block_algorithm_mode(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("mcrypt_module_is_block_algorithm_mode", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mcrypt_module_is_block_algorithm_mode(a0));
  else return (x_mcrypt_module_is_block_algorithm_mode(a0, a1));
}
Variant ei_posix_setpgid(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("posix_setpgid", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_setpgid(a0, a1));
}
Variant ei_dns_get_mx(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("dns_get_mx", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_dns_get_mx(a0, ref(a1)));
  else return (x_dns_get_mx(a0, ref(a1), ref(a2)));
}
Variant ei_headers_list(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("headers_list", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_headers_list());
}
Variant ei_escapeshellarg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellarg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_escapeshellarg(a0));
}
Variant ei_is_scalar(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_scalar", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_scalar(a0));
}
Variant ei_acos(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("acos", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_acos(a0));
}
Variant ei_drawgettextencoding(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("drawgettextencoding", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawgettextencoding(a0));
}
Variant ei_filetype(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("filetype", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_filetype(a0));
}
Variant ei_magicksetresolution(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetresolution", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetresolution(a0, a1, a2));
}
Variant ei_posix_isatty(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_isatty", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_isatty(a0));
}
Variant ei_dom_document_relaxng_validate_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("dom_document_relaxng_validate_file", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_dom_document_relaxng_validate_file(a0, a1));
}
Variant ei_escapeshellcmd(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("escapeshellcmd", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_escapeshellcmd(a0));
}
Variant ei_apc_store(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("apc_store", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_apc_store(a0, a1));
  else if (count == 3) return (x_apc_store(a0, a1, a2));
  else return (x_apc_store(a0, a1, a2, a3));
}
Variant ei_magickresetiterator(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickresetiterator", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickresetiterator(a0), null);
}
Variant ei_libxml_disable_entity_loader(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("libxml_disable_entity_loader", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_libxml_disable_entity_loader());
  else return (x_libxml_disable_entity_loader(a0));
}
Variant ei_apache_lookup_uri(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("apache_lookup_uri", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_apache_lookup_uri(a0));
}
Variant ei_magickmotionblurimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("magickmotionblurimage", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickmotionblurimage(a0, a1, a2, a3));
}
Variant ei_session_cache_expire(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_cache_expire", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_cache_expire());
  else return (x_session_cache_expire(a0));
}
Variant ei_magicksetwandsize(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("magicksetwandsize", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magicksetwandsize(a0, a1, a2));
}
Variant ei_number_format(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("number_format", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_number_format(a0));
  else if (count == 2) return (x_number_format(a0, a1));
  else if (count == 3) return (x_number_format(a0, a1, a2));
  else return (x_number_format(a0, a1, a2, a3));
}
Variant ei_array_reduce(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("array_reduce", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_array_reduce(a0, a1));
  else return (x_array_reduce(a0, a1, a2));
}
Variant ei_xmlwriter_start_dtd_attlist(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_start_dtd_attlist", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_start_dtd_attlist(a0, a1));
}
Variant ei_constant(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("constant", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_constant(a0));
}
Variant ei_strlen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("strlen", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_strlen(a0));
}
Variant ei_srand(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("srand", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_srand(), null);
  else return (x_srand(a0), null);
}
Variant ei_mysql_fetch_object(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("mysql_fetch_object", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_mysql_fetch_object(a0));
  else if (count == 2) return (x_mysql_fetch_object(a0, a1));
  else return (x_mysql_fetch_object(a0, a1, a2));
}
Variant ei_drawpathlinetoverticalrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawpathlinetoverticalrelative", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathlinetoverticalrelative(a0, a1), null);
}
Variant ei_magickminifyimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickminifyimage", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickminifyimage(a0));
}
Variant ei_date_sunset(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 6) return throw_wrong_arguments("date_sunset", count, 1, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_date_sunset(a0));
  else if (count == 2) return (x_date_sunset(a0, a1));
  else if (count == 3) return (x_date_sunset(a0, a1, a2));
  else if (count == 4) return (x_date_sunset(a0, a1, a2, a3));
  else if (count == 5) return (x_date_sunset(a0, a1, a2, a3, a4));
  else return (x_date_sunset(a0, a1, a2, a3, a4, a5));
}
Variant ei_symlink(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("symlink", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_symlink(a0, a1));
}
Variant ei_imagesetpixel(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 4) return throw_wrong_arguments("imagesetpixel", count, 4, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagesetpixel(a0, a1, a2, a3));
}
Variant ei_session_module_name(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("session_module_name", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_session_module_name());
  else return (x_session_module_name(a0));
}
Variant ei_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("split", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_split(a0, a1));
  else return (x_split(a0, a1, a2));
}
Variant ei_drawsetfontstyle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("drawsetfontstyle", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawsetfontstyle(a0, a1), null);
}
Variant ei_imagecreatefromxbm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxbm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromxbm(a0));
}
Variant ei_mysql_db_query(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mysql_db_query", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mysql_db_query(a0, a1));
  else return (x_mysql_db_query(a0, a1, a2));
}
Variant ei_imagecolorclosestalpha(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 5) return throw_wrong_arguments("imagecolorclosestalpha", count, 5, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecolorclosestalpha(a0, a1, a2, a3, a4));
}
Variant ei_gzuncompress(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzuncompress", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzuncompress(a0));
  else return (x_gzuncompress(a0, a1));
}
Variant ei_is_executable(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_executable", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_executable(a0));
}
Variant ei_socket_create_listen(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("socket_create_listen", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_socket_create_listen(a0));
  else return (x_socket_create_listen(a0, a1));
}
Variant ei_pixelgetcolorcount(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("pixelgetcolorcount", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelgetcolorcount(a0));
}
Variant ei_magickqueryconfigureoptions(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("magickqueryconfigureoptions", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickqueryconfigureoptions(a0));
}
Variant ei_iptcembed(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("iptcembed", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_iptcembed(a0, a1));
  else return (x_iptcembed(a0, a1, a2));
}
Variant ei_posix_getgrnam(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("posix_getgrnam", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_posix_getgrnam(a0));
}
Variant ei_rtrim(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("rtrim", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_rtrim(a0));
  else return (x_rtrim(a0, a1));
}
Variant ei_print_r(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("print_r", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_print_r(a0));
  else return (x_print_r(a0, a1));
}
Variant ei_drawpathcurvetoquadraticbeziersmoothrelative(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 3) return throw_wrong_arguments("drawpathcurvetoquadraticbeziersmoothrelative", count, 3, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpathcurvetoquadraticbeziersmoothrelative(a0, a1, a2), null);
}
Variant ei_openssl_pkey_export(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) return throw_wrong_arguments("openssl_pkey_export", count, 2, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_openssl_pkey_export(a0, ref(a1)));
  else if (count == 3) return (x_openssl_pkey_export(a0, ref(a1), a2));
  else return (x_openssl_pkey_export(a0, ref(a1), a2, a3));
}
Variant ei_abs(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("abs", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_abs(a0));
}
Variant ei_restore_exception_handler(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("restore_exception_handler", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_restore_exception_handler());
}
Variant ei_shell_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("shell_exec", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_shell_exec(a0));
}
Variant ei_curl_multi_exec(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("curl_multi_exec", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = ref((*it)->refval(env));
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_curl_multi_exec(a0, ref(a1)));
}
Variant ei_htmlspecialchars(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) return throw_wrong_arguments("htmlspecialchars", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_htmlspecialchars(a0));
  else if (count == 2) return (x_htmlspecialchars(a0, a1));
  else if (count == 3) return (x_htmlspecialchars(a0, a1, a2));
  else return (x_htmlspecialchars(a0, a1, a2, a3));
}
Variant ei_imagexbm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("imagexbm", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_imagexbm(a0));
  else if (count == 2) return (x_imagexbm(a0, a1));
  else return (x_imagexbm(a0, a1, a2));
}
Variant ei_magickgetreleasedate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("magickgetreleasedate", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_magickgetreleasedate());
}
Variant ei_xbox_set_thread_timeout(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("xbox_set_thread_timeout", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xbox_set_thread_timeout(a0), null);
}
Variant ei_sem_remove(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("sem_remove", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_sem_remove(a0));
}
Variant ei_imageellipse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imageellipse", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imageellipse(a0, a1, a2, a3, a4, a5));
}
Variant ei_getprotobynumber(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("getprotobynumber", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_getprotobynumber(a0));
}
Variant ei_pixelsetopacity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("pixelsetopacity", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_pixelsetopacity(a0, a1), null);
}
Variant ei_lchgrp(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("lchgrp", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_lchgrp(a0, a1));
}
Variant ei_simplexml_load_file(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) return throw_wrong_arguments("simplexml_load_file", count, 1, 5, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_simplexml_load_file(a0));
  else if (count == 2) return (x_simplexml_load_file(a0, a1));
  else if (count == 3) return (x_simplexml_load_file(a0, a1, a2));
  else if (count == 4) return (x_simplexml_load_file(a0, a1, a2, a3));
  else return (x_simplexml_load_file(a0, a1, a2, a3, a4));
}
Variant ei_openssl_pkey_get_details(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("openssl_pkey_get_details", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_openssl_pkey_get_details(a0));
}
Variant ei_imagetypes(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) return throw_toomany_arguments("imagetypes", 0, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagetypes());
}
Variant ei_gzseek(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("gzseek", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_gzseek(a0, a1));
  else return (x_gzseek(a0, a1, a2));
}
Variant ei_magickgetmaxtextadvance(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 3 || count > 4) return throw_wrong_arguments("magickgetmaxtextadvance", count, 3, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 3) return (x_magickgetmaxtextadvance(a0, a1, a2));
  else return (x_magickgetmaxtextadvance(a0, a1, a2, a3));
}
Variant ei_func_get_arg(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("func_get_arg", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_func_get_arg(a0));
}
Variant ei_imagefilledrectangle(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("imagefilledrectangle", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagefilledrectangle(a0, a1, a2, a3, a4, a5));
}
Variant ei_drawpushpattern(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 6) return throw_wrong_arguments("drawpushpattern", count, 6, 6, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_drawpushpattern(a0, a1, a2, a3, a4, a5), null);
}
Variant ei_xmlwriter_set_indent(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("xmlwriter_set_indent", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_xmlwriter_set_indent(a0, a1));
}
Variant ei_openssl_csr_get_subject(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("openssl_csr_get_subject", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_openssl_csr_get_subject(a0));
  else return (x_openssl_csr_get_subject(a0, a1));
}
Variant ei_is_numeric(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("is_numeric", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_is_numeric(a0));
}
Variant ei_gzdeflate(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("gzdeflate", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_gzdeflate(a0));
  else return (x_gzdeflate(a0, a1));
}
Variant ei_dns_check_record(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("dns_check_record", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_dns_check_record(a0));
  else return (x_dns_check_record(a0, a1));
}
Variant ei_magicknegateimage(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) return throw_wrong_arguments("magicknegateimage", count, 1, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_magicknegateimage(a0));
  else if (count == 2) return (x_magicknegateimage(a0, a1));
  else return (x_magicknegateimage(a0, a1, a2));
}
Variant ei_socket_last_error(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("socket_last_error", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_socket_last_error());
  else return (x_socket_last_error(a0));
}
Variant ei_create_function(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("create_function", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_create_function(a0, a1));
}
Variant ei_str_split(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) return throw_wrong_arguments("str_split", count, 1, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) return (x_str_split(a0));
  else return (x_str_split(a0, a1));
}
Variant ei_date_parse(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("date_parse", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_date_parse(a0));
}
Variant ei_imagecreatefromxpm(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) return throw_wrong_arguments("imagecreatefromxpm", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_imagecreatefromxpm(a0));
}
Variant ei_mysql_thread_id(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) return throw_toomany_arguments("mysql_thread_id", 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 0) return (x_mysql_thread_id());
  else return (x_mysql_thread_id(a0));
}
Variant ei_mb_encode_numericentity(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 3) return throw_wrong_arguments("mb_encode_numericentity", count, 2, 3, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 2) return (x_mb_encode_numericentity(a0, a1));
  else return (x_mb_encode_numericentity(a0, a1, a2));
}
Variant ei_fb_call_user_func_array_safe(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) return throw_wrong_arguments("fb_call_user_func_array_safe", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  return (x_fb_call_user_func_array_safe(a0, a1));
}
Variant Eval::invoke_from_eval_builtin(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 4095) {
    case 1:
      HASH_INVOKE_FROM_EVAL(0x4F7230DC25F0E001LL, magicknormalizeimage);
      break;
    case 2:
      HASH_INVOKE_FROM_EVAL(0x76C320EDB9B6E002LL, xmlwriter_flush);
      break;
    case 3:
      HASH_INVOKE_FROM_EVAL(0x7E0EC3E131BCA003LL, token_name);
      break;
    case 5:
      HASH_INVOKE_FROM_EVAL(0x20D579E7E4131005LL, imagecolorclosest);
      HASH_INVOKE_FROM_EVAL(0x18A0F1EE8E249005LL, msg_send);
      break;
    case 10:
      HASH_INVOKE_FROM_EVAL(0x555D7A3FB939300ALL, apache_setenv);
      break;
    case 11:
      HASH_INVOKE_FROM_EVAL(0x4FDCCE1C7754600BLL, ob_iconv_handler);
      break;
    case 13:
      HASH_INVOKE_FROM_EVAL(0x40FA17130FA7100DLL, openssl_seal);
      break;
    case 22:
      HASH_INVOKE_FROM_EVAL(0x5623A698A728F016LL, getlastmod);
      break;
    case 24:
      HASH_INVOKE_FROM_EVAL(0x4C915E3480E94018LL, mb_substr_count);
      break;
    case 26:
      HASH_INVOKE_FROM_EVAL(0x03834225EBBC101ALL, drawsettextundercolor);
      break;
    case 34:
      HASH_INVOKE_FROM_EVAL(0x145D42B2AB55D022LL, drawmatte);
      break;
    case 35:
      HASH_INVOKE_FROM_EVAL(0x35C74650867B7023LL, imagesetpixel);
      break;
    case 40:
      HASH_INVOKE_FROM_EVAL(0x601C5152277AE028LL, readfile);
      break;
    case 44:
      HASH_INVOKE_FROM_EVAL(0x464EB9B1F955202CLL, apc_add);
      break;
    case 45:
      HASH_INVOKE_FROM_EVAL(0x3BE730D90618202DLL, collator_sort_with_sort_keys);
      break;
    case 51:
      HASH_INVOKE_FROM_EVAL(0x48F35DFD653D7033LL, pclose);
      break;
    case 54:
      HASH_INVOKE_FROM_EVAL(0x32F23F206C394036LL, curl_setopt_array);
      break;
    case 55:
      HASH_INVOKE_FROM_EVAL(0x418D937957ECE037LL, tanh);
      break;
    case 59:
      HASH_INVOKE_FROM_EVAL(0x40329F2A6B84D03BLL, dom_node_lookup_prefix);
      break;
    case 62:
      HASH_INVOKE_FROM_EVAL(0x32E6E5D3CCE3703ELL, magickgetimagewidth);
      HASH_INVOKE_FROM_EVAL(0x43461C4D9130103ELL, exit);
      HASH_INVOKE_FROM_EVAL(0x67C1ED9B816E503ELL, md5_file);
      HASH_INVOKE_FROM_EVAL(0x497E31C70409603ELL, timezone_name_from_abbr);
      break;
    case 63:
      HASH_INVOKE_FROM_EVAL(0x24206A195B9C203FLL, ucfirst);
      break;
    case 65:
      HASH_INVOKE_FROM_EVAL(0x65B39B11F5D7C041LL, array_unique);
      break;
    case 67:
      HASH_INVOKE_FROM_EVAL(0x5ACCF9166CD9D043LL, ftruncate);
      break;
    case 68:
      HASH_INVOKE_FROM_EVAL(0x378A73FF98B60044LL, curl_init);
      break;
    case 73:
      HASH_INVOKE_FROM_EVAL(0x047A8BF04DB51049LL, range);
      HASH_INVOKE_FROM_EVAL(0x4282E0231F600049LL, fseek);
      break;
    case 75:
      HASH_INVOKE_FROM_EVAL(0x17CD0E68E778C04BLL, drawsetstrokelinejoin);
      HASH_INVOKE_FROM_EVAL(0x6370CF455EA8604BLL, socket_create);
      break;
    case 76:
      HASH_INVOKE_FROM_EVAL(0x7848970191D5A04CLL, mysql_connect_with_db);
      HASH_INVOKE_FROM_EVAL(0x03047FD5FC67204CLL, exif_read_data);
      break;
    case 83:
      HASH_INVOKE_FROM_EVAL(0x15A9EB33DA6E9053LL, getimagesize);
      HASH_INVOKE_FROM_EVAL(0x07EB5C3A3BEA3053LL, acosh);
      break;
    case 87:
      HASH_INVOKE_FROM_EVAL(0x12B22A2E6B344057LL, ldap_sort);
      break;
    case 90:
      HASH_INVOKE_FROM_EVAL(0x271AB768D202F05ALL, mcrypt_module_is_block_algorithm);
      break;
    case 92:
      HASH_INVOKE_FROM_EVAL(0x2B7532A070BF605CLL, openssl_get_privatekey);
      break;
    case 95:
      HASH_INVOKE_FROM_EVAL(0x4B70746F965E705FLL, preg_last_error);
      break;
    case 98:
      HASH_INVOKE_FROM_EVAL(0x745910AD5C922062LL, magickgetmimetype);
      break;
    case 100:
      HASH_INVOKE_FROM_EVAL(0x5CC8BA5ADFAC0064LL, imagegrabscreen);
      break;
    case 101:
      HASH_INVOKE_FROM_EVAL(0x777FE52584FAE065LL, apc_bin_dump);
      break;
    case 103:
      HASH_INVOKE_FROM_EVAL(0x0CE1918B30DF5067LL, sys_getloadavg);
      HASH_INVOKE_FROM_EVAL(0x4512BD5EA7076067LL, openssl_csr_export_to_file);
      break;
    case 111:
      HASH_INVOKE_FROM_EVAL(0x4C6FD8808A62506FLL, session_set_save_handler);
      break;
    case 112:
      HASH_INVOKE_FROM_EVAL(0x3C466098FF7B5070LL, mb_check_encoding);
      break;
    case 120:
      HASH_INVOKE_FROM_EVAL(0x6B268C26E21C1078LL, arsort);
      HASH_INVOKE_FROM_EVAL(0x01AE1DE8FA116078LL, call_user_func_array_async);
      break;
    case 121:
      HASH_INVOKE_FROM_EVAL(0x08AA4EA901C9B079LL, session_encode);
      break;
    case 122:
      HASH_INVOKE_FROM_EVAL(0x5F9DDC342A83807ALL, date_default_timezone_get);
      break;
    case 131:
      HASH_INVOKE_FROM_EVAL(0x1A90213EE1A56083LL, array_pop);
      break;
    case 132:
      HASH_INVOKE_FROM_EVAL(0x53FD8C9AC3F4D084LL, dangling_server_proxy_new_request);
      break;
    case 135:
      HASH_INVOKE_FROM_EVAL(0x255D919D501C5087LL, dom_characterdata_delete_data);
      break;
    case 137:
      HASH_INVOKE_FROM_EVAL(0x4AD554CBAB9CC089LL, call_user_method_array);
      break;
    case 140:
      HASH_INVOKE_FROM_EVAL(0x4F1D1ED7B087208CLL, exec);
      HASH_INVOKE_FROM_EVAL(0x3A0B58797E8FE08CLL, xml_set_external_entity_ref_handler);
      break;
    case 141:
      HASH_INVOKE_FROM_EVAL(0x200864F8F053C08DLL, magickgetversionstring);
      break;
    case 142:
      HASH_INVOKE_FROM_EVAL(0x3E4AE974AFA9708ELL, pixelsetquantumcolor);
      break;
    case 145:
      HASH_INVOKE_FROM_EVAL(0x3E5CF6378A49C091LL, ldap_get_attributes);
      HASH_INVOKE_FROM_EVAL(0x673B36244DC87091LL, closelog);
      HASH_INVOKE_FROM_EVAL(0x1C32BB63986C8091LL, socket_strerror);
      break;
    case 147:
      HASH_INVOKE_FROM_EVAL(0x3B5E32078E37A093LL, imagedestroy);
      break;
    case 158:
      HASH_INVOKE_FROM_EVAL(0x4AF87BA91163D09ELL, mysql_db_name);
      HASH_INVOKE_FROM_EVAL(0x74F0D6D8F1F2709ELL, drawsetstrokedashoffset);
      break;
    case 159:
      HASH_INVOKE_FROM_EVAL(0x2B130322DEC4B09FLL, pixelgetopacityquantum);
      break;
    case 161:
      HASH_INVOKE_FROM_EVAL(0x0DF945F12533F0A1LL, abs);
      break;
    case 162:
      HASH_INVOKE_FROM_EVAL(0x10DF7941C3F3E0A2LL, socket_bind);
      break;
    case 163:
      HASH_INVOKE_FROM_EVAL(0x54242D2846BC60A3LL, magickunsharpmaskimage);
      break;
    case 167:
      HASH_INVOKE_FROM_EVAL(0x74C787060F7290A7LL, icu_transliterate);
      break;
    case 168:
      HASH_INVOKE_FROM_EVAL(0x6E8C61326DCE40A8LL, var_export);
      break;
    case 171:
      HASH_INVOKE_FROM_EVAL(0x439DF153FC32D0ABLL, printf);
      HASH_INVOKE_FROM_EVAL(0x5B1D9F56698A40ABLL, html_entity_decode);
      break;
    case 172:
      HASH_INVOKE_FROM_EVAL(0x6E27DC1E74C5B0ACLL, drawpathstart);
      break;
    case 173:
      HASH_INVOKE_FROM_EVAL(0x4C9252FB9C3300ADLL, pixelsetalphaquantum);
      break;
    case 174:
      HASH_INVOKE_FROM_EVAL(0x47AB4A08446BD0AELL, bcmod);
      HASH_INVOKE_FROM_EVAL(0x4BBD5D8A6E0110AELL, error_log);
      break;
    case 175:
      HASH_INVOKE_FROM_EVAL(0x3954FFED1E0650AFLL, stream_register_wrapper);
      break;
    case 176:
      HASH_INVOKE_FROM_EVAL(0x5B9F8B3E1D8330B0LL, stream_socket_sendto);
      break;
    case 177:
      HASH_INVOKE_FROM_EVAL(0x191B5F1B190BC0B1LL, dom_xpath_register_ns);
      break;
    case 178:
      HASH_INVOKE_FROM_EVAL(0x48BBFB59FB7F90B2LL, iconv_strlen);
      break;
    case 184:
      HASH_INVOKE_FROM_EVAL(0x05A4C165810A30B8LL, gzread);
      break;
    case 185:
      HASH_INVOKE_FROM_EVAL(0x5C659372B2CD80B9LL, imagecolorstotal);
      break;
    case 187:
      HASH_INVOKE_FROM_EVAL(0x331E7DFBE6E240BBLL, libxml_get_errors);
      break;
    case 188:
      HASH_INVOKE_FROM_EVAL(0x3900350CD9D990BCLL, imagecreatefromjpeg);
      break;
    case 192:
      HASH_INVOKE_FROM_EVAL(0x6EDC1E7A8D5710C0LL, memcache_add_server);
      break;
    case 197:
      HASH_INVOKE_FROM_EVAL(0x7424946F7ED520C5LL, magickgetimagefilename);
      HASH_INVOKE_FROM_EVAL(0x6B477F3B9CDB10C5LL, base64_decode);
      break;
    case 199:
      HASH_INVOKE_FROM_EVAL(0x677F33E78342A0C7LL, function_exists);
      break;
    case 200:
      HASH_INVOKE_FROM_EVAL(0x30AB38D851C440C8LL, magickgetimagebackgroundcolor);
      break;
    case 202:
      HASH_INVOKE_FROM_EVAL(0x2EE0967F6EB5A0CALL, date_format);
      HASH_INVOKE_FROM_EVAL(0x4C67DEE74080E0CALL, magicksetimagecompose);
      break;
    case 206:
      HASH_INVOKE_FROM_EVAL(0x64E390E5F2FDC0CELL, ismagickwand);
      break;
    case 210:
      HASH_INVOKE_FROM_EVAL(0x7D1FAF3322A360D2LL, hphp_splfileobject___construct);
      HASH_INVOKE_FROM_EVAL(0x5365BD7509BE60D2LL, ldap_dn2ufn);
      HASH_INVOKE_FROM_EVAL(0x3E4DAD592CD0A0D2LL, magickdescribeimage);
      break;
    case 213:
      HASH_INVOKE_FROM_EVAL(0x3BF44C6DECD790D5LL, xmlwriter_start_dtd_entity);
      break;
    case 216:
      HASH_INVOKE_FROM_EVAL(0x79F2E516A3B070D8LL, libxml_disable_entity_loader);
      break;
    case 217:
      HASH_INVOKE_FROM_EVAL(0x08F6B727D60670D9LL, magicksetimagedepth);
      break;
    case 218:
      HASH_INVOKE_FROM_EVAL(0x6F242340B2E930DALL, hphp_splfileinfo_setfileclass);
      break;
    case 219:
      HASH_INVOKE_FROM_EVAL(0x3801923AD84670DBLL, apc_inc);
      break;
    case 224:
      HASH_INVOKE_FROM_EVAL(0x2E4612DF112010E0LL, imagecopyresized);
      break;
    case 228:
      HASH_INVOKE_FROM_EVAL(0x2B9425038D4230E4LL, imagecreatefromxpm);
      break;
    case 231:
      HASH_INVOKE_FROM_EVAL(0x79E6FD78989B10E7LL, tmpfile);
      HASH_INVOKE_FROM_EVAL(0x59DE3A26AFF570E7LL, magickshaveimage);
      break;
    case 232:
      HASH_INVOKE_FROM_EVAL(0x476F4B6CC987E0E8LL, magickframeimage);
      HASH_INVOKE_FROM_EVAL(0x17CB328F55FDF0E8LL, drawsetstrokeantialias);
      break;
    case 234:
      HASH_INVOKE_FROM_EVAL(0x53BA3992F8C240EALL, imagegrabwindow);
      break;
    case 243:
      HASH_INVOKE_FROM_EVAL(0x315CCBC8C5C7D0F3LL, xmlwriter_write_raw);
      break;
    case 249:
      HASH_INVOKE_FROM_EVAL(0x480797DB7165A0F9LL, xmlwriter_set_indent);
      break;
    case 259:
      HASH_INVOKE_FROM_EVAL(0x1FFCBCF1927D7103LL, posix_setpgid);
      break;
    case 261:
      HASH_INVOKE_FROM_EVAL(0x71E3372AA1AD0105LL, is_infinite);
      HASH_INVOKE_FROM_EVAL(0x509B763CDAD9D105LL, gethostbyaddr);
      break;
    case 264:
      HASH_INVOKE_FROM_EVAL(0x60B8B61133F59108LL, quoted_printable_decode);
      break;
    case 267:
      HASH_INVOKE_FROM_EVAL(0x7DE1BEE0C35D010BLL, pcntl_signal);
      break;
    case 272:
      HASH_INVOKE_FROM_EVAL(0x16B481D0DEA32110LL, call_user_func_async);
      break;
    case 273:
      HASH_INVOKE_FROM_EVAL(0x3A9A5D4FEE79A111LL, getmxrr);
      break;
    case 274:
      HASH_INVOKE_FROM_EVAL(0x0B1BA48B0CFB1112LL, strval);
      HASH_INVOKE_FROM_EVAL(0x28C44527BD59D112LL, is_link);
      break;
    case 276:
      HASH_INVOKE_FROM_EVAL(0x02A4724E6A881114LL, mb_decode_numericentity);
      break;
    case 281:
      HASH_INVOKE_FROM_EVAL(0x3AB82455A70F5119LL, imagecolortransparent);
      HASH_INVOKE_FROM_EVAL(0x2B31A877824A1119LL, stristr);
      break;
    case 284:
      HASH_INVOKE_FROM_EVAL(0x070A63F6A0B8711CLL, array_walk_recursive);
      break;
    case 285:
      HASH_INVOKE_FROM_EVAL(0x291088666B8BF11DLL, drawsetfontfamily);
      break;
    case 286:
      HASH_INVOKE_FROM_EVAL(0x658444BB4E29E11ELL, openssl_free_key);
      break;
    case 287:
      HASH_INVOKE_FROM_EVAL(0x4C70C24C84F5511FLL, magicksetimagegamma);
      break;
    case 291:
      HASH_INVOKE_FROM_EVAL(0x3669138315204123LL, mcrypt_module_get_algo_key_size);
      break;
    case 292:
      HASH_INVOKE_FROM_EVAL(0x7D4D28D561392124LL, drawsettextalignment);
      break;
    case 293:
      HASH_INVOKE_FROM_EVAL(0x7A8B3EC0235EF125LL, magickprofileimage);
      break;
    case 301:
      HASH_INVOKE_FROM_EVAL(0x7579DBE83CE5812DLL, imagerectangle);
      break;
    case 307:
      HASH_INVOKE_FROM_EVAL(0x6A7E0B15FF689133LL, mb_ereg_search_init);
      break;
    case 311:
      HASH_INVOKE_FROM_EVAL(0x5666016FA3C0F137LL, socket_clear_error);
      break;
    case 312:
      HASH_INVOKE_FROM_EVAL(0x2676902697E37138LL, xmlwriter_start_comment);
      break;
    case 314:
      HASH_INVOKE_FROM_EVAL(0x2A57E5D29D73D13ALL, register_tick_function);
      break;
    case 315:
      HASH_INVOKE_FROM_EVAL(0x1F61AFCDC510413BLL, imagefilter);
      break;
    case 319:
      HASH_INVOKE_FROM_EVAL(0x5BFDE63106CE713FLL, dom_element_get_attribute);
      break;
    case 323:
      HASH_INVOKE_FROM_EVAL(0x296C739F28D6C143LL, drawsetfontsize);
      break;
    case 335:
      HASH_INVOKE_FROM_EVAL(0x61A61E91C477514FLL, chop);
      HASH_INVOKE_FROM_EVAL(0x7863294A8F33D14FLL, file);
      break;
    case 337:
      HASH_INVOKE_FROM_EVAL(0x3044E9F91628E151LL, mb_strlen);
      break;
    case 338:
      HASH_INVOKE_FROM_EVAL(0x5D170BCBBBA02152LL, system);
      HASH_INVOKE_FROM_EVAL(0x26DD46D8C1F47152LL, ldap_bind);
      break;
    case 341:
      HASH_INVOKE_FROM_EVAL(0x2623917110168155LL, fclose);
      HASH_INVOKE_FROM_EVAL(0x4F43FE32079C0155LL, magickgetimagesblob);
      break;
    case 347:
      HASH_INVOKE_FROM_EVAL(0x3711AF36391EA15BLL, mysql_list_tables);
      break;
    case 348:
      HASH_INVOKE_FROM_EVAL(0x6CD7466174B9A15CLL, pixelsetredquantum);
      break;
    case 349:
      HASH_INVOKE_FROM_EVAL(0x517941D034E3015DLL, iterator_to_array);
      break;
    case 353:
      HASH_INVOKE_FROM_EVAL(0x309E780586D6C161LL, socket_set_nonblock);
      break;
    case 355:
      HASH_INVOKE_FROM_EVAL(0x36D6B73D289DD163LL, date_sunset);
      break;
    case 360:
      HASH_INVOKE_FROM_EVAL(0x14E46EA3CBCFB168LL, magickgetsamplingfactors);
      break;
    case 361:
      HASH_INVOKE_FROM_EVAL(0x4983571BFEAE6169LL, magickaffinetransformimage);
      HASH_INVOKE_FROM_EVAL(0x1612E331D1726169LL, drawsetstrokecolor);
      break;
    case 366:
      HASH_INVOKE_FROM_EVAL(0x15B61E061268B16ELL, magickenhanceimage);
      HASH_INVOKE_FROM_EVAL(0x0125F8B9428E416ELL, hphp_create_object);
      break;
    case 370:
      HASH_INVOKE_FROM_EVAL(0x59FE6A862E1CB172LL, get_browser);
      break;
    case 372:
      HASH_INVOKE_FROM_EVAL(0x345E070844E3F174LL, create_function);
      break;
    case 375:
      HASH_INVOKE_FROM_EVAL(0x174DB93CAF0D1177LL, hphp_splfileinfo___tostring);
      break;
    case 377:
      HASH_INVOKE_FROM_EVAL(0x6884FAF0D1EF3179LL, posix_mknod);
      break;
    case 379:
      HASH_INVOKE_FROM_EVAL(0x59594143EFC7617BLL, mcrypt_module_open);
      break;
    case 380:
      HASH_INVOKE_FROM_EVAL(0x3E1343B4A3AD717CLL, magickgettextascent);
      break;
    case 383:
      HASH_INVOKE_FROM_EVAL(0x4EF9496D16F9D17FLL, xmlwriter_start_element_ns);
      break;
    case 385:
      HASH_INVOKE_FROM_EVAL(0x2227E30BAB23B181LL, dom_xpath_query);
      HASH_INVOKE_FROM_EVAL(0x1CBD3B58296C8181LL, xmlwriter_write_dtd);
      break;
    case 386:
      HASH_INVOKE_FROM_EVAL(0x7BB7C27B2C118182LL, get_magic_quotes_gpc);
      HASH_INVOKE_FROM_EVAL(0x130B62A8C77F3182LL, mb_ereg_search_getregs);
      break;
    case 389:
      HASH_INVOKE_FROM_EVAL(0x13E90F8874839185LL, ob_get_status);
      HASH_INVOKE_FROM_EVAL(0x54DB5DC6A069A185LL, hphp_get_class_info);
      break;
    case 390:
      HASH_INVOKE_FROM_EVAL(0x5DB5E45860801186LL, openssl_csr_export);
      break;
    case 391:
      HASH_INVOKE_FROM_EVAL(0x1BC448670BA4E187LL, iconv_strpos);
      break;
    case 393:
      HASH_INVOKE_FROM_EVAL(0x0CC53B2F0D38D189LL, timezone_offset_get);
      break;
    case 402:
      HASH_INVOKE_FROM_EVAL(0x07B5BF934F6EA192LL, imagesettile);
      break;
    case 407:
      HASH_INVOKE_FROM_EVAL(0x15AD9CE061C75197LL, timezone_transitions_get);
      break;
    case 409:
      HASH_INVOKE_FROM_EVAL(0x0CE71BC3B75D8199LL, mb_strimwidth);
      break;
    case 411:
      HASH_INVOKE_FROM_EVAL(0x7FF6C2A693CE119BLL, magickcyclecolormapimage);
      HASH_INVOKE_FROM_EVAL(0x74F20C284227219BLL, similar_text);
      break;
    case 416:
      HASH_INVOKE_FROM_EVAL(0x6FB5104FC97A31A0LL, drawpathcurvetorelative);
      break;
    case 418:
      HASH_INVOKE_FROM_EVAL(0x6DFC0765EBAB81A2LL, mcrypt_decrypt);
      HASH_INVOKE_FROM_EVAL(0x2A9015499A2EB1A2LL, fnmatch);
      HASH_INVOKE_FROM_EVAL(0x615723D21421A1A2LL, sem_remove);
      break;
    case 419:
      HASH_INVOKE_FROM_EVAL(0x735B81C45C2971A3LL, drawgetfillopacity);
      break;
    case 422:
      HASH_INVOKE_FROM_EVAL(0x37B4612178EF91A6LL, memcache_get_version);
      break;
    case 425:
      HASH_INVOKE_FROM_EVAL(0x740DC7FFAD8BB1A9LL, imagecolorat);
      HASH_INVOKE_FROM_EVAL(0x0DDFE3B1F6EEE1A9LL, array_reduce);
      break;
    case 426:
      HASH_INVOKE_FROM_EVAL(0x11A5C66A3D0711AALL, apc_sma_info);
      break;
    case 429:
      HASH_INVOKE_FROM_EVAL(0x5A6EFF8C71A431ADLL, socket_get_status);
      HASH_INVOKE_FROM_EVAL(0x50538F37398AF1ADLL, ldap_get_option);
      break;
    case 431:
      HASH_INVOKE_FROM_EVAL(0x5B1F9C2E9FE111AFLL, fb_utf8ize);
      break;
    case 434:
      HASH_INVOKE_FROM_EVAL(0x4B96F870584541B2LL, hphp_splfileobject_setflags);
      break;
    case 438:
      HASH_INVOKE_FROM_EVAL(0x33BD672B4AC301B6LL, mt_rand);
      break;
    case 445:
      HASH_INVOKE_FROM_EVAL(0x589F7316EDC581BDLL, fb_serialize);
      HASH_INVOKE_FROM_EVAL(0x4B3F35310DEA31BDLL, socket_create_pair);
      break;
    case 447:
      HASH_INVOKE_FROM_EVAL(0x0E88ACEB15A581BFLL, magickgetimageextrema);
      HASH_INVOKE_FROM_EVAL(0x681CD0E7D9DB71BFLL, pow);
      break;
    case 450:
      HASH_INVOKE_FROM_EVAL(0x02103322F88C71C2LL, pixelgetcolorcount);
      break;
    case 452:
      HASH_INVOKE_FROM_EVAL(0x3617DAE43A23D1C4LL, xml_parser_set_option);
      break;
    case 454:
      HASH_INVOKE_FROM_EVAL(0x188D37410B6051C6LL, session_unregister);
      break;
    case 455:
      HASH_INVOKE_FROM_EVAL(0x5AE12CB1FFDC21C7LL, drawellipse);
      break;
    case 456:
      HASH_INVOKE_FROM_EVAL(0x11C0B5DA066891C8LL, preg_match_all);
      break;
    case 458:
      HASH_INVOKE_FROM_EVAL(0x75CA86838D24A1CALL, hash_algos);
      break;
    case 460:
      HASH_INVOKE_FROM_EVAL(0x3DF488365DAAF1CCLL, drawgettextencoding);
      break;
    case 461:
      HASH_INVOKE_FROM_EVAL(0x37340B707E7CD1CDLL, magickgetimagebordercolor);
      break;
    case 462:
      HASH_INVOKE_FROM_EVAL(0x2E7741B5440FB1CELL, magicksetlastiterator);
      break;
    case 464:
      HASH_INVOKE_FROM_EVAL(0x03012F3DDD7AB1D0LL, getservbyport);
      break;
    case 468:
      HASH_INVOKE_FROM_EVAL(0x219F3257BA3371D4LL, decbin);
      break;
    case 470:
      HASH_INVOKE_FROM_EVAL(0x78831282736801D6LL, stream_context_get_default);
      break;
    case 472:
      HASH_INVOKE_FROM_EVAL(0x60E9E392663921D8LL, readlink);
      break;
    case 473:
      HASH_INVOKE_FROM_EVAL(0x7A69D0078F4F31D9LL, ldap_start_tls);
      break;
    case 474:
      HASH_INVOKE_FROM_EVAL(0x0482E069503A91DALL, posix_setgid);
      break;
    case 475:
      HASH_INVOKE_FROM_EVAL(0x3FEBBC0DA79F31DBLL, fb_call_user_func_safe);
      break;
    case 476:
      HASH_INVOKE_FROM_EVAL(0x14FB46333D6D11DCLL, xml_set_default_handler);
      HASH_INVOKE_FROM_EVAL(0x5B3A4A72846B21DCLL, current);
      break;
    case 477:
      HASH_INVOKE_FROM_EVAL(0x04666D6F67C7A1DDLL, mysql_list_processes);
      HASH_INVOKE_FROM_EVAL(0x03A183D73942B1DDLL, apc_filehits);
      break;
    case 478:
      HASH_INVOKE_FROM_EVAL(0x44563CC8FA9B11DELL, memcache_set_server_params);
      break;
    case 479:
      HASH_INVOKE_FROM_EVAL(0x7403251412E931DFLL, syslog);
      break;
    case 480:
      HASH_INVOKE_FROM_EVAL(0x5932D2750A8A91E0LL, magickgetpackagename);
      break;
    case 481:
      HASH_INVOKE_FROM_EVAL(0x2771C632A60371E1LL, ftok);
      HASH_INVOKE_FROM_EVAL(0x0ED729A444C611E1LL, openssl_x509_read);
      break;
    case 482:
      HASH_INVOKE_FROM_EVAL(0x67D4BA8513BF41E2LL, newpixelwand);
      break;
    case 483:
      HASH_INVOKE_FROM_EVAL(0x131D11F79A8801E3LL, mb_http_output);
      HASH_INVOKE_FROM_EVAL(0x406BDC51A3FD81E3LL, pcntl_waitpid);
      break;
    case 484:
      HASH_INVOKE_FROM_EVAL(0x08F7A6C37FC7B1E4LL, shm_get_var);
      break;
    case 488:
      HASH_INVOKE_FROM_EVAL(0x7F843353646391E8LL, rad2deg);
      break;
    case 493:
      HASH_INVOKE_FROM_EVAL(0x1B09A9A533FFA1EDLL, drawgetexceptiontype);
      HASH_INVOKE_FROM_EVAL(0x19932EEC5CAE01EDLL, hphp_splfileinfo_getfileinfo);
      break;
    case 497:
      HASH_INVOKE_FROM_EVAL(0x02BCE5B0FBED61F1LL, strlen);
      break;
    case 498:
      HASH_INVOKE_FROM_EVAL(0x46AFE55982B371F2LL, posix_geteuid);
      break;
    case 499:
      HASH_INVOKE_FROM_EVAL(0x582D10141D5601F3LL, stream_context_set_option);
      HASH_INVOKE_FROM_EVAL(0x11BB3CDC5E4971F3LL, xmlwriter_end_pi);
      break;
    case 501:
      HASH_INVOKE_FROM_EVAL(0x542FBDCF960031F5LL, fprintf);
      HASH_INVOKE_FROM_EVAL(0x02ABC00C046291F5LL, imageellipse);
      break;
    case 502:
      HASH_INVOKE_FROM_EVAL(0x06DAF95935D221F6LL, dom_namednodemap_item);
      break;
    case 506:
      HASH_INVOKE_FROM_EVAL(0x135D5CBF936B11FALL, msg_receive);
      break;
    case 509:
      HASH_INVOKE_FROM_EVAL(0x5304E6B47ED0B1FDLL, srand);
      break;
    case 514:
      HASH_INVOKE_FROM_EVAL(0x16699E33370A8202LL, idn_to_unicode);
      break;
    case 515:
      HASH_INVOKE_FROM_EVAL(0x5B3C354575BB8203LL, mysql_free_result);
      break;
    case 520:
      HASH_INVOKE_FROM_EVAL(0x7B525920E026C208LL, gztell);
      break;
    case 523:
      HASH_INVOKE_FROM_EVAL(0x2F5144AB3647C20BLL, dom_text_is_whitespace_in_element_content);
      break;
    case 524:
      HASH_INVOKE_FROM_EVAL(0x41B15671649A320CLL, curl_multi_getcontent);
      HASH_INVOKE_FROM_EVAL(0x257BEA4D6DC9920CLL, ctype_alnum);
      break;
    case 525:
      HASH_INVOKE_FROM_EVAL(0x5C0DECC8CC67E20DLL, magickwriteimagesfile);
      break;
    case 526:
      HASH_INVOKE_FROM_EVAL(0x533642044A00520ELL, pixelgetmagentaquantum);
      break;
    case 527:
      HASH_INVOKE_FROM_EVAL(0x08DC8BF3ADAE520FLL, getallheaders);
      HASH_INVOKE_FROM_EVAL(0x53631CF3A937320FLL, get_class_methods);
      break;
    case 528:
      HASH_INVOKE_FROM_EVAL(0x15EF510022CAF210LL, xml_parser_create_ns);
      HASH_INVOKE_FROM_EVAL(0x2D41D7F8F4113210LL, sinh);
      break;
    case 529:
      HASH_INVOKE_FROM_EVAL(0x438CD1A0327A8211LL, apc_define_constants);
      break;
    case 532:
      HASH_INVOKE_FROM_EVAL(0x7D85E9FACB92D214LL, magickgetimageblob);
      break;
    case 535:
      HASH_INVOKE_FROM_EVAL(0x4BC4B81CC5F32217LL, dom_node_append_child);
      break;
    case 536:
      HASH_INVOKE_FROM_EVAL(0x56C95225813A5218LL, memory_get_usage);
      HASH_INVOKE_FROM_EVAL(0x4D63F2C9AAB79218LL, fb_renamed_functions);
      break;
    case 538:
      HASH_INVOKE_FROM_EVAL(0x72C0C89D897E721ALL, magicksetimagetype);
      break;
    case 539:
      HASH_INVOKE_FROM_EVAL(0x3A90CC67D58A021BLL, hash_hmac_file);
      break;
    case 545:
      HASH_INVOKE_FROM_EVAL(0x345E2BAE171FA221LL, date_sunrise);
      break;
    case 546:
      HASH_INVOKE_FROM_EVAL(0x39E4E0175FADC222LL, drawskewx);
      break;
    case 547:
      HASH_INVOKE_FROM_EVAL(0x5208E8B08455E223LL, dom_node_has_child_nodes);
      break;
    case 550:
      HASH_INVOKE_FROM_EVAL(0x007B6BD94D767226LL, hphp_splfileobject_fpassthru);
      break;
    case 551:
      HASH_INVOKE_FROM_EVAL(0x5A26F00A81BA5227LL, xmlwriter_start_attribute_ns);
      break;
    case 552:
      HASH_INVOKE_FROM_EVAL(0x44911AEE34D63228LL, time_sleep_until);
      HASH_INVOKE_FROM_EVAL(0x7CD3C6F6495D3228LL, memcache_get_stats);
      break;
    case 556:
      HASH_INVOKE_FROM_EVAL(0x4129FFBF3548E22CLL, mb_strpos);
      break;
    case 558:
      HASH_INVOKE_FROM_EVAL(0x0B7559F53F31D22ELL, fb_stubout_intercept_handler);
      break;
    case 560:
      HASH_INVOKE_FROM_EVAL(0x036A5935D9936230LL, hphp_splfileinfo_openfile);
      break;
    case 561:
      HASH_INVOKE_FROM_EVAL(0x61A192D10C004231LL, magickconvolveimage);
      HASH_INVOKE_FROM_EVAL(0x7C07D66F70E43231LL, mailparse_determine_best_xfer_encoding);
      break;
    case 564:
      HASH_INVOKE_FROM_EVAL(0x23C478B2D95F3234LL, dom_element_has_attribute_ns);
      HASH_INVOKE_FROM_EVAL(0x422C51C95928A234LL, str_replace);
      break;
    case 566:
      HASH_INVOKE_FROM_EVAL(0x5542AABF33A2F236LL, stream_filter_remove);
      break;
    case 568:
      HASH_INVOKE_FROM_EVAL(0x695AC59F79E2A238LL, mb_encode_mimeheader);
      break;
    case 570:
      HASH_INVOKE_FROM_EVAL(0x679ABBE5A08C523ALL, xml_parse_into_struct);
      break;
    case 574:
      HASH_INVOKE_FROM_EVAL(0x5E54CE856B78223ELL, array_flip);
      break;
    case 576:
      HASH_INVOKE_FROM_EVAL(0x0DB9DD4AE24B0240LL, base64_encode);
      break;
    case 579:
      HASH_INVOKE_FROM_EVAL(0x78183A24F2ACB243LL, strtotime);
      break;
    case 584:
      HASH_INVOKE_FROM_EVAL(0x7071BB6F0591E248LL, serialize);
      break;
    case 589:
      HASH_INVOKE_FROM_EVAL(0x5E73B9F3B7C8224DLL, parse_hdf_string);
      break;
    case 591:
      HASH_INVOKE_FROM_EVAL(0x1D8FE8E68F7EA24FLL, pixelsetiteratorrow);
      break;
    case 592:
      HASH_INVOKE_FROM_EVAL(0x30747B708DA1D250LL, pushdrawingwand);
      break;
    case 598:
      HASH_INVOKE_FROM_EVAL(0x0384346A8857D256LL, clonemagickwand);
      break;
    case 600:
      HASH_INVOKE_FROM_EVAL(0x32C51FFF185F4258LL, memcache_set);
      break;
    case 603:
      HASH_INVOKE_FROM_EVAL(0x2F8F40E95EDF925BLL, sizeof);
      break;
    case 605:
      HASH_INVOKE_FROM_EVAL(0x7E6024E53AEEE25DLL, apc_delete);
      break;
    case 608:
      HASH_INVOKE_FROM_EVAL(0x71D2D4757B7E4260LL, apache_request_headers);
      break;
    case 609:
      HASH_INVOKE_FROM_EVAL(0x383800902035F261LL, apache_child_terminate);
      HASH_INVOKE_FROM_EVAL(0x48305E8ABB8BC261LL, hphp_instanceof);
      break;
    case 610:
      HASH_INVOKE_FROM_EVAL(0x63AC0EED6D946262LL, pcntl_fork);
      break;
    case 612:
      HASH_INVOKE_FROM_EVAL(0x261F403C4174D264LL, posix_getsid);
      break;
    case 613:
      HASH_INVOKE_FROM_EVAL(0x561DB8F1DC0BC265LL, magickseparateimagechannel);
      break;
    case 615:
      HASH_INVOKE_FROM_EVAL(0x50C5488E19492267LL, mb_list_encodings_alias_names);
      HASH_INVOKE_FROM_EVAL(0x38B376B9D9091267LL, xmlwriter_write_attribute);
      break;
    case 620:
      HASH_INVOKE_FROM_EVAL(0x188DF1EB5FD1B26CLL, mailparse_msg_parse_file);
      break;
    case 622:
      HASH_INVOKE_FROM_EVAL(0x5672949384A4F26ELL, stream_filter_register);
      break;
    case 626:
      HASH_INVOKE_FROM_EVAL(0x1C65F32FF28BC272LL, pathinfo);
      break;
    case 627:
      HASH_INVOKE_FROM_EVAL(0x61C991F216E85273LL, inet_ntop);
      HASH_INVOKE_FROM_EVAL(0x08CC1E49661DB273LL, dom_element_get_attribute_ns);
      break;
    case 634:
      HASH_INVOKE_FROM_EVAL(0x39E05F957C7DD27ALL, magickgetimagedepth);
      break;
    case 636:
      HASH_INVOKE_FROM_EVAL(0x0F7E33D551E0727CLL, posix_getpid);
      break;
    case 637:
      HASH_INVOKE_FROM_EVAL(0x7DB57C59E607627DLL, mcrypt_generic_deinit);
      break;
    case 638:
      HASH_INVOKE_FROM_EVAL(0x4111669F4862E27ELL, drawpathlinetoverticalrelative);
      break;
    case 639:
      HASH_INVOKE_FROM_EVAL(0x5B94A6962F1EC27FLL, magickechoimagesblob);
      HASH_INVOKE_FROM_EVAL(0x57E8781CF111727FLL, fileowner);
      break;
    case 640:
      HASH_INVOKE_FROM_EVAL(0x2E54EF1891172280LL, hphp_splfileinfo_isexecutable);
      break;
    case 641:
      HASH_INVOKE_FROM_EVAL(0x1765A2E5186DE281LL, socket_write);
      HASH_INVOKE_FROM_EVAL(0x0881440DCF5D3281LL, magickflattenimages);
      break;
    case 643:
      HASH_INVOKE_FROM_EVAL(0x4C83B098C8BDA283LL, posix_setsid);
      break;
    case 645:
      HASH_INVOKE_FROM_EVAL(0x5F7DC3612050A285LL, drawsetfontweight);
      HASH_INVOKE_FROM_EVAL(0x1A895A2307126285LL, openssl_pkcs7_decrypt);
      break;
    case 646:
      HASH_INVOKE_FROM_EVAL(0x3A2E2C40B019E286LL, is_a);
      HASH_INVOKE_FROM_EVAL(0x4F028FA6AAEEC286LL, call_user_method);
      break;
    case 647:
      HASH_INVOKE_FROM_EVAL(0x27698DDEDAD6E287LL, openssl_pkey_new);
      HASH_INVOKE_FROM_EVAL(0x23A1E13930E44287LL, xbox_schedule_thread_reset);
      break;
    case 656:
      HASH_INVOKE_FROM_EVAL(0x04C11602C720A290LL, convert_cyr_string);
      break;
    case 660:
      HASH_INVOKE_FROM_EVAL(0x4D05DD57E4052294LL, xmlwriter_output_memory);
      break;
    case 661:
      HASH_INVOKE_FROM_EVAL(0x69868C648BC12295LL, apc_store);
      break;
    case 665:
      HASH_INVOKE_FROM_EVAL(0x22D380E06E67E299LL, stream_encoding);
      HASH_INVOKE_FROM_EVAL(0x5665CB664C38A299LL, parse_ini_string);
      break;
    case 666:
      HASH_INVOKE_FROM_EVAL(0x68272A37CC9E729ALL, mb_strtolower);
      break;
    case 667:
      HASH_INVOKE_FROM_EVAL(0x4A09634AE6DFF29BLL, fileperms);
      break;
    case 668:
      HASH_INVOKE_FROM_EVAL(0x0F71D3E47044E29CLL, drawpathcurvetosmoothrelative);
      break;
    case 674:
      HASH_INVOKE_FROM_EVAL(0x1FBF8A270331C2A2LL, write_hdf_file);
      break;
    case 675:
      HASH_INVOKE_FROM_EVAL(0x10E7B5A0E29CF2A3LL, bcscale);
      HASH_INVOKE_FROM_EVAL(0x743EA4BF2CC8F2A3LL, mysql_field_type);
      break;
    case 678:
      HASH_INVOKE_FROM_EVAL(0x73EF3A19F76872A6LL, iconv_strrpos);
      break;
    case 680:
      HASH_INVOKE_FROM_EVAL(0x5409127FEDE332A8LL, exif_imagetype);
      break;
    case 685:
      HASH_INVOKE_FROM_EVAL(0x35D259398CDDA2ADLL, pixelgetredquantum);
      HASH_INVOKE_FROM_EVAL(0x00AB6FC4E9EE62ADLL, imagefilledrectangle);
      break;
    case 686:
      HASH_INVOKE_FROM_EVAL(0x36AB9E6AA687F2AELL, xmlwriter_start_dtd_element);
      break;
    case 691:
      HASH_INVOKE_FROM_EVAL(0x44530C37F2B522B3LL, drawgetstrokedasharray);
      HASH_INVOKE_FROM_EVAL(0x59BB7B8078AC22B3LL, tempnam);
      break;
    case 694:
      HASH_INVOKE_FROM_EVAL(0x0C4B98B47B0862B6LL, apd_echo);
      HASH_INVOKE_FROM_EVAL(0x0E9C9B409F94B2B6LL, setcookie);
      break;
    case 696:
      HASH_INVOKE_FROM_EVAL(0x3C6D50F3BB8102B8LL, next);
      break;
    case 698:
      HASH_INVOKE_FROM_EVAL(0x4A3D2113D3DFD2BALL, newpixelwandarray);
      break;
    case 700:
      HASH_INVOKE_FROM_EVAL(0x33E08846F3EB42BCLL, ldap_get_values);
      HASH_INVOKE_FROM_EVAL(0x41F7E2214DDE12BCLL, mcrypt_enc_self_test);
      break;
    case 701:
      HASH_INVOKE_FROM_EVAL(0x327C865E52FD12BDLL, ldap_get_values_len);
      break;
    case 702:
      HASH_INVOKE_FROM_EVAL(0x72D6F9B3661AB2BELL, magickgetimage);
      break;
    case 704:
      HASH_INVOKE_FROM_EVAL(0x5B7C1B74BA3452C0LL, newpixelregioniterator);
      break;
    case 707:
      HASH_INVOKE_FROM_EVAL(0x446D76A95365D2C3LL, pixelgetyellow);
      break;
    case 708:
      HASH_INVOKE_FROM_EVAL(0x6018C9F7DF40C2C4LL, xml_get_current_column_number);
      HASH_INVOKE_FROM_EVAL(0x1C7B8161F3C412C4LL, dom_document_create_document_fragment);
      break;
    case 716:
      HASH_INVOKE_FROM_EVAL(0x407EF03C23BF92CCLL, drawpathellipticarcabsolute);
      HASH_INVOKE_FROM_EVAL(0x44273F8BA3F542CCLL, imagesx);
      break;
    case 718:
      HASH_INVOKE_FROM_EVAL(0x1922D51F3E1522CELL, xmlwriter_end_dtd_attlist);
      break;
    case 719:
      HASH_INVOKE_FROM_EVAL(0x4ACE27EC476632CFLL, apc_bin_dumpfile);
      break;
    case 722:
      HASH_INVOKE_FROM_EVAL(0x4D9A87BD0CF742D2LL, imagepsextendfont);
      break;
    case 725:
      HASH_INVOKE_FROM_EVAL(0x4D04C580CF9212D5LL, posix_getgroups);
      break;
    case 726:
      HASH_INVOKE_FROM_EVAL(0x06E9C984B5F0B2D6LL, furchash_hphp_ext);
      break;
    case 728:
      HASH_INVOKE_FROM_EVAL(0x56C4896BA2FF52D8LL, drawsetstrokeopacity);
      break;
    case 730:
      HASH_INVOKE_FROM_EVAL(0x5C6A85B448C352DALL, posix_uname);
      break;
    case 733:
      HASH_INVOKE_FROM_EVAL(0x5F585DF7CB82E2DDLL, hphp_splfileinfo_iswritable);
      break;
    case 738:
      HASH_INVOKE_FROM_EVAL(0x4AEC19D75BF652E2LL, magickremoveimage);
      break;
    case 739:
      HASH_INVOKE_FROM_EVAL(0x45382D0BA5B262E3LL, mysql_get_proto_info);
      break;
    case 749:
      HASH_INVOKE_FROM_EVAL(0x1B9FC9E27B8AB2EDLL, memcache_flush);
      HASH_INVOKE_FROM_EVAL(0x215E0E2EFA7422EDLL, drawgetstrokeantialias);
      break;
    case 750:
      HASH_INVOKE_FROM_EVAL(0x5D43C0E4868EC2EELL, forward_static_call);
      HASH_INVOKE_FROM_EVAL(0x2884B7B3252B02EELL, imagealphablending);
      break;
    case 752:
      HASH_INVOKE_FROM_EVAL(0x25CA0794823AA2F0LL, openssl_csr_get_public_key);
      break;
    case 754:
      HASH_INVOKE_FROM_EVAL(0x2EE56D216BB832F2LL, time_nanosleep);
      break;
    case 756:
      HASH_INVOKE_FROM_EVAL(0x418EC805C5FD32F4LL, mcrypt_get_key_size);
      break;
    case 761:
      HASH_INVOKE_FROM_EVAL(0x00CFD56391DF82F9LL, mysql_data_seek);
      HASH_INVOKE_FROM_EVAL(0x319EF52B36AAB2F9LL, posix_isatty);
      break;
    case 763:
      HASH_INVOKE_FROM_EVAL(0x4D393D30CE1112FBLL, drawpathmovetoabsolute);
      break;
    case 764:
      HASH_INVOKE_FROM_EVAL(0x66D59E4DBC7382FCLL, drawscale);
      break;
    case 766:
      HASH_INVOKE_FROM_EVAL(0x208B66A8731F72FELL, sem_get);
      HASH_INVOKE_FROM_EVAL(0x755A9950B65472FELL, drawgetgravity);
      break;
    case 770:
      HASH_INVOKE_FROM_EVAL(0x0103FE1E2C307302LL, socket_recvfrom);
      break;
    case 772:
      HASH_INVOKE_FROM_EVAL(0x33A532FDB8EAC304LL, memcache_delete);
      break;
    case 773:
      HASH_INVOKE_FROM_EVAL(0x65D40C6B4842F305LL, clearpixelwand);
      break;
    case 774:
      HASH_INVOKE_FROM_EVAL(0x689D60184DD81306LL, htmlspecialchars_decode);
      break;
    case 777:
      HASH_INVOKE_FROM_EVAL(0x414038596F552309LL, magickgetversionnumber);
      HASH_INVOKE_FROM_EVAL(0x47CB27E8FDB60309LL, array_fill);
      break;
    case 779:
      HASH_INVOKE_FROM_EVAL(0x0C6F751411F5E30BLL, strrev);
      HASH_INVOKE_FROM_EVAL(0x65F586C35A88030BLL, magickresizeimage);
      HASH_INVOKE_FROM_EVAL(0x2D2BC1125ECA930BLL, dom_document_relaxng_validate_file);
      break;
    case 780:
      HASH_INVOKE_FROM_EVAL(0x553940FCE453330CLL, hphp_splfileobject_getmaxlinelen);
      break;
    case 785:
      HASH_INVOKE_FROM_EVAL(0x141EDCAE1D155311LL, xbox_get_thread_time);
      break;
    case 789:
      HASH_INVOKE_FROM_EVAL(0x4F1E663AE18FD315LL, msg_remove_queue);
      break;
    case 798:
      HASH_INVOKE_FROM_EVAL(0x27FF9DB54420531ELL, xml_error_string);
      break;
    case 804:
      HASH_INVOKE_FROM_EVAL(0x5E5E4F998C8E7324LL, pcntl_wifexited);
      break;
    case 808:
      HASH_INVOKE_FROM_EVAL(0x73FEB3BF75FFB328LL, ctype_space);
      break;
    case 811:
      HASH_INVOKE_FROM_EVAL(0x2BDB1EE3869E132BLL, restore_error_handler);
      break;
    case 815:
      HASH_INVOKE_FROM_EVAL(0x7DD6461A6290B32FLL, mysql_real_escape_string);
      break;
    case 816:
      HASH_INVOKE_FROM_EVAL(0x300F758BB0E16330LL, mysql_num_rows);
      HASH_INVOKE_FROM_EVAL(0x1601C1826E90B330LL, strptime);
      break;
    case 817:
      HASH_INVOKE_FROM_EVAL(0x00DAFE46631AE331LL, stream_set_timeout);
      break;
    case 818:
      HASH_INVOKE_FROM_EVAL(0x037055C215998332LL, bcsub);
      break;
    case 824:
      HASH_INVOKE_FROM_EVAL(0x549D51040C250338LL, cleardrawingwand);
      break;
    case 825:
      HASH_INVOKE_FROM_EVAL(0x48D57F17C5132339LL, drawgetclippath);
      break;
    case 826:
      HASH_INVOKE_FROM_EVAL(0x34DDF0DFC546033ALL, xbox_task_start);
      break;
    case 829:
      HASH_INVOKE_FROM_EVAL(0x4E166ECE0EC6A33DLL, openssl_pkey_get_public);
      break;
    case 830:
      HASH_INVOKE_FROM_EVAL(0x758EA7E9AA45C33ELL, xmlwriter_end_document);
      break;
    case 835:
      HASH_INVOKE_FROM_EVAL(0x6794CFB89DEEF343LL, curl_exec);
      break;
    case 836:
      HASH_INVOKE_FROM_EVAL(0x1A9DC76AB74F6344LL, openssl_verify);
      break;
    case 837:
      HASH_INVOKE_FROM_EVAL(0x45FAE3D08E96B345LL, curl_errno);
      break;
    case 838:
      HASH_INVOKE_FROM_EVAL(0x4B30FBA18042E346LL, session_cache_expire);
      break;
    case 842:
      HASH_INVOKE_FROM_EVAL(0x208BB4C3C0BA534ALL, xmlwriter_write_dtd_element);
      break;
    case 843:
      HASH_INVOKE_FROM_EVAL(0x3880550F6AD8034BLL, session_destroy);
      HASH_INVOKE_FROM_EVAL(0x57A9E8878872D34BLL, parse_ini_file);
      break;
    case 844:
      HASH_INVOKE_FROM_EVAL(0x0644E5FB91C8134CLL, array_udiff);
      break;
    case 845:
      HASH_INVOKE_FROM_EVAL(0x5998E61D600D634DLL, drawaffine);
      break;
    case 847:
      HASH_INVOKE_FROM_EVAL(0x4F2D0EFF0D4B534FLL, fb_get_taint);
      HASH_INVOKE_FROM_EVAL(0x5C8B3B9FA833934FLL, ldap_first_attribute);
      break;
    case 849:
      HASH_INVOKE_FROM_EVAL(0x2B422699C3A57351LL, sha1);
      break;
    case 852:
      HASH_INVOKE_FROM_EVAL(0x501F4DF5C8997354LL, hphp_get_property);
      HASH_INVOKE_FROM_EVAL(0x77EB4D2F5BDDB354LL, magickgetimageresolution);
      break;
    case 858:
      HASH_INVOKE_FROM_EVAL(0x4BF5DEBDB76EC35ALL, mcrypt_enc_get_iv_size);
      HASH_INVOKE_FROM_EVAL(0x0E0C79E42812235ALL, imagepng);
      break;
    case 859:
      HASH_INVOKE_FROM_EVAL(0x1AC48909BEEF935BLL, func_get_arg);
      break;
    case 861:
      HASH_INVOKE_FROM_EVAL(0x54C3E9AB6FB8E35DLL, magickswirlimage);
      break;
    case 863:
      HASH_INVOKE_FROM_EVAL(0x280DE04F84FB235FLL, popdrawingwand);
      break;
    case 869:
      HASH_INVOKE_FROM_EVAL(0x68DBF8ABB26A8365LL, hphp_directoryiterator_rewind);
      break;
    case 870:
      HASH_INVOKE_FROM_EVAL(0x4EF3469306E44366LL, floatval);
      break;
    case 871:
      HASH_INVOKE_FROM_EVAL(0x4810A9774785C367LL, posix_getpgrp);
      break;
    case 872:
      HASH_INVOKE_FROM_EVAL(0x5D406167C673D368LL, magickcompareimages);
      break;
    case 873:
      HASH_INVOKE_FROM_EVAL(0x6C715D7DD63DA369LL, is_integer);
      break;
    case 878:
      HASH_INVOKE_FROM_EVAL(0x7CE90898E882F36ELL, pixelsetyellow);
      break;
    case 882:
      HASH_INVOKE_FROM_EVAL(0x7107AE03689F5372LL, hphp_invoke);
      break;
    case 888:
      HASH_INVOKE_FROM_EVAL(0x34BAEFD8AE59D378LL, hphp_set_error_page);
      break;
    case 889:
      HASH_INVOKE_FROM_EVAL(0x5ED8901DB5D14379LL, magickcharcoalimage);
      break;
    case 890:
      HASH_INVOKE_FROM_EVAL(0x69EA8DC005FEC37ALL, hphp_splfileobject_fwrite);
      break;
    case 893:
      HASH_INVOKE_FROM_EVAL(0x7C40E2514FB5437DLL, dom_namednodemap_get_named_item_ns);
      break;
    case 900:
      HASH_INVOKE_FROM_EVAL(0x44C1BC500D175384LL, wandgetexception);
      break;
    case 901:
      HASH_INVOKE_FROM_EVAL(0x7C5CA3E2E3C8F385LL, magickflipimage);
      HASH_INVOKE_FROM_EVAL(0x57554E082E0ED385LL, pcntl_exec);
      HASH_INVOKE_FROM_EVAL(0x0B0B8765A4CDD385LL, hphp_splfileobject_fgets);
      break;
    case 902:
      HASH_INVOKE_FROM_EVAL(0x589E24C7664D5386LL, doubleval);
      break;
    case 904:
      HASH_INVOKE_FROM_EVAL(0x791E946E04F50388LL, magicksetresourcelimit);
      break;
    case 907:
      HASH_INVOKE_FROM_EVAL(0x32354CC291ECF38BLL, fb_intercept);
      HASH_INVOKE_FROM_EVAL(0x73A3F87C0A56238BLL, stat);
      break;
    case 908:
      HASH_INVOKE_FROM_EVAL(0x7F18BA1FBD95B38CLL, hphp_directoryiterator_next);
      break;
    case 909:
      HASH_INVOKE_FROM_EVAL(0x4127DE142CD4A38DLL, xml_get_error_code);
      break;
    case 913:
      HASH_INVOKE_FROM_EVAL(0x25FA64929C619391LL, asin);
      break;
    case 914:
      HASH_INVOKE_FROM_EVAL(0x2052D8D4822EF392LL, is_subclass_of);
      HASH_INVOKE_FROM_EVAL(0x2395B0A85E292392LL, hphp_splfileobject_flock);
      break;
    case 916:
      HASH_INVOKE_FROM_EVAL(0x269A220896FD2394LL, deg2rad);
      HASH_INVOKE_FROM_EVAL(0x36953788781F4394LL, mailparse_msg_extract_part);
      break;
    case 917:
      HASH_INVOKE_FROM_EVAL(0x7B0552A224E27395LL, bcsqrt);
      HASH_INVOKE_FROM_EVAL(0x422599B9E8AC0395LL, stream_bucket_make_writeable);
      break;
    case 918:
      HASH_INVOKE_FROM_EVAL(0x15EC64198D93C396LL, openssl_pkcs12_read);
      break;
    case 919:
      HASH_INVOKE_FROM_EVAL(0x1D2C305EA5C82397LL, idn_to_utf8);
      break;
    case 920:
      HASH_INVOKE_FROM_EVAL(0x215547858BA7E398LL, hphp_recursiveiteratoriterator___construct);
      break;
    case 921:
      HASH_INVOKE_FROM_EVAL(0x66DA89629BA5D399LL, posix_getgrgid);
      break;
    case 922:
      HASH_INVOKE_FROM_EVAL(0x0CC562CBD773639ALL, i18n_loc_get_default);
      HASH_INVOKE_FROM_EVAL(0x4C24BC37D807D39ALL, collator_get_strength);
      break;
    case 923:
      HASH_INVOKE_FROM_EVAL(0x25DF28703309C39BLL, idate);
      HASH_INVOKE_FROM_EVAL(0x5B33B55D4B7E339BLL, fpassthru);
      break;
    case 924:
      HASH_INVOKE_FROM_EVAL(0x0136F8F03932E39CLL, session_unset);
      break;
    case 926:
      HASH_INVOKE_FROM_EVAL(0x27AD0D17AA7FB39ELL, ldap_set_rebind_proc);
      break;
    case 927:
      HASH_INVOKE_FROM_EVAL(0x57E72C21F67D039FLL, user_error);
      HASH_INVOKE_FROM_EVAL(0x0368F1779E3AE39FLL, mysql_field_table);
      HASH_INVOKE_FROM_EVAL(0x4019A6916456339FLL, dom_node_remove_child);
      break;
    case 929:
      HASH_INVOKE_FROM_EVAL(0x5C29B6D7973903A1LL, proc_nice);
      break;
    case 930:
      HASH_INVOKE_FROM_EVAL(0x0207E332D629A3A2LL, mailparse_msg_get_structure);
      HASH_INVOKE_FROM_EVAL(0x0A2A4AA078D433A2LL, hexdec);
      break;
    case 932:
      HASH_INVOKE_FROM_EVAL(0x1676FB393F8493A4LL, constant);
      break;
    case 934:
      HASH_INVOKE_FROM_EVAL(0x40E0D496EE29B3A6LL, call_user_func_array);
      break;
    case 936:
      HASH_INVOKE_FROM_EVAL(0x0121CD6CDCE1C3A8LL, mysql_pconnect_with_db);
      HASH_INVOKE_FROM_EVAL(0x4120B8157ED413A8LL, i18n_loc_set_strength);
      break;
    case 937:
      HASH_INVOKE_FROM_EVAL(0x7F9E810BC93023A9LL, memcache_close);
      break;
    case 938:
      HASH_INVOKE_FROM_EVAL(0x3238A5BD362443AALL, escapeshellcmd);
      break;
    case 946:
      HASH_INVOKE_FROM_EVAL(0x3DB7EBC0B670C3B2LL, magicksetimageredprimary);
      break;
    case 947:
      HASH_INVOKE_FROM_EVAL(0x61720D771D1A23B3LL, posix_getpwnam);
      HASH_INVOKE_FROM_EVAL(0x6077CFE09EE4D3B3LL, session_save_path);
      break;
    case 950:
      HASH_INVOKE_FROM_EVAL(0x6E6C0E9A715073B6LL, dom_xpath_register_php_functions);
      HASH_INVOKE_FROM_EVAL(0x6C07640F7C5BD3B6LL, imagettfbbox);
      break;
    case 955:
      HASH_INVOKE_FROM_EVAL(0x5A3F5AAD1B13A3BBLL, is_executable);
      break;
    case 956:
      HASH_INVOKE_FROM_EVAL(0x0629158C42C893BCLL, compact);
      break;
    case 957:
      HASH_INVOKE_FROM_EVAL(0x60294C2616F6A3BDLL, mcrypt_enc_get_supported_key_sizes);
      break;
    case 958:
      HASH_INVOKE_FROM_EVAL(0x49A34964289453BELL, eregi);
      break;
    case 959:
      HASH_INVOKE_FROM_EVAL(0x0E38CDC93E5893BFLL, magicksetimagemattecolor);
      break;
    case 968:
      HASH_INVOKE_FROM_EVAL(0x4D100C70E86593C8LL, stream_set_write_buffer);
      HASH_INVOKE_FROM_EVAL(0x3101CE70BA49A3C8LL, error_reporting);
      break;
    case 971:
      HASH_INVOKE_FROM_EVAL(0x0173CC6FACAB93CBLL, quotemeta);
      HASH_INVOKE_FROM_EVAL(0x4C3B6BE9112E63CBLL, str_split);
      break;
    case 972:
      HASH_INVOKE_FROM_EVAL(0x50C88817090C63CCLL, pcntl_wait);
      break;
    case 974:
      HASH_INVOKE_FROM_EVAL(0x4F9F68F60FD7A3CELL, drawgetfillrule);
      HASH_INVOKE_FROM_EVAL(0x02BEFBEE8287D3CELL, get_magic_quotes_runtime);
      break;
    case 978:
      HASH_INVOKE_FROM_EVAL(0x67C155632E5373D2LL, mailparse_msg_create);
      break;
    case 979:
      HASH_INVOKE_FROM_EVAL(0x734FD402E190E3D3LL, evhttp_async_get);
      HASH_INVOKE_FROM_EVAL(0x0A8D4FAF266973D3LL, bcpow);
      break;
    case 980:
      HASH_INVOKE_FROM_EVAL(0x0FF21F9BE4CCC3D4LL, call_user_func_rpc);
      break;
    case 983:
      HASH_INVOKE_FROM_EVAL(0x382B5B1EF00153D7LL, imagecreatefrompng);
      break;
    case 996:
      HASH_INVOKE_FROM_EVAL(0x7E7718CC939D63E4LL, setrawcookie);
      break;
    case 1000:
      HASH_INVOKE_FROM_EVAL(0x6BB9D669DDB703E8LL, xml_get_current_byte_index);
      HASH_INVOKE_FROM_EVAL(0x4A3127C309B0C3E8LL, drawsetstrokelinecap);
      break;
    case 1002:
      HASH_INVOKE_FROM_EVAL(0x0D3C8F00B0C633EALL, inet_pton);
      HASH_INVOKE_FROM_EVAL(0x6DA49696220FE3EALL, mailparse_rfc822_parse_addresses);
      break;
    case 1003:
      HASH_INVOKE_FROM_EVAL(0x1DAE0831CECB63EBLL, ob_get_clean);
      break;
    case 1006:
      HASH_INVOKE_FROM_EVAL(0x598472448937E3EELL, magickqueryfontmetrics);
      break;
    case 1009:
      HASH_INVOKE_FROM_EVAL(0x5EFE291585A713F1LL, method_exists);
      break;
    case 1010:
      HASH_INVOKE_FROM_EVAL(0x0FE12E46BC9853F2LL, stream_filter_append);
      HASH_INVOKE_FROM_EVAL(0x41A19AE18BC8B3F2LL, curl_error);
      HASH_INVOKE_FROM_EVAL(0x696241660648B3F2LL, magickwhitethresholdimage);
      break;
    case 1012:
      HASH_INVOKE_FROM_EVAL(0x1938C8715806E3F4LL, spl_classes);
      HASH_INVOKE_FROM_EVAL(0x26D53A77483EF3F4LL, drawbezier);
      break;
    case 1015:
      HASH_INVOKE_FROM_EVAL(0x43F22CB4E3E8F3F7LL, apache_note);
      break;
    case 1016:
      HASH_INVOKE_FROM_EVAL(0x4C024573FCD5B3F8LL, var_dump);
      HASH_INVOKE_FROM_EVAL(0x514EA9C8FF5B33F8LL, posix_getrlimit);
      break;
    case 1018:
      HASH_INVOKE_FROM_EVAL(0x1B217E78CBC713FALL, zend_thread_id);
      break;
    case 1025:
      HASH_INVOKE_FROM_EVAL(0x36B9C440B1881401LL, fmod);
      HASH_INVOKE_FROM_EVAL(0x3DCB1C92B5864401LL, gzrewind);
      break;
    case 1028:
      HASH_INVOKE_FROM_EVAL(0x2B12B0E9109D0404LL, iptcembed);
      break;
    case 1033:
      HASH_INVOKE_FROM_EVAL(0x2E57E06900594409LL, xbox_send_message);
      break;
    case 1034:
      HASH_INVOKE_FROM_EVAL(0x6DC61C51FA1D340ALL, show_source);
      break;
    case 1035:
      HASH_INVOKE_FROM_EVAL(0x6C2CE092B900D40BLL, hphp_splfileinfo___construct);
      break;
    case 1037:
      HASH_INVOKE_FROM_EVAL(0x2939C5BAE0C4A40DLL, nl2br);
      HASH_INVOKE_FROM_EVAL(0x267529454569840DLL, ob_flush);
      HASH_INVOKE_FROM_EVAL(0x152C7161567F940DLL, func_num_args);
      HASH_INVOKE_FROM_EVAL(0x002CCCD877D9640DLL, drawpathclose);
      break;
    case 1043:
      HASH_INVOKE_FROM_EVAL(0x56EC1A6732D07413LL, drawgetfontsize);
      HASH_INVOKE_FROM_EVAL(0x20C24D873DC65413LL, openssl_csr_get_subject);
      break;
    case 1051:
      HASH_INVOKE_FROM_EVAL(0x47279C717370B41BLL, acos);
      break;
    case 1054:
      HASH_INVOKE_FROM_EVAL(0x3E4E7C561D3A541ELL, fgetss);
      break;
    case 1055:
      HASH_INVOKE_FROM_EVAL(0x301963016A91741FLL, hphp_stats);
      break;
    case 1059:
      HASH_INVOKE_FROM_EVAL(0x4C9108B5A5807423LL, drawsetfillcolor);
      break;
    case 1062:
      HASH_INVOKE_FROM_EVAL(0x21EFB0B9D1514426LL, magicksetpassphrase);
      HASH_INVOKE_FROM_EVAL(0x161D8EA3339AB426LL, apc_cas);
      break;
    case 1068:
      HASH_INVOKE_FROM_EVAL(0x12D324CC744BF42CLL, pixelgetcolorasstring);
      break;
    case 1069:
      HASH_INVOKE_FROM_EVAL(0x333D1E2E28B0942DLL, imagejpeg);
      HASH_INVOKE_FROM_EVAL(0x2A5A519E4BFE442DLL, mb_eregi);
      break;
    case 1071:
      HASH_INVOKE_FROM_EVAL(0x316F2725AC15042FLL, stream_resolve_include_path);
      break;
    case 1072:
      HASH_INVOKE_FROM_EVAL(0x6349C9658B2A2430LL, memcache_pconnect);
      break;
    case 1074:
      HASH_INVOKE_FROM_EVAL(0x71C6E38BC56CE432LL, stream_wrapper_register);
      break;
    case 1075:
      HASH_INVOKE_FROM_EVAL(0x6829094421CDB433LL, touch);
      break;
    case 1077:
      HASH_INVOKE_FROM_EVAL(0x75DAFEF5BFEF1435LL, imagesetstyle);
      HASH_INVOKE_FROM_EVAL(0x044386A0E8B25435LL, drawgetclipunits);
      break;
    case 1079:
      HASH_INVOKE_FROM_EVAL(0x1AAF02CF6DEBB437LL, magickdeconstructimages);
      break;
    case 1081:
      HASH_INVOKE_FROM_EVAL(0x34C52EF423EFD439LL, proc_open);
      break;
    case 1082:
      HASH_INVOKE_FROM_EVAL(0x5019A1FBF377C43ALL, imagepsbbox);
      break;
    case 1084:
      HASH_INVOKE_FROM_EVAL(0x59ECE01C7629643CLL, mysql_drop_db);
      break;
    case 1088:
      HASH_INVOKE_FROM_EVAL(0x5247425ED698B440LL, hphp_thread_is_warmup_enabled);
      break;
    case 1089:
      HASH_INVOKE_FROM_EVAL(0x158E2271E381C441LL, hash_file);
      HASH_INVOKE_FROM_EVAL(0x05892E3C5B9EB441LL, closedir);
      break;
    case 1090:
      HASH_INVOKE_FROM_EVAL(0x3F869126D0336442LL, trigger_error);
      break;
    case 1105:
      HASH_INVOKE_FROM_EVAL(0x7539134E1CC61451LL, xmlwriter_start_cdata);
      break;
    case 1106:
      HASH_INVOKE_FROM_EVAL(0x1056EF1C14D2A452LL, socket_connect);
      break;
    case 1116:
      HASH_INVOKE_FROM_EVAL(0x436AB52B2099145CLL, ldap_close);
      break;
    case 1117:
      HASH_INVOKE_FROM_EVAL(0x0246AF48CD31245DLL, count_chars);
      break;
    case 1118:
      HASH_INVOKE_FROM_EVAL(0x0ED191E71A60545ELL, magicksetfirstiterator);
      break;
    case 1125:
      HASH_INVOKE_FROM_EVAL(0x05D72365192CE465LL, fwrite);
      HASH_INVOKE_FROM_EVAL(0x406A1404F48E4465LL, posix_getuid);
      break;
    case 1130:
      HASH_INVOKE_FROM_EVAL(0x32643AE461D3F46ALL, mailparse_stream_encode);
      break;
    case 1132:
      HASH_INVOKE_FROM_EVAL(0x07D959A8C0CF546CLL, stream_wrapper_unregister);
      HASH_INVOKE_FROM_EVAL(0x4F39BD300305746CLL, hphp_splfileobject_key);
      break;
    case 1133:
      HASH_INVOKE_FROM_EVAL(0x738D381800CE946DLL, ldap_parse_result);
      HASH_INVOKE_FROM_EVAL(0x5229C0069FD7D46DLL, vfprintf);
      break;
    case 1136:
      HASH_INVOKE_FROM_EVAL(0x0C626F268F120470LL, __halt_compiler);
      break;
    case 1139:
      HASH_INVOKE_FROM_EVAL(0x0F8F276A48900473LL, drawgetstrokelinecap);
      break;
    case 1141:
      HASH_INVOKE_FROM_EVAL(0x268706C46202C475LL, sem_acquire);
      break;
    case 1143:
      HASH_INVOKE_FROM_EVAL(0x18666906A8001477LL, array_diff_assoc);
      break;
    case 1144:
      HASH_INVOKE_FROM_EVAL(0x080594ABE715B478LL, hphp_splfileobject_current);
      HASH_INVOKE_FROM_EVAL(0x6497CC8295DDB478LL, fb_thrift_unserialize);
      break;
    case 1145:
      HASH_INVOKE_FROM_EVAL(0x4859AF715D5A3479LL, magickmagnifyimage);
      break;
    case 1148:
      HASH_INVOKE_FROM_EVAL(0x1A08C578AD3BC47CLL, apache_response_headers);
      HASH_INVOKE_FROM_EVAL(0x2FA7269AB0E1147CLL, mysql_field_seek);
      break;
    case 1150:
      HASH_INVOKE_FROM_EVAL(0x1D583AA4F7F6547ELL, drawpathlinetorelative);
      HASH_INVOKE_FROM_EVAL(0x0AC36D9F961B247ELL, newpixeliterator);
      break;
    case 1151:
      HASH_INVOKE_FROM_EVAL(0x68AE04B02253B47FLL, mb_parse_str);
      break;
    case 1154:
      HASH_INVOKE_FROM_EVAL(0x4590C853C2027482LL, magickembossimage);
      break;
    case 1157:
      HASH_INVOKE_FROM_EVAL(0x250DD3D58EA37485LL, gmstrftime);
      HASH_INVOKE_FROM_EVAL(0x61499C92F4FBA485LL, hphp_splfileobject_fgetc);
      break;
    case 1161:
      HASH_INVOKE_FROM_EVAL(0x4F7EAF5B37663489LL, magickgetimageredprimary);
      HASH_INVOKE_FROM_EVAL(0x7505924F05854489LL, dom_element_set_attribute_ns);
      break;
    case 1162:
      HASH_INVOKE_FROM_EVAL(0x7E88764A1DE8548ALL, drawgetstrokewidth);
      break;
    case 1163:
      HASH_INVOKE_FROM_EVAL(0x5860ACF621DD948BLL, is_file);
      break;
    case 1165:
      HASH_INVOKE_FROM_EVAL(0x23511F83C2BC548DLL, header);
      HASH_INVOKE_FROM_EVAL(0x275D127C87EF048DLL, mysql_db_query);
      break;
    case 1167:
      HASH_INVOKE_FROM_EVAL(0x43672229728A648FLL, drawpushpattern);
      break;
    case 1171:
      HASH_INVOKE_FROM_EVAL(0x56377FCC2447D493LL, magicksetimagepixels);
      break;
    case 1175:
      HASH_INVOKE_FROM_EVAL(0x353E2A635A47F497LL, evhttp_get);
      HASH_INVOKE_FROM_EVAL(0x5388045C2D13D497LL, mysql_num_fields);
      break;
    case 1181:
      HASH_INVOKE_FROM_EVAL(0x7A59813AC331449DLL, mb_ereg_search_regs);
      break;
    case 1183:
      HASH_INVOKE_FROM_EVAL(0x7FF66005524E649FLL, drawgettextdecoration);
      break;
    case 1188:
      HASH_INVOKE_FROM_EVAL(0x6EC476E42A53A4A4LL, ldap_err2str);
      break;
    case 1189:
      HASH_INVOKE_FROM_EVAL(0x18BE9B1C2DE6D4A5LL, imagexbm);
      break;
    case 1192:
      HASH_INVOKE_FROM_EVAL(0x6F4497457F1584A8LL, dom_element_set_id_attribute_node);
      break;
    case 1193:
      HASH_INVOKE_FROM_EVAL(0x386378F2BA3234A9LL, magickevaluateimage);
      break;
    case 1196:
      HASH_INVOKE_FROM_EVAL(0x245AA2790C87C4ACLL, image_type_to_mime_type);
      HASH_INVOKE_FROM_EVAL(0x6E8FFA56842304ACLL, drawgetfont);
      break;
    case 1197:
      HASH_INVOKE_FROM_EVAL(0x3D98ACFCEBB764ADLL, hphp_set_property);
      break;
    case 1199:
      HASH_INVOKE_FROM_EVAL(0x42463E7E5C3434AFLL, mb_strrichr);
      HASH_INVOKE_FROM_EVAL(0x6AC751181531F4AFLL, simplexml_load_string);
      break;
    case 1200:
      HASH_INVOKE_FROM_EVAL(0x0E11D317044974B0LL, magickgetnumberimages);
      HASH_INVOKE_FROM_EVAL(0x3AF65A9F3653E4B0LL, addslashes);
      break;
    case 1201:
      HASH_INVOKE_FROM_EVAL(0x060619D7A1B5F4B1LL, checkdate);
      break;
    case 1203:
      HASH_INVOKE_FROM_EVAL(0x57034CAD772AF4B3LL, magickgetimagechannelmean);
      break;
    case 1204:
      HASH_INVOKE_FROM_EVAL(0x00621C58E54D44B4LL, hphp_recursiveiteratoriterator_key);
      break;
    case 1206:
      HASH_INVOKE_FROM_EVAL(0x3DE291DCBA5134B6LL, dom_document_create_element);
      HASH_INVOKE_FROM_EVAL(0x12A9166E68DCF4B6LL, pixelgetgreen);
      break;
    case 1207:
      HASH_INVOKE_FROM_EVAL(0x7EEBC81AF9BC54B7LL, xml_parser_free);
      break;
    case 1209:
      HASH_INVOKE_FROM_EVAL(0x5351290CD139A4B9LL, mb_strrpos);
      break;
    case 1210:
      HASH_INVOKE_FROM_EVAL(0x6B49D11E633274BALL, fopen);
      break;
    case 1213:
      HASH_INVOKE_FROM_EVAL(0x35BE8F6E7726C4BDLL, dechex);
      HASH_INVOKE_FROM_EVAL(0x5BA371A93F60F4BDLL, use_soap_error_handler);
      break;
    case 1214:
      HASH_INVOKE_FROM_EVAL(0x57278846B8B0E4BELL, ldap_count_entries);
      break;
    case 1215:
      HASH_INVOKE_FROM_EVAL(0x01681C307C5AE4BFLL, strtoupper);
      break;
    case 1219:
      HASH_INVOKE_FROM_EVAL(0x7AAC29849263C4C3LL, getprotobyname);
      break;
    case 1220:
      HASH_INVOKE_FROM_EVAL(0x67EADCF4E81084C4LL, mb_ereg);
      HASH_INVOKE_FROM_EVAL(0x4A24DB9D6B0334C4LL, hphp_recursivedirectoryiterator_next);
      break;
    case 1221:
      HASH_INVOKE_FROM_EVAL(0x34A38DDF2CD914C5LL, long2ip);
      break;
    case 1222:
      HASH_INVOKE_FROM_EVAL(0x651F7FBBA90604C6LL, magickgetimageindex);
      HASH_INVOKE_FROM_EVAL(0x4F7AA8120E33E4C6LL, collator_get_attribute);
      break;
    case 1224:
      HASH_INVOKE_FROM_EVAL(0x1B8BBFC882FDB4C8LL, magicktintimage);
      break;
    case 1230:
      HASH_INVOKE_FROM_EVAL(0x60783C20BF7724CELL, mailparse_msg_free);
      break;
    case 1231:
      HASH_INVOKE_FROM_EVAL(0x72DECE786967A4CFLL, magickpreviousimage);
      break;
    case 1233:
      HASH_INVOKE_FROM_EVAL(0x29EE24C41FD3D4D1LL, mysql_field_name);
      break;
    case 1238:
      HASH_INVOKE_FROM_EVAL(0x19ECDD5A937DD4D6LL, mailparse_msg_get_part_data);
      break;
    case 1239:
      HASH_INVOKE_FROM_EVAL(0x215403F1E335C4D7LL, magicksolarizeimage);
      break;
    case 1240:
      HASH_INVOKE_FROM_EVAL(0x2532EB687D51E4D8LL, unregister_tick_function);
      HASH_INVOKE_FROM_EVAL(0x14BF763DDDC014D8LL, imagepsencodefont);
      HASH_INVOKE_FROM_EVAL(0x56B908FC91C834D8LL, magickflopimage);
      HASH_INVOKE_FROM_EVAL(0x1301F911ED6D54D8LL, is_nan);
      HASH_INVOKE_FROM_EVAL(0x575C5AE3D2A694D8LL, ob_end_clean);
      break;
    case 1247:
      HASH_INVOKE_FROM_EVAL(0x747A7F585CD694DFLL, zend_version);
      HASH_INVOKE_FROM_EVAL(0x2E5E5A0FC3B5C4DFLL, xml_set_character_data_handler);
      break;
    case 1248:
      HASH_INVOKE_FROM_EVAL(0x340A51AE22A924E0LL, reset);
      break;
    case 1251:
      HASH_INVOKE_FROM_EVAL(0x7D57A0D72D6254E3LL, ob_implicit_flush);
      break;
    case 1262:
      HASH_INVOKE_FROM_EVAL(0x5895ADDD91F354EELL, hphp_thread_set_warmup_enabled);
      break;
    case 1265:
      HASH_INVOKE_FROM_EVAL(0x65BD541EAB38E4F1LL, mysql_close);
      break;
    case 1266:
      HASH_INVOKE_FROM_EVAL(0x41276F8DE35354F2LL, dom_document_get_elements_by_tag_name);
      break;
    case 1268:
      HASH_INVOKE_FROM_EVAL(0x436B36C5EB8DB4F4LL, mcrypt_generic);
      break;
    case 1269:
      HASH_INVOKE_FROM_EVAL(0x528AC8D252D224F5LL, log10);
      HASH_INVOKE_FROM_EVAL(0x112A0ACDD8B9D4F5LL, mb_list_mime_names);
      break;
    case 1271:
      HASH_INVOKE_FROM_EVAL(0x0BD9C5D811CB04F7LL, dom_element_set_id_attribute_ns);
      break;
    case 1272:
      HASH_INVOKE_FROM_EVAL(0x011006D90D79E4F8LL, mysql_errno);
      break;
    case 1277:
      HASH_INVOKE_FROM_EVAL(0x002387F1D23B44FDLL, mcrypt_list_modes);
      HASH_INVOKE_FROM_EVAL(0x2CEAE845E4F404FDLL, dom_document_save);
      break;
    case 1287:
      HASH_INVOKE_FROM_EVAL(0x4FC9FE38A748B507LL, intl_get_error_message);
      HASH_INVOKE_FROM_EVAL(0x197A5D237BD4C507LL, mb_ereg_search_getpos);
      break;
    case 1288:
      HASH_INVOKE_FROM_EVAL(0x63A08D6AD1209508LL, magickgetexception);
      break;
    case 1291:
      HASH_INVOKE_FROM_EVAL(0x71DCF11E3640C50BLL, hphp_directoryiterator_valid);
      break;
    case 1295:
      HASH_INVOKE_FROM_EVAL(0x5A66CCB3D924450FLL, xml_parser_create);
      break;
    case 1297:
      HASH_INVOKE_FROM_EVAL(0x09D5355CA8198511LL, mb_internal_encoding);
      HASH_INVOKE_FROM_EVAL(0x3C0304A55503D511LL, magickgetimageiterations);
      break;
    case 1299:
      HASH_INVOKE_FROM_EVAL(0x772E8BF114FEF513LL, eregi_replace);
      break;
    case 1300:
      HASH_INVOKE_FROM_EVAL(0x100385A0988FD514LL, magickgetfilename);
      break;
    case 1305:
      HASH_INVOKE_FROM_EVAL(0x54EDBB6BAF318519LL, memcache_add);
      break;
    case 1314:
      HASH_INVOKE_FROM_EVAL(0x7DA98E0379D33522LL, chdir);
      break;
    case 1316:
      HASH_INVOKE_FROM_EVAL(0x28E724EDE0BB6524LL, mb_strcut);
      break;
    case 1317:
      HASH_INVOKE_FROM_EVAL(0x230FE1D6EC599525LL, link);
      break;
    case 1318:
      HASH_INVOKE_FROM_EVAL(0x57DDA4C3F7FF8526LL, fputcsv);
      break;
    case 1319:
      HASH_INVOKE_FROM_EVAL(0x6B2B942CAF1A2527LL, array_shift);
      break;
    case 1324:
      HASH_INVOKE_FROM_EVAL(0x1AB55BBA0967952CLL, mb_convert_variables);
      break;
    case 1327:
      HASH_INVOKE_FROM_EVAL(0x6770E2559C9A152FLL, openssl_private_decrypt);
      break;
    case 1329:
      HASH_INVOKE_FROM_EVAL(0x6776C27C6123D531LL, dl);
      break;
    case 1330:
      HASH_INVOKE_FROM_EVAL(0x6193A26936F4D532LL, disk_total_space);
      break;
    case 1331:
      HASH_INVOKE_FROM_EVAL(0x313D2A505076A533LL, dir);
      break;
    case 1333:
      HASH_INVOKE_FROM_EVAL(0x6C87406DDC0AB535LL, mcrypt_ecb);
      break;
    case 1334:
      HASH_INVOKE_FROM_EVAL(0x0E80D04691227536LL, eval);
      HASH_INVOKE_FROM_EVAL(0x746DC7AD953EA536LL, memcache_set_compress_threshold);
      break;
    case 1335:
      HASH_INVOKE_FROM_EVAL(0x0830FF7C379D7537LL, dom_text_split_text);
      HASH_INVOKE_FROM_EVAL(0x557C72DE98679537LL, hash_update_stream);
      HASH_INVOKE_FROM_EVAL(0x175B86BCB3124537LL, magickgetexceptionstring);
      break;
    case 1337:
      HASH_INVOKE_FROM_EVAL(0x3C88F0FAC3EDD539LL, phpversion);
      break;
    case 1340:
      HASH_INVOKE_FROM_EVAL(0x5CA55E62F2A5953CLL, drawgetstrokeopacity);
      break;
    case 1341:
      HASH_INVOKE_FROM_EVAL(0x0F32841DBF7A053DLL, fb_crossall_query);
      break;
    case 1342:
      HASH_INVOKE_FROM_EVAL(0x36A80B48E08B753ELL, implode);
      break;
    case 1346:
      HASH_INVOKE_FROM_EVAL(0x59A44591E67D4542LL, drawrender);
      break;
    case 1347:
      HASH_INVOKE_FROM_EVAL(0x20E2B1D920122543LL, die);
      HASH_INVOKE_FROM_EVAL(0x0962EACAE0F0B543LL, hphp_splfileinfo_getlinktarget);
      break;
    case 1348:
      HASH_INVOKE_FROM_EVAL(0x4D397FE5D0C0B544LL, magickmedianfilterimage);
      break;
    case 1350:
      HASH_INVOKE_FROM_EVAL(0x12A739BE0ED32546LL, ignore_user_abort);
      HASH_INVOKE_FROM_EVAL(0x081F76AC889BC546LL, getrusage);
      break;
    case 1352:
      HASH_INVOKE_FROM_EVAL(0x0AD3BFAB5F780548LL, magickcoalesceimages);
      break;
    case 1355:
      HASH_INVOKE_FROM_EVAL(0x40CE61115E11154BLL, msg_stat_queue);
      break;
    case 1356:
      HASH_INVOKE_FROM_EVAL(0x1D011CB0E810D54CLL, pdo_drivers);
      break;
    case 1357:
      HASH_INVOKE_FROM_EVAL(0x0F0702D91EAFB54DLL, drawgettextantialias);
      HASH_INVOKE_FROM_EVAL(0x1B9E769FFEC3C54DLL, pcntl_wtermsig);
      break;
    case 1359:
      HASH_INVOKE_FROM_EVAL(0x30DE78E7131B954FLL, furchash_hphp_ext_supported);
      HASH_INVOKE_FROM_EVAL(0x063200B5AAFEC54FLL, mysql_thread_id);
      break;
    case 1370:
      HASH_INVOKE_FROM_EVAL(0x268EE73DB2EA555ALL, get_object_vars);
      break;
    case 1372:
      HASH_INVOKE_FROM_EVAL(0x5749AD20CAFCD55CLL, pixelgetbluequantum);
      break;
    case 1379:
      HASH_INVOKE_FROM_EVAL(0x1B1B2D70792D9563LL, mysql_get_client_info);
      break;
    case 1382:
      HASH_INVOKE_FROM_EVAL(0x6E2FDBD28F895566LL, timezone_abbreviations_list);
      HASH_INVOKE_FROM_EVAL(0x3DA2058E5C540566LL, spliti);
      break;
    case 1386:
      HASH_INVOKE_FROM_EVAL(0x74599147803DC56ALL, magickgetstringwidth);
      break;
    case 1387:
      HASH_INVOKE_FROM_EVAL(0x0DE86977367F656BLL, register_shutdown_function);
      break;
    case 1390:
      HASH_INVOKE_FROM_EVAL(0x2A1F1B52160DE56ELL, zend_logo_guid);
      break;
    case 1391:
      HASH_INVOKE_FROM_EVAL(0x016722439BBA756FLL, filetype);
      break;
    case 1392:
      HASH_INVOKE_FROM_EVAL(0x13D0427F3BB3E570LL, get_declared_interfaces);
      HASH_INVOKE_FROM_EVAL(0x21B3935EB3140570LL, mysql_fetch_object);
      break;
    case 1393:
      HASH_INVOKE_FROM_EVAL(0x2AD3361DE8B1D571LL, pcntl_signal_dispatch);
      break;
    case 1396:
      HASH_INVOKE_FROM_EVAL(0x636C871213F37574LL, mcrypt_encrypt);
      break;
    case 1399:
      HASH_INVOKE_FROM_EVAL(0x412521E7ADB21577LL, iconv_mime_decode_headers);
      HASH_INVOKE_FROM_EVAL(0x1E154D823451B577LL, magicksetresolution);
      break;
    case 1401:
      HASH_INVOKE_FROM_EVAL(0x1DC8A386E219C579LL, ldap_add);
      break;
    case 1405:
      HASH_INVOKE_FROM_EVAL(0x78EDB608B02A857DLL, join);
      HASH_INVOKE_FROM_EVAL(0x22E08DEDF360057DLL, pixelsetmagenta);
      break;
    case 1406:
      HASH_INVOKE_FROM_EVAL(0x31529E9BCA1E157ELL, shm_remove);
      HASH_INVOKE_FROM_EVAL(0x132776D93181E57ELL, ldap_set_option);
      break;
    case 1410:
      HASH_INVOKE_FROM_EVAL(0x02688986D5D76582LL, magickspreadimage);
      HASH_INVOKE_FROM_EVAL(0x0B1F0EB755BDB582LL, ispixeliterator);
      break;
    case 1411:
      HASH_INVOKE_FROM_EVAL(0x3B2CD86F5DB72583LL, magickblackthresholdimage);
      break;
    case 1419:
      HASH_INVOKE_FROM_EVAL(0x1EF2C1426AB0A58BLL, dom_node_replace_child);
      HASH_INVOKE_FROM_EVAL(0x3A34B44E4C51C58BLL, xml_set_element_handler);
      break;
    case 1420:
      HASH_INVOKE_FROM_EVAL(0x560C2F71978CE58CLL, shm_put_var);
      break;
    case 1426:
      HASH_INVOKE_FROM_EVAL(0x3E9519FE856C4592LL, curl_multi_init);
      HASH_INVOKE_FROM_EVAL(0x5464E148E8A0C592LL, get_extension_funcs);
      HASH_INVOKE_FROM_EVAL(0x7F65501600346592LL, mcrypt_get_block_size);
      break;
    case 1427:
      HASH_INVOKE_FROM_EVAL(0x0F5984B8A7FD8593LL, hphp_splfileinfo_getperms);
      break;
    case 1431:
      HASH_INVOKE_FROM_EVAL(0x513787A813DB0597LL, date_date_set);
      break;
    case 1433:
      HASH_INVOKE_FROM_EVAL(0x12F502A88E0AA599LL, magickcompositeimage);
      break;
    case 1434:
      HASH_INVOKE_FROM_EVAL(0x77F1EDE7D5EF759ALL, apc_cache_info);
      break;
    case 1435:
      HASH_INVOKE_FROM_EVAL(0x37D003B09D0C759BLL, stream_get_contents);
      break;
    case 1440:
      HASH_INVOKE_FROM_EVAL(0x20502FCACBB9F5A0LL, convert_uuencode);
      break;
    case 1441:
      HASH_INVOKE_FROM_EVAL(0x297690F3A63335A1LL, magickrotateimage);
      break;
    case 1444:
      HASH_INVOKE_FROM_EVAL(0x3C014439AE5D75A4LL, magickgetcharheight);
      break;
    case 1448:
      HASH_INVOKE_FROM_EVAL(0x4FBB1F662399A5A8LL, is_soap_fault);
      break;
    case 1451:
      HASH_INVOKE_FROM_EVAL(0x79E0380A18A345ABLL, apache_get_modules);
      break;
    case 1452:
      HASH_INVOKE_FROM_EVAL(0x763BA2B1C60A55ACLL, pixelgetalphaquantum);
      break;
    case 1453:
      HASH_INVOKE_FROM_EVAL(0x4110AF96B98B25ADLL, gzeof);
      break;
    case 1455:
      HASH_INVOKE_FROM_EVAL(0x1636FBA5043CF5AFLL, ldap_error);
      break;
    case 1459:
      HASH_INVOKE_FROM_EVAL(0x001DBE44BC0B55B3LL, magicksetimagecolormapcolor);
      HASH_INVOKE_FROM_EVAL(0x7AFA32F70E8195B3LL, xbox_set_thread_timeout);
      break;
    case 1461:
      HASH_INVOKE_FROM_EVAL(0x3F9C5B4708FC55B5LL, timezone_name_get);
      HASH_INVOKE_FROM_EVAL(0x5EFE573046B565B5LL, mcrypt_module_close);
      break;
    case 1462:
      HASH_INVOKE_FROM_EVAL(0x1A05907F563235B6LL, collator_set_attribute);
      break;
    case 1466:
      HASH_INVOKE_FROM_EVAL(0x05B8EB2C515885BALL, vprintf);
      break;
    case 1472:
      HASH_INVOKE_FROM_EVAL(0x61465CD8C67905C0LL, openssl_pkey_free);
      break;
    case 1473:
      HASH_INVOKE_FROM_EVAL(0x7731B90FB7C975C1LL, magickremoveimageprofile);
      break;
    case 1478:
      HASH_INVOKE_FROM_EVAL(0x3B3D5CE69B1565C6LL, mcrypt_module_is_block_mode);
      break;
    case 1480:
      HASH_INVOKE_FROM_EVAL(0x1CE8175A87C785C8LL, dom_document_validate);
      break;
    case 1481:
      HASH_INVOKE_FROM_EVAL(0x75B299F5E35A95C9LL, mb_strwidth);
      HASH_INVOKE_FROM_EVAL(0x60F8818C0F38D5C9LL, hphp_directoryiterator___tostring);
      break;
    case 1483:
      HASH_INVOKE_FROM_EVAL(0x6751946191FBE5CBLL, override_function);
      break;
    case 1484:
      HASH_INVOKE_FROM_EVAL(0x2A6F86821A39C5CCLL, expm1);
      break;
    case 1486:
      HASH_INVOKE_FROM_EVAL(0x406AC1DDB92925CELL, parse_hdf_file);
      break;
    case 1487:
      HASH_INVOKE_FROM_EVAL(0x5D9818B3E1C385CFLL, openssl_pkey_export_to_file);
      break;
    case 1489:
      HASH_INVOKE_FROM_EVAL(0x054503DBBF5CA5D1LL, imagecopy);
      break;
    case 1492:
      HASH_INVOKE_FROM_EVAL(0x2FE56B4C457AB5D4LL, ctype_graph);
      break;
    case 1493:
      HASH_INVOKE_FROM_EVAL(0x43901543EA8625D5LL, curl_multi_select);
      break;
    case 1494:
      HASH_INVOKE_FROM_EVAL(0x6D265875A19685D6LL, is_float);
      break;
    case 1495:
      HASH_INVOKE_FROM_EVAL(0x617AD1AD708785D7LL, magickmodulateimage);
      break;
    case 1508:
      HASH_INVOKE_FROM_EVAL(0x3A9643992AC805E4LL, magickdrawimage);
      break;
    case 1509:
      HASH_INVOKE_FROM_EVAL(0x470F990B218315E5LL, fb_unset_taint);
      break;
    case 1510:
      HASH_INVOKE_FROM_EVAL(0x6FE2E44FBC44E5E6LL, magickaddnoiseimage);
      HASH_INVOKE_FROM_EVAL(0x08069ECE0EA3C5E6LL, imagecopymergegray);
      break;
    case 1514:
      HASH_INVOKE_FROM_EVAL(0x0B7ACBAB402015EALL, mb_send_mail);
      break;
    case 1518:
      HASH_INVOKE_FROM_EVAL(0x3076D369F63E65EELL, pixelgetalpha);
      break;
    case 1524:
      HASH_INVOKE_FROM_EVAL(0x1E89F15B7F2805F4LL, openssl_pkcs7_encrypt);
      HASH_INVOKE_FROM_EVAL(0x459330C31956A5F4LL, vsprintf);
      break;
    case 1525:
      HASH_INVOKE_FROM_EVAL(0x0D1BD0E5AF4175F5LL, drawsetfont);
      HASH_INVOKE_FROM_EVAL(0x73A1F34DF95B35F5LL, get_defined_constants);
      break;
    case 1527:
      HASH_INVOKE_FROM_EVAL(0x18E4CC945005E5F7LL, drawpushclippath);
      break;
    case 1528:
      HASH_INVOKE_FROM_EVAL(0x7C48F6EA39B7B5F8LL, magickadaptivethresholdimage);
      break;
    case 1531:
      HASH_INVOKE_FROM_EVAL(0x3535B6615F2B05FBLL, session_cache_limiter);
      HASH_INVOKE_FROM_EVAL(0x0FEC4ED541B7F5FBLL, magickgetimagevirtualpixelmethod);
      break;
    case 1532:
      HASH_INVOKE_FROM_EVAL(0x39156C7CCE2D75FCLL, hash_update);
      break;
    case 1533:
      HASH_INVOKE_FROM_EVAL(0x0C1CB24A3FC065FDLL, bcmul);
      HASH_INVOKE_FROM_EVAL(0x46832743CAF5C5FDLL, dom_element_set_attribute_node);
      break;
    case 1534:
      HASH_INVOKE_FROM_EVAL(0x397D3C6576ED75FELL, set_include_path);
      break;
    case 1535:
      HASH_INVOKE_FROM_EVAL(0x40A557CBB9FC35FFLL, mysql_tablename);
      break;
    case 1536:
      HASH_INVOKE_FROM_EVAL(0x552D7CAD93755600LL, dom_document_create_comment);
      break;
    case 1537:
      HASH_INVOKE_FROM_EVAL(0x0F3403D8676C2601LL, mysql_query);
      break;
    case 1545:
      HASH_INVOKE_FROM_EVAL(0x52D5698F31D12609LL, pcntl_setpriority);
      break;
    case 1555:
      HASH_INVOKE_FROM_EVAL(0x36783304F63C4613LL, sscanf);
      HASH_INVOKE_FROM_EVAL(0x4AC405EA2B8C4613LL, magickresetiterator);
      break;
    case 1557:
      HASH_INVOKE_FROM_EVAL(0x6AD774816F8F7615LL, mb_strrchr);
      break;
    case 1558:
      HASH_INVOKE_FROM_EVAL(0x66C7616225F1C616LL, pixelsetgreen);
      HASH_INVOKE_FROM_EVAL(0x7FA6D13B0D38E616LL, imagegif);
      break;
    case 1561:
      HASH_INVOKE_FROM_EVAL(0x6DD51BF03F003619LL, mailparse_uudecode_all);
      HASH_INVOKE_FROM_EVAL(0x2F29627AF1A97619LL, shm_attach);
      break;
    case 1563:
      HASH_INVOKE_FROM_EVAL(0x40DDE277D934061BLL, gzputs);
      break;
    case 1564:
      HASH_INVOKE_FROM_EVAL(0x70725954DC99F61CLL, mcrypt_create_iv);
      break;
    case 1565:
      HASH_INVOKE_FROM_EVAL(0x69E1368FD737F61DLL, dom_namednodemap_get_named_item);
      HASH_INVOKE_FROM_EVAL(0x7E98B97C1B5D861DLL, magickqueryconfigureoptions);
      break;
    case 1569:
      HASH_INVOKE_FROM_EVAL(0x0F71DDE51AA55621LL, hphp_output_global_state);
      break;
    case 1570:
      HASH_INVOKE_FROM_EVAL(0x134550B9EB596622LL, drawgetfontstyle);
      break;
    case 1576:
      HASH_INVOKE_FROM_EVAL(0x1E77B3BCF062D628LL, magickreadimage);
      break;
    case 1577:
      HASH_INVOKE_FROM_EVAL(0x679B81CE06EE0629LL, bcdiv);
      break;
    case 1578:
      HASH_INVOKE_FROM_EVAL(0x608EA42B08A7462ALL, linkinfo);
      break;
    case 1580:
      HASH_INVOKE_FROM_EVAL(0x5CEA60D9C54A162CLL, pcntl_wifstopped);
      break;
    case 1583:
      HASH_INVOKE_FROM_EVAL(0x652C331CE138362FLL, is_string);
      break;
    case 1585:
      HASH_INVOKE_FROM_EVAL(0x5AD6595ACA656631LL, pixelresetiterator);
      break;
    case 1591:
      HASH_INVOKE_FROM_EVAL(0x60276BC7990F9637LL, mysql_list_dbs);
      HASH_INVOKE_FROM_EVAL(0x75AFA49220C9B637LL, collator_sort);
      break;
    case 1595:
      HASH_INVOKE_FROM_EVAL(0x391C68F2BE85E63BLL, pixelgetiteratorexceptionstring);
      break;
    case 1596:
      HASH_INVOKE_FROM_EVAL(0x62DE03461EF4663CLL, symlink);
      break;
    case 1598:
      HASH_INVOKE_FROM_EVAL(0x60302D15A677963ELL, ldap_free_result);
      break;
    case 1599:
      HASH_INVOKE_FROM_EVAL(0x17242BC6C9C9563FLL, crypt);
      break;
    case 1606:
      HASH_INVOKE_FROM_EVAL(0x4901517CB796F646LL, msg_set_queue);
      HASH_INVOKE_FROM_EVAL(0x234F6A0A486E8646LL, natcasesort);
      break;
    case 1614:
      HASH_INVOKE_FROM_EVAL(0x7E978C38D741664ELL, fgetcsv);
      HASH_INVOKE_FROM_EVAL(0x769E5C6A5369F64ELL, ob_list_handlers);
      break;
    case 1618:
      HASH_INVOKE_FROM_EVAL(0x03066277F647E652LL, hphp_splfileobject_ftell);
      break;
    case 1621:
      HASH_INVOKE_FROM_EVAL(0x629EDDC1E74ED655LL, array_uintersect_assoc);
      break;
    case 1625:
      HASH_INVOKE_FROM_EVAL(0x7A4B37C23D674659LL, collator_get_error_message);
      break;
    case 1628:
      HASH_INVOKE_FROM_EVAL(0x381BBFEABFEC865CLL, libxml_get_last_error);
      break;
    case 1630:
      HASH_INVOKE_FROM_EVAL(0x1491ED033E39465ELL, dom_document_schema_validate_xml);
      HASH_INVOKE_FROM_EVAL(0x205BB9CFF397B65ELL, ldap_mod_replace);
      break;
    case 1631:
      HASH_INVOKE_FROM_EVAL(0x1355AFB40AB1165FLL, drawsetfontstyle);
      break;
    case 1634:
      HASH_INVOKE_FROM_EVAL(0x5629E14D6B9FF662LL, dom_document_get_element_by_id);
      break;
    case 1636:
      HASH_INVOKE_FROM_EVAL(0x5B0759F776EC2664LL, newdrawingwand);
      break;
    case 1637:
      HASH_INVOKE_FROM_EVAL(0x08A6AD20C2C5A665LL, hphp_set_static_property);
      break;
    case 1639:
      HASH_INVOKE_FROM_EVAL(0x557A08AC57724667LL, hphp_splfileinfo_getpathinfo);
      break;
    case 1647:
      HASH_INVOKE_FROM_EVAL(0x7D68CADB8069466FLL, magickaverageimages);
      break;
    case 1651:
      HASH_INVOKE_FROM_EVAL(0x126FC82D358E9673LL, magicksetimagevirtualpixelmethod);
      break;
    case 1655:
      HASH_INVOKE_FROM_EVAL(0x001F23CAC36E3677LL, magickgetimagescene);
      break;
    case 1658:
      HASH_INVOKE_FROM_EVAL(0x583AA7498A40E67ALL, drawgetcliprule);
      break;
    case 1659:
      HASH_INVOKE_FROM_EVAL(0x5BCED33A57D9B67BLL, intval);
      break;
    case 1660:
      HASH_INVOKE_FROM_EVAL(0x43B1BAFFB27F367CLL, session_is_registered);
      break;
    case 1661:
      HASH_INVOKE_FROM_EVAL(0x69616E2817E1967DLL, fileinode);
      HASH_INVOKE_FROM_EVAL(0x111DACCF8628267DLL, array_replace_recursive);
      break;
    case 1666:
      HASH_INVOKE_FROM_EVAL(0x665D2615E377A682LL, pagelet_server_task_start);
      HASH_INVOKE_FROM_EVAL(0x5F6750E1C7E5D682LL, imageinterlace);
      break;
    case 1677:
      HASH_INVOKE_FROM_EVAL(0x07A946E3DD8E968DLL, ldap_connect);
      break;
    case 1679:
      HASH_INVOKE_FROM_EVAL(0x2EFF4F69EB1DF68FLL, apache_get_config);
      break;
    case 1680:
      HASH_INVOKE_FROM_EVAL(0x166D5E2336878690LL, imagepolygon);
      break;
    case 1681:
      HASH_INVOKE_FROM_EVAL(0x57BA0BC1A4870691LL, magickgetquantumdepth);
      break;
    case 1682:
      HASH_INVOKE_FROM_EVAL(0x16BE0DBA42800692LL, magickgetimagesize);
      break;
    case 1684:
      HASH_INVOKE_FROM_EVAL(0x2673FAB2B4DE4694LL, destroypixelwands);
      break;
    case 1685:
      HASH_INVOKE_FROM_EVAL(0x7186EF5EF0581695LL, exp);
      break;
    case 1686:
      HASH_INVOKE_FROM_EVAL(0x0DD7A2DB53093696LL, utf8_decode);
      break;
    case 1690:
      HASH_INVOKE_FROM_EVAL(0x5CC40F6A365FE69ALL, session_register);
      break;
    case 1691:
      HASH_INVOKE_FROM_EVAL(0x24D34E49C21DE69BLL, mb_stristr);
      break;
    case 1694:
      HASH_INVOKE_FROM_EVAL(0x5E9821F06711669ELL, gethostbynamel);
      break;
    case 1702:
      HASH_INVOKE_FROM_EVAL(0x0D841874977646A6LL, krsort);
      break;
    case 1703:
      HASH_INVOKE_FROM_EVAL(0x38BBEE42F136D6A7LL, magickgetimageblueprimary);
      break;
    case 1704:
      HASH_INVOKE_FROM_EVAL(0x45AB8F419BA666A8LL, drawpathlinetohorizontalabsolute);
      break;
    case 1706:
      HASH_INVOKE_FROM_EVAL(0x6E9D4D3A119D76AALL, wandgetexceptiontype);
      HASH_INVOKE_FROM_EVAL(0x48C4DB333172F6AALL, parse_url);
      HASH_INVOKE_FROM_EVAL(0x541926FB6D6FC6AALL, magickgetimagecolors);
      break;
    case 1707:
      HASH_INVOKE_FROM_EVAL(0x72B3F8E02D8B16ABLL, array_unshift);
      break;
    case 1711:
      HASH_INVOKE_FROM_EVAL(0x65497D63C0D716AFLL, getdate);
      break;
    case 1712:
      HASH_INVOKE_FROM_EVAL(0x23AAF570C78AC6B0LL, ip2long);
      break;
    case 1714:
      HASH_INVOKE_FROM_EVAL(0x0D669C546C0EC6B2LL, proc_terminate);
      break;
    case 1717:
      HASH_INVOKE_FROM_EVAL(0x798B4197212456B5LL, bcpowmod);
      HASH_INVOKE_FROM_EVAL(0x623CE67C41A9E6B5LL, ldap_next_attribute);
      HASH_INVOKE_FROM_EVAL(0x7E773A36449576B5LL, imagecharup);
      break;
    case 1719:
      HASH_INVOKE_FROM_EVAL(0x0C44E5EEB9C646B7LL, memcache_connect);
      break;
    case 1721:
      HASH_INVOKE_FROM_EVAL(0x316F054CB76446B9LL, openssl_sign);
      break;
    case 1722:
      HASH_INVOKE_FROM_EVAL(0x4605D48C234606BALL, dom_document_import_node);
      HASH_INVOKE_FROM_EVAL(0x72B901C3605CB6BALL, pixelsetopacity);
      break;
    case 1726:
      HASH_INVOKE_FROM_EVAL(0x081D5EA9920076BELL, drawgetfillalpha);
      break;
    case 1732:
      HASH_INVOKE_FROM_EVAL(0x4842AF70A71BE6C4LL, uksort);
      HASH_INVOKE_FROM_EVAL(0x34184B42D6AA86C4LL, mb_ereg_search_pos);
      HASH_INVOKE_FROM_EVAL(0x3C042C09F662C6C4LL, drawsetstrokepatternurl);
      break;
    case 1733:
      HASH_INVOKE_FROM_EVAL(0x28526EF49FF516C5LL, pixelsetgreenquantum);
      break;
    case 1736:
      HASH_INVOKE_FROM_EVAL(0x29DD2C9F889246C8LL, passthru);
      break;
    case 1737:
      HASH_INVOKE_FROM_EVAL(0x2D8DF100C30D06C9LL, xmlwriter_set_indent_string);
      break;
    case 1738:
      HASH_INVOKE_FROM_EVAL(0x41BCD0A72B1396CALL, xmlwriter_start_dtd_attlist);
      break;
    case 1745:
      HASH_INVOKE_FROM_EVAL(0x2B3D5B9AF915D6D1LL, imagecopymerge);
      break;
    case 1746:
      HASH_INVOKE_FROM_EVAL(0x1FDF80EA9B8A96D2LL, collator_set_strength);
      break;
    case 1748:
      HASH_INVOKE_FROM_EVAL(0x04A0E6E8337E56D4LL, drawcolor);
      break;
    case 1749:
      HASH_INVOKE_FROM_EVAL(0x317FFA522A7D96D5LL, imagefilledpolygon);
      break;
    case 1750:
      HASH_INVOKE_FROM_EVAL(0x158348EB08F406D6LL, strtr);
      break;
    case 1761:
      HASH_INVOKE_FROM_EVAL(0x11DA0A0EB8E0D6E1LL, clock_getres);
      break;
    case 1764:
      HASH_INVOKE_FROM_EVAL(0x40D0E3AF799226E4LL, bin2hex);
      HASH_INVOKE_FROM_EVAL(0x1CF3544CB5C9D6E4LL, xml_set_processing_instruction_handler);
      HASH_INVOKE_FROM_EVAL(0x31FFFC333AA6D6E4LL, drawsetfillrule);
      break;
    case 1767:
      HASH_INVOKE_FROM_EVAL(0x44201A16F3D876E7LL, trim);
      break;
    case 1772:
      HASH_INVOKE_FROM_EVAL(0x0A5EFECAE87EA6ECLL, hphp_splfileobject_eof);
      break;
    case 1773:
      HASH_INVOKE_FROM_EVAL(0x04BD4B43921956EDLL, ldap_search);
      HASH_INVOKE_FROM_EVAL(0x2B661CD43C6006EDLL, hphpd_break);
      break;
    case 1774:
      HASH_INVOKE_FROM_EVAL(0x76382756EA00B6EELL, is_object);
      break;
    case 1775:
      HASH_INVOKE_FROM_EVAL(0x0FA74D85885F86EFLL, output_add_rewrite_var);
      break;
    case 1776:
      HASH_INVOKE_FROM_EVAL(0x014BD9A6823256F0LL, extract);
      break;
    case 1777:
      HASH_INVOKE_FROM_EVAL(0x6B7347DF1AA7E6F1LL, drawpopdefs);
      break;
    case 1778:
      HASH_INVOKE_FROM_EVAL(0x314DA880FE2CE6F2LL, session_start);
      break;
    case 1779:
      HASH_INVOKE_FROM_EVAL(0x6F1968BE449FB6F3LL, stream_socket_pair);
      HASH_INVOKE_FROM_EVAL(0x5768A80BB0B926F3LL, apd_set_session_trace_socket);
      break;
    case 1782:
      HASH_INVOKE_FROM_EVAL(0x534C1A5E626C26F6LL, collator_get_error_code);
      break;
    case 1785:
      HASH_INVOKE_FROM_EVAL(0x20740D956F0236F9LL, image2wbmp);
      break;
    case 1791:
      HASH_INVOKE_FROM_EVAL(0x623C20A027A606FFLL, array_uintersect_uassoc);
      break;
    case 1793:
      HASH_INVOKE_FROM_EVAL(0x1A80392751AA7701LL, magickgetformat);
      break;
    case 1796:
      HASH_INVOKE_FROM_EVAL(0x5EFE15CE970A5704LL, drawpolyline);
      break;
    case 1801:
      HASH_INVOKE_FROM_EVAL(0x7681C631B34CC709LL, hphp_splfileobject_fflush);
      HASH_INVOKE_FROM_EVAL(0x21972B2BC7A14709LL, imageistruecolor);
      break;
    case 1803:
      HASH_INVOKE_FROM_EVAL(0x27AF8F6A5DF0B70BLL, dom_document_xinclude);
      HASH_INVOKE_FROM_EVAL(0x5F7873F2DF5BE70BLL, ctype_cntrl);
      break;
    case 1805:
      HASH_INVOKE_FROM_EVAL(0x7CE752299E80B70DLL, unserialize);
      HASH_INVOKE_FROM_EVAL(0x4F3C0DB2F6C8F70DLL, unlink);
      break;
    case 1807:
      HASH_INVOKE_FROM_EVAL(0x2FB2FA1DD832C70FLL, xmlwriter_write_attribute_ns);
      break;
    case 1812:
      HASH_INVOKE_FROM_EVAL(0x1778ED2AF035F714LL, rsort);
      break;
    case 1813:
      HASH_INVOKE_FROM_EVAL(0x25D578B4772C1715LL, define);
      break;
    case 1816:
      HASH_INVOKE_FROM_EVAL(0x7971A5647C957718LL, date_time_set);
      break;
    case 1819:
      HASH_INVOKE_FROM_EVAL(0x3C16230CBC6D471BLL, imagecreatetruecolor);
      break;
    case 1820:
      HASH_INVOKE_FROM_EVAL(0x50AC61A28C5AC71CLL, imagecolorclosestalpha);
      break;
    case 1824:
      HASH_INVOKE_FROM_EVAL(0x2D213FD80048F720LL, usleep);
      break;
    case 1827:
      HASH_INVOKE_FROM_EVAL(0x78420E0B5D110723LL, imagetruecolortopalette);
      break;
    case 1828:
      HASH_INVOKE_FROM_EVAL(0x4DAA3FBC2BD3A724LL, magickequalizeimage);
      break;
    case 1829:
      HASH_INVOKE_FROM_EVAL(0x31EAD049860CE725LL, posix_kill);
      break;
    case 1830:
      HASH_INVOKE_FROM_EVAL(0x523AB2EA95DAD726LL, get_included_files);
      break;
    case 1831:
      HASH_INVOKE_FROM_EVAL(0x11641BE0F11CD727LL, magickgammaimage);
      break;
    case 1833:
      HASH_INVOKE_FROM_EVAL(0x1D30F1E638D71729LL, readgzfile);
      break;
    case 1834:
      HASH_INVOKE_FROM_EVAL(0x17C0D9B1C10B872ALL, openssl_x509_export);
      HASH_INVOKE_FROM_EVAL(0x1F98B41362CDA72ALL, magickgetimagegreenprimary);
      break;
    case 1837:
      HASH_INVOKE_FROM_EVAL(0x14563723F798172DLL, magickpaintopaqueimage);
      break;
    case 1840:
      HASH_INVOKE_FROM_EVAL(0x0D558F552A784730LL, ob_get_contents);
      break;
    case 1842:
      HASH_INVOKE_FROM_EVAL(0x2B1C192C419B8732LL, drawgetexception);
      break;
    case 1850:
      HASH_INVOKE_FROM_EVAL(0x404236CC5ABD973ALL, xhprof_run_trace);
      break;
    case 1855:
      HASH_INVOKE_FROM_EVAL(0x650E641CC0E3873FLL, connection_aborted);
      break;
    case 1857:
      HASH_INVOKE_FROM_EVAL(0x5062777D2B947741LL, wordwrap);
      break;
    case 1863:
      HASH_INVOKE_FROM_EVAL(0x3CD58419E181A747LL, magickstereoimage);
      HASH_INVOKE_FROM_EVAL(0x13BB9EC5A2D2E747LL, hphp_splfileinfo_isdir);
      break;
    case 1864:
      HASH_INVOKE_FROM_EVAL(0x0D7BBA9608A36748LL, magickcombineimages);
      break;
    case 1865:
      HASH_INVOKE_FROM_EVAL(0x73E4417BA7B49749LL, curl_multi_info_read);
      break;
    case 1866:
      HASH_INVOKE_FROM_EVAL(0x1FF03B7DE19DD74ALL, drawpathmovetorelative);
      break;
    case 1867:
      HASH_INVOKE_FROM_EVAL(0x7DA9307A6149B74BLL, get_meta_tags);
      break;
    case 1873:
      HASH_INVOKE_FROM_EVAL(0x017FF216C00D9751LL, property_exists);
      break;
    case 1875:
      HASH_INVOKE_FROM_EVAL(0x42795829DF700753LL, mysql_get_host_info);
      break;
    case 1876:
      HASH_INVOKE_FROM_EVAL(0x53AEFD595C044754LL, max);
      break;
    case 1879:
      HASH_INVOKE_FROM_EVAL(0x7554E3E8674F2757LL, mb_list_encodings);
      break;
    case 1883:
      HASH_INVOKE_FROM_EVAL(0x05D293F45C15F75BLL, ldap_mod_del);
      break;
    case 1884:
      HASH_INVOKE_FROM_EVAL(0x6D5B592E524AF75CLL, hphp_splfileinfo_getbasename);
      break;
    case 1887:
      HASH_INVOKE_FROM_EVAL(0x3EDB48C5DDD9675FLL, socket_select);
      break;
    case 1888:
      HASH_INVOKE_FROM_EVAL(0x1BD984C11BB16760LL, array_merge);
      HASH_INVOKE_FROM_EVAL(0x7AB5E6EA37196760LL, date_timezone_set);
      break;
    case 1889:
      HASH_INVOKE_FROM_EVAL(0x6AF50085AC2AC761LL, xmlwriter_write_element);
      break;
    case 1891:
      HASH_INVOKE_FROM_EVAL(0x7FCE6DD53FED6763LL, intl_is_failure);
      break;
    case 1893:
      HASH_INVOKE_FROM_EVAL(0x1D803CE961921765LL, md5);
      HASH_INVOKE_FROM_EVAL(0x45631C592AD6D765LL, str_ireplace);
      break;
    case 1894:
      HASH_INVOKE_FROM_EVAL(0x1F4505BE6460D766LL, scandir);
      break;
    case 1895:
      HASH_INVOKE_FROM_EVAL(0x2FC27987B3F88767LL, dom_node_clone_node);
      HASH_INVOKE_FROM_EVAL(0x6C280D5855D20767LL, drawsetfillalpha);
      break;
    case 1896:
      HASH_INVOKE_FROM_EVAL(0x179A72074C778768LL, openssl_x509_export_to_file);
      break;
    case 1901:
      HASH_INVOKE_FROM_EVAL(0x3304663FBC6C976DLL, get_html_translation_table);
      HASH_INVOKE_FROM_EVAL(0x553ADA5A41AE976DLL, mb_ereg_replace);
      break;
    case 1902:
      HASH_INVOKE_FROM_EVAL(0x6DB71D850799D76ELL, hphp_splfileobject_fscanf);
      break;
    case 1904:
      HASH_INVOKE_FROM_EVAL(0x6F6C5B9E3DC64770LL, drawgetstrokemiterlimit);
      break;
    case 1909:
      HASH_INVOKE_FROM_EVAL(0x04D9076808F79775LL, getenv);
      break;
    case 1910:
      HASH_INVOKE_FROM_EVAL(0x616DDB67073A0776LL, ord);
      HASH_INVOKE_FROM_EVAL(0x4102C410C5031776LL, magickcolorizeimage);
      break;
    case 1914:
      HASH_INVOKE_FROM_EVAL(0x1FBF36B5D65E677ALL, fb_call_user_func_safe_return);
      HASH_INVOKE_FROM_EVAL(0x4330CE9C9002477ALL, array_udiff_uassoc);
      break;
    case 1915:
      HASH_INVOKE_FROM_EVAL(0x129E39AC523A977BLL, magickgethomeurl);
      break;
    case 1920:
      HASH_INVOKE_FROM_EVAL(0x29824AAA934CE780LL, array_filter);
      break;
    case 1923:
      HASH_INVOKE_FROM_EVAL(0x53B4DBE58B356783LL, imagesetthickness);
      HASH_INVOKE_FROM_EVAL(0x38704D99FEA9B783LL, mysql_fetch_array);
      break;
    case 1924:
      HASH_INVOKE_FROM_EVAL(0x784FD2E7191A3784LL, drawpathellipticarcrelative);
      break;
    case 1925:
      HASH_INVOKE_FROM_EVAL(0x5BFC6198960A5785LL, in_array);
      break;
    case 1927:
      HASH_INVOKE_FROM_EVAL(0x4991643BD854D787LL, drawgetexceptionstring);
      break;
    case 1928:
      HASH_INVOKE_FROM_EVAL(0x32D8CE5D0FA6D788LL, ldap_rename);
      break;
    case 1930:
      HASH_INVOKE_FROM_EVAL(0x70A1EC006032E78ALL, pixelgetquantumcolor);
      break;
    case 1935:
      HASH_INVOKE_FROM_EVAL(0x7B4E25772D0AC78FLL, simplexml_load_file);
      break;
    case 1938:
      HASH_INVOKE_FROM_EVAL(0x0D4891A5E1A20792LL, get_defined_functions);
      break;
    case 1941:
      HASH_INVOKE_FROM_EVAL(0x34BA3AAA6711C795LL, dom_document_create_entity_reference);
      break;
    case 1942:
      HASH_INVOKE_FROM_EVAL(0x5B42B2AB1B57D796LL, array_replace);
      break;
    case 1945:
      HASH_INVOKE_FROM_EVAL(0x26D226FD28566799LL, date_isodate_set);
      break;
    case 1947:
      HASH_INVOKE_FROM_EVAL(0x1196D899ACCD379BLL, evhttp_recv);
      break;
    case 1949:
      HASH_INVOKE_FROM_EVAL(0x02ECD8C169DF579DLL, feof);
      break;
    case 1951:
      HASH_INVOKE_FROM_EVAL(0x4B092931EFB7979FLL, mysql_create_db);
      break;
    case 1959:
      HASH_INVOKE_FROM_EVAL(0x1F76E954F9A147A7LL, magickcontrastimage);
      break;
    case 1961:
      HASH_INVOKE_FROM_EVAL(0x7C251B7DE8DB87A9LL, mcrypt_list_algorithms);
      HASH_INVOKE_FROM_EVAL(0x7707A7FEA07FB7A9LL, hphp_recursivedirectoryiterator___construct);
      break;
    case 1962:
      HASH_INVOKE_FROM_EVAL(0x45A53A884414A7AALL, pack);
      HASH_INVOKE_FROM_EVAL(0x58D6464A3A9127AALL, apc_bin_loadfile);
      break;
    case 1965:
      HASH_INVOKE_FROM_EVAL(0x7DA08D9D148837ADLL, posix_mkfifo);
      HASH_INVOKE_FROM_EVAL(0x217C52A1EBDF87ADLL, apache_get_version);
      break;
    case 1966:
      HASH_INVOKE_FROM_EVAL(0x00141B0E3E6F77AELL, xml_set_unparsed_entity_decl_handler);
      break;
    case 1967:
      HASH_INVOKE_FROM_EVAL(0x16CB9891EF26D7AFLL, drawgetstrokedashoffset);
      break;
    case 1977:
      HASH_INVOKE_FROM_EVAL(0x1FC9406FD7FCD7B9LL, strrpos);
      HASH_INVOKE_FROM_EVAL(0x1B6467AD87E167B9LL, log1p);
      break;
    case 1983:
      HASH_INVOKE_FROM_EVAL(0x3F46374E6E1B07BFLL, posix_getpwuid);
      break;
    case 1984:
      HASH_INVOKE_FROM_EVAL(0x152D1AB941A647C0LL, hphp_get_extension_info);
      HASH_INVOKE_FROM_EVAL(0x52FDAC1D298D67C0LL, mcrypt_enc_get_algorithms_name);
      break;
    case 1985:
      HASH_INVOKE_FROM_EVAL(0x4E172EA6743697C1LL, ldap_first_entry);
      break;
    case 1988:
      HASH_INVOKE_FROM_EVAL(0x3C696836396BE7C4LL, mb_language);
      break;
    case 1990:
      HASH_INVOKE_FROM_EVAL(0x0C8A7BE6ABC957C6LL, clearpixeliterator);
      HASH_INVOKE_FROM_EVAL(0x3D6D684AF537A7C6LL, ldap_explode_dn);
      break;
    case 1991:
      HASH_INVOKE_FROM_EVAL(0x686C5142FD0337C7LL, lcg_value);
      break;
    case 1993:
      HASH_INVOKE_FROM_EVAL(0x6BF7D7B5FBFF77C9LL, hphp_get_thread_id);
      break;
    case 1994:
      HASH_INVOKE_FROM_EVAL(0x3C781898488687CALL, xml_parse);
      HASH_INVOKE_FROM_EVAL(0x55B68546CFAC87CALL, magicksetimageresolution);
      break;
    case 1998:
      HASH_INVOKE_FROM_EVAL(0x3AE33FEA6830C7CELL, magickshearimage);
      break;
    case 1999:
      HASH_INVOKE_FROM_EVAL(0x2FAB1F75659707CFLL, is_scalar);
      break;
    case 2001:
      HASH_INVOKE_FROM_EVAL(0x35B661C87484D7D1LL, openssl_csr_sign);
      break;
    case 2009:
      HASH_INVOKE_FROM_EVAL(0x2ED6760DAA3A67D9LL, strcasecmp);
      break;
    case 2012:
      HASH_INVOKE_FROM_EVAL(0x1FE65AFCC92967DCLL, rmdir);
      break;
    case 2013:
      HASH_INVOKE_FROM_EVAL(0x2B5AEDF1A5FC47DDLL, strripos);
      break;
    case 2017:
      HASH_INVOKE_FROM_EVAL(0x7AA1691D3D94A7E1LL, dom_xpath_evaluate);
      break;
    case 2018:
      HASH_INVOKE_FROM_EVAL(0x0888289CBD2887E2LL, iconv_substr);
      break;
    case 2020:
      HASH_INVOKE_FROM_EVAL(0x2621680306BC97E4LL, magicksetimagescene);
      break;
    case 2023:
      HASH_INVOKE_FROM_EVAL(0x4215DDB57604F7E7LL, xmlwriter_start_pi);
      break;
    case 2024:
      HASH_INVOKE_FROM_EVAL(0x53B7BF8991FA67E8LL, i18n_loc_get_error_code);
      break;
    case 2025:
      HASH_INVOKE_FROM_EVAL(0x6BB8AC68771287E9LL, strcmp);
      break;
    case 2027:
      HASH_INVOKE_FROM_EVAL(0x54AE7140B95027EBLL, pixelgetgreenquantum);
      HASH_INVOKE_FROM_EVAL(0x1A397501431EC7EBLL, is_numeric);
      break;
    case 2029:
      HASH_INVOKE_FROM_EVAL(0x0DC2C2D372EC97EDLL, hphp_crash_log);
      break;
    case 2031:
      HASH_INVOKE_FROM_EVAL(0x5367B0F3A4D2D7EFLL, ldap_list);
      break;
    case 2032:
      HASH_INVOKE_FROM_EVAL(0x14F700DD189DB7F0LL, drawsetclipunits);
      break;
    case 2035:
      HASH_INVOKE_FROM_EVAL(0x73877357478137F3LL, posix_ctermid);
      HASH_INVOKE_FROM_EVAL(0x4B57E07A323FE7F3LL, drawpathlinetoverticalabsolute);
      HASH_INVOKE_FROM_EVAL(0x7F436B50B7BBD7F3LL, getcwd);
      break;
    case 2041:
      HASH_INVOKE_FROM_EVAL(0x376FB2649384A7F9LL, str_pad);
      break;
    case 2042:
      HASH_INVOKE_FROM_EVAL(0x0FD7C3144B4007FALL, libxml_set_streams_context);
      break;
    case 2045:
      HASH_INVOKE_FROM_EVAL(0x238E501F2536E7FDLL, drawsetclippath);
      break;
    case 2048:
      HASH_INVOKE_FROM_EVAL(0x0E66983DD04B0800LL, get_current_user);
      break;
    case 2049:
      HASH_INVOKE_FROM_EVAL(0x290E54137CF06801LL, dom_nodelist_item);
      break;
    case 2051:
      HASH_INVOKE_FROM_EVAL(0x10F7244AA9CB5803LL, imagepstext);
      break;
    case 2052:
      HASH_INVOKE_FROM_EVAL(0x349A0DF6723B6804LL, pixelsetcolorcount);
      break;
    case 2054:
      HASH_INVOKE_FROM_EVAL(0x4D832DD6A72AB806LL, dom_document_create_attribute);
      break;
    case 2056:
      HASH_INVOKE_FROM_EVAL(0x19279D6DB4F70808LL, hash_hmac);
      HASH_INVOKE_FROM_EVAL(0x083B8F01AE15B808LL, assert);
      break;
    case 2057:
      HASH_INVOKE_FROM_EVAL(0x52DCFB6F41D41809LL, dom_characterdata_append_data);
      HASH_INVOKE_FROM_EVAL(0x221F5A9D5E021809LL, magickwriteimages);
      break;
    case 2058:
      HASH_INVOKE_FROM_EVAL(0x5A0D1AE1D4C6F80ALL, array_slice);
      break;
    case 2060:
      HASH_INVOKE_FROM_EVAL(0x3FF63423EC4B280CLL, posix_getegid);
      break;
    case 2061:
      HASH_INVOKE_FROM_EVAL(0x11EC19E702F2C80DLL, getmyinode);
      HASH_INVOKE_FROM_EVAL(0x727F5A6D8E26B80DLL, extension_loaded);
      break;
    case 2064:
      HASH_INVOKE_FROM_EVAL(0x4297B1072CE76810LL, fb_call_user_func_array_safe);
      break;
    case 2067:
      HASH_INVOKE_FROM_EVAL(0x1A6B577442218813LL, pixelsetmagentaquantum);
      HASH_INVOKE_FROM_EVAL(0x5F7940A713863813LL, floor);
      break;
    case 2068:
      HASH_INVOKE_FROM_EVAL(0x3C0DFA15D3447814LL, rawurldecode);
      break;
    case 2071:
      HASH_INVOKE_FROM_EVAL(0x0D8B1D0A8C381817LL, stream_bucket_new);
      break;
    case 2072:
      HASH_INVOKE_FROM_EVAL(0x0FBDB0B22A59B818LL, mailparse_msg_parse);
      break;
    case 2077:
      HASH_INVOKE_FROM_EVAL(0x4D624A655A9B581DLL, drawpoint);
      break;
    case 2081:
      HASH_INVOKE_FROM_EVAL(0x2D52FB9B52EC2821LL, xml_set_notation_decl_handler);
      HASH_INVOKE_FROM_EVAL(0x107DBCA79C15B821LL, addcslashes);
      break;
    case 2082:
      HASH_INVOKE_FROM_EVAL(0x13C241C02DE72822LL, dom_document_relaxng_validate_xml);
      break;
    case 2084:
      HASH_INVOKE_FROM_EVAL(0x2B78E204F615A824LL, openssl_pkcs12_export_to_file);
      break;
    case 2087:
      HASH_INVOKE_FROM_EVAL(0x33EC567341B9C827LL, magickgetmaxtextadvance);
      break;
    case 2089:
      HASH_INVOKE_FROM_EVAL(0x39EE4CCCA716E829LL, stream_context_get_options);
      HASH_INVOKE_FROM_EVAL(0x57FFCEB7FA2D9829LL, usort);
      break;
    case 2092:
      HASH_INVOKE_FROM_EVAL(0x34F0E032AB05C82CLL, pixelsetblue);
      break;
    case 2093:
      HASH_INVOKE_FROM_EVAL(0x1C4AE57BF4E4A82DLL, apc_dec);
      break;
    case 2094:
      HASH_INVOKE_FROM_EVAL(0x3402C1E7544C382ELL, lstat);
      break;
    case 2095:
      HASH_INVOKE_FROM_EVAL(0x79A05154A7F5482FLL, magickgetimagedelay);
      break;
    case 2096:
      HASH_INVOKE_FROM_EVAL(0x5BBFA7EAEBD25830LL, pixelgetcyanquantum);
      break;
    case 2100:
      HASH_INVOKE_FROM_EVAL(0x605132E71CE7D834LL, array_push);
      break;
    case 2101:
      HASH_INVOKE_FROM_EVAL(0x1C4A162E6635B835LL, imageftbbox);
      HASH_INVOKE_FROM_EVAL(0x43A96BA7F58EB835LL, hphp_splfileobject_valid);
      break;
    case 2104:
      HASH_INVOKE_FROM_EVAL(0x63E554E0F11CE838LL, mysql_unbuffered_query);
      HASH_INVOKE_FROM_EVAL(0x03098F16B0AD5838LL, mcrypt_module_get_supported_key_sizes);
      HASH_INVOKE_FROM_EVAL(0x0890F9052322E838LL, fstat);
      break;
    case 2107:
      HASH_INVOKE_FROM_EVAL(0x63E2EA180786B83BLL, pixelsetblack);
      break;
    case 2108:
      HASH_INVOKE_FROM_EVAL(0x7C8969C75CA1783CLL, get_declared_classes);
      HASH_INVOKE_FROM_EVAL(0x034EDEBD109FD83CLL, filesize);
      break;
    case 2115:
      HASH_INVOKE_FROM_EVAL(0x567A7139AD476843LL, socket_listen);
      break;
    case 2118:
      HASH_INVOKE_FROM_EVAL(0x50088ED5D482C846LL, ldap_mod_add);
      break;
    case 2119:
      HASH_INVOKE_FROM_EVAL(0x4E69A952E3EA4847LL, magicksetfilename);
      break;
    case 2122:
      HASH_INVOKE_FROM_EVAL(0x7D3F626E636C084ALL, ldap_delete);
      break;
    case 2123:
      HASH_INVOKE_FROM_EVAL(0x68B7597C22FA484BLL, openssl_public_encrypt);
      break;
    case 2124:
      HASH_INVOKE_FROM_EVAL(0x26A2BBC465A2B84CLL, strcoll);
      break;
    case 2126:
      HASH_INVOKE_FROM_EVAL(0x488C2F267BF2884ELL, array_intersect);
      break;
    case 2127:
      HASH_INVOKE_FROM_EVAL(0x632D491E42E7E84FLL, session_get_cookie_params);
      break;
    case 2128:
      HASH_INVOKE_FROM_EVAL(0x4DDB82A3632FA850LL, atan);
      break;
    case 2129:
      HASH_INVOKE_FROM_EVAL(0x488BFCC942C73851LL, gzopen);
      break;
    case 2134:
      HASH_INVOKE_FROM_EVAL(0x51FD8C9B5109F856LL, dom_characterdata_replace_data);
      break;
    case 2140:
      HASH_INVOKE_FROM_EVAL(0x5A017A4C6A41E85CLL, curl_multi_add_handle);
      break;
    case 2142:
      HASH_INVOKE_FROM_EVAL(0x3D8327794429585ELL, hphpd_install_user_command);
      HASH_INVOKE_FROM_EVAL(0x6B4DE6865142285ELL, destroypixeliterator);
      break;
    case 2145:
      HASH_INVOKE_FROM_EVAL(0x2AD6B0E3B9F3B861LL, array_search);
      break;
    case 2147:
      HASH_INVOKE_FROM_EVAL(0x21B30164F5D49863LL, is_resource);
      break;
    case 2148:
      HASH_INVOKE_FROM_EVAL(0x168EDA8238EEE864LL, mb_detect_order);
      break;
    case 2151:
      HASH_INVOKE_FROM_EVAL(0x65A68A31B96E7867LL, hash);
      break;
    case 2152:
      HASH_INVOKE_FROM_EVAL(0x785C812E6292E868LL, i18n_loc_set_default);
      break;
    case 2153:
      HASH_INVOKE_FROM_EVAL(0x246EC2B1844DB869LL, pixelgetexception);
      break;
    case 2155:
      HASH_INVOKE_FROM_EVAL(0x0C1BBEDECEF1C86BLL, newmagickwand);
      break;
    case 2156:
      HASH_INVOKE_FROM_EVAL(0x6414504A6658286CLL, stripos);
      break;
    case 2159:
      HASH_INVOKE_FROM_EVAL(0x1476A177CC50686FLL, mb_strstr);
      break;
    case 2160:
      HASH_INVOKE_FROM_EVAL(0x34F50577C14C6870LL, array_diff_uassoc);
      break;
    case 2162:
      HASH_INVOKE_FROM_EVAL(0x3C7B86F57AFA0872LL, hebrev);
      HASH_INVOKE_FROM_EVAL(0x558D62FBEB210872LL, str_rot13);
      break;
    case 2163:
      HASH_INVOKE_FROM_EVAL(0x4C06B4AFC1C08873LL, str_shuffle);
      break;
    case 2167:
      HASH_INVOKE_FROM_EVAL(0x6AA3788C9B737877LL, magickdespeckleimage);
      break;
    case 2168:
      HASH_INVOKE_FROM_EVAL(0x00F8C6758B50B878LL, drawpathcurvetoquadraticbezierabsolute);
      break;
    case 2172:
      HASH_INVOKE_FROM_EVAL(0x11DFC3C9D916387CLL, hphp_splfileobject_ftruncate);
      HASH_INVOKE_FROM_EVAL(0x6451BCB825D1787CLL, chroot);
      break;
    case 2173:
      HASH_INVOKE_FROM_EVAL(0x54F84DC9A334287DLL, gzencode);
      HASH_INVOKE_FROM_EVAL(0x2B36081E0828487DLL, debug_print_backtrace);
      break;
    case 2176:
      HASH_INVOKE_FROM_EVAL(0x7549612A72BA5880LL, hphp_splfileinfo_getrealpath);
      break;
    case 2179:
      HASH_INVOKE_FROM_EVAL(0x3EBD8F559B4EA883LL, hphp_splfileobject_getflags);
      break;
    case 2180:
      HASH_INVOKE_FROM_EVAL(0x766CD15A7F2A0884LL, array_uintersect);
      break;
    case 2184:
      HASH_INVOKE_FROM_EVAL(0x1062CF2DA5443888LL, imagedashedline);
      break;
    case 2191:
      HASH_INVOKE_FROM_EVAL(0x5DDC2A079AB7988FLL, dom_document_schema_validate_file);
      HASH_INVOKE_FROM_EVAL(0x539868C56806688FLL, imagecopyresampled);
      break;
    case 2200:
      HASH_INVOKE_FROM_EVAL(0x4AC522FF7BB60898LL, xmlwriter_write_dtd_entity);
      break;
    case 2205:
      HASH_INVOKE_FROM_EVAL(0x1FC855F0E4F1189DLL, magickminifyimage);
      break;
    case 2208:
      HASH_INVOKE_FROM_EVAL(0x6B1A3BCE67BAC8A0LL, openssl_csr_new);
      break;
    case 2209:
      HASH_INVOKE_FROM_EVAL(0x1756D4437A4098A1LL, date_modify);
      break;
    case 2215:
      HASH_INVOKE_FROM_EVAL(0x57105D4E43B078A7LL, magicksetformat);
      HASH_INVOKE_FROM_EVAL(0x6C6B4B739AE1B8A7LL, curl_close);
      break;
    case 2217:
      HASH_INVOKE_FROM_EVAL(0x346B2DB3BA2378A9LL, imagecolormatch);
      break;
    case 2218:
      HASH_INVOKE_FROM_EVAL(0x44BC069A75EE98AALL, xhprof_disable);
      break;
    case 2219:
      HASH_INVOKE_FROM_EVAL(0x39F11BA6A4D778ABLL, strnatcmp);
      break;
    case 2220:
      HASH_INVOKE_FROM_EVAL(0x5B1F4C6424DDD8ACLL, openlog);
      break;
    case 2224:
      HASH_INVOKE_FROM_EVAL(0x2CEF8DDC092698B0LL, drawgetvectorgraphics);
      break;
    case 2226:
      HASH_INVOKE_FROM_EVAL(0x31830AA5032428B2LL, is_double);
      break;
    case 2230:
      HASH_INVOKE_FROM_EVAL(0x5866C5DF3A1AD8B6LL, dom_element_get_attribute_node);
      break;
    case 2236:
      HASH_INVOKE_FROM_EVAL(0x7AE3AE9B634988BCLL, stream_context_create);
      break;
    case 2244:
      HASH_INVOKE_FROM_EVAL(0x5C28BE7FFE6A68C4LL, xml_set_start_namespace_decl_handler);
      break;
    case 2245:
      HASH_INVOKE_FROM_EVAL(0x146A1A7658CCA8C5LL, asinh);
      break;
    case 2247:
      HASH_INVOKE_FROM_EVAL(0x4623383F8534E8C7LL, array_multisort);
      HASH_INVOKE_FROM_EVAL(0x6D9B9BE3CED388C7LL, apc_load_constants);
      break;
    case 2254:
      HASH_INVOKE_FROM_EVAL(0x3FFAA982E4B1E8CELL, date_offset_get);
      break;
    case 2257:
      HASH_INVOKE_FROM_EVAL(0x1015EB3F52B098D1LL, print);
      break;
    case 2258:
      HASH_INVOKE_FROM_EVAL(0x74EB6C564ABC68D2LL, dom_document_create_text_node);
      break;
    case 2260:
      HASH_INVOKE_FROM_EVAL(0x6DB4EE8696C7E8D4LL, magicksetimageiterations);
      break;
    case 2262:
      HASH_INVOKE_FROM_EVAL(0x2F585B36DDDB68D6LL, mb_convert_case);
      HASH_INVOKE_FROM_EVAL(0x26DC8AB4A9CBE8D6LL, iconv);
      break;
    case 2264:
      HASH_INVOKE_FROM_EVAL(0x3A65182A3E8908D8LL, openssl_open);
      break;
    case 2265:
      HASH_INVOKE_FROM_EVAL(0x18B64D6BFE4208D9LL, stream_get_transports);
      break;
    case 2267:
      HASH_INVOKE_FROM_EVAL(0x4052842EC87038DBLL, magickcropimage);
      break;
    case 2268:
      HASH_INVOKE_FROM_EVAL(0x31F50FDA18B888DCLL, magickgetimagetype);
      break;
    case 2276:
      HASH_INVOKE_FROM_EVAL(0x16A18007E10F48E4LL, socket_getsockname);
      break;
    case 2278:
      HASH_INVOKE_FROM_EVAL(0x69887F054A1E28E6LL, strtok);
      break;
    case 2279:
      HASH_INVOKE_FROM_EVAL(0x608729F27FA428E7LL, error_get_last);
      break;
    case 2280:
      HASH_INVOKE_FROM_EVAL(0x4F7ED8C3156AD8E8LL, magicksetimagedispose);
      break;
    case 2293:
      HASH_INVOKE_FROM_EVAL(0x45DA105C5B48F8F5LL, apd_set_pprof_trace);
      break;
    case 2295:
      HASH_INVOKE_FROM_EVAL(0x17582BEA497D48F7LL, ctype_alpha);
      break;
    case 2298:
      HASH_INVOKE_FROM_EVAL(0x6F0F82818B68A8FALL, array_values);
      break;
    case 2299:
      HASH_INVOKE_FROM_EVAL(0x214532C4A2BC28FBLL, ldap_next_entry);
      break;
    case 2300:
      HASH_INVOKE_FROM_EVAL(0x4C2AFB2EFDB1B8FCLL, stripslashes);
      break;
    case 2302:
      HASH_INVOKE_FROM_EVAL(0x047BF4D3D0ED08FELL, strchr);
      break;
    case 2315:
      HASH_INVOKE_FROM_EVAL(0x67B879A1120C190BLL, headers_sent);
      HASH_INVOKE_FROM_EVAL(0x2987B15E11FE890BLL, clock_settime);
      break;
    case 2321:
      HASH_INVOKE_FROM_EVAL(0x04F822B7817E5911LL, bindec);
      HASH_INVOKE_FROM_EVAL(0x0AFD4F231D6CB911LL, magickaddimage);
      HASH_INVOKE_FROM_EVAL(0x5B9B2C3B32906911LL, drawsetfillpatternurl);
      break;
    case 2323:
      HASH_INVOKE_FROM_EVAL(0x55757E1242390913LL, cos);
      break;
    case 2324:
      HASH_INVOKE_FROM_EVAL(0x6E22C6D840B44914LL, mcrypt_generic_init);
      break;
    case 2326:
      HASH_INVOKE_FROM_EVAL(0x245A2DC3B6B62916LL, apache_lookup_uri);
      break;
    case 2329:
      HASH_INVOKE_FROM_EVAL(0x022B16C0D64D7919LL, file_put_contents);
      break;
    case 2331:
      HASH_INVOKE_FROM_EVAL(0x37A3DF6E0795091BLL, memcache_increment);
      break;
    case 2333:
      HASH_INVOKE_FROM_EVAL(0x069C028EFEF8C91DLL, date);
      break;
    case 2335:
      HASH_INVOKE_FROM_EVAL(0x277D7E2D1F5C191FLL, drawpathcurvetoquadraticbezierrelative);
      HASH_INVOKE_FROM_EVAL(0x4E2C55C92D71F91FLL, magickcolorfloodfillimage);
      break;
    case 2337:
      HASH_INVOKE_FROM_EVAL(0x0F5917FFCDD6C921LL, mb_substr);
      break;
    case 2339:
      HASH_INVOKE_FROM_EVAL(0x044B276686B77923LL, fscanf);
      break;
    case 2346:
      HASH_INVOKE_FROM_EVAL(0x174C510386E6492ALL, hphp_directoryiterator_key);
      break;
    case 2349:
      HASH_INVOKE_FROM_EVAL(0x27363CE6CBFC392DLL, pcntl_wexitstatus);
      HASH_INVOKE_FROM_EVAL(0x2337F8C3EE17192DLL, sprintf);
      break;
    case 2350:
      HASH_INVOKE_FROM_EVAL(0x26E8B741BDDDC92ELL, xmlwriter_start_element);
      break;
    case 2352:
      HASH_INVOKE_FROM_EVAL(0x507CE1912FD74930LL, mail);
      HASH_INVOKE_FROM_EVAL(0x30972530BD557930LL, shell_exec);
      break;
    case 2354:
      HASH_INVOKE_FROM_EVAL(0x72C01E1D90BE5932LL, mcrypt_enc_get_block_size);
      break;
    case 2356:
      HASH_INVOKE_FROM_EVAL(0x4FB95164A5F84934LL, mcrypt_generic_end);
      break;
    case 2357:
      HASH_INVOKE_FROM_EVAL(0x46BD9A56BDE40935LL, mysql_escape_string);
      HASH_INVOKE_FROM_EVAL(0x06486B6912479935LL, zlib_get_coding_type);
      HASH_INVOKE_FROM_EVAL(0x48D3CA6CA0B29935LL, mb_regex_set_options);
      break;
    case 2361:
      HASH_INVOKE_FROM_EVAL(0x5B60C8396C624939LL, mb_substitute_character);
      break;
    case 2366:
      HASH_INVOKE_FROM_EVAL(0x3946D67A0D16D93ELL, hphp_splfileinfo_isreadable);
      HASH_INVOKE_FROM_EVAL(0x0CADFE289C92893ELL, socket_getpeername);
      break;
    case 2371:
      HASH_INVOKE_FROM_EVAL(0x7C565AD57BC84943LL, pixelsetindex);
      break;
    case 2373:
      HASH_INVOKE_FROM_EVAL(0x7CB0596B6CCFA945LL, split);
      break;
    case 2375:
      HASH_INVOKE_FROM_EVAL(0x630288865DE68947LL, php_strip_whitespace);
      break;
    case 2376:
      HASH_INVOKE_FROM_EVAL(0x6A3412DE82715948LL, openssl_x509_checkpurpose);
      break;
    case 2377:
      HASH_INVOKE_FROM_EVAL(0x243BB8B284895949LL, apache_get_rewrite_rules);
      break;
    case 2379:
      HASH_INVOKE_FROM_EVAL(0x37F356F578FA394BLL, substr);
      break;
    case 2381:
      HASH_INVOKE_FROM_EVAL(0x3D3AD12E52FF294DLL, imagecreatefromwbmp);
      break;
    case 2387:
      HASH_INVOKE_FROM_EVAL(0x068438AFD33A9953LL, imagecolorclosesthwb);
      break;
    case 2391:
      HASH_INVOKE_FROM_EVAL(0x253AC5D4E450A957LL, magickgetreleasedate);
      break;
    case 2394:
      HASH_INVOKE_FROM_EVAL(0x103C12985527295ALL, hphp_splfileobject_setcsvcontrol);
      HASH_INVOKE_FROM_EVAL(0x7056E766A274895ALL, virtual);
      break;
    case 2397:
      HASH_INVOKE_FROM_EVAL(0x21DBCE74EB1FC95DLL, xmlwriter_text);
      break;
    case 2401:
      HASH_INVOKE_FROM_EVAL(0x5EA7052A00E88961LL, magickgetcopyright);
      break;
    case 2407:
      HASH_INVOKE_FROM_EVAL(0x1419B3BF428B2967LL, evhttp_async_post);
      break;
    case 2415:
      HASH_INVOKE_FROM_EVAL(0x134EF88685C0396FLL, magickgetexceptiontype);
      break;
    case 2417:
      HASH_INVOKE_FROM_EVAL(0x442A28FB6F6C3971LL, xmlwriter_start_attribute);
      HASH_INVOKE_FROM_EVAL(0x72C73F5DA7D6F971LL, magickgetimagecolormapcolor);
      break;
    case 2418:
      HASH_INVOKE_FROM_EVAL(0x758263CEBF2E8972LL, assert_options);
      break;
    case 2421:
      HASH_INVOKE_FROM_EVAL(0x7E26D48503362975LL, drawpathcurvetoabsolute);
      HASH_INVOKE_FROM_EVAL(0x488141281A75E975LL, imagecreatefromgif);
      break;
    case 2423:
      HASH_INVOKE_FROM_EVAL(0x0C16C797916C2977LL, posix_setegid);
      break;
    case 2430:
      HASH_INVOKE_FROM_EVAL(0x5067A65AD1D0297ELL, pixelgetiteratorexception);
      break;
    case 2432:
      HASH_INVOKE_FROM_EVAL(0x3D3445105C335980LL, filectime);
      break;
    case 2434:
      HASH_INVOKE_FROM_EVAL(0x214EA70BDD8FB982LL, magickmorphimages);
      break;
    case 2435:
      HASH_INVOKE_FROM_EVAL(0x3DA64BF893DBF983LL, strncmp);
      break;
    case 2438:
      HASH_INVOKE_FROM_EVAL(0x6ECE4BDB8842E986LL, posix_strerror);
      break;
    case 2439:
      HASH_INVOKE_FROM_EVAL(0x22B3CF8DD3D1A987LL, pixelsynciterator);
      break;
    case 2440:
      HASH_INVOKE_FROM_EVAL(0x489355BDBE396988LL, drawsettextencoding);
      HASH_INVOKE_FROM_EVAL(0x55BE7AE8DEF3F988LL, magickgetstringheight);
      break;
    case 2443:
      HASH_INVOKE_FROM_EVAL(0x0E863EF8C11A598BLL, is_writable);
      break;
    case 2445:
      HASH_INVOKE_FROM_EVAL(0x69003892F71C798DLL, apache_get_scoreboard);
      HASH_INVOKE_FROM_EVAL(0x651A8CBB8D2A398DLL, mysql_stat);
      break;
    case 2446:
      HASH_INVOKE_FROM_EVAL(0x45CFDEE19995398ELL, hphp_recursiveiteratoriterator_next);
      HASH_INVOKE_FROM_EVAL(0x333D4DFD4927898ELL, magickgetimagewhitepoint);
      break;
    case 2448:
      HASH_INVOKE_FROM_EVAL(0x342D957A86A03990LL, hphp_splfileobject_seek);
      break;
    case 2456:
      HASH_INVOKE_FROM_EVAL(0x501AAD31C8086998LL, posix_getcwd);
      break;
    case 2459:
      HASH_INVOKE_FROM_EVAL(0x564D8D3DA1E8E99BLL, xml_get_current_line_number);
      break;
    case 2462:
      HASH_INVOKE_FROM_EVAL(0x59D2DFF08F4DB99ELL, imagecreate);
      break;
    case 2464:
      HASH_INVOKE_FROM_EVAL(0x047EF9173590C9A0LL, session_decode);
      break;
    case 2466:
      HASH_INVOKE_FROM_EVAL(0x01D2367A02F0A9A2LL, magicksetsize);
      break;
    case 2467:
      HASH_INVOKE_FROM_EVAL(0x43D1339C52E309A3LL, hphp_service_thread_started);
      HASH_INVOKE_FROM_EVAL(0x78261FA60B8D89A3LL, imagepsloadfont);
      break;
    case 2468:
      HASH_INVOKE_FROM_EVAL(0x6F8676B049C919A4LL, array_intersect_uassoc);
      break;
    case 2469:
      HASH_INVOKE_FROM_EVAL(0x76988956F35329A5LL, xmlwriter_end_cdata);
      break;
    case 2473:
      HASH_INVOKE_FROM_EVAL(0x6F9CF95104CAE9A9LL, pixelgetyellowquantum);
      break;
    case 2476:
      HASH_INVOKE_FROM_EVAL(0x522256BAA78159ACLL, popen);
      break;
    case 2477:
      HASH_INVOKE_FROM_EVAL(0x05C5AD90751159ADLL, drawpathcurvetoquadraticbeziersmoothabsolute);
      break;
    case 2479:
      HASH_INVOKE_FROM_EVAL(0x25268012A48A99AFLL, magickclipimage);
      break;
    case 2481:
      HASH_INVOKE_FROM_EVAL(0x7C1CE38F14E529B1LL, date_default_timezone_set);
      break;
    case 2482:
      HASH_INVOKE_FROM_EVAL(0x65D7CBE8681CE9B2LL, gzgetss);
      break;
    case 2486:
      HASH_INVOKE_FROM_EVAL(0x5FC1B94446EA59B6LL, magickremoveimageprofiles);
      break;
    case 2487:
      HASH_INVOKE_FROM_EVAL(0x18F2C246FACAD9B7LL, each);
      break;
    case 2488:
      HASH_INVOKE_FROM_EVAL(0x3741447B159359B8LL, mcrypt_get_cipher_name);
      HASH_INVOKE_FROM_EVAL(0x4EFD7A9C90E559B8LL, posix_ttyname);
      break;
    case 2489:
      HASH_INVOKE_FROM_EVAL(0x145702974C97F9B9LL, ltrim);
      break;
    case 2490:
      HASH_INVOKE_FROM_EVAL(0x13B3172E092D99BALL, is_dir);
      break;
    case 2492:
      HASH_INVOKE_FROM_EVAL(0x7E7BF1BDA6DB49BCLL, hphp_splfileinfo_getgroup);
      break;
    case 2494:
      HASH_INVOKE_FROM_EVAL(0x458B5ABEDAC1C9BELL, disk_free_space);
      break;
    case 2498:
      HASH_INVOKE_FROM_EVAL(0x6A7BDB900E7429C2LL, magickconstituteimage);
      break;
    case 2500:
      HASH_INVOKE_FROM_EVAL(0x47B7D3745D80B9C4LL, socket_get_option);
      break;
    case 2502:
      HASH_INVOKE_FROM_EVAL(0x080F661DB8BFC9C6LL, hphp_splfileinfo_getmtime);
      break;
    case 2503:
      HASH_INVOKE_FROM_EVAL(0x6ECDF24B29D789C7LL, strtolower);
      break;
    case 2506:
      HASH_INVOKE_FROM_EVAL(0x5C5B0CC85133B9CALL, mkdir);
      break;
    case 2507:
      HASH_INVOKE_FROM_EVAL(0x032DFAC5B24679CBLL, header_remove);
      break;
    case 2509:
      HASH_INVOKE_FROM_EVAL(0x4E61FE901C1C29CDLL, array_intersect_key);
      break;
    case 2510:
      HASH_INVOKE_FROM_EVAL(0x7A9FB932873D09CELL, gmmktime);
      break;
    case 2511:
      HASH_INVOKE_FROM_EVAL(0x415B91CAEE0689CFLL, magickgetimageinterlacescheme);
      break;
    case 2514:
      HASH_INVOKE_FROM_EVAL(0x3DCCD1FEAD8759D2LL, array_sum);
      break;
    case 2515:
      HASH_INVOKE_FROM_EVAL(0x1C31A9E1207209D3LL, mb_split);
      HASH_INVOKE_FROM_EVAL(0x10C82F357BB7E9D3LL, curl_version);
      HASH_INVOKE_FROM_EVAL(0x25CA0299103F49D3LL, magickgetsize);
      break;
    case 2517:
      HASH_INVOKE_FROM_EVAL(0x245860A2FE4CB9D5LL, socket_set_blocking);
      break;
    case 2519:
      HASH_INVOKE_FROM_EVAL(0x7628053EFCC0C9D7LL, hphp_clear_unflushed);
      break;
    case 2523:
      HASH_INVOKE_FROM_EVAL(0x48B2E069B89489DBLL, magickappendimages);
      break;
    case 2526:
      HASH_INVOKE_FROM_EVAL(0x5C039967E60089DELL, array_intersect_ukey);
      break;
    case 2527:
      HASH_INVOKE_FROM_EVAL(0x349E2E0F2CD7B9DFLL, magickgetversion);
      break;
    case 2534:
      HASH_INVOKE_FROM_EVAL(0x1B44CF284E9B09E6LL, interface_exists);
      break;
    case 2537:
      HASH_INVOKE_FROM_EVAL(0x4ADFA265F07AB9E9LL, drawgettextalignment);
      HASH_INVOKE_FROM_EVAL(0x6A45EB471332A9E9LL, imagecolorexactalpha);
      HASH_INVOKE_FROM_EVAL(0x330EE2729DB7C9E9LL, drawgetfontstretch);
      break;
    case 2538:
      HASH_INVOKE_FROM_EVAL(0x25DDD924EFE979EALL, hash_update_file);
      break;
    case 2539:
      HASH_INVOKE_FROM_EVAL(0x71B0FF80B88459EBLL, diskfreespace);
      break;
    case 2543:
      HASH_INVOKE_FROM_EVAL(0x7EA6200B688459EFLL, ldap_modify);
      break;
    case 2544:
      HASH_INVOKE_FROM_EVAL(0x1FC307200E8959F0LL, stream_bucket_append);
      break;
    case 2547:
      HASH_INVOKE_FROM_EVAL(0x6535B60A4BC449F3LL, dns_get_record);
      break;
    case 2548:
      HASH_INVOKE_FROM_EVAL(0x51201EE65BC729F4LL, localtime);
      break;
    case 2549:
      HASH_INVOKE_FROM_EVAL(0x2BC61637253BE9F5LL, drawgetfontweight);
      HASH_INVOKE_FROM_EVAL(0x35BABFBC091759F5LL, socket_server);
      break;
    case 2557:
      HASH_INVOKE_FROM_EVAL(0x2394D4E030AB69FDLL, getmypid);
      break;
    case 2564:
      HASH_INVOKE_FROM_EVAL(0x0B88D3F582D16A04LL, memcache_get_extended_stats);
      HASH_INVOKE_FROM_EVAL(0x17B83C425BD09A04LL, atanh);
      break;
    case 2567:
      HASH_INVOKE_FROM_EVAL(0x391E0A4CF1EC9A07LL, stream_socket_recvfrom);
      break;
    case 2568:
      HASH_INVOKE_FROM_EVAL(0x0436CA4DFB315A08LL, soundex);
      break;
    case 2571:
      HASH_INVOKE_FROM_EVAL(0x70075DC878825A0BLL, ctype_lower);
      break;
    case 2573:
      HASH_INVOKE_FROM_EVAL(0x736C133EFF8E5A0DLL, mysql_list_fields);
      HASH_INVOKE_FROM_EVAL(0x50A7146A79877A0DLL, pcntl_alarm);
      break;
    case 2577:
      HASH_INVOKE_FROM_EVAL(0x472CA39715598A11LL, mb_eregi_replace);
      break;
    case 2584:
      HASH_INVOKE_FROM_EVAL(0x66A378C6BBC26A18LL, dom_document_create_cdatasection);
      break;
    case 2588:
      HASH_INVOKE_FROM_EVAL(0x12D49AD562F38A1CLL, date_timezone_get);
      break;
    case 2591:
      HASH_INVOKE_FROM_EVAL(0x35C8BD7DFDADEA1FLL, hphp_directoryiterator_current);
      break;
    case 2592:
      HASH_INVOKE_FROM_EVAL(0x2A420675E6AF0A20LL, basename);
      break;
    case 2593:
      HASH_INVOKE_FROM_EVAL(0x14279BB1A6872A21LL, atan2);
      break;
    case 2594:
      HASH_INVOKE_FROM_EVAL(0x3FC127C442BAEA22LL, session_id);
      break;
    case 2597:
      HASH_INVOKE_FROM_EVAL(0x5EC0A3DD935EEA25LL, magickresampleimage);
      HASH_INVOKE_FROM_EVAL(0x1DB9A1FB97A3AA25LL, magicksetimageoption);
      break;
    case 2601:
      HASH_INVOKE_FROM_EVAL(0x618D2A98986B1A29LL, ldap_unbind);
      break;
    case 2602:
      HASH_INVOKE_FROM_EVAL(0x3CAEA6B8D1C92A2ALL, stream_bucket_prepend);
      break;
    case 2604:
      HASH_INVOKE_FROM_EVAL(0x073ACDF9B3F06A2CLL, memcache_setoptimeout);
      break;
    case 2609:
      HASH_INVOKE_FROM_EVAL(0x1F3E32847C1CCA31LL, mb_ereg_match);
      break;
    case 2612:
      HASH_INVOKE_FROM_EVAL(0x2D948E4099975A34LL, restore_include_path);
      HASH_INVOKE_FROM_EVAL(0x5AB266C6E7075A34LL, mysql_error);
      break;
    case 2616:
      HASH_INVOKE_FROM_EVAL(0x3E65EF9761BE5A38LL, pixelgetiteratorexceptiontype);
      break;
    case 2619:
      HASH_INVOKE_FROM_EVAL(0x545A7BE199EC4A3BLL, pcntl_getpriority);
      HASH_INVOKE_FROM_EVAL(0x785ECCF53D98BA3BLL, curl_multi_exec);
      break;
    case 2620:
      HASH_INVOKE_FROM_EVAL(0x21DF7BAEEFABCA3CLL, umask);
      break;
    case 2622:
      HASH_INVOKE_FROM_EVAL(0x31C3A072D092FA3ELL, socket_create_listen);
      break;
    case 2623:
      HASH_INVOKE_FROM_EVAL(0x4C0E2C6882051A3FLL, magickgetresourcelimit);
      break;
    case 2624:
      HASH_INVOKE_FROM_EVAL(0x4926EE59103B2A40LL, destroydrawingwand);
      HASH_INVOKE_FROM_EVAL(0x682C14726D484A40LL, fileatime);
      break;
    case 2626:
      HASH_INVOKE_FROM_EVAL(0x128914E131AFFA42LL, microtime);
      HASH_INVOKE_FROM_EVAL(0x5FF7C3A6BDDCFA42LL, mb_convert_kana);
      break;
    case 2628:
      HASH_INVOKE_FROM_EVAL(0x7F6A6306BBE8AA44LL, imagelayereffect);
      break;
    case 2629:
      HASH_INVOKE_FROM_EVAL(0x7CDF1FB642529A45LL, dom_characterdata_insert_data);
      break;
    case 2631:
      HASH_INVOKE_FROM_EVAL(0x1B45CFF586F85A47LL, utf8_encode);
      break;
    case 2636:
      HASH_INVOKE_FROM_EVAL(0x4894583F517C6A4CLL, intl_get_error_code);
      HASH_INVOKE_FROM_EVAL(0x7039B1C3356B8A4CLL, hphp_splfileobject_rewind);
      break;
    case 2638:
      HASH_INVOKE_FROM_EVAL(0x1635DCC4882CBA4ELL, dom_node_has_attributes);
      break;
    case 2640:
      HASH_INVOKE_FROM_EVAL(0x506BBFC1B32AEA50LL, memcache_replace);
      break;
    case 2647:
      HASH_INVOKE_FROM_EVAL(0x5088945958DD4A57LL, mktime);
      HASH_INVOKE_FROM_EVAL(0x7E929ED7D9BE6A57LL, ini_get);
      break;
    case 2648:
      HASH_INVOKE_FROM_EVAL(0x6E823A722DE1EA58LL, stream_socket_client);
      break;
    case 2651:
      HASH_INVOKE_FROM_EVAL(0x2B18DFF183C0BA5BLL, mb_get_info);
      break;
    case 2653:
      HASH_INVOKE_FROM_EVAL(0x7E1E9C4C3D4E8A5DLL, stream_select);
      break;
    case 2654:
      HASH_INVOKE_FROM_EVAL(0x2C6826999658AA5ELL, getopt);
      break;
    case 2655:
      HASH_INVOKE_FROM_EVAL(0x7CAE3FE798EC0A5FLL, php_logo_guid);
      break;
    case 2661:
      HASH_INVOKE_FROM_EVAL(0x469199B8FD886A65LL, putenv);
      HASH_INVOKE_FROM_EVAL(0x3590F3AAC94E0A65LL, array_change_key_case);
      break;
    case 2662:
      HASH_INVOKE_FROM_EVAL(0x60C4B9EEDBD5FA66LL, pos);
      break;
    case 2664:
      HASH_INVOKE_FROM_EVAL(0x01DD2057FD9B1A68LL, xmlwriter_write_cdata);
      HASH_INVOKE_FROM_EVAL(0x32AD0455A7689A68LL, magickoilpaintimage);
      break;
    case 2665:
      HASH_INVOKE_FROM_EVAL(0x1DD37E722E11AA69LL, session_regenerate_id);
      HASH_INVOKE_FROM_EVAL(0x10CDCF2BB4057A69LL, debug_zval_dump);
      break;
    case 2667:
      HASH_INVOKE_FROM_EVAL(0x0912965F4440FA6BLL, str_repeat);
      break;
    case 2673:
      HASH_INVOKE_FROM_EVAL(0x5B5DA6AD0AD63A71LL, drawannotation);
      break;
    case 2674:
      HASH_INVOKE_FROM_EVAL(0x71AFF1D58D103A72LL, imagefontheight);
      break;
    case 2677:
      HASH_INVOKE_FROM_EVAL(0x7A957BEC6CA57A75LL, preg_replace_callback);
      break;
    case 2681:
      HASH_INVOKE_FROM_EVAL(0x28AC28C54C4E6A79LL, openssl_error_string);
      break;
    case 2685:
      HASH_INVOKE_FROM_EVAL(0x414C2E31304E9A7DLL, stream_get_filters);
      break;
    case 2689:
      HASH_INVOKE_FROM_EVAL(0x09367774F803EA81LL, hphp_recursiveiteratoriterator_valid);
      break;
    case 2690:
      HASH_INVOKE_FROM_EVAL(0x258205B54DC06A82LL, newpixelwands);
      HASH_INVOKE_FROM_EVAL(0x79786FABC5551A82LL, jpeg2wbmp);
      break;
    case 2691:
      HASH_INVOKE_FROM_EVAL(0x11149278DB0A9A83LL, levenshtein);
      break;
    case 2692:
      HASH_INVOKE_FROM_EVAL(0x08C1A5A05B6A0A84LL, ob_get_length);
      break;
    case 2693:
      HASH_INVOKE_FROM_EVAL(0x755DEFDEDF35DA85LL, ctype_print);
      HASH_INVOKE_FROM_EVAL(0x2180916F8D4F6A85LL, drawcomment);
      break;
    case 2695:
      HASH_INVOKE_FROM_EVAL(0x7C5A22328CAB4A87LL, ereg_replace);
      break;
    case 2696:
      HASH_INVOKE_FROM_EVAL(0x1818A3CFBA357A88LL, magicksetwandsize);
      break;
    case 2699:
      HASH_INVOKE_FROM_EVAL(0x7588BD0546C8BA8BLL, hphp_recursivedirectoryiterator_valid);
      HASH_INVOKE_FROM_EVAL(0x7ACBCD9CF335AA8BLL, xmlwriter_start_document);
      break;
    case 2700:
      HASH_INVOKE_FROM_EVAL(0x6A2EEE463F969A8CLL, getservbyname);
      break;
    case 2706:
      HASH_INVOKE_FROM_EVAL(0x1257DB9F159E9A92LL, magickmontageimage);
      break;
    case 2707:
      HASH_INVOKE_FROM_EVAL(0x4A32653C8E719A93LL, pixelgetcyan);
      break;
    case 2708:
      HASH_INVOKE_FROM_EVAL(0x465E6C67F885AA94LL, drawgetstrokelinejoin);
      HASH_INVOKE_FROM_EVAL(0x7761D019E0B5EA94LL, magickstripimage);
      HASH_INVOKE_FROM_EVAL(0x4B1501C4C22FFA94LL, quoted_printable_encode);
      HASH_INVOKE_FROM_EVAL(0x0AC7CBCE30442A94LL, imagepalettecopy);
      break;
    case 2709:
      HASH_INVOKE_FROM_EVAL(0x34B8A4E5AE0EFA95LL, pixelgetopacity);
      break;
    case 2711:
      HASH_INVOKE_FROM_EVAL(0x0089115038C03A97LL, array_diff_ukey);
      break;
    case 2714:
      HASH_INVOKE_FROM_EVAL(0x19AFF8596E19DA9ALL, xhprof_enable);
      break;
    case 2717:
      HASH_INVOKE_FROM_EVAL(0x1234AB687C515A9DLL, mb_encode_numericentity);
      break;
    case 2719:
      HASH_INVOKE_FROM_EVAL(0x2E5E23ECA0525A9FLL, bcadd);
      break;
    case 2720:
      HASH_INVOKE_FROM_EVAL(0x55FAF12AF1920AA0LL, sha1_file);
      break;
    case 2723:
      HASH_INVOKE_FROM_EVAL(0x2B75B48A53AACAA3LL, imagestring);
      break;
    case 2725:
      HASH_INVOKE_FROM_EVAL(0x2418528164415AA5LL, magickscaleimage);
      break;
    case 2726:
      HASH_INVOKE_FROM_EVAL(0x4BBA1E164DF9CAA6LL, localeconv);
      break;
    case 2727:
      HASH_INVOKE_FROM_EVAL(0x797CEC173CBB7AA7LL, ob_get_flush);
      break;
    case 2729:
      HASH_INVOKE_FROM_EVAL(0x2238FC7870E9CAA9LL, strspn);
      break;
    case 2731:
      HASH_INVOKE_FROM_EVAL(0x1331979EF8EF0AABLL, mb_ereg_search);
      break;
    case 2732:
      HASH_INVOKE_FROM_EVAL(0x18CF3E4A60E4AAACLL, pi);
      break;
    case 2735:
      HASH_INVOKE_FROM_EVAL(0x3ED47399FE1D6AAFLL, dom_document_create_attribute_ns);
      break;
    case 2738:
      HASH_INVOKE_FROM_EVAL(0x569EED88F20BAAB2LL, drawgettextundercolor);
      HASH_INVOKE_FROM_EVAL(0x62519270CC9F1AB2LL, stream_get_meta_data);
      break;
    case 2740:
      HASH_INVOKE_FROM_EVAL(0x1BAFB965204D0AB4LL, openssl_x509_check_private_key);
      break;
    case 2751:
      HASH_INVOKE_FROM_EVAL(0x030DFC3D3C88BABFLL, filegroup);
      break;
    case 2757:
      HASH_INVOKE_FROM_EVAL(0x3754E97715176AC5LL, hphp_get_stats);
      break;
    case 2759:
      HASH_INVOKE_FROM_EVAL(0x5D2F899A270D9AC7LL, xmlwriter_end_dtd_element);
      HASH_INVOKE_FROM_EVAL(0x79215854355CBAC7LL, proc_get_status);
      HASH_INVOKE_FROM_EVAL(0x3886D2664F874AC7LL, openssl_pkcs7_verify);
      break;
    case 2761:
      HASH_INVOKE_FROM_EVAL(0x5CA9671385EF0AC9LL, sem_release);
      break;
    case 2762:
      HASH_INVOKE_FROM_EVAL(0x45B30CD663284ACALL, is_int);
      break;
    case 2763:
      HASH_INVOKE_FROM_EVAL(0x348888DDF223AACBLL, mt_getrandmax);
      break;
    case 2764:
      HASH_INVOKE_FROM_EVAL(0x750D0396676E6ACCLL, imagecolorexact);
      HASH_INVOKE_FROM_EVAL(0x2BD6476D2C467ACCLL, pagelet_server_task_status);
      break;
    case 2765:
      HASH_INVOKE_FROM_EVAL(0x173EDC165B673ACDLL, magicktransformimage);
      break;
    case 2769:
      HASH_INVOKE_FROM_EVAL(0x47E2B4F7B8DE5AD1LL, xmlwriter_write_dtd_attlist);
      HASH_INVOKE_FROM_EVAL(0x314317450857FAD1LL, ctype_punct);
      break;
    case 2773:
      HASH_INVOKE_FROM_EVAL(0x0D5DAF8034B41AD5LL, get_include_path);
      HASH_INVOKE_FROM_EVAL(0x5338F971C6DCEAD5LL, hphp_splfileinfo_islink);
      break;
    case 2774:
      HASH_INVOKE_FROM_EVAL(0x231BCE6071220AD6LL, drawcircle);
      break;
    case 2776:
      HASH_INVOKE_FROM_EVAL(0x52401023E146AAD8LL, xmlwriter_end_dtd);
      break;
    case 2779:
      HASH_INVOKE_FROM_EVAL(0x24771ED112008ADBLL, echo);
      HASH_INVOKE_FROM_EVAL(0x56E867A1F7507ADBLL, dom_document_create_processing_instruction);
      break;
    case 2780:
      HASH_INVOKE_FROM_EVAL(0x547E7EE64761AADCLL, imagecreatefromxbm);
      break;
    case 2781:
      HASH_INVOKE_FROM_EVAL(0x3E319E451A32FADDLL, magicksharpenimage);
      break;
    case 2782:
      HASH_INVOKE_FROM_EVAL(0x31D1C58F7BD89ADELL, hphp_directoryiterator_seek);
      break;
    case 2788:
      HASH_INVOKE_FROM_EVAL(0x47B15A7136E94AE4LL, strnatcasecmp);
      HASH_INVOKE_FROM_EVAL(0x1827F1C22F1CCAE4LL, hebrevc);
      break;
    case 2790:
      HASH_INVOKE_FROM_EVAL(0x0E09D0FEA30B6AE6LL, hphp_get_function_info);
      break;
    case 2795:
      HASH_INVOKE_FROM_EVAL(0x225F05071947BAEBLL, drawpathlinetoabsolute);
      break;
    case 2797:
      HASH_INVOKE_FROM_EVAL(0x46C33B4739C2FAEDLL, shm_remove_var);
      break;
    case 2798:
      HASH_INVOKE_FROM_EVAL(0x160A82E3E2CBBAEELL, is_finite);
      break;
    case 2800:
      HASH_INVOKE_FROM_EVAL(0x6B259D5D9D681AF0LL, register_postsend_function);
      break;
    case 2804:
      HASH_INVOKE_FROM_EVAL(0x2EC0ABF9A979FAF4LL, ob_get_level);
      break;
    case 2806:
      HASH_INVOKE_FROM_EVAL(0x2C7C9772AE983AF6LL, drawsetgravity);
      break;
    case 2808:
      HASH_INVOKE_FROM_EVAL(0x12859AD75BAF3AF8LL, magickreadimageblob);
      HASH_INVOKE_FROM_EVAL(0x757229A894864AF8LL, session_set_cookie_params);
      break;
    case 2813:
      HASH_INVOKE_FROM_EVAL(0x16BA422EB6C51AFDLL, gzwrite);
      break;
    case 2814:
      HASH_INVOKE_FROM_EVAL(0x04E86BA79B6CBAFELL, stream_socket_shutdown);
      break;
    case 2815:
      HASH_INVOKE_FROM_EVAL(0x7833F4C337542AFFLL, openssl_pkey_export);
      break;
    case 2817:
      HASH_INVOKE_FROM_EVAL(0x6F3503C7FB12DB01LL, lchgrp);
      break;
    case 2819:
      HASH_INVOKE_FROM_EVAL(0x673A96C50F00FB03LL, str_word_count);
      HASH_INVOKE_FROM_EVAL(0x32458C11C6E74B03LL, pixelsetblackquantum);
      break;
    case 2826:
      HASH_INVOKE_FROM_EVAL(0x14B366EF64A66B0ALL, get_loaded_extensions);
      HASH_INVOKE_FROM_EVAL(0x14AF32A23B507B0ALL, metaphone);
      break;
    case 2829:
      HASH_INVOKE_FROM_EVAL(0x368DBC0699272B0DLL, magicknegateimage);
      break;
    case 2836:
      HASH_INVOKE_FROM_EVAL(0x76675F14C1138B14LL, gzuncompress);
      break;
    case 2837:
      HASH_INVOKE_FROM_EVAL(0x24D0895FBB7BCB15LL, is_callable);
      HASH_INVOKE_FROM_EVAL(0x773E3809C4954B15LL, hphp_recursivedirectoryiterator_current);
      break;
    case 2839:
      HASH_INVOKE_FROM_EVAL(0x66F9A476DAB47B17LL, pixelsetcolor);
      break;
    case 2840:
      HASH_INVOKE_FROM_EVAL(0x70448A629A74FB18LL, ksort);
      break;
    case 2841:
      HASH_INVOKE_FROM_EVAL(0x0551EACBE8278B19LL, decoct);
      break;
    case 2842:
      HASH_INVOKE_FROM_EVAL(0x399522EE0CF3EB1ALL, drawsetstrokewidth);
      break;
    case 2843:
      HASH_INVOKE_FROM_EVAL(0x1B7CE8114AEACB1BLL, magickannotateimage);
      break;
    case 2844:
      HASH_INVOKE_FROM_EVAL(0x249399CEC35B7B1CLL, png2wbmp);
      break;
    case 2845:
      HASH_INVOKE_FROM_EVAL(0x6791459B883F0B1DLL, apache_reset_timeout);
      break;
    case 2846:
      HASH_INVOKE_FROM_EVAL(0x7160AA24D4251B1ELL, mb_strripos);
      break;
    case 2848:
      HASH_INVOKE_FROM_EVAL(0x1112712715D75B20LL, pixelgetblackquantum);
      break;
    case 2853:
      HASH_INVOKE_FROM_EVAL(0x798F2776FECAEB25LL, get_required_files);
      break;
    case 2854:
      HASH_INVOKE_FROM_EVAL(0x24CE95457EACBB26LL, get_parent_class);
      break;
    case 2857:
      HASH_INVOKE_FROM_EVAL(0x17C38BE3A6EE8B29LL, mysql_field_flags);
      break;
    case 2858:
      HASH_INVOKE_FROM_EVAL(0x1F4984938E1DBB2ALL, sort);
      break;
    case 2860:
      HASH_INVOKE_FROM_EVAL(0x70742211FA3EFB2CLL, imagettftext);
      break;
    case 2865:
      HASH_INVOKE_FROM_EVAL(0x442B1E05FC146B31LL, stream_context_set_param);
      break;
    case 2867:
      HASH_INVOKE_FROM_EVAL(0x00DCD60DD8752B33LL, set_exception_handler);
      HASH_INVOKE_FROM_EVAL(0x4D5D45D1F1EB3B33LL, posix_access);
      break;
    case 2868:
      HASH_INVOKE_FROM_EVAL(0x0B7D52E2540ABB34LL, tan);
      break;
    case 2869:
      HASH_INVOKE_FROM_EVAL(0x78842C1950B38B35LL, drawpathfinish);
      break;
    case 2871:
      HASH_INVOKE_FROM_EVAL(0x053B14F52350FB37LL, socket_shutdown);
      break;
    case 2872:
      HASH_INVOKE_FROM_EVAL(0x68C09D6CB8E79B38LL, class_exists);
      break;
    case 2873:
      HASH_INVOKE_FROM_EVAL(0x02A2C373E54FFB39LL, hash_init);
      break;
    case 2874:
      HASH_INVOKE_FROM_EVAL(0x49A45F75B2B25B3ALL, apd_breakpoint);
      break;
    case 2876:
      HASH_INVOKE_FROM_EVAL(0x35F4A0789F367B3CLL, drawpathlinetohorizontalrelative);
      break;
    case 2878:
      HASH_INVOKE_FROM_EVAL(0x5E2AF775FEB04B3ELL, posix_getppid);
      break;
    case 2879:
      HASH_INVOKE_FROM_EVAL(0x0B07AD87DF1B5B3FLL, urldecode);
      break;
    case 2880:
      HASH_INVOKE_FROM_EVAL(0x24CBCBA5C4407B40LL, evhttp_set_cache);
      break;
    case 2884:
      HASH_INVOKE_FROM_EVAL(0x4E4449EBAADD7B44LL, magickpingimage);
      break;
    case 2885:
      HASH_INVOKE_FROM_EVAL(0x684881C79ED1AB45LL, func_get_args);
      HASH_INVOKE_FROM_EVAL(0x72E3AE55A0B33B45LL, ispixelwand);
      break;
    case 2886:
      HASH_INVOKE_FROM_EVAL(0x00D8FE7A00252B46LL, escapeshellarg);
      break;
    case 2893:
      HASH_INVOKE_FROM_EVAL(0x37DF53E4D9348B4DLL, xbox_post_message);
      break;
    case 2896:
      HASH_INVOKE_FROM_EVAL(0x6237393C71E56B50LL, array_fill_keys);
      break;
    case 2899:
      HASH_INVOKE_FROM_EVAL(0x40F0B69D55F7EB53LL, drawsetstrokealpha);
      break;
    case 2901:
      HASH_INVOKE_FROM_EVAL(0x333FB673518A1B55LL, ldap_get_entries);
      break;
    case 2904:
      HASH_INVOKE_FROM_EVAL(0x6158E2E0A5ACCB58LL, idn_to_ascii);
      break;
    case 2907:
      HASH_INVOKE_FROM_EVAL(0x29203294F6214B5BLL, memcache_debug);
      HASH_INVOKE_FROM_EVAL(0x23FD09A13E0D8B5BLL, xmlwriter_open_memory);
      break;
    case 2909:
      HASH_INVOKE_FROM_EVAL(0x4888951358F53B5DLL, dom_document_get_elements_by_tag_name_ns);
      break;
    case 2913:
      HASH_INVOKE_FROM_EVAL(0x7636825871399B61LL, highlight_file);
      break;
    case 2920:
      HASH_INVOKE_FROM_EVAL(0x674F1DA24EDE7B68LL, xmlwriter_end_attribute);
      break;
    case 2922:
      HASH_INVOKE_FROM_EVAL(0x4BD4E9D9D4A56B6ALL, exif_tagname);
      break;
    case 2923:
      HASH_INVOKE_FROM_EVAL(0x5543A0CACD153B6BLL, substr_replace);
      HASH_INVOKE_FROM_EVAL(0x1D4136B4CEAE4B6BLL, stripcslashes);
      break;
    case 2927:
      HASH_INVOKE_FROM_EVAL(0x2D8D57FC1DC6CB6FLL, import_request_variables);
      break;
    case 2928:
      HASH_INVOKE_FROM_EVAL(0x1A73FD4416FECB70LL, magickwriteimagefile);
      break;
    case 2929:
      HASH_INVOKE_FROM_EVAL(0x5E5C875DB04CFB71LL, drawrectangle);
      break;
    case 2933:
      HASH_INVOKE_FROM_EVAL(0x42F0AED7599C1B75LL, magickechoimageblob);
      break;
    case 2934:
      HASH_INVOKE_FROM_EVAL(0x2A63A0BF9B7E3B76LL, ini_alter);
      break;
    case 2935:
      HASH_INVOKE_FROM_EVAL(0x7F5F29D8E63ABB77LL, mcrypt_module_self_test);
      HASH_INVOKE_FROM_EVAL(0x5025B43B46679B77LL, openssl_x509_free);
      break;
    case 2937:
      HASH_INVOKE_FROM_EVAL(0x31242F51AA828B79LL, drawpoppattern);
      break;
    case 2940:
      HASH_INVOKE_FROM_EVAL(0x3A096F905FBF7B7CLL, magickcommentimage);
      break;
    case 2941:
      HASH_INVOKE_FROM_EVAL(0x28DE19828167FB7DLL, magickmapimage);
      break;
    case 2943:
      HASH_INVOKE_FROM_EVAL(0x308C90AD9478CB7FLL, substr_compare);
      break;
    case 2946:
      HASH_INVOKE_FROM_EVAL(0x5BDE96FD5015AB82LL, base_convert);
      break;
    case 2949:
      HASH_INVOKE_FROM_EVAL(0x41F8FDD700C0CB85LL, socket_last_error);
      break;
    case 2955:
      HASH_INVOKE_FROM_EVAL(0x3B72159A4B04FB8BLL, set_time_limit);
      break;
    case 2957:
      HASH_INVOKE_FROM_EVAL(0x3B831DB1A615FB8DLL, xhprof_sample_enable);
      break;
    case 2958:
      HASH_INVOKE_FROM_EVAL(0x62A4D7A03F7C3B8ELL, ceil);
      break;
    case 2967:
      HASH_INVOKE_FROM_EVAL(0x09837A82A928AB97LL, is_null);
      break;
    case 2969:
      HASH_INVOKE_FROM_EVAL(0x076E66D4089A3B99LL, mb_stripos);
      break;
    case 2970:
      HASH_INVOKE_FROM_EVAL(0x023133732CB51B9ALL, exif_thumbnail);
      break;
    case 2975:
      HASH_INVOKE_FROM_EVAL(0x390A267EC6B51B9FLL, socket_sendto);
      break;
    case 2978:
      HASH_INVOKE_FROM_EVAL(0x4870ADD98EE02BA2LL, pcntl_wifsignaled);
      break;
    case 2979:
      HASH_INVOKE_FROM_EVAL(0x444A3375EFBC2BA3LL, openssl_public_decrypt);
      break;
    case 2980:
      HASH_INVOKE_FROM_EVAL(0x0D95DD13A2D3BBA4LL, drawtranslate);
      break;
    case 2986:
      HASH_INVOKE_FROM_EVAL(0x7C833A303C7CFBAALL, getrandmax);
      break;
    case 2987:
      HASH_INVOKE_FROM_EVAL(0x006481EAF2A70BABLL, ldap_errno);
      break;
    case 2991:
      HASH_INVOKE_FROM_EVAL(0x6A2236CDDFF12BAFLL, magickhaspreviousimage);
      break;
    case 2992:
      HASH_INVOKE_FROM_EVAL(0x1F3E4C6660247BB0LL, imagecolorresolve);
      HASH_INVOKE_FROM_EVAL(0x7D9BF61D6CDE3BB0LL, fb_parallel_query);
      break;
    case 2993:
      HASH_INVOKE_FROM_EVAL(0x04A24B397CF46BB1LL, strrchr);
      break;
    case 2997:
      HASH_INVOKE_FROM_EVAL(0x3F7DCC3A00800BB5LL, imagecolorallocate);
      break;
    case 3004:
      HASH_INVOKE_FROM_EVAL(0x43B74276235F4BBCLL, is_bool);
      break;
    case 3006:
      HASH_INVOKE_FROM_EVAL(0x79617ED8EFD1ABBELL, get_class_vars);
      HASH_INVOKE_FROM_EVAL(0x3F56AF1511AEDBBELL, magicklabelimage);
      HASH_INVOKE_FROM_EVAL(0x5ECB0B145B88EBBELL, imagefilledarc);
      HASH_INVOKE_FROM_EVAL(0x42684202E2E62BBELL, mcrypt_get_iv_size);
      break;
    case 3015:
      HASH_INVOKE_FROM_EVAL(0x10C5CF7B55173BC7LL, settype);
      break;
    case 3017:
      HASH_INVOKE_FROM_EVAL(0x0B4E7B9180C4ABC9LL, xml_set_end_namespace_decl_handler);
      HASH_INVOKE_FROM_EVAL(0x22BA0903D344CBC9LL, array_rand);
      break;
    case 3018:
      HASH_INVOKE_FROM_EVAL(0x0D375A94E75ACBCALL, hphp_throw_fatal_error);
      HASH_INVOKE_FROM_EVAL(0x4122DFAC25BDFBCALL, hphp_splfileinfo_getowner);
      break;
    case 3021:
      HASH_INVOKE_FROM_EVAL(0x22251ECF8CD58BCDLL, array_product);
      HASH_INVOKE_FROM_EVAL(0x53A88C8F973CFBCDLL, apc_clear_cache);
      break;
    case 3022:
      HASH_INVOKE_FROM_EVAL(0x45D6BA980AFFDBCELL, msg_get_queue);
      HASH_INVOKE_FROM_EVAL(0x600AFF0A6378ABCELL, is_writeable);
      break;
    case 3024:
      HASH_INVOKE_FROM_EVAL(0x7046755D8374EBD0LL, ctype_digit);
      HASH_INVOKE_FROM_EVAL(0x6846CA07A5E21BD0LL, hphp_directoryiterator___construct);
      break;
    case 3026:
      HASH_INVOKE_FROM_EVAL(0x6FE3C5FF5E883BD2LL, round);
      break;
    case 3028:
      HASH_INVOKE_FROM_EVAL(0x5B2F2A23D8368BD4LL, magickraiseimage);
      HASH_INVOKE_FROM_EVAL(0x4E4EB301A994DBD4LL, drawpolygon);
      break;
    case 3032:
      HASH_INVOKE_FROM_EVAL(0x21E44C7C7A911BD8LL, phpinfo);
      HASH_INVOKE_FROM_EVAL(0x06D5979AB150EBD8LL, dom_node_lookup_namespace_uri);
      break;
    case 3038:
      HASH_INVOKE_FROM_EVAL(0x58D0D9B66F045BDELL, strpos);
      break;
    case 3040:
      HASH_INVOKE_FROM_EVAL(0x2E10B74DC6067BE0LL, strip_tags);
      break;
    case 3041:
      HASH_INVOKE_FROM_EVAL(0x25FBB61480091BE1LL, mysql_client_encoding);
      break;
    case 3047:
      HASH_INVOKE_FROM_EVAL(0x1BB5D99C1D29CBE7LL, strstr);
      break;
    case 3048:
      HASH_INVOKE_FROM_EVAL(0x4E903B706977ABE8LL, imagepsslantfont);
      break;
    case 3051:
      HASH_INVOKE_FROM_EVAL(0x505B44DDF2383BEBLL, drawgetfillcolor);
      HASH_INVOKE_FROM_EVAL(0x0C1904372E8EDBEBLL, stream_copy_to_stream);
      break;
    case 3052:
      HASH_INVOKE_FROM_EVAL(0x44279BB3E2191BECLL, socket_accept);
      HASH_INVOKE_FROM_EVAL(0x5A22BA9B012A9BECLL, dom_document_save_html);
      break;
    case 3054:
      HASH_INVOKE_FROM_EVAL(0x03F50E435DE20BEELL, magickclippathimage);
      HASH_INVOKE_FROM_EVAL(0x790B7C44A3442BEELL, asort);
      break;
    case 3056:
      HASH_INVOKE_FROM_EVAL(0x187C049E785A1BF0LL, iconv_get_encoding);
      HASH_INVOKE_FROM_EVAL(0x04C0582DB1AD7BF0LL, mt_srand);
      break;
    case 3057:
      HASH_INVOKE_FROM_EVAL(0x0CA96856E5BEFBF1LL, iptcparse);
      break;
    case 3060:
      HASH_INVOKE_FROM_EVAL(0x1444DB037B4D5BF4LL, imagegammacorrect);
      break;
    case 3062:
      HASH_INVOKE_FROM_EVAL(0x08B4BEBAB3312BF6LL, image_type_to_extension);
      break;
    case 3063:
      HASH_INVOKE_FROM_EVAL(0x74ABB4A1E10BBBF7LL, time);
      break;
    case 3065:
      HASH_INVOKE_FROM_EVAL(0x5B7F6E0A642BBBF9LL, sleep);
      break;
    case 3068:
      HASH_INVOKE_FROM_EVAL(0x64F52E1DB5E95BFCLL, curl_multi_remove_handle);
      break;
    case 3074:
      HASH_INVOKE_FROM_EVAL(0x249340DF734D9C02LL, magickgetimageheight);
      break;
    case 3077:
      HASH_INVOKE_FROM_EVAL(0x2EC378A759F9EC05LL, xbox_task_status);
      break;
    case 3080:
      HASH_INVOKE_FROM_EVAL(0x48E1616EE837FC08LL, is_uploaded_file);
      break;
    case 3082:
      HASH_INVOKE_FROM_EVAL(0x1E47C281193ABC0ALL, collator_compare);
      break;
    case 3083:
      HASH_INVOKE_FROM_EVAL(0x0EEE484739520C0BLL, magickthresholdimage);
      HASH_INVOKE_FROM_EVAL(0x0833BCE91C40CC0BLL, magickqueryconfigureoption);
      break;
    case 3090:
      HASH_INVOKE_FROM_EVAL(0x062C0FFA8E29DC12LL, intl_error_name);
      HASH_INVOKE_FROM_EVAL(0x510B683F2E764C12LL, fb_load_local_databases);
      break;
    case 3095:
      HASH_INVOKE_FROM_EVAL(0x3A702EF906B37C17LL, collator_get_locale);
      break;
    case 3099:
      HASH_INVOKE_FROM_EVAL(0x67742A0F218F6C1BLL, posix_initgroups);
      HASH_INVOKE_FROM_EVAL(0x7D615C7E3ADB2C1BLL, xmlwriter_write_comment);
      break;
    case 3100:
      HASH_INVOKE_FROM_EVAL(0x758A62BD65E6FC1CLL, imagegd2);
      break;
    case 3102:
      HASH_INVOKE_FROM_EVAL(0x7039C5EBB1D6BC1ELL, array_walk);
      break;
    case 3103:
      HASH_INVOKE_FROM_EVAL(0x3A5D921797669C1FLL, hphp_log);
      break;
    case 3104:
      HASH_INVOKE_FROM_EVAL(0x7BD43EB167198C20LL, xmlwriter_write_pi);
      break;
    case 3105:
      HASH_INVOKE_FROM_EVAL(0x0179CBA2C5F4DC21LL, magickgetimageformat);
      break;
    case 3111:
      HASH_INVOKE_FROM_EVAL(0x5A02EE8ED39F0C27LL, posix_getgrnam);
      break;
    case 3112:
      HASH_INVOKE_FROM_EVAL(0x79A4E240F18BAC28LL, rand);
      break;
    case 3115:
      HASH_INVOKE_FROM_EVAL(0x09A98E99D51E8C2BLL, hphp_recursivedirectoryiterator_seek);
      break;
    case 3116:
      HASH_INVOKE_FROM_EVAL(0x116C3EC924B9AC2CLL, imagegd);
      break;
    case 3122:
      HASH_INVOKE_FROM_EVAL(0x0B9B362534621C32LL, isdrawingwand);
      break;
    case 3123:
      HASH_INVOKE_FROM_EVAL(0x49965C44E9EE3C33LL, set_file_buffer);
      break;
    case 3125:
      HASH_INVOKE_FROM_EVAL(0x2B9A380A29D0EC35LL, session_write_close);
      break;
    case 3128:
      HASH_INVOKE_FROM_EVAL(0x21564F9315F3FC38LL, drawsettextdecoration);
      break;
    case 3132:
      HASH_INVOKE_FROM_EVAL(0x69488CC69B897C3CLL, hphp_recursiveiteratoriterator_getinneriterator);
      break;
    case 3134:
      HASH_INVOKE_FROM_EVAL(0x15EC581662651C3ELL, date_parse);
      break;
    case 3141:
      HASH_INVOKE_FROM_EVAL(0x6EF89BCAD607CC45LL, strncasecmp);
      break;
    case 3142:
      HASH_INVOKE_FROM_EVAL(0x7D992445F5E37C46LL, magicktextureimage);
      break;
    case 3143:
      HASH_INVOKE_FROM_EVAL(0x44055093E56E4C47LL, mcrypt_enc_get_key_size);
      break;
    case 3145:
      HASH_INVOKE_FROM_EVAL(0x2D3F0F8DB0C20C49LL, dom_node_insert_before);
      HASH_INVOKE_FROM_EVAL(0x357F73CEBD6E2C49LL, write_hdf_string);
      break;
    case 3146:
      HASH_INVOKE_FROM_EVAL(0x3C23768CFB492C4ALL, gzinflate);
      break;
    case 3147:
      HASH_INVOKE_FROM_EVAL(0x120E7B01366DFC4BLL, call_user_func_serialized);
      break;
    case 3150:
      HASH_INVOKE_FROM_EVAL(0x5DAC1C64D8F08C4ELL, openssl_pkey_get_private);
      break;
    case 3152:
      HASH_INVOKE_FROM_EVAL(0x04534F26B8D05C50LL, drawgetstrokecolor);
      break;
    case 3153:
      HASH_INVOKE_FROM_EVAL(0x56EDB60C824E8C51LL, key);
      break;
    case 3154:
      HASH_INVOKE_FROM_EVAL(0x1FC294B806F76C52LL, php_sapi_name);
      break;
    case 3159:
      HASH_INVOKE_FROM_EVAL(0x793259E03C37CC57LL, memcache_decrement);
      HASH_INVOKE_FROM_EVAL(0x313E8EB28A111C57LL, hphp_splfileinfo_setinfoclass);
      break;
    case 3160:
      HASH_INVOKE_FROM_EVAL(0x1B8C3DA27170DC58LL, dirname);
      break;
    case 3161:
      HASH_INVOKE_FROM_EVAL(0x57633BDF8DB3FC59LL, i18n_loc_set_attribute);
      break;
    case 3166:
      HASH_INVOKE_FROM_EVAL(0x47B38F1E4FA29C5ELL, fb_get_code_coverage);
      break;
    case 3169:
      HASH_INVOKE_FROM_EVAL(0x6E54EEDA1D887C61LL, magicksetimageinterlacescheme);
      HASH_INVOKE_FROM_EVAL(0x5176725DA884DC61LL, curl_setopt);
      break;
    case 3171:
      HASH_INVOKE_FROM_EVAL(0x43C0E9827D502C63LL, array_intersect_assoc);
      break;
    case 3172:
      HASH_INVOKE_FROM_EVAL(0x3409D717D9246C64LL, libxml_use_internal_errors);
      break;
    case 3175:
      HASH_INVOKE_FROM_EVAL(0x07DC355325165C67LL, magickwriteimage);
      break;
    case 3176:
      HASH_INVOKE_FROM_EVAL(0x10D6AE9D688D1C68LL, copy);
      break;
    case 3178:
      HASH_INVOKE_FROM_EVAL(0x41BD9EA0BC5E4C6ALL, move_uploaded_file);
      break;
    case 3179:
      HASH_INVOKE_FROM_EVAL(0x7C6B37BF6300AC6BLL, iconv_mime_encode);
      break;
    case 3185:
      HASH_INVOKE_FROM_EVAL(0x1E074215FE5FCC71LL, set_error_handler);
      HASH_INVOKE_FROM_EVAL(0x18D9ED67E8E0FC71LL, dom_attr_is_id);
      break;
    case 3188:
      HASH_INVOKE_FROM_EVAL(0x20F0AAA486F39C74LL, dom_element_get_elements_by_tag_name_ns);
      break;
    case 3189:
      HASH_INVOKE_FROM_EVAL(0x528366F3195ACC75LL, xbox_task_result);
      break;
    case 3190:
      HASH_INVOKE_FROM_EVAL(0x1C35934C6BC52C76LL, libxml_clear_errors);
      break;
    case 3192:
      HASH_INVOKE_FROM_EVAL(0x665F08996BD4AC78LL, magicksetimagegreenprimary);
      break;
    case 3194:
      HASH_INVOKE_FROM_EVAL(0x05D7B804ECDE8C7ALL, checkdnsrr);
      HASH_INVOKE_FROM_EVAL(0x05F3BC04D61CAC7ALL, get_defined_vars);
      break;
    case 3195:
      HASH_INVOKE_FROM_EVAL(0x749E45FBD48BEC7BLL, hphp_recursivedirectoryiterator___tostring);
      HASH_INVOKE_FROM_EVAL(0x71B25229CD080C7BLL, dom_element_set_attribute_node_ns);
      break;
    case 3198:
      HASH_INVOKE_FROM_EVAL(0x5F41821072A06C7ELL, hphp_splfileinfo_getctime);
      break;
    case 3201:
      HASH_INVOKE_FROM_EVAL(0x767806D6F1053C81LL, sin);
      break;
    case 3204:
      HASH_INVOKE_FROM_EVAL(0x5D49AF7004696C84LL, shm_detach);
      break;
    case 3205:
      HASH_INVOKE_FROM_EVAL(0x56DA17241B793C85LL, mysql_set_timeout);
      break;
    case 3209:
      HASH_INVOKE_FROM_EVAL(0x0F9C0C82F40F2C89LL, pixelsetcyanquantum);
      break;
    case 3214:
      HASH_INVOKE_FROM_EVAL(0x467470230015AC8ELL, mcrypt_module_is_block_algorithm_mode);
      break;
    case 3215:
      HASH_INVOKE_FROM_EVAL(0x4173EFD9A8EECC8FLL, magicknewimage);
      break;
    case 3216:
      HASH_INVOKE_FROM_EVAL(0x05556EDFC1BB0C90LL, mysql_info);
      HASH_INVOKE_FROM_EVAL(0x3F0C947E68D02C90LL, ini_get_all);
      break;
    case 3217:
      HASH_INVOKE_FROM_EVAL(0x4E04B71729485C91LL, clonedrawingwand);
      break;
    case 3219:
      HASH_INVOKE_FROM_EVAL(0x0F8242C6327B5C93LL, dns_check_record);
      break;
    case 3222:
      HASH_INVOKE_FROM_EVAL(0x47C5BC101A512C96LL, magickquantizeimage);
      break;
    case 3225:
      HASH_INVOKE_FROM_EVAL(0x2EA6E1D600786C99LL, mb_strtoupper);
      break;
    case 3226:
      HASH_INVOKE_FROM_EVAL(0x374F20BDAF709C9ALL, mb_preferred_mime_name);
      break;
    case 3227:
      HASH_INVOKE_FROM_EVAL(0x36F7F9FD7766DC9BLL, xmlwriter_end_comment);
      break;
    case 3230:
      HASH_INVOKE_FROM_EVAL(0x50296037C7968C9ELL, preg_split);
      break;
    case 3233:
      HASH_INVOKE_FROM_EVAL(0x4590B5971EC9ACA1LL, getmygid);
      break;
    case 3235:
      HASH_INVOKE_FROM_EVAL(0x737253E9FC112CA3LL, socket_close);
      break;
    case 3245:
      HASH_INVOKE_FROM_EVAL(0x1C1216F2B7C16CADLL, ftell);
      break;
    case 3246:
      HASH_INVOKE_FROM_EVAL(0x12580A083B0D7CAELL, iterator_apply);
      HASH_INVOKE_FROM_EVAL(0x3ACD2F1EA5282CAELL, magickmattefloodfillimage);
      break;
    case 3248:
      HASH_INVOKE_FROM_EVAL(0x373B3FADEACB7CB0LL, openssl_private_encrypt);
      break;
    case 3249:
      HASH_INVOKE_FROM_EVAL(0x40D8DC24FA917CB1LL, hphp_splfileobject_fgetss);
      HASH_INVOKE_FROM_EVAL(0x735555B148E58CB1LL, ldap_read);
      break;
    case 3250:
      HASH_INVOKE_FROM_EVAL(0x56023CC5ECC9ECB2LL, dns_get_mx);
      break;
    case 3252:
      HASH_INVOKE_FROM_EVAL(0x41FBEF9F7A024CB4LL, xmlwriter_end_element);
      HASH_INVOKE_FROM_EVAL(0x742AD1AA5A80ECB4LL, output_reset_rewrite_vars);
      break;
    case 3254:
      HASH_INVOKE_FROM_EVAL(0x560637BE51C36CB6LL, ezmlm_hash);
      break;
    case 3255:
      HASH_INVOKE_FROM_EVAL(0x3DFD5CA79919DCB7LL, imageantialias);
      HASH_INVOKE_FROM_EVAL(0x39E03AAC188D3CB7LL, magickgetimagecompressionquality);
      break;
    case 3259:
      HASH_INVOKE_FROM_EVAL(0x41D3B07854936CBBLL, token_get_all);
      HASH_INVOKE_FROM_EVAL(0x15ACD9F32D214CBBLL, mysql_fetch_lengths);
      break;
    case 3260:
      HASH_INVOKE_FROM_EVAL(0x19C1872E55A7ECBCLL, is_long);
      HASH_INVOKE_FROM_EVAL(0x3978BE548631ECBCLL, hash_final);
      HASH_INVOKE_FROM_EVAL(0x733137183026ACBCLL, hphp_splfileobject_next);
      break;
    case 3264:
      HASH_INVOKE_FROM_EVAL(0x3033FE14E114FCC0LL, magicksetimageblueprimary);
      break;
    case 3266:
      HASH_INVOKE_FROM_EVAL(0x42BCEFCF899D0CC2LL, magickgetimagecolorspace);
      HASH_INVOKE_FROM_EVAL(0x34B6388D7730BCC2LL, drawline);
      break;
    case 3267:
      HASH_INVOKE_FROM_EVAL(0x7A147B8B98C76CC3LL, key_exists);
      break;
    case 3278:
      HASH_INVOKE_FROM_EVAL(0x0183A548B759BCCELL, posix_getpgid);
      HASH_INVOKE_FROM_EVAL(0x66273C5932B1FCCELL, clock_gettime);
      break;
    case 3279:
      HASH_INVOKE_FROM_EVAL(0x407B1F3AFEC43CCFLL, pixelgetblue);
      break;
    case 3281:
      HASH_INVOKE_FROM_EVAL(0x576C5DC462663CD1LL, explode);
      break;
    case 3282:
      HASH_INVOKE_FROM_EVAL(0x1FD3FB2AB0F48CD2LL, magickgetimagesignature);
      break;
    case 3283:
      HASH_INVOKE_FROM_EVAL(0x544302E2FAD3FCD3LL, magicknextimage);
      HASH_INVOKE_FROM_EVAL(0x6406BC03A5D84CD3LL, dom_element_remove_attribute);
      break;
    case 3284:
      HASH_INVOKE_FROM_EVAL(0x323FE1D92C9B3CD4LL, gzdecode);
      break;
    case 3285:
      HASH_INVOKE_FROM_EVAL(0x757BC444FDF79CD5LL, posix_get_last_error);
      break;
    case 3286:
      HASH_INVOKE_FROM_EVAL(0x11166D3106DB6CD6LL, wandhasexception);
      break;
    case 3289:
      HASH_INVOKE_FROM_EVAL(0x27BFAF1293A60CD9LL, ldap_get_dn);
      break;
    case 3290:
      HASH_INVOKE_FROM_EVAL(0x674AA2DBDA5E4CDALL, imageloadfont);
      HASH_INVOKE_FROM_EVAL(0x09C6455B4BC6FCDALL, drawsetviewbox);
      break;
    case 3298:
      HASH_INVOKE_FROM_EVAL(0x6B92530A9ABA0CE2LL, session_commit);
      break;
    case 3300:
      HASH_INVOKE_FROM_EVAL(0x7CDDF96AFEA2DCE4LL, chunk_split);
      break;
    case 3306:
      HASH_INVOKE_FROM_EVAL(0x5A8AF4F880DA4CEALL, mailparse_msg_extract_whole_part_file);
      HASH_INVOKE_FROM_EVAL(0x7821BD05E5228CEALL, imagewbmp);
      break;
    case 3310:
      HASH_INVOKE_FROM_EVAL(0x78FFA0E69D6AACEELL, mcrypt_cfb);
      break;
    case 3311:
      HASH_INVOKE_FROM_EVAL(0x6AA89C314C647CEFLL, magickgetimagehistogram);
      break;
    case 3313:
      HASH_INVOKE_FROM_EVAL(0x21C8FC9A94404CF1LL, php_ini_scanned_files);
      break;
    case 3314:
      HASH_INVOKE_FROM_EVAL(0x26C49BBC67475CF2LL, magicksetimagewhitepoint);
      break;
    case 3315:
      HASH_INVOKE_FROM_EVAL(0x5C1F75D51C077CF3LL, pixelgetindex);
      break;
    case 3317:
      HASH_INVOKE_FROM_EVAL(0x26729ECB00B8ECF5LL, end_user_func_async);
      break;
    case 3319:
      HASH_INVOKE_FROM_EVAL(0x1C30C8470100ECF7LL, mcrypt_enc_is_block_mode);
      break;
    case 3321:
      HASH_INVOKE_FROM_EVAL(0x537CF5DE8C43CCF9LL, curl_getinfo);
      break;
    case 3323:
      HASH_INVOKE_FROM_EVAL(0x09B4EE276DCCFCFBLL, mysql_fetch_row);
      break;
    case 3326:
      HASH_INVOKE_FROM_EVAL(0x768F3E6D1CBA5CFELL, socket_recv);
      break;
    case 3327:
      HASH_INVOKE_FROM_EVAL(0x748D3DFF0EB57CFFLL, uniqid);
      HASH_INVOKE_FROM_EVAL(0x48A2F2A7A4620CFFLL, pixelsetyellowquantum);
      break;
    case 3330:
      HASH_INVOKE_FROM_EVAL(0x018F22AEA371ED02LL, filemtime);
      HASH_INVOKE_FROM_EVAL(0x7EB48D1BB5B7AD02LL, dom_element_set_attribute);
      break;
    case 3331:
      HASH_INVOKE_FROM_EVAL(0x48EE7157C4392D03LL, apache_getenv);
      break;
    case 3332:
      HASH_INVOKE_FROM_EVAL(0x1248250E701DAD04LL, magickgaussianblurimage);
      break;
    case 3334:
      HASH_INVOKE_FROM_EVAL(0x2BA9FB0F8B76DD06LL, number_format);
      break;
    case 3335:
      HASH_INVOKE_FROM_EVAL(0x19B643D858DC6D07LL, magickgetimagerenderingintent);
      break;
    case 3337:
      HASH_INVOKE_FROM_EVAL(0x153F7DBFC9047D09LL, pixelsetred);
      break;
    case 3338:
      HASH_INVOKE_FROM_EVAL(0x6E8996DD071CED0ALL, dom_element_remove_attribute_node);
      break;
    case 3340:
      HASH_INVOKE_FROM_EVAL(0x30A8326034801D0CLL, mysql_pconnect);
      break;
    case 3341:
      HASH_INVOKE_FROM_EVAL(0x3ACE8A8BC9ACDD0DLL, iconv_mime_decode);
      break;
    case 3344:
      HASH_INVOKE_FROM_EVAL(0x42BEEC88EE81FD10LL, imagechar);
      HASH_INVOKE_FROM_EVAL(0x08F41A00D5D57D10LL, mb_decode_mimeheader);
      HASH_INVOKE_FROM_EVAL(0x5CEFA5A265104D10LL, count);
      break;
    case 3345:
      HASH_INVOKE_FROM_EVAL(0x2D484921B5400D11LL, magickradialblurimage);
      break;
    case 3346:
      HASH_INVOKE_FROM_EVAL(0x5F165B40AEEE5D12LL, hphp_splfileinfo_getfilename);
      break;
    case 3348:
      HASH_INVOKE_FROM_EVAL(0x63837ECAF6235D14LL, preg_replace);
      break;
    case 3351:
      HASH_INVOKE_FROM_EVAL(0x12BB5E00E714ED17LL, magickgetimagecompose);
      break;
    case 3354:
      HASH_INVOKE_FROM_EVAL(0x75DB75CA9DE56D1ALL, xml_parser_get_option);
      HASH_INVOKE_FROM_EVAL(0x39994614C6315D1ALL, hphp_recursivedirectoryiterator_key);
      break;
    case 3355:
      HASH_INVOKE_FROM_EVAL(0x70C22A7EEF54CD1BLL, ldap_compare);
      break;
    case 3358:
      HASH_INVOKE_FROM_EVAL(0x25DADFF238A15D1ELL, collator_create);
      break;
    case 3359:
      HASH_INVOKE_FROM_EVAL(0x566465036CCBCD1FLL, min);
      break;
    case 3365:
      HASH_INVOKE_FROM_EVAL(0x71DF0C17F47EDD25LL, getprotobynumber);
      break;
    case 3366:
      HASH_INVOKE_FROM_EVAL(0x429D088E9779CD26LL, dom_document_normalize_document);
      break;
    case 3368:
      HASH_INVOKE_FROM_EVAL(0x7C12261259F87D28LL, mcrypt_enc_is_block_algorithm_mode);
      break;
    case 3369:
      HASH_INVOKE_FROM_EVAL(0x632D50B69429ED29LL, socket_set_block);
      break;
    case 3370:
      HASH_INVOKE_FROM_EVAL(0x7A9C06B9CF853D2ALL, substr_count);
      break;
    case 3378:
      HASH_INVOKE_FROM_EVAL(0x4DAC43060BA57D32LL, stream_wrapper_restore);
      break;
    case 3382:
      HASH_INVOKE_FROM_EVAL(0x515841235FADCD36LL, class_implements);
      break;
    case 3383:
      HASH_INVOKE_FROM_EVAL(0x3ACF745D381E9D37LL, rtrim);
      break;
    case 3384:
      HASH_INVOKE_FROM_EVAL(0x0BA3AD85EB597D38LL, pagelet_server_task_result);
      break;
    case 3387:
      HASH_INVOKE_FROM_EVAL(0x0784B2B034560D3BLL, destroypixelwand);
      HASH_INVOKE_FROM_EVAL(0x6C9AE626DAD02D3BLL, mailparse_msg_extract_part_file);
      break;
    case 3392:
      HASH_INVOKE_FROM_EVAL(0x198627C81DABAD40LL, register_cleanup_function);
      break;
    case 3393:
      HASH_INVOKE_FROM_EVAL(0x6B6DA1EE18673D41LL, xmlwriter_end_dtd_entity);
      break;
    case 3394:
      HASH_INVOKE_FROM_EVAL(0x40497FCA4EC4DD42LL, posix_seteuid);
      HASH_INVOKE_FROM_EVAL(0x298BA735FA3ABD42LL, nl_langinfo);
      break;
    case 3397:
      HASH_INVOKE_FROM_EVAL(0x400A44045A999D45LL, rawurlencode);
      break;
    case 3398:
      HASH_INVOKE_FROM_EVAL(0x502CF4EB0A747D46LL, magicksetimagebias);
      HASH_INVOKE_FROM_EVAL(0x455DB7F86BCEDD46LL, pixelsetopacityquantum);
      HASH_INVOKE_FROM_EVAL(0x59AD2C922FF75D46LL, mdecrypt_generic);
      break;
    case 3401:
      HASH_INVOKE_FROM_EVAL(0x113ED435AEFDDD49LL, imagecolorallocatealpha);
      HASH_INVOKE_FROM_EVAL(0x41785512C45FCD49LL, mysql_ping);
      break;
    case 3407:
      HASH_INVOKE_FROM_EVAL(0x0FBCF35ADD209D4FLL, drawarc);
      break;
    case 3408:
      HASH_INVOKE_FROM_EVAL(0x39B11A2A25E40D50LL, mysql_get_server_info);
      HASH_INVOKE_FROM_EVAL(0x337D2252CDA22D50LL, is_real);
      break;
    case 3413:
      HASH_INVOKE_FROM_EVAL(0x36D672EF4FBEFD55LL, json_encode);
      break;
    case 3416:
      HASH_INVOKE_FROM_EVAL(0x146109BDD2F97D58LL, hphp_splfileobject_setmaxlinelen);
      break;
    case 3418:
      HASH_INVOKE_FROM_EVAL(0x4ACCF26A7AE80D5ALL, imagefilltoborder);
      break;
    case 3419:
      HASH_INVOKE_FROM_EVAL(0x41B5E3D2AADE2D5BLL, drawroundrectangle);
      break;
    case 3420:
      HASH_INVOKE_FROM_EVAL(0x1371413B4F6F8D5CLL, pixelgetred);
      break;
    case 3424:
      HASH_INVOKE_FROM_EVAL(0x6FACBD7F02B6FD60LL, uasort);
      HASH_INVOKE_FROM_EVAL(0x567276D68FE12D60LL, preg_quote);
      break;
    case 3425:
      HASH_INVOKE_FROM_EVAL(0x34F150F3D94E6D61LL, gzpassthru);
      HASH_INVOKE_FROM_EVAL(0x357BAB6E700EBD61LL, destroypixelwandarray);
      break;
    case 3430:
      HASH_INVOKE_FROM_EVAL(0x0C393EE8F6540D66LL, bccomp);
      break;
    case 3437:
      HASH_INVOKE_FROM_EVAL(0x21D924BA98BFCD6DLL, file_get_contents);
      HASH_INVOKE_FROM_EVAL(0x7D9E024FD8696D6DLL, get_class);
      HASH_INVOKE_FROM_EVAL(0x4351AFD0FD818D6DLL, magickmotionblurimage);
      break;
    case 3438:
      HASH_INVOKE_FROM_EVAL(0x0B1348D1540E7D6ELL, magicksetimageformat);
      break;
    case 3441:
      HASH_INVOKE_FROM_EVAL(0x74FDC4596C654D71LL, dom_node_is_default_namespace);
      break;
    case 3443:
      HASH_INVOKE_FROM_EVAL(0x7D8DCC72522CBD73LL, mb_detect_encoding);
      break;
    case 3446:
      HASH_INVOKE_FROM_EVAL(0x7467E8107EF08D76LL, unpack);
      break;
    case 3447:
      HASH_INVOKE_FROM_EVAL(0x3ED49C2BBDDFAD77LL, ldap_next_reference);
      HASH_INVOKE_FROM_EVAL(0x7FCAAAB932C57D77LL, iterator_count);
      break;
    case 3448:
      HASH_INVOKE_FROM_EVAL(0x6352349F97557D78LL, stream_socket_get_name);
      break;
    case 3451:
      HASH_INVOKE_FROM_EVAL(0x680A7EB3DA1F5D7BLL, prev);
      break;
    case 3454:
      HASH_INVOKE_FROM_EVAL(0x384E8BC9B5FE2D7ELL, magickfximage);
      break;
    case 3455:
      HASH_INVOKE_FROM_EVAL(0x4E19AFB75A62AD7FLL, imagerotate);
      break;
    case 3457:
      HASH_INVOKE_FROM_EVAL(0x25EA810DAEA74D81LL, ob_clean);
      break;
    case 3458:
      HASH_INVOKE_FROM_EVAL(0x2D15262403ADDD82LL, drawcomposite);
      break;
    case 3459:
      HASH_INVOKE_FROM_EVAL(0x1B0FF5C02F571D83LL, fb_rename_function);
      break;
    case 3463:
      HASH_INVOKE_FROM_EVAL(0x344091B785FE8D87LL, socket_set_timeout);
      break;
    case 3464:
      HASH_INVOKE_FROM_EVAL(0x2AFF8525E93D6D88LL, drawsetfillopacity);
      HASH_INVOKE_FROM_EVAL(0x1F22C82816F9AD88LL, hphp_splfileinfo_getpath);
      break;
    case 3465:
      HASH_INVOKE_FROM_EVAL(0x230E7AD147721D89LL, end);
      break;
    case 3470:
      HASH_INVOKE_FROM_EVAL(0x6A351AEDFC4D0D8ELL, magickgetimagemimetype);
      break;
    case 3471:
      HASH_INVOKE_FROM_EVAL(0x1806DC9468882D8FLL, gzfile);
      break;
    case 3472:
      HASH_INVOKE_FROM_EVAL(0x5E4360FC28D0AD90LL, magicksetinterlacescheme);
      break;
    case 3473:
      HASH_INVOKE_FROM_EVAL(0x5695393CF6428D91LL, dom_element_set_id_attribute);
      HASH_INVOKE_FROM_EVAL(0x48444F8F18E60D91LL, strftime);
      HASH_INVOKE_FROM_EVAL(0x7C2B3FE61FBDFD91LL, openssl_pkey_get_details);
      break;
    case 3480:
      HASH_INVOKE_FROM_EVAL(0x06A796D329C21D98LL, call_user_func);
      break;
    case 3485:
      HASH_INVOKE_FROM_EVAL(0x74BE8836F3B13D9DLL, session_name);
      break;
    case 3486:
      HASH_INVOKE_FROM_EVAL(0x30C1AE2B06990D9ELL, gzseek);
      break;
    case 3488:
      HASH_INVOKE_FROM_EVAL(0x73B43ABDD5C61DA0LL, shuffle);
      HASH_INVOKE_FROM_EVAL(0x5E8606470A09BDA0LL, magickposterizeimage);
      HASH_INVOKE_FROM_EVAL(0x7084C6294240CDA0LL, octdec);
      HASH_INVOKE_FROM_EVAL(0x167A11C41EB71DA0LL, pixelgetexceptiontype);
      break;
    case 3490:
      HASH_INVOKE_FROM_EVAL(0x71583A8FEF5C7DA2LL, sys_get_temp_dir);
      break;
    case 3493:
      HASH_INVOKE_FROM_EVAL(0x46B2F287D2FC7DA5LL, memcache_get);
      break;
    case 3494:
      HASH_INVOKE_FROM_EVAL(0x28DC1AD6DA9E7DA6LL, gethostbyname);
      break;
    case 3496:
      HASH_INVOKE_FROM_EVAL(0x18FEAF2459E5ADA8LL, dom_element_has_attribute);
      HASH_INVOKE_FROM_EVAL(0x572AE270D9E4FDA8LL, socket_set_option);
      HASH_INVOKE_FROM_EVAL(0x474A096265502DA8LL, glob);
      break;
    case 3498:
      HASH_INVOKE_FROM_EVAL(0x6326C14D0FFA7DAALL, fb_thrift_serialize);
      break;
    case 3499:
      HASH_INVOKE_FROM_EVAL(0x188720048AB37DABLL, magickquantizeimages);
      HASH_INVOKE_FROM_EVAL(0x66764CAABFF4CDABLL, array_keys);
      break;
    case 3505:
      HASH_INVOKE_FROM_EVAL(0x67EAC6D7332F3DB1LL, hphp_splfileobject_fgetcsv);
      break;
    case 3506:
      HASH_INVOKE_FROM_EVAL(0x257371BC40186DB2LL, magickblurimage);
      break;
    case 3507:
      HASH_INVOKE_FROM_EVAL(0x628069E483F35DB3LL, hphp_splfileobject_fstat);
      HASH_INVOKE_FROM_EVAL(0x53F2C6F5AE244DB3LL, drawpushdefs);
      break;
    case 3512:
      HASH_INVOKE_FROM_EVAL(0x2B1D442AEA06ADB8LL, strpbrk);
      break;
    case 3514:
      HASH_INVOKE_FROM_EVAL(0x5E0C6E797607DDBALL, mysql_result);
      HASH_INVOKE_FROM_EVAL(0x7964DE73DCA17DBALL, magickhasnextimage);
      break;
    case 3516:
      HASH_INVOKE_FROM_EVAL(0x770DEDCB168B0DBCLL, mb_ereg_search_setpos);
      break;
    case 3517:
      HASH_INVOKE_FROM_EVAL(0x48AA091B1E493DBDLL, setlocale);
      HASH_INVOKE_FROM_EVAL(0x01E6FF7D9746CDBDLL, stream_socket_accept);
      break;
    case 3521:
      HASH_INVOKE_FROM_EVAL(0x683E88F441F9BDC1LL, chgrp);
      break;
    case 3523:
      HASH_INVOKE_FROM_EVAL(0x069EE6F604BA2DC3LL, array_reverse);
      HASH_INVOKE_FROM_EVAL(0x0433140BB339DDC3LL, log);
      break;
    case 3524:
      HASH_INVOKE_FROM_EVAL(0x2A38BA8B4A0F9DC4LL, apc_fetch);
      break;
    case 3526:
      HASH_INVOKE_FROM_EVAL(0x73210FEAA2EACDC6LL, imagecolorsforindex);
      break;
    case 3528:
      HASH_INVOKE_FROM_EVAL(0x66C3E73210067DC8LL, magickgetimageunits);
      break;
    case 3530:
      HASH_INVOKE_FROM_EVAL(0x3BB701F2BDD0ADCALL, magickgetimageprofile);
      break;
    case 3534:
      HASH_INVOKE_FROM_EVAL(0x3E5C990C32470DCELL, array_combine);
      HASH_INVOKE_FROM_EVAL(0x4AD5B65BCE665DCELL, array_key_exists);
      HASH_INVOKE_FROM_EVAL(0x40C3C7DE46D62DCELL, ob_start);
      break;
    case 3536:
      HASH_INVOKE_FROM_EVAL(0x0E1C354339208DD0LL, imagetypes);
      break;
    case 3541:
      HASH_INVOKE_FROM_EVAL(0x7E1801C8E70D1DD5LL, imagefontwidth);
      break;
    case 3543:
      HASH_INVOKE_FROM_EVAL(0x638690DF6D06FDD7LL, imageconvolution);
      HASH_INVOKE_FROM_EVAL(0x1AE08377A1630DD7LL, mysql_insert_id);
      break;
    case 3548:
      HASH_INVOKE_FROM_EVAL(0x5EBE067E3FAECDDCLL, ob_gzhandler);
      HASH_INVOKE_FROM_EVAL(0x2497295AC9F72DDCLL, stream_set_blocking);
      break;
    case 3549:
      HASH_INVOKE_FROM_EVAL(0x3B00B916C3682DDDLL, ctype_upper);
      break;
    case 3560:
      HASH_INVOKE_FROM_EVAL(0x47A4BA8616D02DE8LL, restore_exception_handler);
      break;
    case 3564:
      HASH_INVOKE_FROM_EVAL(0x5B51DD18C3E13DECLL, openssl_x509_parse);
      HASH_INVOKE_FROM_EVAL(0x5ABB7486CE861DECLL, array_merge_recursive);
      break;
    case 3567:
      HASH_INVOKE_FROM_EVAL(0x0BB22147ADADDDEFLL, pfsockopen);
      HASH_INVOKE_FROM_EVAL(0x72293DCE8CC4BDEFLL, htmlspecialchars);
      break;
    case 3571:
      HASH_INVOKE_FROM_EVAL(0x7AE1BE187F18FDF3LL, fgets);
      break;
    case 3572:
      HASH_INVOKE_FROM_EVAL(0x73B30E65808A6DF4LL, ctype_xdigit);
      HASH_INVOKE_FROM_EVAL(0x5046A0D9DFDB5DF4LL, strcspn);
      break;
    case 3575:
      HASH_INVOKE_FROM_EVAL(0x23E563F1EC919DF7LL, hphp_splfileinfo_getpathname);
      break;
    case 3576:
      HASH_INVOKE_FROM_EVAL(0x5E43280BC8DD1DF8LL, magicktrimimage);
      break;
    case 3579:
      HASH_INVOKE_FROM_EVAL(0x47C62D58B0B65DFBLL, thrift_protocol_write_binary);
      break;
    case 3582:
      HASH_INVOKE_FROM_EVAL(0x21F24104004CFDFELL, evhttp_post);
      HASH_INVOKE_FROM_EVAL(0x072690BF719D7DFELL, hphp_recursivedirectoryiterator_rewind);
      break;
    case 3586:
      HASH_INVOKE_FROM_EVAL(0x7829D2171DFBFE02LL, magickgetimagegamma);
      break;
    case 3596:
      HASH_INVOKE_FROM_EVAL(0x3AD6E084483B2E0CLL, array_udiff_assoc);
      break;
    case 3597:
      HASH_INVOKE_FROM_EVAL(0x5EB0A2F93E650E0DLL, array_diff_key);
      HASH_INVOKE_FROM_EVAL(0x756B92411E7FBE0DLL, stream_get_wrappers);
      break;
    case 3598:
      HASH_INVOKE_FROM_EVAL(0x5230E4C9D8D64E0ELL, highlight_string);
      break;
    case 3602:
      HASH_INVOKE_FROM_EVAL(0x05FAA2085D94FE12LL, urlencode);
      HASH_INVOKE_FROM_EVAL(0x76636D0F0C090E12LL, curl_copy_handle);
      break;
    case 3604:
      HASH_INVOKE_FROM_EVAL(0x41E394B12170BE14LL, socket_send);
      HASH_INVOKE_FROM_EVAL(0x3192209D50C1FE14LL, pixelsetalpha);
      break;
    case 3605:
      HASH_INVOKE_FROM_EVAL(0x525F197D74423E15LL, get_resource_type);
      break;
    case 3607:
      HASH_INVOKE_FROM_EVAL(0x0F5759A501FAFE17LL, imagecreatefromgd2part);
      HASH_INVOKE_FROM_EVAL(0x3D13FD5FE3AF6E17LL, imagestringup);
      break;
    case 3609:
      HASH_INVOKE_FROM_EVAL(0x4A694B42B21A9E19LL, destroymagickwand);
      break;
    case 3611:
      HASH_INVOKE_FROM_EVAL(0x7FA0B63054221E1BLL, magickrollimage);
      break;
    case 3616:
      HASH_INVOKE_FROM_EVAL(0x7BDA47B5C47EAE20LL, fread);
      break;
    case 3617:
      HASH_INVOKE_FROM_EVAL(0x5B7F218FA08D8E21LL, imagefilledellipse);
      break;
    case 3621:
      HASH_INVOKE_FROM_EVAL(0x1C6246FA51EBDE25LL, hphp_get_static_property);
      break;
    case 3624:
      HASH_INVOKE_FROM_EVAL(0x3456885FF0679E28LL, lchown);
      break;
    case 3625:
      HASH_INVOKE_FROM_EVAL(0x73FE5C79E14A0E29LL, pixelsetbluequantum);
      break;
    case 3629:
      HASH_INVOKE_FROM_EVAL(0x7817FA38BAAEFE2DLL, fsockopen);
      break;
    case 3630:
      HASH_INVOKE_FROM_EVAL(0x3E62C1A48E9EEE2ELL, hphp_splfileinfo_getsize);
      break;
    case 3634:
      HASH_INVOKE_FROM_EVAL(0x000AAF93F814AE32LL, drawsetvectorgraphics);
      break;
    case 3635:
      HASH_INVOKE_FROM_EVAL(0x38433635F28B4E33LL, is_readable);
      break;
    case 3638:
      HASH_INVOKE_FROM_EVAL(0x2E42ED1E15CCFE36LL, mysql_affected_rows);
      break;
    case 3642:
      HASH_INVOKE_FROM_EVAL(0x6E2CF6ECA0987E3ALL, get_headers);
      HASH_INVOKE_FROM_EVAL(0x13048F0A79F7CE3ALL, magicksetsamplingfactors);
      break;
    case 3648:
      HASH_INVOKE_FROM_EVAL(0x11681FDE841D0E40LL, drawskewy);
      break;
    case 3650:
      HASH_INVOKE_FROM_EVAL(0x160B01F095B20E42LL, mb_output_handler);
      break;
    case 3652:
      HASH_INVOKE_FROM_EVAL(0x71B7756BD1B43E44LL, dom_document_savexml);
      break;
    case 3654:
      HASH_INVOKE_FROM_EVAL(0x7F4C1DF551150E46LL, pixelgetnextiteratorrow);
      break;
    case 3660:
      HASH_INVOKE_FROM_EVAL(0x1EEBDFD62B6BEE4CLL, mcrypt_module_get_algo_block_size);
      break;
    case 3663:
      HASH_INVOKE_FROM_EVAL(0x62C934CD93938E4FLL, magickimplodeimage);
      break;
    case 3664:
      HASH_INVOKE_FROM_EVAL(0x4022005DE7E24E50LL, openssl_pkcs7_sign);
      break;
    case 3668:
      HASH_INVOKE_FROM_EVAL(0x6BF155774D546E54LL, define_syslog_variables);
      HASH_INVOKE_FROM_EVAL(0x7B6BF544EB420E54LL, hphp_recursivedirectoryiterator_haschildren);
      break;
    case 3671:
      HASH_INVOKE_FROM_EVAL(0x21B07F1F212BDE57LL, hphp_get_original_class_name);
      HASH_INVOKE_FROM_EVAL(0x2DEF52641933CE57LL, magickgetimagemattecolor);
      break;
    case 3675:
      HASH_INVOKE_FROM_EVAL(0x299F1A5895461E5BLL, curl_multi_close);
      break;
    case 3676:
      HASH_INVOKE_FROM_EVAL(0x532D0D905CE60E5CLL, posix_times);
      break;
    case 3677:
      HASH_INVOKE_FROM_EVAL(0x38373F6643B14E5DLL, ldap_parse_reference);
      break;
    case 3681:
      HASH_INVOKE_FROM_EVAL(0x593EA675D239CE61LL, ldap_first_reference);
      break;
    case 3682:
      HASH_INVOKE_FROM_EVAL(0x7639C74DBC4F4E62LL, array_splice);
      break;
    case 3683:
      HASH_INVOKE_FROM_EVAL(0x4B6FE37D66784E63LL, imagesy);
      HASH_INVOKE_FROM_EVAL(0x5697E5F6AAF47E63LL, mb_http_input);
      break;
    case 3684:
      HASH_INVOKE_FROM_EVAL(0x4F0DF8BBC4340E64LL, stream_socket_server);
      break;
    case 3685:
      HASH_INVOKE_FROM_EVAL(0x21D5A3208639EE65LL, dom_element_get_attribute_node_ns);
      break;
    case 3686:
      HASH_INVOKE_FROM_EVAL(0x6CB3DEB458A2DE66LL, apc_bin_load);
      break;
    case 3688:
      HASH_INVOKE_FROM_EVAL(0x5B1DFB89BFC1CE68LL, realpath);
      break;
    case 3689:
      HASH_INVOKE_FROM_EVAL(0x24B836D2C79D0E69LL, magickgetimagepixels);
      break;
    case 3690:
      HASH_INVOKE_FROM_EVAL(0x2F9816D9A2B2CE6ALL, mysql_set_charset);
      HASH_INVOKE_FROM_EVAL(0x25C0C5E961AFDE6ALL, xmlwriter_full_end_element);
      break;
    case 3693:
      HASH_INVOKE_FROM_EVAL(0x714001ABB0D76E6DLL, magickgetinterlacescheme);
      break;
    case 3695:
      HASH_INVOKE_FROM_EVAL(0x7E6223D0CF184E6FLL, magickqueryformats);
      break;
    case 3697:
      HASH_INVOKE_FROM_EVAL(0x6AC126DCE941FE71LL, memory_get_peak_usage);
      break;
    case 3699:
      HASH_INVOKE_FROM_EVAL(0x3B28CA1BE1D0DE73LL, xbox_get_thread_timeout);
      break;
    case 3700:
      HASH_INVOKE_FROM_EVAL(0x47D0510206B89E74LL, ini_restore);
      break;
    case 3701:
      HASH_INVOKE_FROM_EVAL(0x4EC7C66593DDEE75LL, sql_regcase);
      break;
    case 3702:
      HASH_INVOKE_FROM_EVAL(0x36E9EC047FC73E76LL, mb_convert_encoding);
      break;
    case 3703:
      HASH_INVOKE_FROM_EVAL(0x12B7B2D835B80E77LL, chmod);
      break;
    case 3706:
      HASH_INVOKE_FROM_EVAL(0x6A3D9F8EDB005E7ALL, flush);
      break;
    case 3708:
      HASH_INVOKE_FROM_EVAL(0x4D9C5B9A944CCE7CLL, convert_uudecode);
      break;
    case 3710:
      HASH_INVOKE_FROM_EVAL(0x51060D186C703E7ELL, headers_list);
      break;
    case 3713:
      HASH_INVOKE_FROM_EVAL(0x0ECFC3676B4FDE81LL, chr);
      HASH_INVOKE_FROM_EVAL(0x3B426B13FA584E81LL, fb_unserialize);
      break;
    case 3714:
      HASH_INVOKE_FROM_EVAL(0x379F7BF525FF1E82LL, magicksetimagecolorspace);
      break;
    case 3715:
      HASH_INVOKE_FROM_EVAL(0x724011CF7C31AE83LL, sqrt);
      break;
    case 3716:
      HASH_INVOKE_FROM_EVAL(0x1765A63835CC4E84LL, drawgetfontfamily);
      break;
    case 3717:
      HASH_INVOKE_FROM_EVAL(0x4710320ED6638E85LL, rename_function);
      break;
    case 3720:
      HASH_INVOKE_FROM_EVAL(0x1569DCC552EE8E88LL, cosh);
      break;
    case 3722:
      HASH_INVOKE_FROM_EVAL(0x15C9E5C16374EE8ALL, gzclose);
      break;
    case 3726:
      HASH_INVOKE_FROM_EVAL(0x29A2FBD427647E8ELL, mysql_connect);
      break;
    case 3728:
      HASH_INVOKE_FROM_EVAL(0x33D6CC3959D3CE90LL, clearmagickwand);
      break;
    case 3731:
      HASH_INVOKE_FROM_EVAL(0x5E968924197F5E93LL, mcrypt_ofb);
      HASH_INVOKE_FROM_EVAL(0x37A9E8F91C33EE93LL, magickborderimage);
      break;
    case 3735:
      HASH_INVOKE_FROM_EVAL(0x6254E9BDC11F3E97LL, imagecreatefromgd2);
      break;
    case 3739:
      HASH_INVOKE_FROM_EVAL(0x2A019CAA1188BE9BLL, preg_grep);
      break;
    case 3742:
      HASH_INVOKE_FROM_EVAL(0x76EBE919625D8E9ELL, openssl_pkcs12_export);
      break;
    case 3743:
      HASH_INVOKE_FROM_EVAL(0x224004A728974E9FLL, spl_object_hash);
      HASH_INVOKE_FROM_EVAL(0x7CFF820207DC6E9FLL, debug_backtrace);
      break;
    case 3744:
      HASH_INVOKE_FROM_EVAL(0x37C5AF6E7E8B5EA0LL, fputs);
      break;
    case 3747:
      HASH_INVOKE_FROM_EVAL(0x6467FFB910B8BEA3LL, magickspliceimage);
      break;
    case 3750:
      HASH_INVOKE_FROM_EVAL(0x1D7B8E395613AEA6LL, dom_element_remove_attribute_ns);
      break;
    case 3752:
      HASH_INVOKE_FROM_EVAL(0x3C6190E9534F3EA8LL, ebcdic2ascii);
      break;
    case 3753:
      HASH_INVOKE_FROM_EVAL(0x308D76DB12424EA9LL, magicksetimageindex);
      break;
    case 3755:
      HASH_INVOKE_FROM_EVAL(0x632D4FC346797EABLL, pixelgetexceptionstring);
      break;
    case 3758:
      HASH_INVOKE_FROM_EVAL(0x5772A0B8C16DAEAELL, posix_setuid);
      break;
    case 3759:
      HASH_INVOKE_FROM_EVAL(0x12D83A92EFB0EEAFLL, xmlwriter_open_uri);
      break;
    case 3761:
      HASH_INVOKE_FROM_EVAL(0x33FE101882726EB1LL, proc_close);
      break;
    case 3763:
      HASH_INVOKE_FROM_EVAL(0x7DB9D839ACE0DEB3LL, natsort);
      HASH_INVOKE_FROM_EVAL(0x7379B5B97EC2EEB3LL, hypot);
      break;
    case 3764:
      HASH_INVOKE_FROM_EVAL(0x1F936B3C5406DEB4LL, fb_set_taint);
      break;
    case 3767:
      HASH_INVOKE_FROM_EVAL(0x58B9EFA0FB35FEB7LL, stream_filter_prepend);
      break;
    case 3769:
      HASH_INVOKE_FROM_EVAL(0x2A483AD7A3D07EB9LL, magickgetwandsize);
      break;
    case 3770:
      HASH_INVOKE_FROM_EVAL(0x1F5B2728DE875EBALL, magicksetimage);
      break;
    case 3773:
      HASH_INVOKE_FROM_EVAL(0x31A30B274AD2DEBDLL, call_user_func_array_rpc);
      break;
    case 3776:
      HASH_INVOKE_FROM_EVAL(0x2475D7045D9DEEC0LL, magicksetimagecompression);
      HASH_INVOKE_FROM_EVAL(0x495316E596537EC0LL, imagefttext);
      break;
    case 3778:
      HASH_INVOKE_FROM_EVAL(0x4CDD0B7BF826FEC2LL, rewinddir);
      break;
    case 3780:
      HASH_INVOKE_FROM_EVAL(0x7052903F1B17AEC4LL, parse_str);
      break;
    case 3781:
      HASH_INVOKE_FROM_EVAL(0x7D69B3537C353EC5LL, hphp_splfileinfo_isfile);
      break;
    case 3783:
      HASH_INVOKE_FROM_EVAL(0x4FC99DC20A955EC7LL, session_module_name);
      break;
    case 3785:
      HASH_INVOKE_FROM_EVAL(0x58C8DCAAE5B7CEC9LL, get_cfg_var);
      break;
    case 3786:
      HASH_INVOKE_FROM_EVAL(0x08E6C1CD3AC64ECALL, hphp_splfileinfo_gettype);
      HASH_INVOKE_FROM_EVAL(0x1AA83A1057BE6ECALL, mysql_field_len);
      break;
    case 3794:
      HASH_INVOKE_FROM_EVAL(0x3CCD09EC3511CED2LL, apd_stop_trace);
      break;
    case 3798:
      HASH_INVOKE_FROM_EVAL(0x134B37520683DED6LL, imagesetbrush);
      break;
    case 3800:
      HASH_INVOKE_FROM_EVAL(0x338D9D95095D1ED8LL, magicksetimagedelay);
      break;
    case 3801:
      HASH_INVOKE_FROM_EVAL(0x7F802A06996BBED9LL, apd_set_browser_trace);
      break;
    case 3802:
      HASH_INVOKE_FROM_EVAL(0x29E2771785CCBEDALL, magickgettextdescent);
      break;
    case 3803:
      HASH_INVOKE_FROM_EVAL(0x16331E18B5CD8EDBLL, timezone_open);
      HASH_INVOKE_FROM_EVAL(0x1340509769275EDBLL, magickgetimagecompression);
      break;
    case 3808:
      HASH_INVOKE_FROM_EVAL(0x7A1C6E429399CEE0LL, iconv_set_encoding);
      break;
    case 3809:
      HASH_INVOKE_FROM_EVAL(0x528BA9796BD0FEE1LL, fb_rpc_intercept_handler);
      break;
    case 3811:
      HASH_INVOKE_FROM_EVAL(0x1F4AACF075E9CEE3LL, memcache_get_server_status);
      HASH_INVOKE_FROM_EVAL(0x28A98134BD97BEE3LL, mb_regex_encoding);
      HASH_INVOKE_FROM_EVAL(0x0E1368A3BDFE6EE3LL, hphp_recursiveiteratoriterator_rewind);
      break;
    case 3812:
      HASH_INVOKE_FROM_EVAL(0x5B6FF42ACB2FBEE4LL, getmyuid);
      break;
    case 3813:
      HASH_INVOKE_FROM_EVAL(0x367CFD20B4446EE5LL, is_array);
      break;
    case 3816:
      HASH_INVOKE_FROM_EVAL(0x6CB6650E66CE4EE8LL, magicksetimagebordercolor);
      HASH_INVOKE_FROM_EVAL(0x32B3951DFD2B9EE8LL, hphp_directoryiterator_isdot);
      break;
    case 3819:
      HASH_INVOKE_FROM_EVAL(0x72882DBF2D49CEEBLL, set_magic_quotes_runtime);
      break;
    case 3824:
      HASH_INVOKE_FROM_EVAL(0x7DFF9707F1CD9EF0LL, dangling_server_proxy_old_request);
      break;
    case 3832:
      HASH_INVOKE_FROM_EVAL(0x33FD10AC81146EF8LL, thrift_protocol_read_binary);
      break;
    case 3833:
      HASH_INVOKE_FROM_EVAL(0x200FC256EB093EF9LL, gettimeofday);
      break;
    case 3835:
      HASH_INVOKE_FROM_EVAL(0x6D450F078F02BEFBLL, apd_continue);
      break;
    case 3837:
      HASH_INVOKE_FROM_EVAL(0x0CF27A6BC84CEEFDLL, openssl_get_publickey);
      HASH_INVOKE_FROM_EVAL(0x283E167EB3F04EFDLL, posix_getgid);
      break;
    case 3840:
      HASH_INVOKE_FROM_EVAL(0x09637D7CA2E33F00LL, fgetc);
      break;
    case 3841:
      HASH_INVOKE_FROM_EVAL(0x66137942508EBF01LL, date_create);
      HASH_INVOKE_FROM_EVAL(0x7B6A0D7510184F01LL, mysql_fetch_assoc);
      break;
    case 3842:
      HASH_INVOKE_FROM_EVAL(0x78A02A603FA6FF02LL, magickreducenoiseimage);
      break;
    case 3845:
      HASH_INVOKE_FROM_EVAL(0x6842585E79988F05LL, magickmosaicimages);
      break;
    case 3846:
      HASH_INVOKE_FROM_EVAL(0x1D3B08AA0AF50F06LL, gettype);
      HASH_INVOKE_FROM_EVAL(0x6692475BA65A2F06LL, imagearc);
      break;
    case 3851:
      HASH_INVOKE_FROM_EVAL(0x7756593AAC1F6F0BLL, imagecreatefromstring);
      break;
    case 3855:
      HASH_INVOKE_FROM_EVAL(0x61E7A36CA7FF5F0FLL, drawsetcliprule);
      HASH_INVOKE_FROM_EVAL(0x4BD54A631F665F0FLL, drawpathcurvetosmoothabsolute);
      break;
    case 3856:
      HASH_INVOKE_FROM_EVAL(0x700A75BF904DAF10LL, magickgetcharwidth);
      break;
    case 3858:
      HASH_INVOKE_FROM_EVAL(0x042492DDA48C4F12LL, gzdeflate);
      break;
    case 3859:
      HASH_INVOKE_FROM_EVAL(0x3B197C0731233F13LL, dom_characterdata_substring_data);
      break;
    case 3860:
      HASH_INVOKE_FROM_EVAL(0x04525BA2AE51EF14LL, date_sun_info);
      break;
    case 3861:
      HASH_INVOKE_FROM_EVAL(0x12F09EAED9078F15LL, mysql_fetch_field);
      break;
    case 3862:
      HASH_INVOKE_FROM_EVAL(0x23B7D9E4EC992F16LL, stream_get_line);
      HASH_INVOKE_FROM_EVAL(0x38664EFE3E0A0F16LL, json_decode);
      HASH_INVOKE_FROM_EVAL(0x0287B907DDA3EF16LL, hphpd_get_user_commands);
      break;
    case 3867:
      HASH_INVOKE_FROM_EVAL(0x27A4633381195F1BLL, chown);
      break;
    case 3871:
      HASH_INVOKE_FROM_EVAL(0x7C0C145EFE0EBF1FLL, defined);
      break;
    case 3872:
      HASH_INVOKE_FROM_EVAL(0x2C4206A0BD904F20LL, hphp_splfileobject_fseek);
      break;
    case 3873:
      HASH_INVOKE_FROM_EVAL(0x4282496A4BF42F21LL, php_uname);
      HASH_INVOKE_FROM_EVAL(0x77EC28645855AF21LL, magicksetcompressionquality);
      HASH_INVOKE_FROM_EVAL(0x1FF5B9A4FC78BF21LL, drawsettextantialias);
      break;
    case 3876:
      HASH_INVOKE_FROM_EVAL(0x05BD68F1D09CEF24LL, array_count_values);
      HASH_INVOKE_FROM_EVAL(0x5FA07E8B63BEAF24LL, mcrypt_enc_get_modes_name);
      break;
    case 3879:
      HASH_INVOKE_FROM_EVAL(0x4BAA5B688E6F6F27LL, gd_info);
      break;
    case 3884:
      HASH_INVOKE_FROM_EVAL(0x035EFF9E1757DF2CLL, http_build_query);
      break;
    case 3890:
      HASH_INVOKE_FROM_EVAL(0x78257F34467BDF32LL, drawsetstrokedasharray);
      HASH_INVOKE_FROM_EVAL(0x2B66EACB77AE9F32LL, print_r);
      break;
    case 3897:
      HASH_INVOKE_FROM_EVAL(0x0D4446B2DBC8EF39LL, hphp_splfileinfo_getinode);
      HASH_INVOKE_FROM_EVAL(0x3E9146C06AAEFF39LL, magicksetimagecompressionquality);
      HASH_INVOKE_FROM_EVAL(0x496CF4113CEA8F39LL, magicksetimagefilename);
      break;
    case 3899:
      HASH_INVOKE_FROM_EVAL(0x7EE74F798791CF3BLL, magickedgeimage);
      break;
    case 3900:
      HASH_INVOKE_FROM_EVAL(0x41136A5F28E84F3CLL, forward_static_call_array);
      break;
    case 3903:
      HASH_INVOKE_FROM_EVAL(0x1A9EFDD653DB8F3FLL, pcntl_wstopsig);
      break;
    case 3906:
      HASH_INVOKE_FROM_EVAL(0x3B46305DA1154F42LL, drawpopclippath);
      break;
    case 3909:
      HASH_INVOKE_FROM_EVAL(0x4E36A077234B8F45LL, pixelgetblack);
      HASH_INVOKE_FROM_EVAL(0x79265AADD9A8AF45LL, mcrypt_cbc);
      HASH_INVOKE_FROM_EVAL(0x5D3A31AB0E326F45LL, crc32);
      break;
    case 3910:
      HASH_INVOKE_FROM_EVAL(0x079EA27F72594F46LL, gzgets);
      break;
    case 3920:
      HASH_INVOKE_FROM_EVAL(0x7978A278AEAFAF50LL, pixelgetmagenta);
      break;
    case 3925:
      HASH_INVOKE_FROM_EVAL(0x49D986274B1C5F55LL, collator_asort);
      break;
    case 3926:
      HASH_INVOKE_FROM_EVAL(0x621590803EC88F56LL, imageline);
      break;
    case 3928:
      HASH_INVOKE_FROM_EVAL(0x0551AAE8F1A6FF58LL, magicklevelimage);
      break;
    case 3929:
      HASH_INVOKE_FROM_EVAL(0x38246B6BDE246F59LL, magickgetimagedispose);
      break;
    case 3931:
      HASH_INVOKE_FROM_EVAL(0x24F698A8A4B5AF5BLL, imagecolordeallocate);
      HASH_INVOKE_FROM_EVAL(0x76418F884500DF5BLL, stream_socket_enable_crypto);
      break;
    case 3933:
      HASH_INVOKE_FROM_EVAL(0x07FF92CF46DDFF5DLL, imagepsfreefont);
      break;
    case 3935:
      HASH_INVOKE_FROM_EVAL(0x703D339DD44E8F5FLL, dom_element_get_elements_by_tag_name);
      break;
    case 3936:
      HASH_INVOKE_FROM_EVAL(0x4F1D2858AD31AF60LL, imagecreatefromgd);
      break;
    case 3939:
      HASH_INVOKE_FROM_EVAL(0x1FFD204252F60F63LL, magicksetimageprofile);
      break;
    case 3940:
      HASH_INVOKE_FROM_EVAL(0x41EF51E62AD3DF64LL, pagelet_server_is_enabled);
      HASH_INVOKE_FROM_EVAL(0x280051555A21DF64LL, rename);
      break;
    case 3942:
      HASH_INVOKE_FROM_EVAL(0x6FFF1304EA444F66LL, drawsetstrokemiterlimit);
      break;
    case 3943:
      HASH_INVOKE_FROM_EVAL(0x319407AC92912F67LL, ereg);
      break;
    case 3946:
      HASH_INVOKE_FROM_EVAL(0x1670096FDE27AF6ALL, rewind);
      break;
    case 3947:
      HASH_INVOKE_FROM_EVAL(0x56EF59D6CB0A5F6BLL, dom_document_save_html_file);
      break;
    case 3948:
      HASH_INVOKE_FROM_EVAL(0x23D5E9E53D11BF6CLL, gmdate);
      break;
    case 3950:
      HASH_INVOKE_FROM_EVAL(0x3A56371CDDEA0F6ELL, gzgetc);
      break;
    case 3951:
      HASH_INVOKE_FROM_EVAL(0x42C4EC9D9F782F6FLL, htmlentities);
      break;
    case 3952:
      HASH_INVOKE_FROM_EVAL(0x68C257B62A36EF70LL, magicksetimagebackgroundcolor);
      HASH_INVOKE_FROM_EVAL(0x71557D108E5C0F70LL, xml_set_object);
      break;
    case 3954:
      HASH_INVOKE_FROM_EVAL(0x4B22EF06BAA83F72LL, version_compare);
      break;
    case 3956:
      HASH_INVOKE_FROM_EVAL(0x18BC9BF6D1E3CF74LL, magickpreviewimages);
      break;
    case 3961:
      HASH_INVOKE_FROM_EVAL(0x4BE9D91DD8624F79LL, money_format);
      break;
    case 3962:
      HASH_INVOKE_FROM_EVAL(0x7B0E6DB649084F7ALL, clearstatcache);
      break;
    case 3966:
      HASH_INVOKE_FROM_EVAL(0x7064BEBF508F3F7ELL, socket_read);
      break;
    case 3968:
      HASH_INVOKE_FROM_EVAL(0x63F18DE0DB807F80LL, magickqueryfonts);
      break;
    case 3972:
      HASH_INVOKE_FROM_EVAL(0x14402B01D00E9F84LL, magicksteganoimage);
      break;
    case 3973:
      HASH_INVOKE_FROM_EVAL(0x7EF68B9A55222F85LL, wandgetexceptionstring);
      break;
    case 3974:
      HASH_INVOKE_FROM_EVAL(0x44CE4DB1CE7E9F86LL, flock);
      break;
    case 3977:
      HASH_INVOKE_FROM_EVAL(0x13F52A829BAC0F89LL, timezone_identifiers_list);
      break;
    case 3979:
      HASH_INVOKE_FROM_EVAL(0x2755DD4112AA5F8BLL, magicksampleimage);
      HASH_INVOKE_FROM_EVAL(0x3703D22147C24F8BLL, pixelsetcyan);
      break;
    case 3982:
      HASH_INVOKE_FROM_EVAL(0x7A8F1104B0CCDF8ELL, phpcredits);
      break;
    case 3983:
      HASH_INVOKE_FROM_EVAL(0x4A6C46DC7FE29F8FLL, hphp_recursivedirectoryiterator_getchildren);
      break;
    case 3985:
      HASH_INVOKE_FROM_EVAL(0x78463112BE739F91LL, connection_timeout);
      break;
    case 3986:
      HASH_INVOKE_FROM_EVAL(0x288D61E7DE28AF92LL, ucwords);
      break;
    case 3988:
      HASH_INVOKE_FROM_EVAL(0x76B9D87BC7F02F94LL, preg_match);
      break;
    case 3989:
      HASH_INVOKE_FROM_EVAL(0x40D620CBA0D41F95LL, opendir);
      break;
    case 3991:
      HASH_INVOKE_FROM_EVAL(0x35117886C885DF97LL, hphp_recursivedirectoryiterator_getsubpathname);
      HASH_INVOKE_FROM_EVAL(0x6F9651265C096F97LL, magickreadimages);
      break;
    case 3992:
      HASH_INVOKE_FROM_EVAL(0x0293F60B46511F98LL, drawsetfontstretch);
      HASH_INVOKE_FROM_EVAL(0x66F1F0DB16C82F98LL, imagesavealpha);
      break;
    case 3994:
      HASH_INVOKE_FROM_EVAL(0x2B7CAC006AF27F9ALL, fflush);
      break;
    case 3995:
      HASH_INVOKE_FROM_EVAL(0x44244ECFB9F76F9BLL, dom_document_create_element_ns);
      break;
    case 3997:
      HASH_INVOKE_FROM_EVAL(0x0AD6DE8829773F9DLL, apc_compile_file);
      break;
    case 4004:
      HASH_INVOKE_FROM_EVAL(0x0E7E9AA21AE99FA4LL, hphp_recursiveiteratoriterator_current);
      break;
    case 4006:
      HASH_INVOKE_FROM_EVAL(0x0DEEA8C3E3A47FA6LL, read_exif_data);
      break;
    case 4014:
      HASH_INVOKE_FROM_EVAL(0x64D269A505D51FAELL, array_map);
      break;
    case 4015:
      HASH_INVOKE_FROM_EVAL(0x03979AACDBB24FAFLL, mailparse_msg_get_part);
      break;
    case 4016:
      HASH_INVOKE_FROM_EVAL(0x4A0B5F4676578FB0LL, imagecolorresolvealpha);
      break;
    case 4017:
      HASH_INVOKE_FROM_EVAL(0x0F78ECF42C30DFB1LL, array_chunk);
      break;
    case 4020:
      HASH_INVOKE_FROM_EVAL(0x3900FDF1C97BEFB4LL, drawrotate);
      break;
    case 4022:
      HASH_INVOKE_FROM_EVAL(0x56C0CCB57BB6EFB6LL, magicksetimageunits);
      HASH_INVOKE_FROM_EVAL(0x2B451EF5D52C4FB6LL, array_diff);
      break;
    case 4023:
      HASH_INVOKE_FROM_EVAL(0x6465CD999F4C5FB7LL, hphp_invoke_method);
      break;
    case 4024:
      HASH_INVOKE_FROM_EVAL(0x6DB2DB341ECF3FB8LL, file_exists);
      break;
    case 4026:
      HASH_INVOKE_FROM_EVAL(0x0664323CB1CC2FBALL, imagecolorset);
      break;
    case 4031:
      HASH_INVOKE_FROM_EVAL(0x70B38AB9EAE16FBFLL, ini_set);
      break;
    case 4033:
      HASH_INVOKE_FROM_EVAL(0x3FF9AAFF85DDDFC1LL, class_parents);
      break;
    case 4034:
      HASH_INVOKE_FROM_EVAL(0x6CA22E62D4762FC2LL, magickpainttransparentimage);
      HASH_INVOKE_FROM_EVAL(0x460470C490FAFFC2LL, dom_node_normalize);
      break;
    case 4037:
      HASH_INVOKE_FROM_EVAL(0x38498DD4C28D0FC5LL, hphp_splfileinfo_getatime);
      break;
    case 4043:
      HASH_INVOKE_FROM_EVAL(0x38237A4515F42FCBLL, array_pad);
      break;
    case 4045:
      HASH_INVOKE_FROM_EVAL(0x474566F3A2BE0FCDLL, mcrypt_enc_is_block_algorithm);
      break;
    case 4046:
      HASH_INVOKE_FROM_EVAL(0x042193C97C65FFCELL, magickwaveimage);
      break;
    case 4047:
      HASH_INVOKE_FROM_EVAL(0x3A3CFC1F001A6FCFLL, magickreadimagefile);
      break;
    case 4048:
      HASH_INVOKE_FROM_EVAL(0x21104CCA2942AFD0LL, fb_const_fetch);
      HASH_INVOKE_FROM_EVAL(0x2EAA47FA6C3FEFD0LL, drawgetstrokealpha);
      HASH_INVOKE_FROM_EVAL(0x53DB5D0490C51FD0LL, xhprof_sample_disable);
      break;
    case 4052:
      HASH_INVOKE_FROM_EVAL(0x4970B72A182E4FD4LL, readdir);
      break;
    case 4053:
      HASH_INVOKE_FROM_EVAL(0x751283FE764CAFD5LL, mysql_select_db);
      break;
    case 4054:
      HASH_INVOKE_FROM_EVAL(0x7FC00035D14B9FD6LL, apc_delete_file);
      break;
    case 4056:
      HASH_INVOKE_FROM_EVAL(0x4234F2B59531FFD8LL, posix_getlogin);
      break;
    case 4061:
      HASH_INVOKE_FROM_EVAL(0x4EDEDA4278CD3FDDLL, magickchopimage);
      break;
    case 4062:
      HASH_INVOKE_FROM_EVAL(0x7F5FC3CAF8CE9FDELL, gzcompress);
      HASH_INVOKE_FROM_EVAL(0x72925D2DF7E61FDELL, drawpathcurvetoquadraticbeziersmoothrelative);
      break;
    case 4071:
      HASH_INVOKE_FROM_EVAL(0x217067889854CFE7LL, xmlwriter_start_dtd);
      break;
    case 4072:
      HASH_INVOKE_FROM_EVAL(0x4D7AEC41CFD73FE8LL, hphp_recursivedirectoryiterator_getsubpath);
      break;
    case 4075:
      HASH_INVOKE_FROM_EVAL(0x67D1EE05DFE71FEBLL, hphp_splfileobject_getcvscontrol);
      break;
    case 4079:
      HASH_INVOKE_FROM_EVAL(0x00EEEE9C6CEA5FEFLL, xmlwriter_write_element_ns);
      break;
    case 4080:
      HASH_INVOKE_FROM_EVAL(0x1189B7C4F4874FF0LL, php_check_syntax);
      break;
    case 4085:
      HASH_INVOKE_FROM_EVAL(0x191ECE88E06E6FF5LL, dom_node_is_supported);
      break;
    case 4086:
      HASH_INVOKE_FROM_EVAL(0x25FCE64E12505FF6LL, magicksetimagerenderingintent);
      break;
    case 4087:
      HASH_INVOKE_FROM_EVAL(0x7883232CD1A7CFF7LL, dom_node_is_same_node);
      break;
    case 4090:
      HASH_INVOKE_FROM_EVAL(0x13EE24AF67113FFALL, ob_end_flush);
      break;
    case 4091:
      HASH_INVOKE_FROM_EVAL(0x68E499A4D75BDFFBLL, ascii2ebcdic);
      HASH_INVOKE_FROM_EVAL(0x63BE4CEF1FC47FFBLL, imagefill);
      break;
    case 4094:
      HASH_INVOKE_FROM_EVAL(0x32F8747E480CCFFELL, connection_status);
      break;
    default:
      break;
  }
  return invoke_failed(s, eval_get_params(env, caller), -1, fatal);
}

///////////////////////////////////////////////////////////////////////////////
}
